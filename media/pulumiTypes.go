// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package media

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-azure-native-sdk/v2/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Describes Advanced Audio Codec (AAC) audio encoding settings.
type AacAudio struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels *int `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AacAudio'.
	OdataType string `pulumi:"odataType"`
	// The encoding profile to be used when encoding audio with AAC.
	Profile *string `pulumi:"profile"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate *int `pulumi:"samplingRate"`
}

// AacAudioInput is an input type that accepts AacAudioArgs and AacAudioOutput values.
// You can construct a concrete instance of `AacAudioInput` via:
//
//	AacAudioArgs{...}
type AacAudioInput interface {
	pulumi.Input

	ToAacAudioOutput() AacAudioOutput
	ToAacAudioOutputWithContext(context.Context) AacAudioOutput
}

// Describes Advanced Audio Codec (AAC) audio encoding settings.
type AacAudioArgs struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate pulumi.IntPtrInput `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels pulumi.IntPtrInput `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AacAudio'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The encoding profile to be used when encoding audio with AAC.
	Profile pulumi.StringPtrInput `pulumi:"profile"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate pulumi.IntPtrInput `pulumi:"samplingRate"`
}

func (AacAudioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AacAudio)(nil)).Elem()
}

func (i AacAudioArgs) ToAacAudioOutput() AacAudioOutput {
	return i.ToAacAudioOutputWithContext(context.Background())
}

func (i AacAudioArgs) ToAacAudioOutputWithContext(ctx context.Context) AacAudioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AacAudioOutput)
}

// Describes Advanced Audio Codec (AAC) audio encoding settings.
type AacAudioOutput struct{ *pulumi.OutputState }

func (AacAudioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AacAudio)(nil)).Elem()
}

func (o AacAudioOutput) ToAacAudioOutput() AacAudioOutput {
	return o
}

func (o AacAudioOutput) ToAacAudioOutputWithContext(ctx context.Context) AacAudioOutput {
	return o
}

// The bitrate, in bits per second, of the output encoded audio.
func (o AacAudioOutput) Bitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AacAudio) *int { return v.Bitrate }).(pulumi.IntPtrOutput)
}

// The number of channels in the audio.
func (o AacAudioOutput) Channels() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AacAudio) *int { return v.Channels }).(pulumi.IntPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o AacAudioOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AacAudio) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AacAudio'.
func (o AacAudioOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AacAudio) string { return v.OdataType }).(pulumi.StringOutput)
}

// The encoding profile to be used when encoding audio with AAC.
func (o AacAudioOutput) Profile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AacAudio) *string { return v.Profile }).(pulumi.StringPtrOutput)
}

// The sampling rate to use for encoding in hertz.
func (o AacAudioOutput) SamplingRate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AacAudio) *int { return v.SamplingRate }).(pulumi.IntPtrOutput)
}

// Describes Advanced Audio Codec (AAC) audio encoding settings.
type AacAudioResponse struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels *int `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AacAudio'.
	OdataType string `pulumi:"odataType"`
	// The encoding profile to be used when encoding audio with AAC.
	Profile *string `pulumi:"profile"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate *int `pulumi:"samplingRate"`
}

// Describes Advanced Audio Codec (AAC) audio encoding settings.
type AacAudioResponseOutput struct{ *pulumi.OutputState }

func (AacAudioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AacAudioResponse)(nil)).Elem()
}

func (o AacAudioResponseOutput) ToAacAudioResponseOutput() AacAudioResponseOutput {
	return o
}

func (o AacAudioResponseOutput) ToAacAudioResponseOutputWithContext(ctx context.Context) AacAudioResponseOutput {
	return o
}

// The bitrate, in bits per second, of the output encoded audio.
func (o AacAudioResponseOutput) Bitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AacAudioResponse) *int { return v.Bitrate }).(pulumi.IntPtrOutput)
}

// The number of channels in the audio.
func (o AacAudioResponseOutput) Channels() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AacAudioResponse) *int { return v.Channels }).(pulumi.IntPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o AacAudioResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AacAudioResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AacAudio'.
func (o AacAudioResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AacAudioResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The encoding profile to be used when encoding audio with AAC.
func (o AacAudioResponseOutput) Profile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AacAudioResponse) *string { return v.Profile }).(pulumi.StringPtrOutput)
}

// The sampling rate to use for encoding in hertz.
func (o AacAudioResponseOutput) SamplingRate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AacAudioResponse) *int { return v.SamplingRate }).(pulumi.IntPtrOutput)
}

// Specifies the clip time as an absolute time position in the media file.  The absolute time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type AbsoluteClipTime struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AbsoluteClipTime'.
	OdataType string `pulumi:"odataType"`
	// The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S for 30 seconds.
	Time string `pulumi:"time"`
}

// AbsoluteClipTimeInput is an input type that accepts AbsoluteClipTimeArgs and AbsoluteClipTimeOutput values.
// You can construct a concrete instance of `AbsoluteClipTimeInput` via:
//
//	AbsoluteClipTimeArgs{...}
type AbsoluteClipTimeInput interface {
	pulumi.Input

	ToAbsoluteClipTimeOutput() AbsoluteClipTimeOutput
	ToAbsoluteClipTimeOutputWithContext(context.Context) AbsoluteClipTimeOutput
}

// Specifies the clip time as an absolute time position in the media file.  The absolute time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type AbsoluteClipTimeArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AbsoluteClipTime'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S for 30 seconds.
	Time pulumi.StringInput `pulumi:"time"`
}

func (AbsoluteClipTimeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AbsoluteClipTime)(nil)).Elem()
}

func (i AbsoluteClipTimeArgs) ToAbsoluteClipTimeOutput() AbsoluteClipTimeOutput {
	return i.ToAbsoluteClipTimeOutputWithContext(context.Background())
}

func (i AbsoluteClipTimeArgs) ToAbsoluteClipTimeOutputWithContext(ctx context.Context) AbsoluteClipTimeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AbsoluteClipTimeOutput)
}

func (i AbsoluteClipTimeArgs) ToAbsoluteClipTimePtrOutput() AbsoluteClipTimePtrOutput {
	return i.ToAbsoluteClipTimePtrOutputWithContext(context.Background())
}

func (i AbsoluteClipTimeArgs) ToAbsoluteClipTimePtrOutputWithContext(ctx context.Context) AbsoluteClipTimePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AbsoluteClipTimeOutput).ToAbsoluteClipTimePtrOutputWithContext(ctx)
}

// AbsoluteClipTimePtrInput is an input type that accepts AbsoluteClipTimeArgs, AbsoluteClipTimePtr and AbsoluteClipTimePtrOutput values.
// You can construct a concrete instance of `AbsoluteClipTimePtrInput` via:
//
//	        AbsoluteClipTimeArgs{...}
//
//	or:
//
//	        nil
type AbsoluteClipTimePtrInput interface {
	pulumi.Input

	ToAbsoluteClipTimePtrOutput() AbsoluteClipTimePtrOutput
	ToAbsoluteClipTimePtrOutputWithContext(context.Context) AbsoluteClipTimePtrOutput
}

type absoluteClipTimePtrType AbsoluteClipTimeArgs

func AbsoluteClipTimePtr(v *AbsoluteClipTimeArgs) AbsoluteClipTimePtrInput {
	return (*absoluteClipTimePtrType)(v)
}

func (*absoluteClipTimePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AbsoluteClipTime)(nil)).Elem()
}

func (i *absoluteClipTimePtrType) ToAbsoluteClipTimePtrOutput() AbsoluteClipTimePtrOutput {
	return i.ToAbsoluteClipTimePtrOutputWithContext(context.Background())
}

func (i *absoluteClipTimePtrType) ToAbsoluteClipTimePtrOutputWithContext(ctx context.Context) AbsoluteClipTimePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AbsoluteClipTimePtrOutput)
}

// Specifies the clip time as an absolute time position in the media file.  The absolute time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type AbsoluteClipTimeOutput struct{ *pulumi.OutputState }

func (AbsoluteClipTimeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AbsoluteClipTime)(nil)).Elem()
}

func (o AbsoluteClipTimeOutput) ToAbsoluteClipTimeOutput() AbsoluteClipTimeOutput {
	return o
}

func (o AbsoluteClipTimeOutput) ToAbsoluteClipTimeOutputWithContext(ctx context.Context) AbsoluteClipTimeOutput {
	return o
}

func (o AbsoluteClipTimeOutput) ToAbsoluteClipTimePtrOutput() AbsoluteClipTimePtrOutput {
	return o.ToAbsoluteClipTimePtrOutputWithContext(context.Background())
}

func (o AbsoluteClipTimeOutput) ToAbsoluteClipTimePtrOutputWithContext(ctx context.Context) AbsoluteClipTimePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AbsoluteClipTime) *AbsoluteClipTime {
		return &v
	}).(AbsoluteClipTimePtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AbsoluteClipTime'.
func (o AbsoluteClipTimeOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AbsoluteClipTime) string { return v.OdataType }).(pulumi.StringOutput)
}

// The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S for 30 seconds.
func (o AbsoluteClipTimeOutput) Time() pulumi.StringOutput {
	return o.ApplyT(func(v AbsoluteClipTime) string { return v.Time }).(pulumi.StringOutput)
}

type AbsoluteClipTimePtrOutput struct{ *pulumi.OutputState }

func (AbsoluteClipTimePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AbsoluteClipTime)(nil)).Elem()
}

func (o AbsoluteClipTimePtrOutput) ToAbsoluteClipTimePtrOutput() AbsoluteClipTimePtrOutput {
	return o
}

func (o AbsoluteClipTimePtrOutput) ToAbsoluteClipTimePtrOutputWithContext(ctx context.Context) AbsoluteClipTimePtrOutput {
	return o
}

func (o AbsoluteClipTimePtrOutput) Elem() AbsoluteClipTimeOutput {
	return o.ApplyT(func(v *AbsoluteClipTime) AbsoluteClipTime {
		if v != nil {
			return *v
		}
		var ret AbsoluteClipTime
		return ret
	}).(AbsoluteClipTimeOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AbsoluteClipTime'.
func (o AbsoluteClipTimePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AbsoluteClipTime) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S for 30 seconds.
func (o AbsoluteClipTimePtrOutput) Time() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AbsoluteClipTime) *string {
		if v == nil {
			return nil
		}
		return &v.Time
	}).(pulumi.StringPtrOutput)
}

// Specifies the clip time as an absolute time position in the media file.  The absolute time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type AbsoluteClipTimeResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AbsoluteClipTime'.
	OdataType string `pulumi:"odataType"`
	// The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S for 30 seconds.
	Time string `pulumi:"time"`
}

// Specifies the clip time as an absolute time position in the media file.  The absolute time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type AbsoluteClipTimeResponseOutput struct{ *pulumi.OutputState }

func (AbsoluteClipTimeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AbsoluteClipTimeResponse)(nil)).Elem()
}

func (o AbsoluteClipTimeResponseOutput) ToAbsoluteClipTimeResponseOutput() AbsoluteClipTimeResponseOutput {
	return o
}

func (o AbsoluteClipTimeResponseOutput) ToAbsoluteClipTimeResponseOutputWithContext(ctx context.Context) AbsoluteClipTimeResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AbsoluteClipTime'.
func (o AbsoluteClipTimeResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AbsoluteClipTimeResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S for 30 seconds.
func (o AbsoluteClipTimeResponseOutput) Time() pulumi.StringOutput {
	return o.ApplyT(func(v AbsoluteClipTimeResponse) string { return v.Time }).(pulumi.StringOutput)
}

type AbsoluteClipTimeResponsePtrOutput struct{ *pulumi.OutputState }

func (AbsoluteClipTimeResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AbsoluteClipTimeResponse)(nil)).Elem()
}

func (o AbsoluteClipTimeResponsePtrOutput) ToAbsoluteClipTimeResponsePtrOutput() AbsoluteClipTimeResponsePtrOutput {
	return o
}

func (o AbsoluteClipTimeResponsePtrOutput) ToAbsoluteClipTimeResponsePtrOutputWithContext(ctx context.Context) AbsoluteClipTimeResponsePtrOutput {
	return o
}

func (o AbsoluteClipTimeResponsePtrOutput) Elem() AbsoluteClipTimeResponseOutput {
	return o.ApplyT(func(v *AbsoluteClipTimeResponse) AbsoluteClipTimeResponse {
		if v != nil {
			return *v
		}
		var ret AbsoluteClipTimeResponse
		return ret
	}).(AbsoluteClipTimeResponseOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AbsoluteClipTime'.
func (o AbsoluteClipTimeResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AbsoluteClipTimeResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S for 30 seconds.
func (o AbsoluteClipTimeResponsePtrOutput) Time() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AbsoluteClipTimeResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Time
	}).(pulumi.StringPtrOutput)
}

type AccessControl struct {
	// The behavior for IP access control in Key Delivery.
	DefaultAction *string `pulumi:"defaultAction"`
	// The IP allow list for access control in Key Delivery. If the default action is set to 'Allow', the IP allow list must be empty.
	IpAllowList []string `pulumi:"ipAllowList"`
}

// AccessControlInput is an input type that accepts AccessControlArgs and AccessControlOutput values.
// You can construct a concrete instance of `AccessControlInput` via:
//
//	AccessControlArgs{...}
type AccessControlInput interface {
	pulumi.Input

	ToAccessControlOutput() AccessControlOutput
	ToAccessControlOutputWithContext(context.Context) AccessControlOutput
}

type AccessControlArgs struct {
	// The behavior for IP access control in Key Delivery.
	DefaultAction pulumi.StringPtrInput `pulumi:"defaultAction"`
	// The IP allow list for access control in Key Delivery. If the default action is set to 'Allow', the IP allow list must be empty.
	IpAllowList pulumi.StringArrayInput `pulumi:"ipAllowList"`
}

func (AccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessControl)(nil)).Elem()
}

func (i AccessControlArgs) ToAccessControlOutput() AccessControlOutput {
	return i.ToAccessControlOutputWithContext(context.Background())
}

func (i AccessControlArgs) ToAccessControlOutputWithContext(ctx context.Context) AccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessControlOutput)
}

func (i AccessControlArgs) ToAccessControlPtrOutput() AccessControlPtrOutput {
	return i.ToAccessControlPtrOutputWithContext(context.Background())
}

func (i AccessControlArgs) ToAccessControlPtrOutputWithContext(ctx context.Context) AccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessControlOutput).ToAccessControlPtrOutputWithContext(ctx)
}

// AccessControlPtrInput is an input type that accepts AccessControlArgs, AccessControlPtr and AccessControlPtrOutput values.
// You can construct a concrete instance of `AccessControlPtrInput` via:
//
//	        AccessControlArgs{...}
//
//	or:
//
//	        nil
type AccessControlPtrInput interface {
	pulumi.Input

	ToAccessControlPtrOutput() AccessControlPtrOutput
	ToAccessControlPtrOutputWithContext(context.Context) AccessControlPtrOutput
}

type accessControlPtrType AccessControlArgs

func AccessControlPtr(v *AccessControlArgs) AccessControlPtrInput {
	return (*accessControlPtrType)(v)
}

func (*accessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessControl)(nil)).Elem()
}

func (i *accessControlPtrType) ToAccessControlPtrOutput() AccessControlPtrOutput {
	return i.ToAccessControlPtrOutputWithContext(context.Background())
}

func (i *accessControlPtrType) ToAccessControlPtrOutputWithContext(ctx context.Context) AccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessControlPtrOutput)
}

type AccessControlOutput struct{ *pulumi.OutputState }

func (AccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessControl)(nil)).Elem()
}

func (o AccessControlOutput) ToAccessControlOutput() AccessControlOutput {
	return o
}

func (o AccessControlOutput) ToAccessControlOutputWithContext(ctx context.Context) AccessControlOutput {
	return o
}

func (o AccessControlOutput) ToAccessControlPtrOutput() AccessControlPtrOutput {
	return o.ToAccessControlPtrOutputWithContext(context.Background())
}

func (o AccessControlOutput) ToAccessControlPtrOutputWithContext(ctx context.Context) AccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AccessControl) *AccessControl {
		return &v
	}).(AccessControlPtrOutput)
}

// The behavior for IP access control in Key Delivery.
func (o AccessControlOutput) DefaultAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AccessControl) *string { return v.DefaultAction }).(pulumi.StringPtrOutput)
}

// The IP allow list for access control in Key Delivery. If the default action is set to 'Allow', the IP allow list must be empty.
func (o AccessControlOutput) IpAllowList() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AccessControl) []string { return v.IpAllowList }).(pulumi.StringArrayOutput)
}

type AccessControlPtrOutput struct{ *pulumi.OutputState }

func (AccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessControl)(nil)).Elem()
}

func (o AccessControlPtrOutput) ToAccessControlPtrOutput() AccessControlPtrOutput {
	return o
}

func (o AccessControlPtrOutput) ToAccessControlPtrOutputWithContext(ctx context.Context) AccessControlPtrOutput {
	return o
}

func (o AccessControlPtrOutput) Elem() AccessControlOutput {
	return o.ApplyT(func(v *AccessControl) AccessControl {
		if v != nil {
			return *v
		}
		var ret AccessControl
		return ret
	}).(AccessControlOutput)
}

// The behavior for IP access control in Key Delivery.
func (o AccessControlPtrOutput) DefaultAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessControl) *string {
		if v == nil {
			return nil
		}
		return v.DefaultAction
	}).(pulumi.StringPtrOutput)
}

// The IP allow list for access control in Key Delivery. If the default action is set to 'Allow', the IP allow list must be empty.
func (o AccessControlPtrOutput) IpAllowList() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AccessControl) []string {
		if v == nil {
			return nil
		}
		return v.IpAllowList
	}).(pulumi.StringArrayOutput)
}

type AccessControlResponse struct {
	// The behavior for IP access control in Key Delivery.
	DefaultAction *string `pulumi:"defaultAction"`
	// The IP allow list for access control in Key Delivery. If the default action is set to 'Allow', the IP allow list must be empty.
	IpAllowList []string `pulumi:"ipAllowList"`
}

type AccessControlResponseOutput struct{ *pulumi.OutputState }

func (AccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessControlResponse)(nil)).Elem()
}

func (o AccessControlResponseOutput) ToAccessControlResponseOutput() AccessControlResponseOutput {
	return o
}

func (o AccessControlResponseOutput) ToAccessControlResponseOutputWithContext(ctx context.Context) AccessControlResponseOutput {
	return o
}

// The behavior for IP access control in Key Delivery.
func (o AccessControlResponseOutput) DefaultAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AccessControlResponse) *string { return v.DefaultAction }).(pulumi.StringPtrOutput)
}

// The IP allow list for access control in Key Delivery. If the default action is set to 'Allow', the IP allow list must be empty.
func (o AccessControlResponseOutput) IpAllowList() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AccessControlResponse) []string { return v.IpAllowList }).(pulumi.StringArrayOutput)
}

type AccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (AccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessControlResponse)(nil)).Elem()
}

func (o AccessControlResponsePtrOutput) ToAccessControlResponsePtrOutput() AccessControlResponsePtrOutput {
	return o
}

func (o AccessControlResponsePtrOutput) ToAccessControlResponsePtrOutputWithContext(ctx context.Context) AccessControlResponsePtrOutput {
	return o
}

func (o AccessControlResponsePtrOutput) Elem() AccessControlResponseOutput {
	return o.ApplyT(func(v *AccessControlResponse) AccessControlResponse {
		if v != nil {
			return *v
		}
		var ret AccessControlResponse
		return ret
	}).(AccessControlResponseOutput)
}

// The behavior for IP access control in Key Delivery.
func (o AccessControlResponsePtrOutput) DefaultAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessControlResponse) *string {
		if v == nil {
			return nil
		}
		return v.DefaultAction
	}).(pulumi.StringPtrOutput)
}

// The IP allow list for access control in Key Delivery. If the default action is set to 'Allow', the IP allow list must be empty.
func (o AccessControlResponsePtrOutput) IpAllowList() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AccessControlResponse) []string {
		if v == nil {
			return nil
		}
		return v.IpAllowList
	}).(pulumi.StringArrayOutput)
}

type AccountEncryption struct {
	// The Key Vault identity.
	Identity *ResourceIdentity `pulumi:"identity"`
	// The properties of the key used to encrypt the account.
	KeyVaultProperties *KeyVaultProperties `pulumi:"keyVaultProperties"`
	// The type of key used to encrypt the Account Key.
	Type string `pulumi:"type"`
}

// AccountEncryptionInput is an input type that accepts AccountEncryptionArgs and AccountEncryptionOutput values.
// You can construct a concrete instance of `AccountEncryptionInput` via:
//
//	AccountEncryptionArgs{...}
type AccountEncryptionInput interface {
	pulumi.Input

	ToAccountEncryptionOutput() AccountEncryptionOutput
	ToAccountEncryptionOutputWithContext(context.Context) AccountEncryptionOutput
}

type AccountEncryptionArgs struct {
	// The Key Vault identity.
	Identity ResourceIdentityPtrInput `pulumi:"identity"`
	// The properties of the key used to encrypt the account.
	KeyVaultProperties KeyVaultPropertiesPtrInput `pulumi:"keyVaultProperties"`
	// The type of key used to encrypt the Account Key.
	Type pulumi.StringInput `pulumi:"type"`
}

func (AccountEncryptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AccountEncryption)(nil)).Elem()
}

func (i AccountEncryptionArgs) ToAccountEncryptionOutput() AccountEncryptionOutput {
	return i.ToAccountEncryptionOutputWithContext(context.Background())
}

func (i AccountEncryptionArgs) ToAccountEncryptionOutputWithContext(ctx context.Context) AccountEncryptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionOutput)
}

func (i AccountEncryptionArgs) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return i.ToAccountEncryptionPtrOutputWithContext(context.Background())
}

func (i AccountEncryptionArgs) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionOutput).ToAccountEncryptionPtrOutputWithContext(ctx)
}

// AccountEncryptionPtrInput is an input type that accepts AccountEncryptionArgs, AccountEncryptionPtr and AccountEncryptionPtrOutput values.
// You can construct a concrete instance of `AccountEncryptionPtrInput` via:
//
//	        AccountEncryptionArgs{...}
//
//	or:
//
//	        nil
type AccountEncryptionPtrInput interface {
	pulumi.Input

	ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput
	ToAccountEncryptionPtrOutputWithContext(context.Context) AccountEncryptionPtrOutput
}

type accountEncryptionPtrType AccountEncryptionArgs

func AccountEncryptionPtr(v *AccountEncryptionArgs) AccountEncryptionPtrInput {
	return (*accountEncryptionPtrType)(v)
}

func (*accountEncryptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountEncryption)(nil)).Elem()
}

func (i *accountEncryptionPtrType) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return i.ToAccountEncryptionPtrOutputWithContext(context.Background())
}

func (i *accountEncryptionPtrType) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionPtrOutput)
}

type AccountEncryptionOutput struct{ *pulumi.OutputState }

func (AccountEncryptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccountEncryption)(nil)).Elem()
}

func (o AccountEncryptionOutput) ToAccountEncryptionOutput() AccountEncryptionOutput {
	return o
}

func (o AccountEncryptionOutput) ToAccountEncryptionOutputWithContext(ctx context.Context) AccountEncryptionOutput {
	return o
}

func (o AccountEncryptionOutput) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return o.ToAccountEncryptionPtrOutputWithContext(context.Background())
}

func (o AccountEncryptionOutput) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AccountEncryption) *AccountEncryption {
		return &v
	}).(AccountEncryptionPtrOutput)
}

// The Key Vault identity.
func (o AccountEncryptionOutput) Identity() ResourceIdentityPtrOutput {
	return o.ApplyT(func(v AccountEncryption) *ResourceIdentity { return v.Identity }).(ResourceIdentityPtrOutput)
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionOutput) KeyVaultProperties() KeyVaultPropertiesPtrOutput {
	return o.ApplyT(func(v AccountEncryption) *KeyVaultProperties { return v.KeyVaultProperties }).(KeyVaultPropertiesPtrOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AccountEncryption) string { return v.Type }).(pulumi.StringOutput)
}

type AccountEncryptionPtrOutput struct{ *pulumi.OutputState }

func (AccountEncryptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountEncryption)(nil)).Elem()
}

func (o AccountEncryptionPtrOutput) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return o
}

func (o AccountEncryptionPtrOutput) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return o
}

func (o AccountEncryptionPtrOutput) Elem() AccountEncryptionOutput {
	return o.ApplyT(func(v *AccountEncryption) AccountEncryption {
		if v != nil {
			return *v
		}
		var ret AccountEncryption
		return ret
	}).(AccountEncryptionOutput)
}

// The Key Vault identity.
func (o AccountEncryptionPtrOutput) Identity() ResourceIdentityPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) *ResourceIdentity {
		if v == nil {
			return nil
		}
		return v.Identity
	}).(ResourceIdentityPtrOutput)
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionPtrOutput) KeyVaultProperties() KeyVaultPropertiesPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) *KeyVaultProperties {
		if v == nil {
			return nil
		}
		return v.KeyVaultProperties
	}).(KeyVaultPropertiesPtrOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

type AccountEncryptionResponse struct {
	// The Key Vault identity.
	Identity *ResourceIdentityResponse `pulumi:"identity"`
	// The properties of the key used to encrypt the account.
	KeyVaultProperties *KeyVaultPropertiesResponse `pulumi:"keyVaultProperties"`
	// The current status of the Key Vault mapping.
	Status string `pulumi:"status"`
	// The type of key used to encrypt the Account Key.
	Type string `pulumi:"type"`
}

type AccountEncryptionResponseOutput struct{ *pulumi.OutputState }

func (AccountEncryptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccountEncryptionResponse)(nil)).Elem()
}

func (o AccountEncryptionResponseOutput) ToAccountEncryptionResponseOutput() AccountEncryptionResponseOutput {
	return o
}

func (o AccountEncryptionResponseOutput) ToAccountEncryptionResponseOutputWithContext(ctx context.Context) AccountEncryptionResponseOutput {
	return o
}

// The Key Vault identity.
func (o AccountEncryptionResponseOutput) Identity() ResourceIdentityResponsePtrOutput {
	return o.ApplyT(func(v AccountEncryptionResponse) *ResourceIdentityResponse { return v.Identity }).(ResourceIdentityResponsePtrOutput)
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionResponseOutput) KeyVaultProperties() KeyVaultPropertiesResponsePtrOutput {
	return o.ApplyT(func(v AccountEncryptionResponse) *KeyVaultPropertiesResponse { return v.KeyVaultProperties }).(KeyVaultPropertiesResponsePtrOutput)
}

// The current status of the Key Vault mapping.
func (o AccountEncryptionResponseOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v AccountEncryptionResponse) string { return v.Status }).(pulumi.StringOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AccountEncryptionResponse) string { return v.Type }).(pulumi.StringOutput)
}

type AccountEncryptionResponsePtrOutput struct{ *pulumi.OutputState }

func (AccountEncryptionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountEncryptionResponse)(nil)).Elem()
}

func (o AccountEncryptionResponsePtrOutput) ToAccountEncryptionResponsePtrOutput() AccountEncryptionResponsePtrOutput {
	return o
}

func (o AccountEncryptionResponsePtrOutput) ToAccountEncryptionResponsePtrOutputWithContext(ctx context.Context) AccountEncryptionResponsePtrOutput {
	return o
}

func (o AccountEncryptionResponsePtrOutput) Elem() AccountEncryptionResponseOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) AccountEncryptionResponse {
		if v != nil {
			return *v
		}
		var ret AccountEncryptionResponse
		return ret
	}).(AccountEncryptionResponseOutput)
}

// The Key Vault identity.
func (o AccountEncryptionResponsePtrOutput) Identity() ResourceIdentityResponsePtrOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) *ResourceIdentityResponse {
		if v == nil {
			return nil
		}
		return v.Identity
	}).(ResourceIdentityResponsePtrOutput)
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionResponsePtrOutput) KeyVaultProperties() KeyVaultPropertiesResponsePtrOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) *KeyVaultPropertiesResponse {
		if v == nil {
			return nil
		}
		return v.KeyVaultProperties
	}).(KeyVaultPropertiesResponsePtrOutput)
}

// The current status of the Key Vault mapping.
func (o AccountEncryptionResponsePtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Status
	}).(pulumi.StringPtrOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// Akamai access control
type AkamaiAccessControl struct {
	// authentication key list
	AkamaiSignatureHeaderAuthenticationKeyList []AkamaiSignatureHeaderAuthenticationKey `pulumi:"akamaiSignatureHeaderAuthenticationKeyList"`
}

// AkamaiAccessControlInput is an input type that accepts AkamaiAccessControlArgs and AkamaiAccessControlOutput values.
// You can construct a concrete instance of `AkamaiAccessControlInput` via:
//
//	AkamaiAccessControlArgs{...}
type AkamaiAccessControlInput interface {
	pulumi.Input

	ToAkamaiAccessControlOutput() AkamaiAccessControlOutput
	ToAkamaiAccessControlOutputWithContext(context.Context) AkamaiAccessControlOutput
}

// Akamai access control
type AkamaiAccessControlArgs struct {
	// authentication key list
	AkamaiSignatureHeaderAuthenticationKeyList AkamaiSignatureHeaderAuthenticationKeyArrayInput `pulumi:"akamaiSignatureHeaderAuthenticationKeyList"`
}

func (AkamaiAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiAccessControl)(nil)).Elem()
}

func (i AkamaiAccessControlArgs) ToAkamaiAccessControlOutput() AkamaiAccessControlOutput {
	return i.ToAkamaiAccessControlOutputWithContext(context.Background())
}

func (i AkamaiAccessControlArgs) ToAkamaiAccessControlOutputWithContext(ctx context.Context) AkamaiAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AkamaiAccessControlOutput)
}

func (i AkamaiAccessControlArgs) ToAkamaiAccessControlPtrOutput() AkamaiAccessControlPtrOutput {
	return i.ToAkamaiAccessControlPtrOutputWithContext(context.Background())
}

func (i AkamaiAccessControlArgs) ToAkamaiAccessControlPtrOutputWithContext(ctx context.Context) AkamaiAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AkamaiAccessControlOutput).ToAkamaiAccessControlPtrOutputWithContext(ctx)
}

// AkamaiAccessControlPtrInput is an input type that accepts AkamaiAccessControlArgs, AkamaiAccessControlPtr and AkamaiAccessControlPtrOutput values.
// You can construct a concrete instance of `AkamaiAccessControlPtrInput` via:
//
//	        AkamaiAccessControlArgs{...}
//
//	or:
//
//	        nil
type AkamaiAccessControlPtrInput interface {
	pulumi.Input

	ToAkamaiAccessControlPtrOutput() AkamaiAccessControlPtrOutput
	ToAkamaiAccessControlPtrOutputWithContext(context.Context) AkamaiAccessControlPtrOutput
}

type akamaiAccessControlPtrType AkamaiAccessControlArgs

func AkamaiAccessControlPtr(v *AkamaiAccessControlArgs) AkamaiAccessControlPtrInput {
	return (*akamaiAccessControlPtrType)(v)
}

func (*akamaiAccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AkamaiAccessControl)(nil)).Elem()
}

func (i *akamaiAccessControlPtrType) ToAkamaiAccessControlPtrOutput() AkamaiAccessControlPtrOutput {
	return i.ToAkamaiAccessControlPtrOutputWithContext(context.Background())
}

func (i *akamaiAccessControlPtrType) ToAkamaiAccessControlPtrOutputWithContext(ctx context.Context) AkamaiAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AkamaiAccessControlPtrOutput)
}

// Akamai access control
type AkamaiAccessControlOutput struct{ *pulumi.OutputState }

func (AkamaiAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiAccessControl)(nil)).Elem()
}

func (o AkamaiAccessControlOutput) ToAkamaiAccessControlOutput() AkamaiAccessControlOutput {
	return o
}

func (o AkamaiAccessControlOutput) ToAkamaiAccessControlOutputWithContext(ctx context.Context) AkamaiAccessControlOutput {
	return o
}

func (o AkamaiAccessControlOutput) ToAkamaiAccessControlPtrOutput() AkamaiAccessControlPtrOutput {
	return o.ToAkamaiAccessControlPtrOutputWithContext(context.Background())
}

func (o AkamaiAccessControlOutput) ToAkamaiAccessControlPtrOutputWithContext(ctx context.Context) AkamaiAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AkamaiAccessControl) *AkamaiAccessControl {
		return &v
	}).(AkamaiAccessControlPtrOutput)
}

// authentication key list
func (o AkamaiAccessControlOutput) AkamaiSignatureHeaderAuthenticationKeyList() AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o.ApplyT(func(v AkamaiAccessControl) []AkamaiSignatureHeaderAuthenticationKey {
		return v.AkamaiSignatureHeaderAuthenticationKeyList
	}).(AkamaiSignatureHeaderAuthenticationKeyArrayOutput)
}

type AkamaiAccessControlPtrOutput struct{ *pulumi.OutputState }

func (AkamaiAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AkamaiAccessControl)(nil)).Elem()
}

func (o AkamaiAccessControlPtrOutput) ToAkamaiAccessControlPtrOutput() AkamaiAccessControlPtrOutput {
	return o
}

func (o AkamaiAccessControlPtrOutput) ToAkamaiAccessControlPtrOutputWithContext(ctx context.Context) AkamaiAccessControlPtrOutput {
	return o
}

func (o AkamaiAccessControlPtrOutput) Elem() AkamaiAccessControlOutput {
	return o.ApplyT(func(v *AkamaiAccessControl) AkamaiAccessControl {
		if v != nil {
			return *v
		}
		var ret AkamaiAccessControl
		return ret
	}).(AkamaiAccessControlOutput)
}

// authentication key list
func (o AkamaiAccessControlPtrOutput) AkamaiSignatureHeaderAuthenticationKeyList() AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o.ApplyT(func(v *AkamaiAccessControl) []AkamaiSignatureHeaderAuthenticationKey {
		if v == nil {
			return nil
		}
		return v.AkamaiSignatureHeaderAuthenticationKeyList
	}).(AkamaiSignatureHeaderAuthenticationKeyArrayOutput)
}

// Akamai access control
type AkamaiAccessControlResponse struct {
	// authentication key list
	AkamaiSignatureHeaderAuthenticationKeyList []AkamaiSignatureHeaderAuthenticationKeyResponse `pulumi:"akamaiSignatureHeaderAuthenticationKeyList"`
}

// Akamai access control
type AkamaiAccessControlResponseOutput struct{ *pulumi.OutputState }

func (AkamaiAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiAccessControlResponse)(nil)).Elem()
}

func (o AkamaiAccessControlResponseOutput) ToAkamaiAccessControlResponseOutput() AkamaiAccessControlResponseOutput {
	return o
}

func (o AkamaiAccessControlResponseOutput) ToAkamaiAccessControlResponseOutputWithContext(ctx context.Context) AkamaiAccessControlResponseOutput {
	return o
}

// authentication key list
func (o AkamaiAccessControlResponseOutput) AkamaiSignatureHeaderAuthenticationKeyList() AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput {
	return o.ApplyT(func(v AkamaiAccessControlResponse) []AkamaiSignatureHeaderAuthenticationKeyResponse {
		return v.AkamaiSignatureHeaderAuthenticationKeyList
	}).(AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput)
}

type AkamaiAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (AkamaiAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AkamaiAccessControlResponse)(nil)).Elem()
}

func (o AkamaiAccessControlResponsePtrOutput) ToAkamaiAccessControlResponsePtrOutput() AkamaiAccessControlResponsePtrOutput {
	return o
}

func (o AkamaiAccessControlResponsePtrOutput) ToAkamaiAccessControlResponsePtrOutputWithContext(ctx context.Context) AkamaiAccessControlResponsePtrOutput {
	return o
}

func (o AkamaiAccessControlResponsePtrOutput) Elem() AkamaiAccessControlResponseOutput {
	return o.ApplyT(func(v *AkamaiAccessControlResponse) AkamaiAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret AkamaiAccessControlResponse
		return ret
	}).(AkamaiAccessControlResponseOutput)
}

// authentication key list
func (o AkamaiAccessControlResponsePtrOutput) AkamaiSignatureHeaderAuthenticationKeyList() AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput {
	return o.ApplyT(func(v *AkamaiAccessControlResponse) []AkamaiSignatureHeaderAuthenticationKeyResponse {
		if v == nil {
			return nil
		}
		return v.AkamaiSignatureHeaderAuthenticationKeyList
	}).(AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput)
}

// Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKey struct {
	// authentication key
	Base64Key *string `pulumi:"base64Key"`
	// The expiration time of the authentication key.
	Expiration *string `pulumi:"expiration"`
	// identifier of the key
	Identifier *string `pulumi:"identifier"`
}

// AkamaiSignatureHeaderAuthenticationKeyInput is an input type that accepts AkamaiSignatureHeaderAuthenticationKeyArgs and AkamaiSignatureHeaderAuthenticationKeyOutput values.
// You can construct a concrete instance of `AkamaiSignatureHeaderAuthenticationKeyInput` via:
//
//	AkamaiSignatureHeaderAuthenticationKeyArgs{...}
type AkamaiSignatureHeaderAuthenticationKeyInput interface {
	pulumi.Input

	ToAkamaiSignatureHeaderAuthenticationKeyOutput() AkamaiSignatureHeaderAuthenticationKeyOutput
	ToAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(context.Context) AkamaiSignatureHeaderAuthenticationKeyOutput
}

// Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKeyArgs struct {
	// authentication key
	Base64Key pulumi.StringPtrInput `pulumi:"base64Key"`
	// The expiration time of the authentication key.
	Expiration pulumi.StringPtrInput `pulumi:"expiration"`
	// identifier of the key
	Identifier pulumi.StringPtrInput `pulumi:"identifier"`
}

func (AkamaiSignatureHeaderAuthenticationKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (i AkamaiSignatureHeaderAuthenticationKeyArgs) ToAkamaiSignatureHeaderAuthenticationKeyOutput() AkamaiSignatureHeaderAuthenticationKeyOutput {
	return i.ToAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(context.Background())
}

func (i AkamaiSignatureHeaderAuthenticationKeyArgs) ToAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AkamaiSignatureHeaderAuthenticationKeyOutput)
}

// AkamaiSignatureHeaderAuthenticationKeyArrayInput is an input type that accepts AkamaiSignatureHeaderAuthenticationKeyArray and AkamaiSignatureHeaderAuthenticationKeyArrayOutput values.
// You can construct a concrete instance of `AkamaiSignatureHeaderAuthenticationKeyArrayInput` via:
//
//	AkamaiSignatureHeaderAuthenticationKeyArray{ AkamaiSignatureHeaderAuthenticationKeyArgs{...} }
type AkamaiSignatureHeaderAuthenticationKeyArrayInput interface {
	pulumi.Input

	ToAkamaiSignatureHeaderAuthenticationKeyArrayOutput() AkamaiSignatureHeaderAuthenticationKeyArrayOutput
	ToAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(context.Context) AkamaiSignatureHeaderAuthenticationKeyArrayOutput
}

type AkamaiSignatureHeaderAuthenticationKeyArray []AkamaiSignatureHeaderAuthenticationKeyInput

func (AkamaiSignatureHeaderAuthenticationKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (i AkamaiSignatureHeaderAuthenticationKeyArray) ToAkamaiSignatureHeaderAuthenticationKeyArrayOutput() AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return i.ToAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(context.Background())
}

func (i AkamaiSignatureHeaderAuthenticationKeyArray) ToAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AkamaiSignatureHeaderAuthenticationKeyArrayOutput)
}

// Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKeyOutput struct{ *pulumi.OutputState }

func (AkamaiSignatureHeaderAuthenticationKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (o AkamaiSignatureHeaderAuthenticationKeyOutput) ToAkamaiSignatureHeaderAuthenticationKeyOutput() AkamaiSignatureHeaderAuthenticationKeyOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyOutput) ToAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyOutput {
	return o
}

// authentication key
func (o AkamaiSignatureHeaderAuthenticationKeyOutput) Base64Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKey) *string { return v.Base64Key }).(pulumi.StringPtrOutput)
}

// The expiration time of the authentication key.
func (o AkamaiSignatureHeaderAuthenticationKeyOutput) Expiration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKey) *string { return v.Expiration }).(pulumi.StringPtrOutput)
}

// identifier of the key
func (o AkamaiSignatureHeaderAuthenticationKeyOutput) Identifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKey) *string { return v.Identifier }).(pulumi.StringPtrOutput)
}

type AkamaiSignatureHeaderAuthenticationKeyArrayOutput struct{ *pulumi.OutputState }

func (AkamaiSignatureHeaderAuthenticationKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (o AkamaiSignatureHeaderAuthenticationKeyArrayOutput) ToAkamaiSignatureHeaderAuthenticationKeyArrayOutput() AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyArrayOutput) ToAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyArrayOutput) Index(i pulumi.IntInput) AkamaiSignatureHeaderAuthenticationKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AkamaiSignatureHeaderAuthenticationKey {
		return vs[0].([]AkamaiSignatureHeaderAuthenticationKey)[vs[1].(int)]
	}).(AkamaiSignatureHeaderAuthenticationKeyOutput)
}

// Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKeyResponse struct {
	// authentication key
	Base64Key *string `pulumi:"base64Key"`
	// The expiration time of the authentication key.
	Expiration *string `pulumi:"expiration"`
	// identifier of the key
	Identifier *string `pulumi:"identifier"`
}

// Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKeyResponseOutput struct{ *pulumi.OutputState }

func (AkamaiSignatureHeaderAuthenticationKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiSignatureHeaderAuthenticationKeyResponse)(nil)).Elem()
}

func (o AkamaiSignatureHeaderAuthenticationKeyResponseOutput) ToAkamaiSignatureHeaderAuthenticationKeyResponseOutput() AkamaiSignatureHeaderAuthenticationKeyResponseOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyResponseOutput) ToAkamaiSignatureHeaderAuthenticationKeyResponseOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyResponseOutput {
	return o
}

// authentication key
func (o AkamaiSignatureHeaderAuthenticationKeyResponseOutput) Base64Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKeyResponse) *string { return v.Base64Key }).(pulumi.StringPtrOutput)
}

// The expiration time of the authentication key.
func (o AkamaiSignatureHeaderAuthenticationKeyResponseOutput) Expiration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKeyResponse) *string { return v.Expiration }).(pulumi.StringPtrOutput)
}

// identifier of the key
func (o AkamaiSignatureHeaderAuthenticationKeyResponseOutput) Identifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKeyResponse) *string { return v.Identifier }).(pulumi.StringPtrOutput)
}

type AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput struct{ *pulumi.OutputState }

func (AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AkamaiSignatureHeaderAuthenticationKeyResponse)(nil)).Elem()
}

func (o AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput) ToAkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput() AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput) ToAkamaiSignatureHeaderAuthenticationKeyResponseArrayOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput) Index(i pulumi.IntInput) AkamaiSignatureHeaderAuthenticationKeyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AkamaiSignatureHeaderAuthenticationKeyResponse {
		return vs[0].([]AkamaiSignatureHeaderAuthenticationKeyResponse)[vs[1].(int)]
	}).(AkamaiSignatureHeaderAuthenticationKeyResponseOutput)
}

// The streaming endpoint current sku.
type ArmStreamingEndpointCurrentSku struct {
	// The streaming endpoint sku capacity.
	Capacity *int `pulumi:"capacity"`
}

// ArmStreamingEndpointCurrentSkuInput is an input type that accepts ArmStreamingEndpointCurrentSkuArgs and ArmStreamingEndpointCurrentSkuOutput values.
// You can construct a concrete instance of `ArmStreamingEndpointCurrentSkuInput` via:
//
//	ArmStreamingEndpointCurrentSkuArgs{...}
type ArmStreamingEndpointCurrentSkuInput interface {
	pulumi.Input

	ToArmStreamingEndpointCurrentSkuOutput() ArmStreamingEndpointCurrentSkuOutput
	ToArmStreamingEndpointCurrentSkuOutputWithContext(context.Context) ArmStreamingEndpointCurrentSkuOutput
}

// The streaming endpoint current sku.
type ArmStreamingEndpointCurrentSkuArgs struct {
	// The streaming endpoint sku capacity.
	Capacity pulumi.IntPtrInput `pulumi:"capacity"`
}

func (ArmStreamingEndpointCurrentSkuArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ArmStreamingEndpointCurrentSku)(nil)).Elem()
}

func (i ArmStreamingEndpointCurrentSkuArgs) ToArmStreamingEndpointCurrentSkuOutput() ArmStreamingEndpointCurrentSkuOutput {
	return i.ToArmStreamingEndpointCurrentSkuOutputWithContext(context.Background())
}

func (i ArmStreamingEndpointCurrentSkuArgs) ToArmStreamingEndpointCurrentSkuOutputWithContext(ctx context.Context) ArmStreamingEndpointCurrentSkuOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArmStreamingEndpointCurrentSkuOutput)
}

func (i ArmStreamingEndpointCurrentSkuArgs) ToArmStreamingEndpointCurrentSkuPtrOutput() ArmStreamingEndpointCurrentSkuPtrOutput {
	return i.ToArmStreamingEndpointCurrentSkuPtrOutputWithContext(context.Background())
}

func (i ArmStreamingEndpointCurrentSkuArgs) ToArmStreamingEndpointCurrentSkuPtrOutputWithContext(ctx context.Context) ArmStreamingEndpointCurrentSkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArmStreamingEndpointCurrentSkuOutput).ToArmStreamingEndpointCurrentSkuPtrOutputWithContext(ctx)
}

// ArmStreamingEndpointCurrentSkuPtrInput is an input type that accepts ArmStreamingEndpointCurrentSkuArgs, ArmStreamingEndpointCurrentSkuPtr and ArmStreamingEndpointCurrentSkuPtrOutput values.
// You can construct a concrete instance of `ArmStreamingEndpointCurrentSkuPtrInput` via:
//
//	        ArmStreamingEndpointCurrentSkuArgs{...}
//
//	or:
//
//	        nil
type ArmStreamingEndpointCurrentSkuPtrInput interface {
	pulumi.Input

	ToArmStreamingEndpointCurrentSkuPtrOutput() ArmStreamingEndpointCurrentSkuPtrOutput
	ToArmStreamingEndpointCurrentSkuPtrOutputWithContext(context.Context) ArmStreamingEndpointCurrentSkuPtrOutput
}

type armStreamingEndpointCurrentSkuPtrType ArmStreamingEndpointCurrentSkuArgs

func ArmStreamingEndpointCurrentSkuPtr(v *ArmStreamingEndpointCurrentSkuArgs) ArmStreamingEndpointCurrentSkuPtrInput {
	return (*armStreamingEndpointCurrentSkuPtrType)(v)
}

func (*armStreamingEndpointCurrentSkuPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ArmStreamingEndpointCurrentSku)(nil)).Elem()
}

func (i *armStreamingEndpointCurrentSkuPtrType) ToArmStreamingEndpointCurrentSkuPtrOutput() ArmStreamingEndpointCurrentSkuPtrOutput {
	return i.ToArmStreamingEndpointCurrentSkuPtrOutputWithContext(context.Background())
}

func (i *armStreamingEndpointCurrentSkuPtrType) ToArmStreamingEndpointCurrentSkuPtrOutputWithContext(ctx context.Context) ArmStreamingEndpointCurrentSkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArmStreamingEndpointCurrentSkuPtrOutput)
}

// The streaming endpoint current sku.
type ArmStreamingEndpointCurrentSkuOutput struct{ *pulumi.OutputState }

func (ArmStreamingEndpointCurrentSkuOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ArmStreamingEndpointCurrentSku)(nil)).Elem()
}

func (o ArmStreamingEndpointCurrentSkuOutput) ToArmStreamingEndpointCurrentSkuOutput() ArmStreamingEndpointCurrentSkuOutput {
	return o
}

func (o ArmStreamingEndpointCurrentSkuOutput) ToArmStreamingEndpointCurrentSkuOutputWithContext(ctx context.Context) ArmStreamingEndpointCurrentSkuOutput {
	return o
}

func (o ArmStreamingEndpointCurrentSkuOutput) ToArmStreamingEndpointCurrentSkuPtrOutput() ArmStreamingEndpointCurrentSkuPtrOutput {
	return o.ToArmStreamingEndpointCurrentSkuPtrOutputWithContext(context.Background())
}

func (o ArmStreamingEndpointCurrentSkuOutput) ToArmStreamingEndpointCurrentSkuPtrOutputWithContext(ctx context.Context) ArmStreamingEndpointCurrentSkuPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ArmStreamingEndpointCurrentSku) *ArmStreamingEndpointCurrentSku {
		return &v
	}).(ArmStreamingEndpointCurrentSkuPtrOutput)
}

// The streaming endpoint sku capacity.
func (o ArmStreamingEndpointCurrentSkuOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ArmStreamingEndpointCurrentSku) *int { return v.Capacity }).(pulumi.IntPtrOutput)
}

type ArmStreamingEndpointCurrentSkuPtrOutput struct{ *pulumi.OutputState }

func (ArmStreamingEndpointCurrentSkuPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ArmStreamingEndpointCurrentSku)(nil)).Elem()
}

func (o ArmStreamingEndpointCurrentSkuPtrOutput) ToArmStreamingEndpointCurrentSkuPtrOutput() ArmStreamingEndpointCurrentSkuPtrOutput {
	return o
}

func (o ArmStreamingEndpointCurrentSkuPtrOutput) ToArmStreamingEndpointCurrentSkuPtrOutputWithContext(ctx context.Context) ArmStreamingEndpointCurrentSkuPtrOutput {
	return o
}

func (o ArmStreamingEndpointCurrentSkuPtrOutput) Elem() ArmStreamingEndpointCurrentSkuOutput {
	return o.ApplyT(func(v *ArmStreamingEndpointCurrentSku) ArmStreamingEndpointCurrentSku {
		if v != nil {
			return *v
		}
		var ret ArmStreamingEndpointCurrentSku
		return ret
	}).(ArmStreamingEndpointCurrentSkuOutput)
}

// The streaming endpoint sku capacity.
func (o ArmStreamingEndpointCurrentSkuPtrOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ArmStreamingEndpointCurrentSku) *int {
		if v == nil {
			return nil
		}
		return v.Capacity
	}).(pulumi.IntPtrOutput)
}

// The streaming endpoint current sku.
type ArmStreamingEndpointCurrentSkuResponse struct {
	// The streaming endpoint sku capacity.
	Capacity *int `pulumi:"capacity"`
	// The streaming endpoint sku name.
	Name string `pulumi:"name"`
}

// The streaming endpoint current sku.
type ArmStreamingEndpointCurrentSkuResponseOutput struct{ *pulumi.OutputState }

func (ArmStreamingEndpointCurrentSkuResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ArmStreamingEndpointCurrentSkuResponse)(nil)).Elem()
}

func (o ArmStreamingEndpointCurrentSkuResponseOutput) ToArmStreamingEndpointCurrentSkuResponseOutput() ArmStreamingEndpointCurrentSkuResponseOutput {
	return o
}

func (o ArmStreamingEndpointCurrentSkuResponseOutput) ToArmStreamingEndpointCurrentSkuResponseOutputWithContext(ctx context.Context) ArmStreamingEndpointCurrentSkuResponseOutput {
	return o
}

// The streaming endpoint sku capacity.
func (o ArmStreamingEndpointCurrentSkuResponseOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ArmStreamingEndpointCurrentSkuResponse) *int { return v.Capacity }).(pulumi.IntPtrOutput)
}

// The streaming endpoint sku name.
func (o ArmStreamingEndpointCurrentSkuResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ArmStreamingEndpointCurrentSkuResponse) string { return v.Name }).(pulumi.StringOutput)
}

type ArmStreamingEndpointCurrentSkuResponsePtrOutput struct{ *pulumi.OutputState }

func (ArmStreamingEndpointCurrentSkuResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ArmStreamingEndpointCurrentSkuResponse)(nil)).Elem()
}

func (o ArmStreamingEndpointCurrentSkuResponsePtrOutput) ToArmStreamingEndpointCurrentSkuResponsePtrOutput() ArmStreamingEndpointCurrentSkuResponsePtrOutput {
	return o
}

func (o ArmStreamingEndpointCurrentSkuResponsePtrOutput) ToArmStreamingEndpointCurrentSkuResponsePtrOutputWithContext(ctx context.Context) ArmStreamingEndpointCurrentSkuResponsePtrOutput {
	return o
}

func (o ArmStreamingEndpointCurrentSkuResponsePtrOutput) Elem() ArmStreamingEndpointCurrentSkuResponseOutput {
	return o.ApplyT(func(v *ArmStreamingEndpointCurrentSkuResponse) ArmStreamingEndpointCurrentSkuResponse {
		if v != nil {
			return *v
		}
		var ret ArmStreamingEndpointCurrentSkuResponse
		return ret
	}).(ArmStreamingEndpointCurrentSkuResponseOutput)
}

// The streaming endpoint sku capacity.
func (o ArmStreamingEndpointCurrentSkuResponsePtrOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ArmStreamingEndpointCurrentSkuResponse) *int {
		if v == nil {
			return nil
		}
		return v.Capacity
	}).(pulumi.IntPtrOutput)
}

// The streaming endpoint sku name.
func (o ArmStreamingEndpointCurrentSkuResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ArmStreamingEndpointCurrentSkuResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// The Asset File Storage encryption metadata.
type AssetFileEncryptionMetadataResponse struct {
	// The Asset File Id.
	AssetFileId string `pulumi:"assetFileId"`
	// The Asset File name.
	AssetFileName *string `pulumi:"assetFileName"`
	// The Asset File initialization vector.
	InitializationVector *string `pulumi:"initializationVector"`
}

// The Asset File Storage encryption metadata.
type AssetFileEncryptionMetadataResponseOutput struct{ *pulumi.OutputState }

func (AssetFileEncryptionMetadataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AssetFileEncryptionMetadataResponse)(nil)).Elem()
}

func (o AssetFileEncryptionMetadataResponseOutput) ToAssetFileEncryptionMetadataResponseOutput() AssetFileEncryptionMetadataResponseOutput {
	return o
}

func (o AssetFileEncryptionMetadataResponseOutput) ToAssetFileEncryptionMetadataResponseOutputWithContext(ctx context.Context) AssetFileEncryptionMetadataResponseOutput {
	return o
}

// The Asset File Id.
func (o AssetFileEncryptionMetadataResponseOutput) AssetFileId() pulumi.StringOutput {
	return o.ApplyT(func(v AssetFileEncryptionMetadataResponse) string { return v.AssetFileId }).(pulumi.StringOutput)
}

// The Asset File name.
func (o AssetFileEncryptionMetadataResponseOutput) AssetFileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AssetFileEncryptionMetadataResponse) *string { return v.AssetFileName }).(pulumi.StringPtrOutput)
}

// The Asset File initialization vector.
func (o AssetFileEncryptionMetadataResponseOutput) InitializationVector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AssetFileEncryptionMetadataResponse) *string { return v.InitializationVector }).(pulumi.StringPtrOutput)
}

type AssetFileEncryptionMetadataResponseArrayOutput struct{ *pulumi.OutputState }

func (AssetFileEncryptionMetadataResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AssetFileEncryptionMetadataResponse)(nil)).Elem()
}

func (o AssetFileEncryptionMetadataResponseArrayOutput) ToAssetFileEncryptionMetadataResponseArrayOutput() AssetFileEncryptionMetadataResponseArrayOutput {
	return o
}

func (o AssetFileEncryptionMetadataResponseArrayOutput) ToAssetFileEncryptionMetadataResponseArrayOutputWithContext(ctx context.Context) AssetFileEncryptionMetadataResponseArrayOutput {
	return o
}

func (o AssetFileEncryptionMetadataResponseArrayOutput) Index(i pulumi.IntInput) AssetFileEncryptionMetadataResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AssetFileEncryptionMetadataResponse {
		return vs[0].([]AssetFileEncryptionMetadataResponse)[vs[1].(int)]
	}).(AssetFileEncryptionMetadataResponseOutput)
}

// Properties of the Streaming Locator.
type AssetStreamingLocatorResponse struct {
	// Asset Name.
	AssetName string `pulumi:"assetName"`
	// The creation time of the Streaming Locator.
	Created string `pulumi:"created"`
	// Name of the default ContentKeyPolicy used by this Streaming Locator.
	DefaultContentKeyPolicyName string `pulumi:"defaultContentKeyPolicyName"`
	// The end time of the Streaming Locator.
	EndTime string `pulumi:"endTime"`
	// Streaming Locator name.
	Name string `pulumi:"name"`
	// The start time of the Streaming Locator.
	StartTime string `pulumi:"startTime"`
	// StreamingLocatorId of the Streaming Locator.
	StreamingLocatorId string `pulumi:"streamingLocatorId"`
	// Name of the Streaming Policy used by this Streaming Locator.
	StreamingPolicyName string `pulumi:"streamingPolicyName"`
}

// Properties of the Streaming Locator.
type AssetStreamingLocatorResponseOutput struct{ *pulumi.OutputState }

func (AssetStreamingLocatorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AssetStreamingLocatorResponse)(nil)).Elem()
}

func (o AssetStreamingLocatorResponseOutput) ToAssetStreamingLocatorResponseOutput() AssetStreamingLocatorResponseOutput {
	return o
}

func (o AssetStreamingLocatorResponseOutput) ToAssetStreamingLocatorResponseOutputWithContext(ctx context.Context) AssetStreamingLocatorResponseOutput {
	return o
}

// Asset Name.
func (o AssetStreamingLocatorResponseOutput) AssetName() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.AssetName }).(pulumi.StringOutput)
}

// The creation time of the Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) Created() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.Created }).(pulumi.StringOutput)
}

// Name of the default ContentKeyPolicy used by this Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) DefaultContentKeyPolicyName() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.DefaultContentKeyPolicyName }).(pulumi.StringOutput)
}

// The end time of the Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.EndTime }).(pulumi.StringOutput)
}

// Streaming Locator name.
func (o AssetStreamingLocatorResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The start time of the Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.StartTime }).(pulumi.StringOutput)
}

// StreamingLocatorId of the Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) StreamingLocatorId() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.StreamingLocatorId }).(pulumi.StringOutput)
}

// Name of the Streaming Policy used by this Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) StreamingPolicyName() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.StreamingPolicyName }).(pulumi.StringOutput)
}

type AssetStreamingLocatorResponseArrayOutput struct{ *pulumi.OutputState }

func (AssetStreamingLocatorResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AssetStreamingLocatorResponse)(nil)).Elem()
}

func (o AssetStreamingLocatorResponseArrayOutput) ToAssetStreamingLocatorResponseArrayOutput() AssetStreamingLocatorResponseArrayOutput {
	return o
}

func (o AssetStreamingLocatorResponseArrayOutput) ToAssetStreamingLocatorResponseArrayOutputWithContext(ctx context.Context) AssetStreamingLocatorResponseArrayOutput {
	return o
}

func (o AssetStreamingLocatorResponseArrayOutput) Index(i pulumi.IntInput) AssetStreamingLocatorResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AssetStreamingLocatorResponse {
		return vs[0].([]AssetStreamingLocatorResponse)[vs[1].(int)]
	}).(AssetStreamingLocatorResponseOutput)
}

// Defines the common properties for all audio codecs.
type Audio struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels *int `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Audio'.
	OdataType string `pulumi:"odataType"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate *int `pulumi:"samplingRate"`
}

// AudioInput is an input type that accepts AudioArgs and AudioOutput values.
// You can construct a concrete instance of `AudioInput` via:
//
//	AudioArgs{...}
type AudioInput interface {
	pulumi.Input

	ToAudioOutput() AudioOutput
	ToAudioOutputWithContext(context.Context) AudioOutput
}

// Defines the common properties for all audio codecs.
type AudioArgs struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate pulumi.IntPtrInput `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels pulumi.IntPtrInput `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Audio'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate pulumi.IntPtrInput `pulumi:"samplingRate"`
}

func (AudioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Audio)(nil)).Elem()
}

func (i AudioArgs) ToAudioOutput() AudioOutput {
	return i.ToAudioOutputWithContext(context.Background())
}

func (i AudioArgs) ToAudioOutputWithContext(ctx context.Context) AudioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudioOutput)
}

// Defines the common properties for all audio codecs.
type AudioOutput struct{ *pulumi.OutputState }

func (AudioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Audio)(nil)).Elem()
}

func (o AudioOutput) ToAudioOutput() AudioOutput {
	return o
}

func (o AudioOutput) ToAudioOutputWithContext(ctx context.Context) AudioOutput {
	return o
}

// The bitrate, in bits per second, of the output encoded audio.
func (o AudioOutput) Bitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Audio) *int { return v.Bitrate }).(pulumi.IntPtrOutput)
}

// The number of channels in the audio.
func (o AudioOutput) Channels() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Audio) *int { return v.Channels }).(pulumi.IntPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o AudioOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Audio) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.Audio'.
func (o AudioOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v Audio) string { return v.OdataType }).(pulumi.StringOutput)
}

// The sampling rate to use for encoding in hertz.
func (o AudioOutput) SamplingRate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Audio) *int { return v.SamplingRate }).(pulumi.IntPtrOutput)
}

// The Audio Analyzer preset applies a pre-defined set of AI-based analysis operations, including speech transcription. Currently, the preset supports processing of content with a single audio track.
type AudioAnalyzerPreset struct {
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `pulumi:"audioLanguage"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioAnalyzerPreset'.
	OdataType string `pulumi:"odataType"`
}

// AudioAnalyzerPresetInput is an input type that accepts AudioAnalyzerPresetArgs and AudioAnalyzerPresetOutput values.
// You can construct a concrete instance of `AudioAnalyzerPresetInput` via:
//
//	AudioAnalyzerPresetArgs{...}
type AudioAnalyzerPresetInput interface {
	pulumi.Input

	ToAudioAnalyzerPresetOutput() AudioAnalyzerPresetOutput
	ToAudioAnalyzerPresetOutputWithContext(context.Context) AudioAnalyzerPresetOutput
}

// The Audio Analyzer preset applies a pre-defined set of AI-based analysis operations, including speech transcription. Currently, the preset supports processing of content with a single audio track.
type AudioAnalyzerPresetArgs struct {
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage pulumi.StringPtrInput `pulumi:"audioLanguage"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions pulumi.StringMapInput `pulumi:"experimentalOptions"`
	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioAnalyzerPreset'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (AudioAnalyzerPresetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioAnalyzerPreset)(nil)).Elem()
}

func (i AudioAnalyzerPresetArgs) ToAudioAnalyzerPresetOutput() AudioAnalyzerPresetOutput {
	return i.ToAudioAnalyzerPresetOutputWithContext(context.Background())
}

func (i AudioAnalyzerPresetArgs) ToAudioAnalyzerPresetOutputWithContext(ctx context.Context) AudioAnalyzerPresetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudioAnalyzerPresetOutput)
}

func (i AudioAnalyzerPresetArgs) ToAudioAnalyzerPresetPtrOutput() AudioAnalyzerPresetPtrOutput {
	return i.ToAudioAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (i AudioAnalyzerPresetArgs) ToAudioAnalyzerPresetPtrOutputWithContext(ctx context.Context) AudioAnalyzerPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudioAnalyzerPresetOutput).ToAudioAnalyzerPresetPtrOutputWithContext(ctx)
}

// AudioAnalyzerPresetPtrInput is an input type that accepts AudioAnalyzerPresetArgs, AudioAnalyzerPresetPtr and AudioAnalyzerPresetPtrOutput values.
// You can construct a concrete instance of `AudioAnalyzerPresetPtrInput` via:
//
//	        AudioAnalyzerPresetArgs{...}
//
//	or:
//
//	        nil
type AudioAnalyzerPresetPtrInput interface {
	pulumi.Input

	ToAudioAnalyzerPresetPtrOutput() AudioAnalyzerPresetPtrOutput
	ToAudioAnalyzerPresetPtrOutputWithContext(context.Context) AudioAnalyzerPresetPtrOutput
}

type audioAnalyzerPresetPtrType AudioAnalyzerPresetArgs

func AudioAnalyzerPresetPtr(v *AudioAnalyzerPresetArgs) AudioAnalyzerPresetPtrInput {
	return (*audioAnalyzerPresetPtrType)(v)
}

func (*audioAnalyzerPresetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AudioAnalyzerPreset)(nil)).Elem()
}

func (i *audioAnalyzerPresetPtrType) ToAudioAnalyzerPresetPtrOutput() AudioAnalyzerPresetPtrOutput {
	return i.ToAudioAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (i *audioAnalyzerPresetPtrType) ToAudioAnalyzerPresetPtrOutputWithContext(ctx context.Context) AudioAnalyzerPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudioAnalyzerPresetPtrOutput)
}

// The Audio Analyzer preset applies a pre-defined set of AI-based analysis operations, including speech transcription. Currently, the preset supports processing of content with a single audio track.
type AudioAnalyzerPresetOutput struct{ *pulumi.OutputState }

func (AudioAnalyzerPresetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioAnalyzerPreset)(nil)).Elem()
}

func (o AudioAnalyzerPresetOutput) ToAudioAnalyzerPresetOutput() AudioAnalyzerPresetOutput {
	return o
}

func (o AudioAnalyzerPresetOutput) ToAudioAnalyzerPresetOutputWithContext(ctx context.Context) AudioAnalyzerPresetOutput {
	return o
}

func (o AudioAnalyzerPresetOutput) ToAudioAnalyzerPresetPtrOutput() AudioAnalyzerPresetPtrOutput {
	return o.ToAudioAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (o AudioAnalyzerPresetOutput) ToAudioAnalyzerPresetPtrOutputWithContext(ctx context.Context) AudioAnalyzerPresetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AudioAnalyzerPreset) *AudioAnalyzerPreset {
		return &v
	}).(AudioAnalyzerPresetPtrOutput)
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
func (o AudioAnalyzerPresetOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioAnalyzerPreset) *string { return v.AudioLanguage }).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o AudioAnalyzerPresetOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v AudioAnalyzerPreset) map[string]string { return v.ExperimentalOptions }).(pulumi.StringMapOutput)
}

// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
func (o AudioAnalyzerPresetOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioAnalyzerPreset) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioAnalyzerPreset'.
func (o AudioAnalyzerPresetOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AudioAnalyzerPreset) string { return v.OdataType }).(pulumi.StringOutput)
}

type AudioAnalyzerPresetPtrOutput struct{ *pulumi.OutputState }

func (AudioAnalyzerPresetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AudioAnalyzerPreset)(nil)).Elem()
}

func (o AudioAnalyzerPresetPtrOutput) ToAudioAnalyzerPresetPtrOutput() AudioAnalyzerPresetPtrOutput {
	return o
}

func (o AudioAnalyzerPresetPtrOutput) ToAudioAnalyzerPresetPtrOutputWithContext(ctx context.Context) AudioAnalyzerPresetPtrOutput {
	return o
}

func (o AudioAnalyzerPresetPtrOutput) Elem() AudioAnalyzerPresetOutput {
	return o.ApplyT(func(v *AudioAnalyzerPreset) AudioAnalyzerPreset {
		if v != nil {
			return *v
		}
		var ret AudioAnalyzerPreset
		return ret
	}).(AudioAnalyzerPresetOutput)
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
func (o AudioAnalyzerPresetPtrOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return v.AudioLanguage
	}).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o AudioAnalyzerPresetPtrOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *AudioAnalyzerPreset) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExperimentalOptions
	}).(pulumi.StringMapOutput)
}

// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
func (o AudioAnalyzerPresetPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioAnalyzerPreset'.
func (o AudioAnalyzerPresetPtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// The Audio Analyzer preset applies a pre-defined set of AI-based analysis operations, including speech transcription. Currently, the preset supports processing of content with a single audio track.
type AudioAnalyzerPresetResponse struct {
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `pulumi:"audioLanguage"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioAnalyzerPreset'.
	OdataType string `pulumi:"odataType"`
}

// The Audio Analyzer preset applies a pre-defined set of AI-based analysis operations, including speech transcription. Currently, the preset supports processing of content with a single audio track.
type AudioAnalyzerPresetResponseOutput struct{ *pulumi.OutputState }

func (AudioAnalyzerPresetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioAnalyzerPresetResponse)(nil)).Elem()
}

func (o AudioAnalyzerPresetResponseOutput) ToAudioAnalyzerPresetResponseOutput() AudioAnalyzerPresetResponseOutput {
	return o
}

func (o AudioAnalyzerPresetResponseOutput) ToAudioAnalyzerPresetResponseOutputWithContext(ctx context.Context) AudioAnalyzerPresetResponseOutput {
	return o
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
func (o AudioAnalyzerPresetResponseOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioAnalyzerPresetResponse) *string { return v.AudioLanguage }).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o AudioAnalyzerPresetResponseOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v AudioAnalyzerPresetResponse) map[string]string { return v.ExperimentalOptions }).(pulumi.StringMapOutput)
}

// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
func (o AudioAnalyzerPresetResponseOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioAnalyzerPresetResponse) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioAnalyzerPreset'.
func (o AudioAnalyzerPresetResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AudioAnalyzerPresetResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

type AudioAnalyzerPresetResponsePtrOutput struct{ *pulumi.OutputState }

func (AudioAnalyzerPresetResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AudioAnalyzerPresetResponse)(nil)).Elem()
}

func (o AudioAnalyzerPresetResponsePtrOutput) ToAudioAnalyzerPresetResponsePtrOutput() AudioAnalyzerPresetResponsePtrOutput {
	return o
}

func (o AudioAnalyzerPresetResponsePtrOutput) ToAudioAnalyzerPresetResponsePtrOutputWithContext(ctx context.Context) AudioAnalyzerPresetResponsePtrOutput {
	return o
}

func (o AudioAnalyzerPresetResponsePtrOutput) Elem() AudioAnalyzerPresetResponseOutput {
	return o.ApplyT(func(v *AudioAnalyzerPresetResponse) AudioAnalyzerPresetResponse {
		if v != nil {
			return *v
		}
		var ret AudioAnalyzerPresetResponse
		return ret
	}).(AudioAnalyzerPresetResponseOutput)
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
func (o AudioAnalyzerPresetResponsePtrOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioAnalyzerPresetResponse) *string {
		if v == nil {
			return nil
		}
		return v.AudioLanguage
	}).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o AudioAnalyzerPresetResponsePtrOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *AudioAnalyzerPresetResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExperimentalOptions
	}).(pulumi.StringMapOutput)
}

// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
func (o AudioAnalyzerPresetResponsePtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioAnalyzerPresetResponse) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioAnalyzerPreset'.
func (o AudioAnalyzerPresetResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioAnalyzerPresetResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// Describes the properties of an audio overlay.
type AudioOverlay struct {
	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `pulumi:"audioGainLevel"`
	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
	End *string `pulumi:"end"`
	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `pulumi:"fadeInDuration"`
	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `pulumi:"fadeOutDuration"`
	// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel string `pulumi:"inputLabel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioOverlay'.
	OdataType string `pulumi:"odataType"`
	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
	Start *string `pulumi:"start"`
}

// AudioOverlayInput is an input type that accepts AudioOverlayArgs and AudioOverlayOutput values.
// You can construct a concrete instance of `AudioOverlayInput` via:
//
//	AudioOverlayArgs{...}
type AudioOverlayInput interface {
	pulumi.Input

	ToAudioOverlayOutput() AudioOverlayOutput
	ToAudioOverlayOutputWithContext(context.Context) AudioOverlayOutput
}

// Describes the properties of an audio overlay.
type AudioOverlayArgs struct {
	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel pulumi.Float64PtrInput `pulumi:"audioGainLevel"`
	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
	End pulumi.StringPtrInput `pulumi:"end"`
	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration pulumi.StringPtrInput `pulumi:"fadeInDuration"`
	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration pulumi.StringPtrInput `pulumi:"fadeOutDuration"`
	// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel pulumi.StringInput `pulumi:"inputLabel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioOverlay'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
	Start pulumi.StringPtrInput `pulumi:"start"`
}

func (AudioOverlayArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioOverlay)(nil)).Elem()
}

func (i AudioOverlayArgs) ToAudioOverlayOutput() AudioOverlayOutput {
	return i.ToAudioOverlayOutputWithContext(context.Background())
}

func (i AudioOverlayArgs) ToAudioOverlayOutputWithContext(ctx context.Context) AudioOverlayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudioOverlayOutput)
}

// Describes the properties of an audio overlay.
type AudioOverlayOutput struct{ *pulumi.OutputState }

func (AudioOverlayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioOverlay)(nil)).Elem()
}

func (o AudioOverlayOutput) ToAudioOverlayOutput() AudioOverlayOutput {
	return o
}

func (o AudioOverlayOutput) ToAudioOverlayOutputWithContext(ctx context.Context) AudioOverlayOutput {
	return o
}

// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
func (o AudioOverlayOutput) AudioGainLevel() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v AudioOverlay) *float64 { return v.AudioGainLevel }).(pulumi.Float64PtrOutput)
}

// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
func (o AudioOverlayOutput) End() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioOverlay) *string { return v.End }).(pulumi.StringPtrOutput)
}

// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
func (o AudioOverlayOutput) FadeInDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioOverlay) *string { return v.FadeInDuration }).(pulumi.StringPtrOutput)
}

// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
func (o AudioOverlayOutput) FadeOutDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioOverlay) *string { return v.FadeOutDuration }).(pulumi.StringPtrOutput)
}

// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
func (o AudioOverlayOutput) InputLabel() pulumi.StringOutput {
	return o.ApplyT(func(v AudioOverlay) string { return v.InputLabel }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioOverlay'.
func (o AudioOverlayOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AudioOverlay) string { return v.OdataType }).(pulumi.StringOutput)
}

// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
func (o AudioOverlayOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioOverlay) *string { return v.Start }).(pulumi.StringPtrOutput)
}

// Describes the properties of an audio overlay.
type AudioOverlayResponse struct {
	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `pulumi:"audioGainLevel"`
	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
	End *string `pulumi:"end"`
	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `pulumi:"fadeInDuration"`
	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `pulumi:"fadeOutDuration"`
	// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel string `pulumi:"inputLabel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioOverlay'.
	OdataType string `pulumi:"odataType"`
	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
	Start *string `pulumi:"start"`
}

// Describes the properties of an audio overlay.
type AudioOverlayResponseOutput struct{ *pulumi.OutputState }

func (AudioOverlayResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioOverlayResponse)(nil)).Elem()
}

func (o AudioOverlayResponseOutput) ToAudioOverlayResponseOutput() AudioOverlayResponseOutput {
	return o
}

func (o AudioOverlayResponseOutput) ToAudioOverlayResponseOutputWithContext(ctx context.Context) AudioOverlayResponseOutput {
	return o
}

// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
func (o AudioOverlayResponseOutput) AudioGainLevel() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v AudioOverlayResponse) *float64 { return v.AudioGainLevel }).(pulumi.Float64PtrOutput)
}

// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
func (o AudioOverlayResponseOutput) End() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioOverlayResponse) *string { return v.End }).(pulumi.StringPtrOutput)
}

// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
func (o AudioOverlayResponseOutput) FadeInDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioOverlayResponse) *string { return v.FadeInDuration }).(pulumi.StringPtrOutput)
}

// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
func (o AudioOverlayResponseOutput) FadeOutDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioOverlayResponse) *string { return v.FadeOutDuration }).(pulumi.StringPtrOutput)
}

// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
func (o AudioOverlayResponseOutput) InputLabel() pulumi.StringOutput {
	return o.ApplyT(func(v AudioOverlayResponse) string { return v.InputLabel }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioOverlay'.
func (o AudioOverlayResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AudioOverlayResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
func (o AudioOverlayResponseOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioOverlayResponse) *string { return v.Start }).(pulumi.StringPtrOutput)
}

// Defines the common properties for all audio codecs.
type AudioResponse struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels *int `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Audio'.
	OdataType string `pulumi:"odataType"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate *int `pulumi:"samplingRate"`
}

// Defines the common properties for all audio codecs.
type AudioResponseOutput struct{ *pulumi.OutputState }

func (AudioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioResponse)(nil)).Elem()
}

func (o AudioResponseOutput) ToAudioResponseOutput() AudioResponseOutput {
	return o
}

func (o AudioResponseOutput) ToAudioResponseOutputWithContext(ctx context.Context) AudioResponseOutput {
	return o
}

// The bitrate, in bits per second, of the output encoded audio.
func (o AudioResponseOutput) Bitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AudioResponse) *int { return v.Bitrate }).(pulumi.IntPtrOutput)
}

// The number of channels in the audio.
func (o AudioResponseOutput) Channels() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AudioResponse) *int { return v.Channels }).(pulumi.IntPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o AudioResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.Audio'.
func (o AudioResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AudioResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The sampling rate to use for encoding in hertz.
func (o AudioResponseOutput) SamplingRate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AudioResponse) *int { return v.SamplingRate }).(pulumi.IntPtrOutput)
}

// Represents an audio track in the asset.
type AudioTrack struct {
	// The DASH specific setting for the audio track.
	DashSettings *DashSettings `pulumi:"dashSettings"`
	// The display name of the audio track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
	DisplayName *string `pulumi:"displayName"`
	// The file name to the source file. This file is located in the storage container of the asset.
	FileName *string `pulumi:"fileName"`
	// The HLS specific setting for the audio track.
	HlsSettings *HlsSettings `pulumi:"hlsSettings"`
	// The RFC5646 language code for the audio track.
	LanguageCode *string `pulumi:"languageCode"`
	// The MPEG-4 audio track ID for the audio track.
	Mpeg4TrackId *int `pulumi:"mpeg4TrackId"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioTrack'.
	OdataType string `pulumi:"odataType"`
}

// AudioTrackInput is an input type that accepts AudioTrackArgs and AudioTrackOutput values.
// You can construct a concrete instance of `AudioTrackInput` via:
//
//	AudioTrackArgs{...}
type AudioTrackInput interface {
	pulumi.Input

	ToAudioTrackOutput() AudioTrackOutput
	ToAudioTrackOutputWithContext(context.Context) AudioTrackOutput
}

// Represents an audio track in the asset.
type AudioTrackArgs struct {
	// The DASH specific setting for the audio track.
	DashSettings DashSettingsPtrInput `pulumi:"dashSettings"`
	// The display name of the audio track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// The file name to the source file. This file is located in the storage container of the asset.
	FileName pulumi.StringPtrInput `pulumi:"fileName"`
	// The HLS specific setting for the audio track.
	HlsSettings HlsSettingsPtrInput `pulumi:"hlsSettings"`
	// The RFC5646 language code for the audio track.
	LanguageCode pulumi.StringPtrInput `pulumi:"languageCode"`
	// The MPEG-4 audio track ID for the audio track.
	Mpeg4TrackId pulumi.IntPtrInput `pulumi:"mpeg4TrackId"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioTrack'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (AudioTrackArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioTrack)(nil)).Elem()
}

func (i AudioTrackArgs) ToAudioTrackOutput() AudioTrackOutput {
	return i.ToAudioTrackOutputWithContext(context.Background())
}

func (i AudioTrackArgs) ToAudioTrackOutputWithContext(ctx context.Context) AudioTrackOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudioTrackOutput)
}

func (i AudioTrackArgs) ToAudioTrackPtrOutput() AudioTrackPtrOutput {
	return i.ToAudioTrackPtrOutputWithContext(context.Background())
}

func (i AudioTrackArgs) ToAudioTrackPtrOutputWithContext(ctx context.Context) AudioTrackPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudioTrackOutput).ToAudioTrackPtrOutputWithContext(ctx)
}

// AudioTrackPtrInput is an input type that accepts AudioTrackArgs, AudioTrackPtr and AudioTrackPtrOutput values.
// You can construct a concrete instance of `AudioTrackPtrInput` via:
//
//	        AudioTrackArgs{...}
//
//	or:
//
//	        nil
type AudioTrackPtrInput interface {
	pulumi.Input

	ToAudioTrackPtrOutput() AudioTrackPtrOutput
	ToAudioTrackPtrOutputWithContext(context.Context) AudioTrackPtrOutput
}

type audioTrackPtrType AudioTrackArgs

func AudioTrackPtr(v *AudioTrackArgs) AudioTrackPtrInput {
	return (*audioTrackPtrType)(v)
}

func (*audioTrackPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AudioTrack)(nil)).Elem()
}

func (i *audioTrackPtrType) ToAudioTrackPtrOutput() AudioTrackPtrOutput {
	return i.ToAudioTrackPtrOutputWithContext(context.Background())
}

func (i *audioTrackPtrType) ToAudioTrackPtrOutputWithContext(ctx context.Context) AudioTrackPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudioTrackPtrOutput)
}

// Represents an audio track in the asset.
type AudioTrackOutput struct{ *pulumi.OutputState }

func (AudioTrackOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioTrack)(nil)).Elem()
}

func (o AudioTrackOutput) ToAudioTrackOutput() AudioTrackOutput {
	return o
}

func (o AudioTrackOutput) ToAudioTrackOutputWithContext(ctx context.Context) AudioTrackOutput {
	return o
}

func (o AudioTrackOutput) ToAudioTrackPtrOutput() AudioTrackPtrOutput {
	return o.ToAudioTrackPtrOutputWithContext(context.Background())
}

func (o AudioTrackOutput) ToAudioTrackPtrOutputWithContext(ctx context.Context) AudioTrackPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AudioTrack) *AudioTrack {
		return &v
	}).(AudioTrackPtrOutput)
}

// The DASH specific setting for the audio track.
func (o AudioTrackOutput) DashSettings() DashSettingsPtrOutput {
	return o.ApplyT(func(v AudioTrack) *DashSettings { return v.DashSettings }).(DashSettingsPtrOutput)
}

// The display name of the audio track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
func (o AudioTrackOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioTrack) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// The file name to the source file. This file is located in the storage container of the asset.
func (o AudioTrackOutput) FileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioTrack) *string { return v.FileName }).(pulumi.StringPtrOutput)
}

// The HLS specific setting for the audio track.
func (o AudioTrackOutput) HlsSettings() HlsSettingsPtrOutput {
	return o.ApplyT(func(v AudioTrack) *HlsSettings { return v.HlsSettings }).(HlsSettingsPtrOutput)
}

// The RFC5646 language code for the audio track.
func (o AudioTrackOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioTrack) *string { return v.LanguageCode }).(pulumi.StringPtrOutput)
}

// The MPEG-4 audio track ID for the audio track.
func (o AudioTrackOutput) Mpeg4TrackId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AudioTrack) *int { return v.Mpeg4TrackId }).(pulumi.IntPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioTrack'.
func (o AudioTrackOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AudioTrack) string { return v.OdataType }).(pulumi.StringOutput)
}

type AudioTrackPtrOutput struct{ *pulumi.OutputState }

func (AudioTrackPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AudioTrack)(nil)).Elem()
}

func (o AudioTrackPtrOutput) ToAudioTrackPtrOutput() AudioTrackPtrOutput {
	return o
}

func (o AudioTrackPtrOutput) ToAudioTrackPtrOutputWithContext(ctx context.Context) AudioTrackPtrOutput {
	return o
}

func (o AudioTrackPtrOutput) Elem() AudioTrackOutput {
	return o.ApplyT(func(v *AudioTrack) AudioTrack {
		if v != nil {
			return *v
		}
		var ret AudioTrack
		return ret
	}).(AudioTrackOutput)
}

// The DASH specific setting for the audio track.
func (o AudioTrackPtrOutput) DashSettings() DashSettingsPtrOutput {
	return o.ApplyT(func(v *AudioTrack) *DashSettings {
		if v == nil {
			return nil
		}
		return v.DashSettings
	}).(DashSettingsPtrOutput)
}

// The display name of the audio track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
func (o AudioTrackPtrOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioTrack) *string {
		if v == nil {
			return nil
		}
		return v.DisplayName
	}).(pulumi.StringPtrOutput)
}

// The file name to the source file. This file is located in the storage container of the asset.
func (o AudioTrackPtrOutput) FileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioTrack) *string {
		if v == nil {
			return nil
		}
		return v.FileName
	}).(pulumi.StringPtrOutput)
}

// The HLS specific setting for the audio track.
func (o AudioTrackPtrOutput) HlsSettings() HlsSettingsPtrOutput {
	return o.ApplyT(func(v *AudioTrack) *HlsSettings {
		if v == nil {
			return nil
		}
		return v.HlsSettings
	}).(HlsSettingsPtrOutput)
}

// The RFC5646 language code for the audio track.
func (o AudioTrackPtrOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioTrack) *string {
		if v == nil {
			return nil
		}
		return v.LanguageCode
	}).(pulumi.StringPtrOutput)
}

// The MPEG-4 audio track ID for the audio track.
func (o AudioTrackPtrOutput) Mpeg4TrackId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AudioTrack) *int {
		if v == nil {
			return nil
		}
		return v.Mpeg4TrackId
	}).(pulumi.IntPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioTrack'.
func (o AudioTrackPtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioTrack) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// A TrackSelection to select audio tracks.
type AudioTrackDescriptor struct {
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioTrackDescriptor'.
	OdataType string `pulumi:"odataType"`
}

// AudioTrackDescriptorInput is an input type that accepts AudioTrackDescriptorArgs and AudioTrackDescriptorOutput values.
// You can construct a concrete instance of `AudioTrackDescriptorInput` via:
//
//	AudioTrackDescriptorArgs{...}
type AudioTrackDescriptorInput interface {
	pulumi.Input

	ToAudioTrackDescriptorOutput() AudioTrackDescriptorOutput
	ToAudioTrackDescriptorOutputWithContext(context.Context) AudioTrackDescriptorOutput
}

// A TrackSelection to select audio tracks.
type AudioTrackDescriptorArgs struct {
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping pulumi.StringPtrInput `pulumi:"channelMapping"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioTrackDescriptor'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (AudioTrackDescriptorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioTrackDescriptor)(nil)).Elem()
}

func (i AudioTrackDescriptorArgs) ToAudioTrackDescriptorOutput() AudioTrackDescriptorOutput {
	return i.ToAudioTrackDescriptorOutputWithContext(context.Background())
}

func (i AudioTrackDescriptorArgs) ToAudioTrackDescriptorOutputWithContext(ctx context.Context) AudioTrackDescriptorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudioTrackDescriptorOutput)
}

// A TrackSelection to select audio tracks.
type AudioTrackDescriptorOutput struct{ *pulumi.OutputState }

func (AudioTrackDescriptorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioTrackDescriptor)(nil)).Elem()
}

func (o AudioTrackDescriptorOutput) ToAudioTrackDescriptorOutput() AudioTrackDescriptorOutput {
	return o
}

func (o AudioTrackDescriptorOutput) ToAudioTrackDescriptorOutputWithContext(ctx context.Context) AudioTrackDescriptorOutput {
	return o
}

// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
func (o AudioTrackDescriptorOutput) ChannelMapping() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioTrackDescriptor) *string { return v.ChannelMapping }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioTrackDescriptor'.
func (o AudioTrackDescriptorOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AudioTrackDescriptor) string { return v.OdataType }).(pulumi.StringOutput)
}

// A TrackSelection to select audio tracks.
type AudioTrackDescriptorResponse struct {
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioTrackDescriptor'.
	OdataType string `pulumi:"odataType"`
}

// A TrackSelection to select audio tracks.
type AudioTrackDescriptorResponseOutput struct{ *pulumi.OutputState }

func (AudioTrackDescriptorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioTrackDescriptorResponse)(nil)).Elem()
}

func (o AudioTrackDescriptorResponseOutput) ToAudioTrackDescriptorResponseOutput() AudioTrackDescriptorResponseOutput {
	return o
}

func (o AudioTrackDescriptorResponseOutput) ToAudioTrackDescriptorResponseOutputWithContext(ctx context.Context) AudioTrackDescriptorResponseOutput {
	return o
}

// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
func (o AudioTrackDescriptorResponseOutput) ChannelMapping() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioTrackDescriptorResponse) *string { return v.ChannelMapping }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioTrackDescriptor'.
func (o AudioTrackDescriptorResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AudioTrackDescriptorResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Represents an audio track in the asset.
type AudioTrackResponse struct {
	// The stream bit rate for the audio track.
	BitRate int `pulumi:"bitRate"`
	// The DASH specific setting for the audio track.
	DashSettings *DashSettingsResponse `pulumi:"dashSettings"`
	// The display name of the audio track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
	DisplayName *string `pulumi:"displayName"`
	// The file name to the source file. This file is located in the storage container of the asset.
	FileName *string `pulumi:"fileName"`
	// The HLS specific setting for the audio track.
	HlsSettings *HlsSettingsResponse `pulumi:"hlsSettings"`
	// The RFC5646 language code for the audio track.
	LanguageCode *string `pulumi:"languageCode"`
	// The MPEG-4 audio track ID for the audio track.
	Mpeg4TrackId *int `pulumi:"mpeg4TrackId"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioTrack'.
	OdataType string `pulumi:"odataType"`
}

// Represents an audio track in the asset.
type AudioTrackResponseOutput struct{ *pulumi.OutputState }

func (AudioTrackResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AudioTrackResponse)(nil)).Elem()
}

func (o AudioTrackResponseOutput) ToAudioTrackResponseOutput() AudioTrackResponseOutput {
	return o
}

func (o AudioTrackResponseOutput) ToAudioTrackResponseOutputWithContext(ctx context.Context) AudioTrackResponseOutput {
	return o
}

// The stream bit rate for the audio track.
func (o AudioTrackResponseOutput) BitRate() pulumi.IntOutput {
	return o.ApplyT(func(v AudioTrackResponse) int { return v.BitRate }).(pulumi.IntOutput)
}

// The DASH specific setting for the audio track.
func (o AudioTrackResponseOutput) DashSettings() DashSettingsResponsePtrOutput {
	return o.ApplyT(func(v AudioTrackResponse) *DashSettingsResponse { return v.DashSettings }).(DashSettingsResponsePtrOutput)
}

// The display name of the audio track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
func (o AudioTrackResponseOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioTrackResponse) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// The file name to the source file. This file is located in the storage container of the asset.
func (o AudioTrackResponseOutput) FileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioTrackResponse) *string { return v.FileName }).(pulumi.StringPtrOutput)
}

// The HLS specific setting for the audio track.
func (o AudioTrackResponseOutput) HlsSettings() HlsSettingsResponsePtrOutput {
	return o.ApplyT(func(v AudioTrackResponse) *HlsSettingsResponse { return v.HlsSettings }).(HlsSettingsResponsePtrOutput)
}

// The RFC5646 language code for the audio track.
func (o AudioTrackResponseOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AudioTrackResponse) *string { return v.LanguageCode }).(pulumi.StringPtrOutput)
}

// The MPEG-4 audio track ID for the audio track.
func (o AudioTrackResponseOutput) Mpeg4TrackId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AudioTrackResponse) *int { return v.Mpeg4TrackId }).(pulumi.IntPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioTrack'.
func (o AudioTrackResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v AudioTrackResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

type AudioTrackResponsePtrOutput struct{ *pulumi.OutputState }

func (AudioTrackResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AudioTrackResponse)(nil)).Elem()
}

func (o AudioTrackResponsePtrOutput) ToAudioTrackResponsePtrOutput() AudioTrackResponsePtrOutput {
	return o
}

func (o AudioTrackResponsePtrOutput) ToAudioTrackResponsePtrOutputWithContext(ctx context.Context) AudioTrackResponsePtrOutput {
	return o
}

func (o AudioTrackResponsePtrOutput) Elem() AudioTrackResponseOutput {
	return o.ApplyT(func(v *AudioTrackResponse) AudioTrackResponse {
		if v != nil {
			return *v
		}
		var ret AudioTrackResponse
		return ret
	}).(AudioTrackResponseOutput)
}

// The stream bit rate for the audio track.
func (o AudioTrackResponsePtrOutput) BitRate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AudioTrackResponse) *int {
		if v == nil {
			return nil
		}
		return &v.BitRate
	}).(pulumi.IntPtrOutput)
}

// The DASH specific setting for the audio track.
func (o AudioTrackResponsePtrOutput) DashSettings() DashSettingsResponsePtrOutput {
	return o.ApplyT(func(v *AudioTrackResponse) *DashSettingsResponse {
		if v == nil {
			return nil
		}
		return v.DashSettings
	}).(DashSettingsResponsePtrOutput)
}

// The display name of the audio track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
func (o AudioTrackResponsePtrOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioTrackResponse) *string {
		if v == nil {
			return nil
		}
		return v.DisplayName
	}).(pulumi.StringPtrOutput)
}

// The file name to the source file. This file is located in the storage container of the asset.
func (o AudioTrackResponsePtrOutput) FileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioTrackResponse) *string {
		if v == nil {
			return nil
		}
		return v.FileName
	}).(pulumi.StringPtrOutput)
}

// The HLS specific setting for the audio track.
func (o AudioTrackResponsePtrOutput) HlsSettings() HlsSettingsResponsePtrOutput {
	return o.ApplyT(func(v *AudioTrackResponse) *HlsSettingsResponse {
		if v == nil {
			return nil
		}
		return v.HlsSettings
	}).(HlsSettingsResponsePtrOutput)
}

// The RFC5646 language code for the audio track.
func (o AudioTrackResponsePtrOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioTrackResponse) *string {
		if v == nil {
			return nil
		}
		return v.LanguageCode
	}).(pulumi.StringPtrOutput)
}

// The MPEG-4 audio track ID for the audio track.
func (o AudioTrackResponsePtrOutput) Mpeg4TrackId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AudioTrackResponse) *int {
		if v == nil {
			return nil
		}
		return v.Mpeg4TrackId
	}).(pulumi.IntPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.AudioTrack'.
func (o AudioTrackResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AudioTrackResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// Describes a built-in preset for encoding the input video with the Standard Encoder.
type BuiltInStandardEncoderPreset struct {
	// Optional configuration settings for encoder. Configurations is only supported for ContentAwareEncoding and H265ContentAwareEncoding BuiltInStandardEncoderPreset.
	Configurations *PresetConfigurations `pulumi:"configurations"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.BuiltInStandardEncoderPreset'.
	OdataType string `pulumi:"odataType"`
	// The built-in preset to be used for encoding videos.
	PresetName string `pulumi:"presetName"`
}

// BuiltInStandardEncoderPresetInput is an input type that accepts BuiltInStandardEncoderPresetArgs and BuiltInStandardEncoderPresetOutput values.
// You can construct a concrete instance of `BuiltInStandardEncoderPresetInput` via:
//
//	BuiltInStandardEncoderPresetArgs{...}
type BuiltInStandardEncoderPresetInput interface {
	pulumi.Input

	ToBuiltInStandardEncoderPresetOutput() BuiltInStandardEncoderPresetOutput
	ToBuiltInStandardEncoderPresetOutputWithContext(context.Context) BuiltInStandardEncoderPresetOutput
}

// Describes a built-in preset for encoding the input video with the Standard Encoder.
type BuiltInStandardEncoderPresetArgs struct {
	// Optional configuration settings for encoder. Configurations is only supported for ContentAwareEncoding and H265ContentAwareEncoding BuiltInStandardEncoderPreset.
	Configurations PresetConfigurationsPtrInput `pulumi:"configurations"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.BuiltInStandardEncoderPreset'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The built-in preset to be used for encoding videos.
	PresetName pulumi.StringInput `pulumi:"presetName"`
}

func (BuiltInStandardEncoderPresetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuiltInStandardEncoderPreset)(nil)).Elem()
}

func (i BuiltInStandardEncoderPresetArgs) ToBuiltInStandardEncoderPresetOutput() BuiltInStandardEncoderPresetOutput {
	return i.ToBuiltInStandardEncoderPresetOutputWithContext(context.Background())
}

func (i BuiltInStandardEncoderPresetArgs) ToBuiltInStandardEncoderPresetOutputWithContext(ctx context.Context) BuiltInStandardEncoderPresetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuiltInStandardEncoderPresetOutput)
}

func (i BuiltInStandardEncoderPresetArgs) ToBuiltInStandardEncoderPresetPtrOutput() BuiltInStandardEncoderPresetPtrOutput {
	return i.ToBuiltInStandardEncoderPresetPtrOutputWithContext(context.Background())
}

func (i BuiltInStandardEncoderPresetArgs) ToBuiltInStandardEncoderPresetPtrOutputWithContext(ctx context.Context) BuiltInStandardEncoderPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuiltInStandardEncoderPresetOutput).ToBuiltInStandardEncoderPresetPtrOutputWithContext(ctx)
}

// BuiltInStandardEncoderPresetPtrInput is an input type that accepts BuiltInStandardEncoderPresetArgs, BuiltInStandardEncoderPresetPtr and BuiltInStandardEncoderPresetPtrOutput values.
// You can construct a concrete instance of `BuiltInStandardEncoderPresetPtrInput` via:
//
//	        BuiltInStandardEncoderPresetArgs{...}
//
//	or:
//
//	        nil
type BuiltInStandardEncoderPresetPtrInput interface {
	pulumi.Input

	ToBuiltInStandardEncoderPresetPtrOutput() BuiltInStandardEncoderPresetPtrOutput
	ToBuiltInStandardEncoderPresetPtrOutputWithContext(context.Context) BuiltInStandardEncoderPresetPtrOutput
}

type builtInStandardEncoderPresetPtrType BuiltInStandardEncoderPresetArgs

func BuiltInStandardEncoderPresetPtr(v *BuiltInStandardEncoderPresetArgs) BuiltInStandardEncoderPresetPtrInput {
	return (*builtInStandardEncoderPresetPtrType)(v)
}

func (*builtInStandardEncoderPresetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuiltInStandardEncoderPreset)(nil)).Elem()
}

func (i *builtInStandardEncoderPresetPtrType) ToBuiltInStandardEncoderPresetPtrOutput() BuiltInStandardEncoderPresetPtrOutput {
	return i.ToBuiltInStandardEncoderPresetPtrOutputWithContext(context.Background())
}

func (i *builtInStandardEncoderPresetPtrType) ToBuiltInStandardEncoderPresetPtrOutputWithContext(ctx context.Context) BuiltInStandardEncoderPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuiltInStandardEncoderPresetPtrOutput)
}

// Describes a built-in preset for encoding the input video with the Standard Encoder.
type BuiltInStandardEncoderPresetOutput struct{ *pulumi.OutputState }

func (BuiltInStandardEncoderPresetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuiltInStandardEncoderPreset)(nil)).Elem()
}

func (o BuiltInStandardEncoderPresetOutput) ToBuiltInStandardEncoderPresetOutput() BuiltInStandardEncoderPresetOutput {
	return o
}

func (o BuiltInStandardEncoderPresetOutput) ToBuiltInStandardEncoderPresetOutputWithContext(ctx context.Context) BuiltInStandardEncoderPresetOutput {
	return o
}

func (o BuiltInStandardEncoderPresetOutput) ToBuiltInStandardEncoderPresetPtrOutput() BuiltInStandardEncoderPresetPtrOutput {
	return o.ToBuiltInStandardEncoderPresetPtrOutputWithContext(context.Background())
}

func (o BuiltInStandardEncoderPresetOutput) ToBuiltInStandardEncoderPresetPtrOutputWithContext(ctx context.Context) BuiltInStandardEncoderPresetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BuiltInStandardEncoderPreset) *BuiltInStandardEncoderPreset {
		return &v
	}).(BuiltInStandardEncoderPresetPtrOutput)
}

// Optional configuration settings for encoder. Configurations is only supported for ContentAwareEncoding and H265ContentAwareEncoding BuiltInStandardEncoderPreset.
func (o BuiltInStandardEncoderPresetOutput) Configurations() PresetConfigurationsPtrOutput {
	return o.ApplyT(func(v BuiltInStandardEncoderPreset) *PresetConfigurations { return v.Configurations }).(PresetConfigurationsPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.BuiltInStandardEncoderPreset'.
func (o BuiltInStandardEncoderPresetOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v BuiltInStandardEncoderPreset) string { return v.OdataType }).(pulumi.StringOutput)
}

// The built-in preset to be used for encoding videos.
func (o BuiltInStandardEncoderPresetOutput) PresetName() pulumi.StringOutput {
	return o.ApplyT(func(v BuiltInStandardEncoderPreset) string { return v.PresetName }).(pulumi.StringOutput)
}

type BuiltInStandardEncoderPresetPtrOutput struct{ *pulumi.OutputState }

func (BuiltInStandardEncoderPresetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuiltInStandardEncoderPreset)(nil)).Elem()
}

func (o BuiltInStandardEncoderPresetPtrOutput) ToBuiltInStandardEncoderPresetPtrOutput() BuiltInStandardEncoderPresetPtrOutput {
	return o
}

func (o BuiltInStandardEncoderPresetPtrOutput) ToBuiltInStandardEncoderPresetPtrOutputWithContext(ctx context.Context) BuiltInStandardEncoderPresetPtrOutput {
	return o
}

func (o BuiltInStandardEncoderPresetPtrOutput) Elem() BuiltInStandardEncoderPresetOutput {
	return o.ApplyT(func(v *BuiltInStandardEncoderPreset) BuiltInStandardEncoderPreset {
		if v != nil {
			return *v
		}
		var ret BuiltInStandardEncoderPreset
		return ret
	}).(BuiltInStandardEncoderPresetOutput)
}

// Optional configuration settings for encoder. Configurations is only supported for ContentAwareEncoding and H265ContentAwareEncoding BuiltInStandardEncoderPreset.
func (o BuiltInStandardEncoderPresetPtrOutput) Configurations() PresetConfigurationsPtrOutput {
	return o.ApplyT(func(v *BuiltInStandardEncoderPreset) *PresetConfigurations {
		if v == nil {
			return nil
		}
		return v.Configurations
	}).(PresetConfigurationsPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.BuiltInStandardEncoderPreset'.
func (o BuiltInStandardEncoderPresetPtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuiltInStandardEncoderPreset) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// The built-in preset to be used for encoding videos.
func (o BuiltInStandardEncoderPresetPtrOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuiltInStandardEncoderPreset) *string {
		if v == nil {
			return nil
		}
		return &v.PresetName
	}).(pulumi.StringPtrOutput)
}

// Describes a built-in preset for encoding the input video with the Standard Encoder.
type BuiltInStandardEncoderPresetResponse struct {
	// Optional configuration settings for encoder. Configurations is only supported for ContentAwareEncoding and H265ContentAwareEncoding BuiltInStandardEncoderPreset.
	Configurations *PresetConfigurationsResponse `pulumi:"configurations"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.BuiltInStandardEncoderPreset'.
	OdataType string `pulumi:"odataType"`
	// The built-in preset to be used for encoding videos.
	PresetName string `pulumi:"presetName"`
}

// Describes a built-in preset for encoding the input video with the Standard Encoder.
type BuiltInStandardEncoderPresetResponseOutput struct{ *pulumi.OutputState }

func (BuiltInStandardEncoderPresetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuiltInStandardEncoderPresetResponse)(nil)).Elem()
}

func (o BuiltInStandardEncoderPresetResponseOutput) ToBuiltInStandardEncoderPresetResponseOutput() BuiltInStandardEncoderPresetResponseOutput {
	return o
}

func (o BuiltInStandardEncoderPresetResponseOutput) ToBuiltInStandardEncoderPresetResponseOutputWithContext(ctx context.Context) BuiltInStandardEncoderPresetResponseOutput {
	return o
}

// Optional configuration settings for encoder. Configurations is only supported for ContentAwareEncoding and H265ContentAwareEncoding BuiltInStandardEncoderPreset.
func (o BuiltInStandardEncoderPresetResponseOutput) Configurations() PresetConfigurationsResponsePtrOutput {
	return o.ApplyT(func(v BuiltInStandardEncoderPresetResponse) *PresetConfigurationsResponse { return v.Configurations }).(PresetConfigurationsResponsePtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.BuiltInStandardEncoderPreset'.
func (o BuiltInStandardEncoderPresetResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v BuiltInStandardEncoderPresetResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The built-in preset to be used for encoding videos.
func (o BuiltInStandardEncoderPresetResponseOutput) PresetName() pulumi.StringOutput {
	return o.ApplyT(func(v BuiltInStandardEncoderPresetResponse) string { return v.PresetName }).(pulumi.StringOutput)
}

type BuiltInStandardEncoderPresetResponsePtrOutput struct{ *pulumi.OutputState }

func (BuiltInStandardEncoderPresetResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuiltInStandardEncoderPresetResponse)(nil)).Elem()
}

func (o BuiltInStandardEncoderPresetResponsePtrOutput) ToBuiltInStandardEncoderPresetResponsePtrOutput() BuiltInStandardEncoderPresetResponsePtrOutput {
	return o
}

func (o BuiltInStandardEncoderPresetResponsePtrOutput) ToBuiltInStandardEncoderPresetResponsePtrOutputWithContext(ctx context.Context) BuiltInStandardEncoderPresetResponsePtrOutput {
	return o
}

func (o BuiltInStandardEncoderPresetResponsePtrOutput) Elem() BuiltInStandardEncoderPresetResponseOutput {
	return o.ApplyT(func(v *BuiltInStandardEncoderPresetResponse) BuiltInStandardEncoderPresetResponse {
		if v != nil {
			return *v
		}
		var ret BuiltInStandardEncoderPresetResponse
		return ret
	}).(BuiltInStandardEncoderPresetResponseOutput)
}

// Optional configuration settings for encoder. Configurations is only supported for ContentAwareEncoding and H265ContentAwareEncoding BuiltInStandardEncoderPreset.
func (o BuiltInStandardEncoderPresetResponsePtrOutput) Configurations() PresetConfigurationsResponsePtrOutput {
	return o.ApplyT(func(v *BuiltInStandardEncoderPresetResponse) *PresetConfigurationsResponse {
		if v == nil {
			return nil
		}
		return v.Configurations
	}).(PresetConfigurationsResponsePtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.BuiltInStandardEncoderPreset'.
func (o BuiltInStandardEncoderPresetResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuiltInStandardEncoderPresetResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// The built-in preset to be used for encoding videos.
func (o BuiltInStandardEncoderPresetResponsePtrOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuiltInStandardEncoderPresetResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PresetName
	}).(pulumi.StringPtrOutput)
}

// Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfiguration struct {
	// FairPlay configurations
	FairPlay *StreamingPolicyFairPlayConfiguration `pulumi:"fairPlay"`
	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfiguration `pulumi:"playReady"`
	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfiguration `pulumi:"widevine"`
}

// CbcsDrmConfigurationInput is an input type that accepts CbcsDrmConfigurationArgs and CbcsDrmConfigurationOutput values.
// You can construct a concrete instance of `CbcsDrmConfigurationInput` via:
//
//	CbcsDrmConfigurationArgs{...}
type CbcsDrmConfigurationInput interface {
	pulumi.Input

	ToCbcsDrmConfigurationOutput() CbcsDrmConfigurationOutput
	ToCbcsDrmConfigurationOutputWithContext(context.Context) CbcsDrmConfigurationOutput
}

// Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfigurationArgs struct {
	// FairPlay configurations
	FairPlay StreamingPolicyFairPlayConfigurationPtrInput `pulumi:"fairPlay"`
	// PlayReady configurations
	PlayReady StreamingPolicyPlayReadyConfigurationPtrInput `pulumi:"playReady"`
	// Widevine configurations
	Widevine StreamingPolicyWidevineConfigurationPtrInput `pulumi:"widevine"`
}

func (CbcsDrmConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CbcsDrmConfiguration)(nil)).Elem()
}

func (i CbcsDrmConfigurationArgs) ToCbcsDrmConfigurationOutput() CbcsDrmConfigurationOutput {
	return i.ToCbcsDrmConfigurationOutputWithContext(context.Background())
}

func (i CbcsDrmConfigurationArgs) ToCbcsDrmConfigurationOutputWithContext(ctx context.Context) CbcsDrmConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CbcsDrmConfigurationOutput)
}

func (i CbcsDrmConfigurationArgs) ToCbcsDrmConfigurationPtrOutput() CbcsDrmConfigurationPtrOutput {
	return i.ToCbcsDrmConfigurationPtrOutputWithContext(context.Background())
}

func (i CbcsDrmConfigurationArgs) ToCbcsDrmConfigurationPtrOutputWithContext(ctx context.Context) CbcsDrmConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CbcsDrmConfigurationOutput).ToCbcsDrmConfigurationPtrOutputWithContext(ctx)
}

// CbcsDrmConfigurationPtrInput is an input type that accepts CbcsDrmConfigurationArgs, CbcsDrmConfigurationPtr and CbcsDrmConfigurationPtrOutput values.
// You can construct a concrete instance of `CbcsDrmConfigurationPtrInput` via:
//
//	        CbcsDrmConfigurationArgs{...}
//
//	or:
//
//	        nil
type CbcsDrmConfigurationPtrInput interface {
	pulumi.Input

	ToCbcsDrmConfigurationPtrOutput() CbcsDrmConfigurationPtrOutput
	ToCbcsDrmConfigurationPtrOutputWithContext(context.Context) CbcsDrmConfigurationPtrOutput
}

type cbcsDrmConfigurationPtrType CbcsDrmConfigurationArgs

func CbcsDrmConfigurationPtr(v *CbcsDrmConfigurationArgs) CbcsDrmConfigurationPtrInput {
	return (*cbcsDrmConfigurationPtrType)(v)
}

func (*cbcsDrmConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CbcsDrmConfiguration)(nil)).Elem()
}

func (i *cbcsDrmConfigurationPtrType) ToCbcsDrmConfigurationPtrOutput() CbcsDrmConfigurationPtrOutput {
	return i.ToCbcsDrmConfigurationPtrOutputWithContext(context.Background())
}

func (i *cbcsDrmConfigurationPtrType) ToCbcsDrmConfigurationPtrOutputWithContext(ctx context.Context) CbcsDrmConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CbcsDrmConfigurationPtrOutput)
}

// Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfigurationOutput struct{ *pulumi.OutputState }

func (CbcsDrmConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CbcsDrmConfiguration)(nil)).Elem()
}

func (o CbcsDrmConfigurationOutput) ToCbcsDrmConfigurationOutput() CbcsDrmConfigurationOutput {
	return o
}

func (o CbcsDrmConfigurationOutput) ToCbcsDrmConfigurationOutputWithContext(ctx context.Context) CbcsDrmConfigurationOutput {
	return o
}

func (o CbcsDrmConfigurationOutput) ToCbcsDrmConfigurationPtrOutput() CbcsDrmConfigurationPtrOutput {
	return o.ToCbcsDrmConfigurationPtrOutputWithContext(context.Background())
}

func (o CbcsDrmConfigurationOutput) ToCbcsDrmConfigurationPtrOutputWithContext(ctx context.Context) CbcsDrmConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CbcsDrmConfiguration) *CbcsDrmConfiguration {
		return &v
	}).(CbcsDrmConfigurationPtrOutput)
}

// FairPlay configurations
func (o CbcsDrmConfigurationOutput) FairPlay() StreamingPolicyFairPlayConfigurationPtrOutput {
	return o.ApplyT(func(v CbcsDrmConfiguration) *StreamingPolicyFairPlayConfiguration { return v.FairPlay }).(StreamingPolicyFairPlayConfigurationPtrOutput)
}

// PlayReady configurations
func (o CbcsDrmConfigurationOutput) PlayReady() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ApplyT(func(v CbcsDrmConfiguration) *StreamingPolicyPlayReadyConfiguration { return v.PlayReady }).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Widevine configurations
func (o CbcsDrmConfigurationOutput) Widevine() StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ApplyT(func(v CbcsDrmConfiguration) *StreamingPolicyWidevineConfiguration { return v.Widevine }).(StreamingPolicyWidevineConfigurationPtrOutput)
}

type CbcsDrmConfigurationPtrOutput struct{ *pulumi.OutputState }

func (CbcsDrmConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CbcsDrmConfiguration)(nil)).Elem()
}

func (o CbcsDrmConfigurationPtrOutput) ToCbcsDrmConfigurationPtrOutput() CbcsDrmConfigurationPtrOutput {
	return o
}

func (o CbcsDrmConfigurationPtrOutput) ToCbcsDrmConfigurationPtrOutputWithContext(ctx context.Context) CbcsDrmConfigurationPtrOutput {
	return o
}

func (o CbcsDrmConfigurationPtrOutput) Elem() CbcsDrmConfigurationOutput {
	return o.ApplyT(func(v *CbcsDrmConfiguration) CbcsDrmConfiguration {
		if v != nil {
			return *v
		}
		var ret CbcsDrmConfiguration
		return ret
	}).(CbcsDrmConfigurationOutput)
}

// FairPlay configurations
func (o CbcsDrmConfigurationPtrOutput) FairPlay() StreamingPolicyFairPlayConfigurationPtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfiguration) *StreamingPolicyFairPlayConfiguration {
		if v == nil {
			return nil
		}
		return v.FairPlay
	}).(StreamingPolicyFairPlayConfigurationPtrOutput)
}

// PlayReady configurations
func (o CbcsDrmConfigurationPtrOutput) PlayReady() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfiguration) *StreamingPolicyPlayReadyConfiguration {
		if v == nil {
			return nil
		}
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Widevine configurations
func (o CbcsDrmConfigurationPtrOutput) Widevine() StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfiguration) *StreamingPolicyWidevineConfiguration {
		if v == nil {
			return nil
		}
		return v.Widevine
	}).(StreamingPolicyWidevineConfigurationPtrOutput)
}

// Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfigurationResponse struct {
	// FairPlay configurations
	FairPlay *StreamingPolicyFairPlayConfigurationResponse `pulumi:"fairPlay"`
	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfigurationResponse `pulumi:"playReady"`
	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfigurationResponse `pulumi:"widevine"`
}

// Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfigurationResponseOutput struct{ *pulumi.OutputState }

func (CbcsDrmConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CbcsDrmConfigurationResponse)(nil)).Elem()
}

func (o CbcsDrmConfigurationResponseOutput) ToCbcsDrmConfigurationResponseOutput() CbcsDrmConfigurationResponseOutput {
	return o
}

func (o CbcsDrmConfigurationResponseOutput) ToCbcsDrmConfigurationResponseOutputWithContext(ctx context.Context) CbcsDrmConfigurationResponseOutput {
	return o
}

// FairPlay configurations
func (o CbcsDrmConfigurationResponseOutput) FairPlay() StreamingPolicyFairPlayConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CbcsDrmConfigurationResponse) *StreamingPolicyFairPlayConfigurationResponse { return v.FairPlay }).(StreamingPolicyFairPlayConfigurationResponsePtrOutput)
}

// PlayReady configurations
func (o CbcsDrmConfigurationResponseOutput) PlayReady() StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CbcsDrmConfigurationResponse) *StreamingPolicyPlayReadyConfigurationResponse {
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationResponsePtrOutput)
}

// Widevine configurations
func (o CbcsDrmConfigurationResponseOutput) Widevine() StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CbcsDrmConfigurationResponse) *StreamingPolicyWidevineConfigurationResponse { return v.Widevine }).(StreamingPolicyWidevineConfigurationResponsePtrOutput)
}

type CbcsDrmConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (CbcsDrmConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CbcsDrmConfigurationResponse)(nil)).Elem()
}

func (o CbcsDrmConfigurationResponsePtrOutput) ToCbcsDrmConfigurationResponsePtrOutput() CbcsDrmConfigurationResponsePtrOutput {
	return o
}

func (o CbcsDrmConfigurationResponsePtrOutput) ToCbcsDrmConfigurationResponsePtrOutputWithContext(ctx context.Context) CbcsDrmConfigurationResponsePtrOutput {
	return o
}

func (o CbcsDrmConfigurationResponsePtrOutput) Elem() CbcsDrmConfigurationResponseOutput {
	return o.ApplyT(func(v *CbcsDrmConfigurationResponse) CbcsDrmConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret CbcsDrmConfigurationResponse
		return ret
	}).(CbcsDrmConfigurationResponseOutput)
}

// FairPlay configurations
func (o CbcsDrmConfigurationResponsePtrOutput) FairPlay() StreamingPolicyFairPlayConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfigurationResponse) *StreamingPolicyFairPlayConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.FairPlay
	}).(StreamingPolicyFairPlayConfigurationResponsePtrOutput)
}

// PlayReady configurations
func (o CbcsDrmConfigurationResponsePtrOutput) PlayReady() StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfigurationResponse) *StreamingPolicyPlayReadyConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationResponsePtrOutput)
}

// Widevine configurations
func (o CbcsDrmConfigurationResponsePtrOutput) Widevine() StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfigurationResponse) *StreamingPolicyWidevineConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.Widevine
	}).(StreamingPolicyWidevineConfigurationResponsePtrOutput)
}

// Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfiguration struct {
	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfiguration `pulumi:"playReady"`
	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfiguration `pulumi:"widevine"`
}

// CencDrmConfigurationInput is an input type that accepts CencDrmConfigurationArgs and CencDrmConfigurationOutput values.
// You can construct a concrete instance of `CencDrmConfigurationInput` via:
//
//	CencDrmConfigurationArgs{...}
type CencDrmConfigurationInput interface {
	pulumi.Input

	ToCencDrmConfigurationOutput() CencDrmConfigurationOutput
	ToCencDrmConfigurationOutputWithContext(context.Context) CencDrmConfigurationOutput
}

// Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfigurationArgs struct {
	// PlayReady configurations
	PlayReady StreamingPolicyPlayReadyConfigurationPtrInput `pulumi:"playReady"`
	// Widevine configurations
	Widevine StreamingPolicyWidevineConfigurationPtrInput `pulumi:"widevine"`
}

func (CencDrmConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CencDrmConfiguration)(nil)).Elem()
}

func (i CencDrmConfigurationArgs) ToCencDrmConfigurationOutput() CencDrmConfigurationOutput {
	return i.ToCencDrmConfigurationOutputWithContext(context.Background())
}

func (i CencDrmConfigurationArgs) ToCencDrmConfigurationOutputWithContext(ctx context.Context) CencDrmConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CencDrmConfigurationOutput)
}

func (i CencDrmConfigurationArgs) ToCencDrmConfigurationPtrOutput() CencDrmConfigurationPtrOutput {
	return i.ToCencDrmConfigurationPtrOutputWithContext(context.Background())
}

func (i CencDrmConfigurationArgs) ToCencDrmConfigurationPtrOutputWithContext(ctx context.Context) CencDrmConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CencDrmConfigurationOutput).ToCencDrmConfigurationPtrOutputWithContext(ctx)
}

// CencDrmConfigurationPtrInput is an input type that accepts CencDrmConfigurationArgs, CencDrmConfigurationPtr and CencDrmConfigurationPtrOutput values.
// You can construct a concrete instance of `CencDrmConfigurationPtrInput` via:
//
//	        CencDrmConfigurationArgs{...}
//
//	or:
//
//	        nil
type CencDrmConfigurationPtrInput interface {
	pulumi.Input

	ToCencDrmConfigurationPtrOutput() CencDrmConfigurationPtrOutput
	ToCencDrmConfigurationPtrOutputWithContext(context.Context) CencDrmConfigurationPtrOutput
}

type cencDrmConfigurationPtrType CencDrmConfigurationArgs

func CencDrmConfigurationPtr(v *CencDrmConfigurationArgs) CencDrmConfigurationPtrInput {
	return (*cencDrmConfigurationPtrType)(v)
}

func (*cencDrmConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CencDrmConfiguration)(nil)).Elem()
}

func (i *cencDrmConfigurationPtrType) ToCencDrmConfigurationPtrOutput() CencDrmConfigurationPtrOutput {
	return i.ToCencDrmConfigurationPtrOutputWithContext(context.Background())
}

func (i *cencDrmConfigurationPtrType) ToCencDrmConfigurationPtrOutputWithContext(ctx context.Context) CencDrmConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CencDrmConfigurationPtrOutput)
}

// Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfigurationOutput struct{ *pulumi.OutputState }

func (CencDrmConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CencDrmConfiguration)(nil)).Elem()
}

func (o CencDrmConfigurationOutput) ToCencDrmConfigurationOutput() CencDrmConfigurationOutput {
	return o
}

func (o CencDrmConfigurationOutput) ToCencDrmConfigurationOutputWithContext(ctx context.Context) CencDrmConfigurationOutput {
	return o
}

func (o CencDrmConfigurationOutput) ToCencDrmConfigurationPtrOutput() CencDrmConfigurationPtrOutput {
	return o.ToCencDrmConfigurationPtrOutputWithContext(context.Background())
}

func (o CencDrmConfigurationOutput) ToCencDrmConfigurationPtrOutputWithContext(ctx context.Context) CencDrmConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CencDrmConfiguration) *CencDrmConfiguration {
		return &v
	}).(CencDrmConfigurationPtrOutput)
}

// PlayReady configurations
func (o CencDrmConfigurationOutput) PlayReady() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ApplyT(func(v CencDrmConfiguration) *StreamingPolicyPlayReadyConfiguration { return v.PlayReady }).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Widevine configurations
func (o CencDrmConfigurationOutput) Widevine() StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ApplyT(func(v CencDrmConfiguration) *StreamingPolicyWidevineConfiguration { return v.Widevine }).(StreamingPolicyWidevineConfigurationPtrOutput)
}

type CencDrmConfigurationPtrOutput struct{ *pulumi.OutputState }

func (CencDrmConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CencDrmConfiguration)(nil)).Elem()
}

func (o CencDrmConfigurationPtrOutput) ToCencDrmConfigurationPtrOutput() CencDrmConfigurationPtrOutput {
	return o
}

func (o CencDrmConfigurationPtrOutput) ToCencDrmConfigurationPtrOutputWithContext(ctx context.Context) CencDrmConfigurationPtrOutput {
	return o
}

func (o CencDrmConfigurationPtrOutput) Elem() CencDrmConfigurationOutput {
	return o.ApplyT(func(v *CencDrmConfiguration) CencDrmConfiguration {
		if v != nil {
			return *v
		}
		var ret CencDrmConfiguration
		return ret
	}).(CencDrmConfigurationOutput)
}

// PlayReady configurations
func (o CencDrmConfigurationPtrOutput) PlayReady() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ApplyT(func(v *CencDrmConfiguration) *StreamingPolicyPlayReadyConfiguration {
		if v == nil {
			return nil
		}
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Widevine configurations
func (o CencDrmConfigurationPtrOutput) Widevine() StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ApplyT(func(v *CencDrmConfiguration) *StreamingPolicyWidevineConfiguration {
		if v == nil {
			return nil
		}
		return v.Widevine
	}).(StreamingPolicyWidevineConfigurationPtrOutput)
}

// Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfigurationResponse struct {
	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfigurationResponse `pulumi:"playReady"`
	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfigurationResponse `pulumi:"widevine"`
}

// Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfigurationResponseOutput struct{ *pulumi.OutputState }

func (CencDrmConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CencDrmConfigurationResponse)(nil)).Elem()
}

func (o CencDrmConfigurationResponseOutput) ToCencDrmConfigurationResponseOutput() CencDrmConfigurationResponseOutput {
	return o
}

func (o CencDrmConfigurationResponseOutput) ToCencDrmConfigurationResponseOutputWithContext(ctx context.Context) CencDrmConfigurationResponseOutput {
	return o
}

// PlayReady configurations
func (o CencDrmConfigurationResponseOutput) PlayReady() StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CencDrmConfigurationResponse) *StreamingPolicyPlayReadyConfigurationResponse {
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationResponsePtrOutput)
}

// Widevine configurations
func (o CencDrmConfigurationResponseOutput) Widevine() StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CencDrmConfigurationResponse) *StreamingPolicyWidevineConfigurationResponse { return v.Widevine }).(StreamingPolicyWidevineConfigurationResponsePtrOutput)
}

type CencDrmConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (CencDrmConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CencDrmConfigurationResponse)(nil)).Elem()
}

func (o CencDrmConfigurationResponsePtrOutput) ToCencDrmConfigurationResponsePtrOutput() CencDrmConfigurationResponsePtrOutput {
	return o
}

func (o CencDrmConfigurationResponsePtrOutput) ToCencDrmConfigurationResponsePtrOutputWithContext(ctx context.Context) CencDrmConfigurationResponsePtrOutput {
	return o
}

func (o CencDrmConfigurationResponsePtrOutput) Elem() CencDrmConfigurationResponseOutput {
	return o.ApplyT(func(v *CencDrmConfigurationResponse) CencDrmConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret CencDrmConfigurationResponse
		return ret
	}).(CencDrmConfigurationResponseOutput)
}

// PlayReady configurations
func (o CencDrmConfigurationResponsePtrOutput) PlayReady() StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CencDrmConfigurationResponse) *StreamingPolicyPlayReadyConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationResponsePtrOutput)
}

// Widevine configurations
func (o CencDrmConfigurationResponsePtrOutput) Widevine() StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CencDrmConfigurationResponse) *StreamingPolicyWidevineConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.Widevine
	}).(StreamingPolicyWidevineConfigurationResponsePtrOutput)
}

// Class to specify ClearKey configuration of common encryption schemes in Streaming Policy
type ClearKeyEncryptionConfiguration struct {
	// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token value is {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId.
	CustomKeysAcquisitionUrlTemplate *string `pulumi:"customKeysAcquisitionUrlTemplate"`
}

// ClearKeyEncryptionConfigurationInput is an input type that accepts ClearKeyEncryptionConfigurationArgs and ClearKeyEncryptionConfigurationOutput values.
// You can construct a concrete instance of `ClearKeyEncryptionConfigurationInput` via:
//
//	ClearKeyEncryptionConfigurationArgs{...}
type ClearKeyEncryptionConfigurationInput interface {
	pulumi.Input

	ToClearKeyEncryptionConfigurationOutput() ClearKeyEncryptionConfigurationOutput
	ToClearKeyEncryptionConfigurationOutputWithContext(context.Context) ClearKeyEncryptionConfigurationOutput
}

// Class to specify ClearKey configuration of common encryption schemes in Streaming Policy
type ClearKeyEncryptionConfigurationArgs struct {
	// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token value is {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId.
	CustomKeysAcquisitionUrlTemplate pulumi.StringPtrInput `pulumi:"customKeysAcquisitionUrlTemplate"`
}

func (ClearKeyEncryptionConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClearKeyEncryptionConfiguration)(nil)).Elem()
}

func (i ClearKeyEncryptionConfigurationArgs) ToClearKeyEncryptionConfigurationOutput() ClearKeyEncryptionConfigurationOutput {
	return i.ToClearKeyEncryptionConfigurationOutputWithContext(context.Background())
}

func (i ClearKeyEncryptionConfigurationArgs) ToClearKeyEncryptionConfigurationOutputWithContext(ctx context.Context) ClearKeyEncryptionConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClearKeyEncryptionConfigurationOutput)
}

func (i ClearKeyEncryptionConfigurationArgs) ToClearKeyEncryptionConfigurationPtrOutput() ClearKeyEncryptionConfigurationPtrOutput {
	return i.ToClearKeyEncryptionConfigurationPtrOutputWithContext(context.Background())
}

func (i ClearKeyEncryptionConfigurationArgs) ToClearKeyEncryptionConfigurationPtrOutputWithContext(ctx context.Context) ClearKeyEncryptionConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClearKeyEncryptionConfigurationOutput).ToClearKeyEncryptionConfigurationPtrOutputWithContext(ctx)
}

// ClearKeyEncryptionConfigurationPtrInput is an input type that accepts ClearKeyEncryptionConfigurationArgs, ClearKeyEncryptionConfigurationPtr and ClearKeyEncryptionConfigurationPtrOutput values.
// You can construct a concrete instance of `ClearKeyEncryptionConfigurationPtrInput` via:
//
//	        ClearKeyEncryptionConfigurationArgs{...}
//
//	or:
//
//	        nil
type ClearKeyEncryptionConfigurationPtrInput interface {
	pulumi.Input

	ToClearKeyEncryptionConfigurationPtrOutput() ClearKeyEncryptionConfigurationPtrOutput
	ToClearKeyEncryptionConfigurationPtrOutputWithContext(context.Context) ClearKeyEncryptionConfigurationPtrOutput
}

type clearKeyEncryptionConfigurationPtrType ClearKeyEncryptionConfigurationArgs

func ClearKeyEncryptionConfigurationPtr(v *ClearKeyEncryptionConfigurationArgs) ClearKeyEncryptionConfigurationPtrInput {
	return (*clearKeyEncryptionConfigurationPtrType)(v)
}

func (*clearKeyEncryptionConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClearKeyEncryptionConfiguration)(nil)).Elem()
}

func (i *clearKeyEncryptionConfigurationPtrType) ToClearKeyEncryptionConfigurationPtrOutput() ClearKeyEncryptionConfigurationPtrOutput {
	return i.ToClearKeyEncryptionConfigurationPtrOutputWithContext(context.Background())
}

func (i *clearKeyEncryptionConfigurationPtrType) ToClearKeyEncryptionConfigurationPtrOutputWithContext(ctx context.Context) ClearKeyEncryptionConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClearKeyEncryptionConfigurationPtrOutput)
}

// Class to specify ClearKey configuration of common encryption schemes in Streaming Policy
type ClearKeyEncryptionConfigurationOutput struct{ *pulumi.OutputState }

func (ClearKeyEncryptionConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClearKeyEncryptionConfiguration)(nil)).Elem()
}

func (o ClearKeyEncryptionConfigurationOutput) ToClearKeyEncryptionConfigurationOutput() ClearKeyEncryptionConfigurationOutput {
	return o
}

func (o ClearKeyEncryptionConfigurationOutput) ToClearKeyEncryptionConfigurationOutputWithContext(ctx context.Context) ClearKeyEncryptionConfigurationOutput {
	return o
}

func (o ClearKeyEncryptionConfigurationOutput) ToClearKeyEncryptionConfigurationPtrOutput() ClearKeyEncryptionConfigurationPtrOutput {
	return o.ToClearKeyEncryptionConfigurationPtrOutputWithContext(context.Background())
}

func (o ClearKeyEncryptionConfigurationOutput) ToClearKeyEncryptionConfigurationPtrOutputWithContext(ctx context.Context) ClearKeyEncryptionConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClearKeyEncryptionConfiguration) *ClearKeyEncryptionConfiguration {
		return &v
	}).(ClearKeyEncryptionConfigurationPtrOutput)
}

// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token value is {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId.
func (o ClearKeyEncryptionConfigurationOutput) CustomKeysAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClearKeyEncryptionConfiguration) *string { return v.CustomKeysAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

type ClearKeyEncryptionConfigurationPtrOutput struct{ *pulumi.OutputState }

func (ClearKeyEncryptionConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClearKeyEncryptionConfiguration)(nil)).Elem()
}

func (o ClearKeyEncryptionConfigurationPtrOutput) ToClearKeyEncryptionConfigurationPtrOutput() ClearKeyEncryptionConfigurationPtrOutput {
	return o
}

func (o ClearKeyEncryptionConfigurationPtrOutput) ToClearKeyEncryptionConfigurationPtrOutputWithContext(ctx context.Context) ClearKeyEncryptionConfigurationPtrOutput {
	return o
}

func (o ClearKeyEncryptionConfigurationPtrOutput) Elem() ClearKeyEncryptionConfigurationOutput {
	return o.ApplyT(func(v *ClearKeyEncryptionConfiguration) ClearKeyEncryptionConfiguration {
		if v != nil {
			return *v
		}
		var ret ClearKeyEncryptionConfiguration
		return ret
	}).(ClearKeyEncryptionConfigurationOutput)
}

// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token value is {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId.
func (o ClearKeyEncryptionConfigurationPtrOutput) CustomKeysAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClearKeyEncryptionConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.CustomKeysAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Class to specify ClearKey configuration of common encryption schemes in Streaming Policy
type ClearKeyEncryptionConfigurationResponse struct {
	// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token value is {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId.
	CustomKeysAcquisitionUrlTemplate *string `pulumi:"customKeysAcquisitionUrlTemplate"`
}

// Class to specify ClearKey configuration of common encryption schemes in Streaming Policy
type ClearKeyEncryptionConfigurationResponseOutput struct{ *pulumi.OutputState }

func (ClearKeyEncryptionConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClearKeyEncryptionConfigurationResponse)(nil)).Elem()
}

func (o ClearKeyEncryptionConfigurationResponseOutput) ToClearKeyEncryptionConfigurationResponseOutput() ClearKeyEncryptionConfigurationResponseOutput {
	return o
}

func (o ClearKeyEncryptionConfigurationResponseOutput) ToClearKeyEncryptionConfigurationResponseOutputWithContext(ctx context.Context) ClearKeyEncryptionConfigurationResponseOutput {
	return o
}

// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token value is {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId.
func (o ClearKeyEncryptionConfigurationResponseOutput) CustomKeysAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClearKeyEncryptionConfigurationResponse) *string { return v.CustomKeysAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

type ClearKeyEncryptionConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (ClearKeyEncryptionConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClearKeyEncryptionConfigurationResponse)(nil)).Elem()
}

func (o ClearKeyEncryptionConfigurationResponsePtrOutput) ToClearKeyEncryptionConfigurationResponsePtrOutput() ClearKeyEncryptionConfigurationResponsePtrOutput {
	return o
}

func (o ClearKeyEncryptionConfigurationResponsePtrOutput) ToClearKeyEncryptionConfigurationResponsePtrOutputWithContext(ctx context.Context) ClearKeyEncryptionConfigurationResponsePtrOutput {
	return o
}

func (o ClearKeyEncryptionConfigurationResponsePtrOutput) Elem() ClearKeyEncryptionConfigurationResponseOutput {
	return o.ApplyT(func(v *ClearKeyEncryptionConfigurationResponse) ClearKeyEncryptionConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret ClearKeyEncryptionConfigurationResponse
		return ret
	}).(ClearKeyEncryptionConfigurationResponseOutput)
}

// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token value is {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId.
func (o ClearKeyEncryptionConfigurationResponsePtrOutput) CustomKeysAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClearKeyEncryptionConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.CustomKeysAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcs struct {
	// Optional configuration supporting ClearKey in CommonEncryptionCbcs encryption scheme.
	ClearKeyEncryptionConfiguration *ClearKeyEncryptionConfiguration `pulumi:"clearKeyEncryptionConfiguration"`
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelection `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `pulumi:"contentKeys"`
	// Configuration of DRMs for current encryption scheme
	Drm *CbcsDrmConfiguration `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `pulumi:"enabledProtocols"`
}

// CommonEncryptionCbcsInput is an input type that accepts CommonEncryptionCbcsArgs and CommonEncryptionCbcsOutput values.
// You can construct a concrete instance of `CommonEncryptionCbcsInput` via:
//
//	CommonEncryptionCbcsArgs{...}
type CommonEncryptionCbcsInput interface {
	pulumi.Input

	ToCommonEncryptionCbcsOutput() CommonEncryptionCbcsOutput
	ToCommonEncryptionCbcsOutputWithContext(context.Context) CommonEncryptionCbcsOutput
}

// Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcsArgs struct {
	// Optional configuration supporting ClearKey in CommonEncryptionCbcs encryption scheme.
	ClearKeyEncryptionConfiguration ClearKeyEncryptionConfigurationPtrInput `pulumi:"clearKeyEncryptionConfiguration"`
	// Representing which tracks should not be encrypted
	ClearTracks TrackSelectionArrayInput `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys StreamingPolicyContentKeysPtrInput `pulumi:"contentKeys"`
	// Configuration of DRMs for current encryption scheme
	Drm CbcsDrmConfigurationPtrInput `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols EnabledProtocolsPtrInput `pulumi:"enabledProtocols"`
}

func (CommonEncryptionCbcsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCbcs)(nil)).Elem()
}

func (i CommonEncryptionCbcsArgs) ToCommonEncryptionCbcsOutput() CommonEncryptionCbcsOutput {
	return i.ToCommonEncryptionCbcsOutputWithContext(context.Background())
}

func (i CommonEncryptionCbcsArgs) ToCommonEncryptionCbcsOutputWithContext(ctx context.Context) CommonEncryptionCbcsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCbcsOutput)
}

func (i CommonEncryptionCbcsArgs) ToCommonEncryptionCbcsPtrOutput() CommonEncryptionCbcsPtrOutput {
	return i.ToCommonEncryptionCbcsPtrOutputWithContext(context.Background())
}

func (i CommonEncryptionCbcsArgs) ToCommonEncryptionCbcsPtrOutputWithContext(ctx context.Context) CommonEncryptionCbcsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCbcsOutput).ToCommonEncryptionCbcsPtrOutputWithContext(ctx)
}

// CommonEncryptionCbcsPtrInput is an input type that accepts CommonEncryptionCbcsArgs, CommonEncryptionCbcsPtr and CommonEncryptionCbcsPtrOutput values.
// You can construct a concrete instance of `CommonEncryptionCbcsPtrInput` via:
//
//	        CommonEncryptionCbcsArgs{...}
//
//	or:
//
//	        nil
type CommonEncryptionCbcsPtrInput interface {
	pulumi.Input

	ToCommonEncryptionCbcsPtrOutput() CommonEncryptionCbcsPtrOutput
	ToCommonEncryptionCbcsPtrOutputWithContext(context.Context) CommonEncryptionCbcsPtrOutput
}

type commonEncryptionCbcsPtrType CommonEncryptionCbcsArgs

func CommonEncryptionCbcsPtr(v *CommonEncryptionCbcsArgs) CommonEncryptionCbcsPtrInput {
	return (*commonEncryptionCbcsPtrType)(v)
}

func (*commonEncryptionCbcsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCbcs)(nil)).Elem()
}

func (i *commonEncryptionCbcsPtrType) ToCommonEncryptionCbcsPtrOutput() CommonEncryptionCbcsPtrOutput {
	return i.ToCommonEncryptionCbcsPtrOutputWithContext(context.Background())
}

func (i *commonEncryptionCbcsPtrType) ToCommonEncryptionCbcsPtrOutputWithContext(ctx context.Context) CommonEncryptionCbcsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCbcsPtrOutput)
}

// Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcsOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCbcsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCbcs)(nil)).Elem()
}

func (o CommonEncryptionCbcsOutput) ToCommonEncryptionCbcsOutput() CommonEncryptionCbcsOutput {
	return o
}

func (o CommonEncryptionCbcsOutput) ToCommonEncryptionCbcsOutputWithContext(ctx context.Context) CommonEncryptionCbcsOutput {
	return o
}

func (o CommonEncryptionCbcsOutput) ToCommonEncryptionCbcsPtrOutput() CommonEncryptionCbcsPtrOutput {
	return o.ToCommonEncryptionCbcsPtrOutputWithContext(context.Background())
}

func (o CommonEncryptionCbcsOutput) ToCommonEncryptionCbcsPtrOutputWithContext(ctx context.Context) CommonEncryptionCbcsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CommonEncryptionCbcs) *CommonEncryptionCbcs {
		return &v
	}).(CommonEncryptionCbcsPtrOutput)
}

// Optional configuration supporting ClearKey in CommonEncryptionCbcs encryption scheme.
func (o CommonEncryptionCbcsOutput) ClearKeyEncryptionConfiguration() ClearKeyEncryptionConfigurationPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcs) *ClearKeyEncryptionConfiguration {
		return v.ClearKeyEncryptionConfiguration
	}).(ClearKeyEncryptionConfigurationPtrOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCbcsOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v CommonEncryptionCbcs) []TrackSelection { return v.ClearTracks }).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCbcsOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcs) *StreamingPolicyContentKeys { return v.ContentKeys }).(StreamingPolicyContentKeysPtrOutput)
}

// Configuration of DRMs for current encryption scheme
func (o CommonEncryptionCbcsOutput) Drm() CbcsDrmConfigurationPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcs) *CbcsDrmConfiguration { return v.Drm }).(CbcsDrmConfigurationPtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCbcsOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcs) *EnabledProtocols { return v.EnabledProtocols }).(EnabledProtocolsPtrOutput)
}

type CommonEncryptionCbcsPtrOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCbcsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCbcs)(nil)).Elem()
}

func (o CommonEncryptionCbcsPtrOutput) ToCommonEncryptionCbcsPtrOutput() CommonEncryptionCbcsPtrOutput {
	return o
}

func (o CommonEncryptionCbcsPtrOutput) ToCommonEncryptionCbcsPtrOutputWithContext(ctx context.Context) CommonEncryptionCbcsPtrOutput {
	return o
}

func (o CommonEncryptionCbcsPtrOutput) Elem() CommonEncryptionCbcsOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcs) CommonEncryptionCbcs {
		if v != nil {
			return *v
		}
		var ret CommonEncryptionCbcs
		return ret
	}).(CommonEncryptionCbcsOutput)
}

// Optional configuration supporting ClearKey in CommonEncryptionCbcs encryption scheme.
func (o CommonEncryptionCbcsPtrOutput) ClearKeyEncryptionConfiguration() ClearKeyEncryptionConfigurationPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcs) *ClearKeyEncryptionConfiguration {
		if v == nil {
			return nil
		}
		return v.ClearKeyEncryptionConfiguration
	}).(ClearKeyEncryptionConfigurationPtrOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCbcsPtrOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcs) []TrackSelection {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCbcsPtrOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcs) *StreamingPolicyContentKeys {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysPtrOutput)
}

// Configuration of DRMs for current encryption scheme
func (o CommonEncryptionCbcsPtrOutput) Drm() CbcsDrmConfigurationPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcs) *CbcsDrmConfiguration {
		if v == nil {
			return nil
		}
		return v.Drm
	}).(CbcsDrmConfigurationPtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCbcsPtrOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcs) *EnabledProtocols {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsPtrOutput)
}

// Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcsResponse struct {
	// Optional configuration supporting ClearKey in CommonEncryptionCbcs encryption scheme.
	ClearKeyEncryptionConfiguration *ClearKeyEncryptionConfigurationResponse `pulumi:"clearKeyEncryptionConfiguration"`
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelectionResponse `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeysResponse `pulumi:"contentKeys"`
	// Configuration of DRMs for current encryption scheme
	Drm *CbcsDrmConfigurationResponse `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocolsResponse `pulumi:"enabledProtocols"`
}

// Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcsResponseOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCbcsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCbcsResponse)(nil)).Elem()
}

func (o CommonEncryptionCbcsResponseOutput) ToCommonEncryptionCbcsResponseOutput() CommonEncryptionCbcsResponseOutput {
	return o
}

func (o CommonEncryptionCbcsResponseOutput) ToCommonEncryptionCbcsResponseOutputWithContext(ctx context.Context) CommonEncryptionCbcsResponseOutput {
	return o
}

// Optional configuration supporting ClearKey in CommonEncryptionCbcs encryption scheme.
func (o CommonEncryptionCbcsResponseOutput) ClearKeyEncryptionConfiguration() ClearKeyEncryptionConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcsResponse) *ClearKeyEncryptionConfigurationResponse {
		return v.ClearKeyEncryptionConfiguration
	}).(ClearKeyEncryptionConfigurationResponsePtrOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCbcsResponseOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v CommonEncryptionCbcsResponse) []TrackSelectionResponse { return v.ClearTracks }).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCbcsResponseOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcsResponse) *StreamingPolicyContentKeysResponse { return v.ContentKeys }).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Configuration of DRMs for current encryption scheme
func (o CommonEncryptionCbcsResponseOutput) Drm() CbcsDrmConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcsResponse) *CbcsDrmConfigurationResponse { return v.Drm }).(CbcsDrmConfigurationResponsePtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCbcsResponseOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcsResponse) *EnabledProtocolsResponse { return v.EnabledProtocols }).(EnabledProtocolsResponsePtrOutput)
}

type CommonEncryptionCbcsResponsePtrOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCbcsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCbcsResponse)(nil)).Elem()
}

func (o CommonEncryptionCbcsResponsePtrOutput) ToCommonEncryptionCbcsResponsePtrOutput() CommonEncryptionCbcsResponsePtrOutput {
	return o
}

func (o CommonEncryptionCbcsResponsePtrOutput) ToCommonEncryptionCbcsResponsePtrOutputWithContext(ctx context.Context) CommonEncryptionCbcsResponsePtrOutput {
	return o
}

func (o CommonEncryptionCbcsResponsePtrOutput) Elem() CommonEncryptionCbcsResponseOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcsResponse) CommonEncryptionCbcsResponse {
		if v != nil {
			return *v
		}
		var ret CommonEncryptionCbcsResponse
		return ret
	}).(CommonEncryptionCbcsResponseOutput)
}

// Optional configuration supporting ClearKey in CommonEncryptionCbcs encryption scheme.
func (o CommonEncryptionCbcsResponsePtrOutput) ClearKeyEncryptionConfiguration() ClearKeyEncryptionConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcsResponse) *ClearKeyEncryptionConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.ClearKeyEncryptionConfiguration
	}).(ClearKeyEncryptionConfigurationResponsePtrOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCbcsResponsePtrOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcsResponse) []TrackSelectionResponse {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCbcsResponsePtrOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcsResponse) *StreamingPolicyContentKeysResponse {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Configuration of DRMs for current encryption scheme
func (o CommonEncryptionCbcsResponsePtrOutput) Drm() CbcsDrmConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcsResponse) *CbcsDrmConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.Drm
	}).(CbcsDrmConfigurationResponsePtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCbcsResponsePtrOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcsResponse) *EnabledProtocolsResponse {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsResponsePtrOutput)
}

// Class for envelope encryption scheme
type CommonEncryptionCenc struct {
	// Optional configuration supporting ClearKey in CommonEncryptionCenc encryption scheme.
	ClearKeyEncryptionConfiguration *ClearKeyEncryptionConfiguration `pulumi:"clearKeyEncryptionConfiguration"`
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelection `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `pulumi:"contentKeys"`
	// Configuration of DRMs for CommonEncryptionCenc encryption scheme
	Drm *CencDrmConfiguration `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `pulumi:"enabledProtocols"`
}

// CommonEncryptionCencInput is an input type that accepts CommonEncryptionCencArgs and CommonEncryptionCencOutput values.
// You can construct a concrete instance of `CommonEncryptionCencInput` via:
//
//	CommonEncryptionCencArgs{...}
type CommonEncryptionCencInput interface {
	pulumi.Input

	ToCommonEncryptionCencOutput() CommonEncryptionCencOutput
	ToCommonEncryptionCencOutputWithContext(context.Context) CommonEncryptionCencOutput
}

// Class for envelope encryption scheme
type CommonEncryptionCencArgs struct {
	// Optional configuration supporting ClearKey in CommonEncryptionCenc encryption scheme.
	ClearKeyEncryptionConfiguration ClearKeyEncryptionConfigurationPtrInput `pulumi:"clearKeyEncryptionConfiguration"`
	// Representing which tracks should not be encrypted
	ClearTracks TrackSelectionArrayInput `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys StreamingPolicyContentKeysPtrInput `pulumi:"contentKeys"`
	// Configuration of DRMs for CommonEncryptionCenc encryption scheme
	Drm CencDrmConfigurationPtrInput `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols EnabledProtocolsPtrInput `pulumi:"enabledProtocols"`
}

func (CommonEncryptionCencArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCenc)(nil)).Elem()
}

func (i CommonEncryptionCencArgs) ToCommonEncryptionCencOutput() CommonEncryptionCencOutput {
	return i.ToCommonEncryptionCencOutputWithContext(context.Background())
}

func (i CommonEncryptionCencArgs) ToCommonEncryptionCencOutputWithContext(ctx context.Context) CommonEncryptionCencOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCencOutput)
}

func (i CommonEncryptionCencArgs) ToCommonEncryptionCencPtrOutput() CommonEncryptionCencPtrOutput {
	return i.ToCommonEncryptionCencPtrOutputWithContext(context.Background())
}

func (i CommonEncryptionCencArgs) ToCommonEncryptionCencPtrOutputWithContext(ctx context.Context) CommonEncryptionCencPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCencOutput).ToCommonEncryptionCencPtrOutputWithContext(ctx)
}

// CommonEncryptionCencPtrInput is an input type that accepts CommonEncryptionCencArgs, CommonEncryptionCencPtr and CommonEncryptionCencPtrOutput values.
// You can construct a concrete instance of `CommonEncryptionCencPtrInput` via:
//
//	        CommonEncryptionCencArgs{...}
//
//	or:
//
//	        nil
type CommonEncryptionCencPtrInput interface {
	pulumi.Input

	ToCommonEncryptionCencPtrOutput() CommonEncryptionCencPtrOutput
	ToCommonEncryptionCencPtrOutputWithContext(context.Context) CommonEncryptionCencPtrOutput
}

type commonEncryptionCencPtrType CommonEncryptionCencArgs

func CommonEncryptionCencPtr(v *CommonEncryptionCencArgs) CommonEncryptionCencPtrInput {
	return (*commonEncryptionCencPtrType)(v)
}

func (*commonEncryptionCencPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCenc)(nil)).Elem()
}

func (i *commonEncryptionCencPtrType) ToCommonEncryptionCencPtrOutput() CommonEncryptionCencPtrOutput {
	return i.ToCommonEncryptionCencPtrOutputWithContext(context.Background())
}

func (i *commonEncryptionCencPtrType) ToCommonEncryptionCencPtrOutputWithContext(ctx context.Context) CommonEncryptionCencPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCencPtrOutput)
}

// Class for envelope encryption scheme
type CommonEncryptionCencOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCencOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCenc)(nil)).Elem()
}

func (o CommonEncryptionCencOutput) ToCommonEncryptionCencOutput() CommonEncryptionCencOutput {
	return o
}

func (o CommonEncryptionCencOutput) ToCommonEncryptionCencOutputWithContext(ctx context.Context) CommonEncryptionCencOutput {
	return o
}

func (o CommonEncryptionCencOutput) ToCommonEncryptionCencPtrOutput() CommonEncryptionCencPtrOutput {
	return o.ToCommonEncryptionCencPtrOutputWithContext(context.Background())
}

func (o CommonEncryptionCencOutput) ToCommonEncryptionCencPtrOutputWithContext(ctx context.Context) CommonEncryptionCencPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CommonEncryptionCenc) *CommonEncryptionCenc {
		return &v
	}).(CommonEncryptionCencPtrOutput)
}

// Optional configuration supporting ClearKey in CommonEncryptionCenc encryption scheme.
func (o CommonEncryptionCencOutput) ClearKeyEncryptionConfiguration() ClearKeyEncryptionConfigurationPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCenc) *ClearKeyEncryptionConfiguration {
		return v.ClearKeyEncryptionConfiguration
	}).(ClearKeyEncryptionConfigurationPtrOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCencOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v CommonEncryptionCenc) []TrackSelection { return v.ClearTracks }).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCencOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCenc) *StreamingPolicyContentKeys { return v.ContentKeys }).(StreamingPolicyContentKeysPtrOutput)
}

// Configuration of DRMs for CommonEncryptionCenc encryption scheme
func (o CommonEncryptionCencOutput) Drm() CencDrmConfigurationPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCenc) *CencDrmConfiguration { return v.Drm }).(CencDrmConfigurationPtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCencOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCenc) *EnabledProtocols { return v.EnabledProtocols }).(EnabledProtocolsPtrOutput)
}

type CommonEncryptionCencPtrOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCencPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCenc)(nil)).Elem()
}

func (o CommonEncryptionCencPtrOutput) ToCommonEncryptionCencPtrOutput() CommonEncryptionCencPtrOutput {
	return o
}

func (o CommonEncryptionCencPtrOutput) ToCommonEncryptionCencPtrOutputWithContext(ctx context.Context) CommonEncryptionCencPtrOutput {
	return o
}

func (o CommonEncryptionCencPtrOutput) Elem() CommonEncryptionCencOutput {
	return o.ApplyT(func(v *CommonEncryptionCenc) CommonEncryptionCenc {
		if v != nil {
			return *v
		}
		var ret CommonEncryptionCenc
		return ret
	}).(CommonEncryptionCencOutput)
}

// Optional configuration supporting ClearKey in CommonEncryptionCenc encryption scheme.
func (o CommonEncryptionCencPtrOutput) ClearKeyEncryptionConfiguration() ClearKeyEncryptionConfigurationPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCenc) *ClearKeyEncryptionConfiguration {
		if v == nil {
			return nil
		}
		return v.ClearKeyEncryptionConfiguration
	}).(ClearKeyEncryptionConfigurationPtrOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCencPtrOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v *CommonEncryptionCenc) []TrackSelection {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCencPtrOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCenc) *StreamingPolicyContentKeys {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysPtrOutput)
}

// Configuration of DRMs for CommonEncryptionCenc encryption scheme
func (o CommonEncryptionCencPtrOutput) Drm() CencDrmConfigurationPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCenc) *CencDrmConfiguration {
		if v == nil {
			return nil
		}
		return v.Drm
	}).(CencDrmConfigurationPtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCencPtrOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCenc) *EnabledProtocols {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsPtrOutput)
}

// Class for envelope encryption scheme
type CommonEncryptionCencResponse struct {
	// Optional configuration supporting ClearKey in CommonEncryptionCenc encryption scheme.
	ClearKeyEncryptionConfiguration *ClearKeyEncryptionConfigurationResponse `pulumi:"clearKeyEncryptionConfiguration"`
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelectionResponse `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeysResponse `pulumi:"contentKeys"`
	// Configuration of DRMs for CommonEncryptionCenc encryption scheme
	Drm *CencDrmConfigurationResponse `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocolsResponse `pulumi:"enabledProtocols"`
}

// Class for envelope encryption scheme
type CommonEncryptionCencResponseOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCencResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCencResponse)(nil)).Elem()
}

func (o CommonEncryptionCencResponseOutput) ToCommonEncryptionCencResponseOutput() CommonEncryptionCencResponseOutput {
	return o
}

func (o CommonEncryptionCencResponseOutput) ToCommonEncryptionCencResponseOutputWithContext(ctx context.Context) CommonEncryptionCencResponseOutput {
	return o
}

// Optional configuration supporting ClearKey in CommonEncryptionCenc encryption scheme.
func (o CommonEncryptionCencResponseOutput) ClearKeyEncryptionConfiguration() ClearKeyEncryptionConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCencResponse) *ClearKeyEncryptionConfigurationResponse {
		return v.ClearKeyEncryptionConfiguration
	}).(ClearKeyEncryptionConfigurationResponsePtrOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCencResponseOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v CommonEncryptionCencResponse) []TrackSelectionResponse { return v.ClearTracks }).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCencResponseOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCencResponse) *StreamingPolicyContentKeysResponse { return v.ContentKeys }).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Configuration of DRMs for CommonEncryptionCenc encryption scheme
func (o CommonEncryptionCencResponseOutput) Drm() CencDrmConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCencResponse) *CencDrmConfigurationResponse { return v.Drm }).(CencDrmConfigurationResponsePtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCencResponseOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCencResponse) *EnabledProtocolsResponse { return v.EnabledProtocols }).(EnabledProtocolsResponsePtrOutput)
}

type CommonEncryptionCencResponsePtrOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCencResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCencResponse)(nil)).Elem()
}

func (o CommonEncryptionCencResponsePtrOutput) ToCommonEncryptionCencResponsePtrOutput() CommonEncryptionCencResponsePtrOutput {
	return o
}

func (o CommonEncryptionCencResponsePtrOutput) ToCommonEncryptionCencResponsePtrOutputWithContext(ctx context.Context) CommonEncryptionCencResponsePtrOutput {
	return o
}

func (o CommonEncryptionCencResponsePtrOutput) Elem() CommonEncryptionCencResponseOutput {
	return o.ApplyT(func(v *CommonEncryptionCencResponse) CommonEncryptionCencResponse {
		if v != nil {
			return *v
		}
		var ret CommonEncryptionCencResponse
		return ret
	}).(CommonEncryptionCencResponseOutput)
}

// Optional configuration supporting ClearKey in CommonEncryptionCenc encryption scheme.
func (o CommonEncryptionCencResponsePtrOutput) ClearKeyEncryptionConfiguration() ClearKeyEncryptionConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCencResponse) *ClearKeyEncryptionConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.ClearKeyEncryptionConfiguration
	}).(ClearKeyEncryptionConfigurationResponsePtrOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCencResponsePtrOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v *CommonEncryptionCencResponse) []TrackSelectionResponse {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCencResponsePtrOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCencResponse) *StreamingPolicyContentKeysResponse {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Configuration of DRMs for CommonEncryptionCenc encryption scheme
func (o CommonEncryptionCencResponsePtrOutput) Drm() CencDrmConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCencResponse) *CencDrmConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.Drm
	}).(CencDrmConfigurationResponsePtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCencResponsePtrOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCencResponse) *EnabledProtocolsResponse {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsResponsePtrOutput)
}

// Represents a configuration for non-DRM keys.
type ContentKeyPolicyClearKeyConfiguration struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration'.
	OdataType string `pulumi:"odataType"`
}

// ContentKeyPolicyClearKeyConfigurationInput is an input type that accepts ContentKeyPolicyClearKeyConfigurationArgs and ContentKeyPolicyClearKeyConfigurationOutput values.
// You can construct a concrete instance of `ContentKeyPolicyClearKeyConfigurationInput` via:
//
//	ContentKeyPolicyClearKeyConfigurationArgs{...}
type ContentKeyPolicyClearKeyConfigurationInput interface {
	pulumi.Input

	ToContentKeyPolicyClearKeyConfigurationOutput() ContentKeyPolicyClearKeyConfigurationOutput
	ToContentKeyPolicyClearKeyConfigurationOutputWithContext(context.Context) ContentKeyPolicyClearKeyConfigurationOutput
}

// Represents a configuration for non-DRM keys.
type ContentKeyPolicyClearKeyConfigurationArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (ContentKeyPolicyClearKeyConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyClearKeyConfiguration)(nil)).Elem()
}

func (i ContentKeyPolicyClearKeyConfigurationArgs) ToContentKeyPolicyClearKeyConfigurationOutput() ContentKeyPolicyClearKeyConfigurationOutput {
	return i.ToContentKeyPolicyClearKeyConfigurationOutputWithContext(context.Background())
}

func (i ContentKeyPolicyClearKeyConfigurationArgs) ToContentKeyPolicyClearKeyConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyClearKeyConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyClearKeyConfigurationOutput)
}

// Represents a configuration for non-DRM keys.
type ContentKeyPolicyClearKeyConfigurationOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyClearKeyConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyClearKeyConfiguration)(nil)).Elem()
}

func (o ContentKeyPolicyClearKeyConfigurationOutput) ToContentKeyPolicyClearKeyConfigurationOutput() ContentKeyPolicyClearKeyConfigurationOutput {
	return o
}

func (o ContentKeyPolicyClearKeyConfigurationOutput) ToContentKeyPolicyClearKeyConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyClearKeyConfigurationOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration'.
func (o ContentKeyPolicyClearKeyConfigurationOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyClearKeyConfiguration) string { return v.OdataType }).(pulumi.StringOutput)
}

// Represents a configuration for non-DRM keys.
type ContentKeyPolicyClearKeyConfigurationResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration'.
	OdataType string `pulumi:"odataType"`
}

// Represents a configuration for non-DRM keys.
type ContentKeyPolicyClearKeyConfigurationResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyClearKeyConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyClearKeyConfigurationResponse)(nil)).Elem()
}

func (o ContentKeyPolicyClearKeyConfigurationResponseOutput) ToContentKeyPolicyClearKeyConfigurationResponseOutput() ContentKeyPolicyClearKeyConfigurationResponseOutput {
	return o
}

func (o ContentKeyPolicyClearKeyConfigurationResponseOutput) ToContentKeyPolicyClearKeyConfigurationResponseOutputWithContext(ctx context.Context) ContentKeyPolicyClearKeyConfigurationResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration'.
func (o ContentKeyPolicyClearKeyConfigurationResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyClearKeyConfigurationResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies a configuration for FairPlay licenses.
type ContentKeyPolicyFairPlayConfiguration struct {
	// The key that must be used as FairPlay Application Secret key. This needs to be base64 encoded.
	Ask string `pulumi:"ask"`
	// The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
	FairPlayPfx string `pulumi:"fairPlayPfx"`
	// The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
	FairPlayPfxPassword string `pulumi:"fairPlayPfxPassword"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration'.
	OdataType string `pulumi:"odataType"`
	// Offline rental policy
	OfflineRentalConfiguration *ContentKeyPolicyFairPlayOfflineRentalConfiguration `pulumi:"offlineRentalConfiguration"`
	// The rental and lease key type.
	RentalAndLeaseKeyType string `pulumi:"rentalAndLeaseKeyType"`
	// The rental duration. Must be greater than or equal to 0.
	RentalDuration float64 `pulumi:"rentalDuration"`
}

// ContentKeyPolicyFairPlayConfigurationInput is an input type that accepts ContentKeyPolicyFairPlayConfigurationArgs and ContentKeyPolicyFairPlayConfigurationOutput values.
// You can construct a concrete instance of `ContentKeyPolicyFairPlayConfigurationInput` via:
//
//	ContentKeyPolicyFairPlayConfigurationArgs{...}
type ContentKeyPolicyFairPlayConfigurationInput interface {
	pulumi.Input

	ToContentKeyPolicyFairPlayConfigurationOutput() ContentKeyPolicyFairPlayConfigurationOutput
	ToContentKeyPolicyFairPlayConfigurationOutputWithContext(context.Context) ContentKeyPolicyFairPlayConfigurationOutput
}

// Specifies a configuration for FairPlay licenses.
type ContentKeyPolicyFairPlayConfigurationArgs struct {
	// The key that must be used as FairPlay Application Secret key. This needs to be base64 encoded.
	Ask pulumi.StringInput `pulumi:"ask"`
	// The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
	FairPlayPfx pulumi.StringInput `pulumi:"fairPlayPfx"`
	// The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
	FairPlayPfxPassword pulumi.StringInput `pulumi:"fairPlayPfxPassword"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Offline rental policy
	OfflineRentalConfiguration ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrInput `pulumi:"offlineRentalConfiguration"`
	// The rental and lease key type.
	RentalAndLeaseKeyType pulumi.StringInput `pulumi:"rentalAndLeaseKeyType"`
	// The rental duration. Must be greater than or equal to 0.
	RentalDuration pulumi.Float64Input `pulumi:"rentalDuration"`
}

func (ContentKeyPolicyFairPlayConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyFairPlayConfiguration)(nil)).Elem()
}

func (i ContentKeyPolicyFairPlayConfigurationArgs) ToContentKeyPolicyFairPlayConfigurationOutput() ContentKeyPolicyFairPlayConfigurationOutput {
	return i.ToContentKeyPolicyFairPlayConfigurationOutputWithContext(context.Background())
}

func (i ContentKeyPolicyFairPlayConfigurationArgs) ToContentKeyPolicyFairPlayConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyFairPlayConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyFairPlayConfigurationOutput)
}

// Specifies a configuration for FairPlay licenses.
type ContentKeyPolicyFairPlayConfigurationOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyFairPlayConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyFairPlayConfiguration)(nil)).Elem()
}

func (o ContentKeyPolicyFairPlayConfigurationOutput) ToContentKeyPolicyFairPlayConfigurationOutput() ContentKeyPolicyFairPlayConfigurationOutput {
	return o
}

func (o ContentKeyPolicyFairPlayConfigurationOutput) ToContentKeyPolicyFairPlayConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyFairPlayConfigurationOutput {
	return o
}

// The key that must be used as FairPlay Application Secret key. This needs to be base64 encoded.
func (o ContentKeyPolicyFairPlayConfigurationOutput) Ask() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfiguration) string { return v.Ask }).(pulumi.StringOutput)
}

// The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
func (o ContentKeyPolicyFairPlayConfigurationOutput) FairPlayPfx() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfiguration) string { return v.FairPlayPfx }).(pulumi.StringOutput)
}

// The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
func (o ContentKeyPolicyFairPlayConfigurationOutput) FairPlayPfxPassword() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfiguration) string { return v.FairPlayPfxPassword }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration'.
func (o ContentKeyPolicyFairPlayConfigurationOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfiguration) string { return v.OdataType }).(pulumi.StringOutput)
}

// Offline rental policy
func (o ContentKeyPolicyFairPlayConfigurationOutput) OfflineRentalConfiguration() ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfiguration) *ContentKeyPolicyFairPlayOfflineRentalConfiguration {
		return v.OfflineRentalConfiguration
	}).(ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput)
}

// The rental and lease key type.
func (o ContentKeyPolicyFairPlayConfigurationOutput) RentalAndLeaseKeyType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfiguration) string { return v.RentalAndLeaseKeyType }).(pulumi.StringOutput)
}

// The rental duration. Must be greater than or equal to 0.
func (o ContentKeyPolicyFairPlayConfigurationOutput) RentalDuration() pulumi.Float64Output {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfiguration) float64 { return v.RentalDuration }).(pulumi.Float64Output)
}

// Specifies a configuration for FairPlay licenses.
type ContentKeyPolicyFairPlayConfigurationResponse struct {
	// The key that must be used as FairPlay Application Secret key. This needs to be base64 encoded.
	Ask string `pulumi:"ask"`
	// The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
	FairPlayPfx string `pulumi:"fairPlayPfx"`
	// The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
	FairPlayPfxPassword string `pulumi:"fairPlayPfxPassword"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration'.
	OdataType string `pulumi:"odataType"`
	// Offline rental policy
	OfflineRentalConfiguration *ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse `pulumi:"offlineRentalConfiguration"`
	// The rental and lease key type.
	RentalAndLeaseKeyType string `pulumi:"rentalAndLeaseKeyType"`
	// The rental duration. Must be greater than or equal to 0.
	RentalDuration float64 `pulumi:"rentalDuration"`
}

// Specifies a configuration for FairPlay licenses.
type ContentKeyPolicyFairPlayConfigurationResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyFairPlayConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyFairPlayConfigurationResponse)(nil)).Elem()
}

func (o ContentKeyPolicyFairPlayConfigurationResponseOutput) ToContentKeyPolicyFairPlayConfigurationResponseOutput() ContentKeyPolicyFairPlayConfigurationResponseOutput {
	return o
}

func (o ContentKeyPolicyFairPlayConfigurationResponseOutput) ToContentKeyPolicyFairPlayConfigurationResponseOutputWithContext(ctx context.Context) ContentKeyPolicyFairPlayConfigurationResponseOutput {
	return o
}

// The key that must be used as FairPlay Application Secret key. This needs to be base64 encoded.
func (o ContentKeyPolicyFairPlayConfigurationResponseOutput) Ask() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfigurationResponse) string { return v.Ask }).(pulumi.StringOutput)
}

// The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
func (o ContentKeyPolicyFairPlayConfigurationResponseOutput) FairPlayPfx() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfigurationResponse) string { return v.FairPlayPfx }).(pulumi.StringOutput)
}

// The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
func (o ContentKeyPolicyFairPlayConfigurationResponseOutput) FairPlayPfxPassword() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfigurationResponse) string { return v.FairPlayPfxPassword }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration'.
func (o ContentKeyPolicyFairPlayConfigurationResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfigurationResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Offline rental policy
func (o ContentKeyPolicyFairPlayConfigurationResponseOutput) OfflineRentalConfiguration() ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfigurationResponse) *ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse {
		return v.OfflineRentalConfiguration
	}).(ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput)
}

// The rental and lease key type.
func (o ContentKeyPolicyFairPlayConfigurationResponseOutput) RentalAndLeaseKeyType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfigurationResponse) string { return v.RentalAndLeaseKeyType }).(pulumi.StringOutput)
}

// The rental duration. Must be greater than or equal to 0.
func (o ContentKeyPolicyFairPlayConfigurationResponseOutput) RentalDuration() pulumi.Float64Output {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayConfigurationResponse) float64 { return v.RentalDuration }).(pulumi.Float64Output)
}

type ContentKeyPolicyFairPlayOfflineRentalConfiguration struct {
	// Playback duration
	PlaybackDurationSeconds float64 `pulumi:"playbackDurationSeconds"`
	// Storage duration
	StorageDurationSeconds float64 `pulumi:"storageDurationSeconds"`
}

// ContentKeyPolicyFairPlayOfflineRentalConfigurationInput is an input type that accepts ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs and ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput values.
// You can construct a concrete instance of `ContentKeyPolicyFairPlayOfflineRentalConfigurationInput` via:
//
//	ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs{...}
type ContentKeyPolicyFairPlayOfflineRentalConfigurationInput interface {
	pulumi.Input

	ToContentKeyPolicyFairPlayOfflineRentalConfigurationOutput() ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput
	ToContentKeyPolicyFairPlayOfflineRentalConfigurationOutputWithContext(context.Context) ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput
}

type ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs struct {
	// Playback duration
	PlaybackDurationSeconds pulumi.Float64Input `pulumi:"playbackDurationSeconds"`
	// Storage duration
	StorageDurationSeconds pulumi.Float64Input `pulumi:"storageDurationSeconds"`
}

func (ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyFairPlayOfflineRentalConfiguration)(nil)).Elem()
}

func (i ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs) ToContentKeyPolicyFairPlayOfflineRentalConfigurationOutput() ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput {
	return i.ToContentKeyPolicyFairPlayOfflineRentalConfigurationOutputWithContext(context.Background())
}

func (i ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs) ToContentKeyPolicyFairPlayOfflineRentalConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput)
}

func (i ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs) ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput() ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput {
	return i.ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutputWithContext(context.Background())
}

func (i ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs) ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutputWithContext(ctx context.Context) ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput).ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutputWithContext(ctx)
}

// ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrInput is an input type that accepts ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs, ContentKeyPolicyFairPlayOfflineRentalConfigurationPtr and ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput values.
// You can construct a concrete instance of `ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrInput` via:
//
//	        ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs{...}
//
//	or:
//
//	        nil
type ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrInput interface {
	pulumi.Input

	ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput() ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput
	ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutputWithContext(context.Context) ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput
}

type contentKeyPolicyFairPlayOfflineRentalConfigurationPtrType ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs

func ContentKeyPolicyFairPlayOfflineRentalConfigurationPtr(v *ContentKeyPolicyFairPlayOfflineRentalConfigurationArgs) ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrInput {
	return (*contentKeyPolicyFairPlayOfflineRentalConfigurationPtrType)(v)
}

func (*contentKeyPolicyFairPlayOfflineRentalConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContentKeyPolicyFairPlayOfflineRentalConfiguration)(nil)).Elem()
}

func (i *contentKeyPolicyFairPlayOfflineRentalConfigurationPtrType) ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput() ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput {
	return i.ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutputWithContext(context.Background())
}

func (i *contentKeyPolicyFairPlayOfflineRentalConfigurationPtrType) ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutputWithContext(ctx context.Context) ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput)
}

type ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyFairPlayOfflineRentalConfiguration)(nil)).Elem()
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput) ToContentKeyPolicyFairPlayOfflineRentalConfigurationOutput() ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput {
	return o
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput) ToContentKeyPolicyFairPlayOfflineRentalConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput {
	return o
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput) ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput() ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput {
	return o.ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutputWithContext(context.Background())
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput) ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutputWithContext(ctx context.Context) ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContentKeyPolicyFairPlayOfflineRentalConfiguration) *ContentKeyPolicyFairPlayOfflineRentalConfiguration {
		return &v
	}).(ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput)
}

// Playback duration
func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput) PlaybackDurationSeconds() pulumi.Float64Output {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayOfflineRentalConfiguration) float64 { return v.PlaybackDurationSeconds }).(pulumi.Float64Output)
}

// Storage duration
func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput) StorageDurationSeconds() pulumi.Float64Output {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayOfflineRentalConfiguration) float64 { return v.StorageDurationSeconds }).(pulumi.Float64Output)
}

type ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContentKeyPolicyFairPlayOfflineRentalConfiguration)(nil)).Elem()
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput) ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput() ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput {
	return o
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput) ToContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutputWithContext(ctx context.Context) ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput {
	return o
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput) Elem() ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput {
	return o.ApplyT(func(v *ContentKeyPolicyFairPlayOfflineRentalConfiguration) ContentKeyPolicyFairPlayOfflineRentalConfiguration {
		if v != nil {
			return *v
		}
		var ret ContentKeyPolicyFairPlayOfflineRentalConfiguration
		return ret
	}).(ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput)
}

// Playback duration
func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput) PlaybackDurationSeconds() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyFairPlayOfflineRentalConfiguration) *float64 {
		if v == nil {
			return nil
		}
		return &v.PlaybackDurationSeconds
	}).(pulumi.Float64PtrOutput)
}

// Storage duration
func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput) StorageDurationSeconds() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyFairPlayOfflineRentalConfiguration) *float64 {
		if v == nil {
			return nil
		}
		return &v.StorageDurationSeconds
	}).(pulumi.Float64PtrOutput)
}

type ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse struct {
	// Playback duration
	PlaybackDurationSeconds float64 `pulumi:"playbackDurationSeconds"`
	// Storage duration
	StorageDurationSeconds float64 `pulumi:"storageDurationSeconds"`
}

type ContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse)(nil)).Elem()
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput) ToContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput() ContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput {
	return o
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput) ToContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutputWithContext(ctx context.Context) ContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput {
	return o
}

// Playback duration
func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput) PlaybackDurationSeconds() pulumi.Float64Output {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse) float64 {
		return v.PlaybackDurationSeconds
	}).(pulumi.Float64Output)
}

// Storage duration
func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput) StorageDurationSeconds() pulumi.Float64Output {
	return o.ApplyT(func(v ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse) float64 {
		return v.StorageDurationSeconds
	}).(pulumi.Float64Output)
}

type ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse)(nil)).Elem()
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput) ToContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput() ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput {
	return o
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput) ToContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutputWithContext(ctx context.Context) ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput {
	return o
}

func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput) Elem() ContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput {
	return o.ApplyT(func(v *ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse) ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse
		return ret
	}).(ContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput)
}

// Playback duration
func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput) PlaybackDurationSeconds() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.PlaybackDurationSeconds
	}).(pulumi.Float64PtrOutput)
}

// Storage duration
func (o ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput) StorageDurationSeconds() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.StorageDurationSeconds
	}).(pulumi.Float64PtrOutput)
}

// Represents an open restriction. License or key will be delivered on every request.
type ContentKeyPolicyOpenRestriction struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyOpenRestriction'.
	OdataType string `pulumi:"odataType"`
}

// ContentKeyPolicyOpenRestrictionInput is an input type that accepts ContentKeyPolicyOpenRestrictionArgs and ContentKeyPolicyOpenRestrictionOutput values.
// You can construct a concrete instance of `ContentKeyPolicyOpenRestrictionInput` via:
//
//	ContentKeyPolicyOpenRestrictionArgs{...}
type ContentKeyPolicyOpenRestrictionInput interface {
	pulumi.Input

	ToContentKeyPolicyOpenRestrictionOutput() ContentKeyPolicyOpenRestrictionOutput
	ToContentKeyPolicyOpenRestrictionOutputWithContext(context.Context) ContentKeyPolicyOpenRestrictionOutput
}

// Represents an open restriction. License or key will be delivered on every request.
type ContentKeyPolicyOpenRestrictionArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyOpenRestriction'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (ContentKeyPolicyOpenRestrictionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyOpenRestriction)(nil)).Elem()
}

func (i ContentKeyPolicyOpenRestrictionArgs) ToContentKeyPolicyOpenRestrictionOutput() ContentKeyPolicyOpenRestrictionOutput {
	return i.ToContentKeyPolicyOpenRestrictionOutputWithContext(context.Background())
}

func (i ContentKeyPolicyOpenRestrictionArgs) ToContentKeyPolicyOpenRestrictionOutputWithContext(ctx context.Context) ContentKeyPolicyOpenRestrictionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyOpenRestrictionOutput)
}

// Represents an open restriction. License or key will be delivered on every request.
type ContentKeyPolicyOpenRestrictionOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyOpenRestrictionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyOpenRestriction)(nil)).Elem()
}

func (o ContentKeyPolicyOpenRestrictionOutput) ToContentKeyPolicyOpenRestrictionOutput() ContentKeyPolicyOpenRestrictionOutput {
	return o
}

func (o ContentKeyPolicyOpenRestrictionOutput) ToContentKeyPolicyOpenRestrictionOutputWithContext(ctx context.Context) ContentKeyPolicyOpenRestrictionOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyOpenRestriction'.
func (o ContentKeyPolicyOpenRestrictionOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyOpenRestriction) string { return v.OdataType }).(pulumi.StringOutput)
}

// Represents an open restriction. License or key will be delivered on every request.
type ContentKeyPolicyOpenRestrictionResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyOpenRestriction'.
	OdataType string `pulumi:"odataType"`
}

// Represents an open restriction. License or key will be delivered on every request.
type ContentKeyPolicyOpenRestrictionResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyOpenRestrictionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyOpenRestrictionResponse)(nil)).Elem()
}

func (o ContentKeyPolicyOpenRestrictionResponseOutput) ToContentKeyPolicyOpenRestrictionResponseOutput() ContentKeyPolicyOpenRestrictionResponseOutput {
	return o
}

func (o ContentKeyPolicyOpenRestrictionResponseOutput) ToContentKeyPolicyOpenRestrictionResponseOutputWithContext(ctx context.Context) ContentKeyPolicyOpenRestrictionResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyOpenRestriction'.
func (o ContentKeyPolicyOpenRestrictionResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyOpenRestrictionResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Represents a policy option.
type ContentKeyPolicyOption struct {
	// The key delivery configuration.
	Configuration interface{} `pulumi:"configuration"`
	// The Policy Option description.
	Name *string `pulumi:"name"`
	// The requirements that must be met to deliver keys with this configuration
	Restriction interface{} `pulumi:"restriction"`
}

// ContentKeyPolicyOptionInput is an input type that accepts ContentKeyPolicyOptionArgs and ContentKeyPolicyOptionOutput values.
// You can construct a concrete instance of `ContentKeyPolicyOptionInput` via:
//
//	ContentKeyPolicyOptionArgs{...}
type ContentKeyPolicyOptionInput interface {
	pulumi.Input

	ToContentKeyPolicyOptionOutput() ContentKeyPolicyOptionOutput
	ToContentKeyPolicyOptionOutputWithContext(context.Context) ContentKeyPolicyOptionOutput
}

// Represents a policy option.
type ContentKeyPolicyOptionArgs struct {
	// The key delivery configuration.
	Configuration pulumi.Input `pulumi:"configuration"`
	// The Policy Option description.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The requirements that must be met to deliver keys with this configuration
	Restriction pulumi.Input `pulumi:"restriction"`
}

func (ContentKeyPolicyOptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyOption)(nil)).Elem()
}

func (i ContentKeyPolicyOptionArgs) ToContentKeyPolicyOptionOutput() ContentKeyPolicyOptionOutput {
	return i.ToContentKeyPolicyOptionOutputWithContext(context.Background())
}

func (i ContentKeyPolicyOptionArgs) ToContentKeyPolicyOptionOutputWithContext(ctx context.Context) ContentKeyPolicyOptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyOptionOutput)
}

// ContentKeyPolicyOptionArrayInput is an input type that accepts ContentKeyPolicyOptionArray and ContentKeyPolicyOptionArrayOutput values.
// You can construct a concrete instance of `ContentKeyPolicyOptionArrayInput` via:
//
//	ContentKeyPolicyOptionArray{ ContentKeyPolicyOptionArgs{...} }
type ContentKeyPolicyOptionArrayInput interface {
	pulumi.Input

	ToContentKeyPolicyOptionArrayOutput() ContentKeyPolicyOptionArrayOutput
	ToContentKeyPolicyOptionArrayOutputWithContext(context.Context) ContentKeyPolicyOptionArrayOutput
}

type ContentKeyPolicyOptionArray []ContentKeyPolicyOptionInput

func (ContentKeyPolicyOptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyOption)(nil)).Elem()
}

func (i ContentKeyPolicyOptionArray) ToContentKeyPolicyOptionArrayOutput() ContentKeyPolicyOptionArrayOutput {
	return i.ToContentKeyPolicyOptionArrayOutputWithContext(context.Background())
}

func (i ContentKeyPolicyOptionArray) ToContentKeyPolicyOptionArrayOutputWithContext(ctx context.Context) ContentKeyPolicyOptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyOptionArrayOutput)
}

// Represents a policy option.
type ContentKeyPolicyOptionOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyOptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyOption)(nil)).Elem()
}

func (o ContentKeyPolicyOptionOutput) ToContentKeyPolicyOptionOutput() ContentKeyPolicyOptionOutput {
	return o
}

func (o ContentKeyPolicyOptionOutput) ToContentKeyPolicyOptionOutputWithContext(ctx context.Context) ContentKeyPolicyOptionOutput {
	return o
}

// The key delivery configuration.
func (o ContentKeyPolicyOptionOutput) Configuration() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyOption) interface{} { return v.Configuration }).(pulumi.AnyOutput)
}

// The Policy Option description.
func (o ContentKeyPolicyOptionOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyOption) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The requirements that must be met to deliver keys with this configuration
func (o ContentKeyPolicyOptionOutput) Restriction() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyOption) interface{} { return v.Restriction }).(pulumi.AnyOutput)
}

type ContentKeyPolicyOptionArrayOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyOptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyOption)(nil)).Elem()
}

func (o ContentKeyPolicyOptionArrayOutput) ToContentKeyPolicyOptionArrayOutput() ContentKeyPolicyOptionArrayOutput {
	return o
}

func (o ContentKeyPolicyOptionArrayOutput) ToContentKeyPolicyOptionArrayOutputWithContext(ctx context.Context) ContentKeyPolicyOptionArrayOutput {
	return o
}

func (o ContentKeyPolicyOptionArrayOutput) Index(i pulumi.IntInput) ContentKeyPolicyOptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentKeyPolicyOption {
		return vs[0].([]ContentKeyPolicyOption)[vs[1].(int)]
	}).(ContentKeyPolicyOptionOutput)
}

// Represents a policy option.
type ContentKeyPolicyOptionResponse struct {
	// The key delivery configuration.
	Configuration interface{} `pulumi:"configuration"`
	// The Policy Option description.
	Name *string `pulumi:"name"`
	// The legacy Policy Option ID.
	PolicyOptionId string `pulumi:"policyOptionId"`
	// The requirements that must be met to deliver keys with this configuration
	Restriction interface{} `pulumi:"restriction"`
}

// Represents a policy option.
type ContentKeyPolicyOptionResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyOptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyOptionResponse)(nil)).Elem()
}

func (o ContentKeyPolicyOptionResponseOutput) ToContentKeyPolicyOptionResponseOutput() ContentKeyPolicyOptionResponseOutput {
	return o
}

func (o ContentKeyPolicyOptionResponseOutput) ToContentKeyPolicyOptionResponseOutputWithContext(ctx context.Context) ContentKeyPolicyOptionResponseOutput {
	return o
}

// The key delivery configuration.
func (o ContentKeyPolicyOptionResponseOutput) Configuration() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyOptionResponse) interface{} { return v.Configuration }).(pulumi.AnyOutput)
}

// The Policy Option description.
func (o ContentKeyPolicyOptionResponseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyOptionResponse) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The legacy Policy Option ID.
func (o ContentKeyPolicyOptionResponseOutput) PolicyOptionId() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyOptionResponse) string { return v.PolicyOptionId }).(pulumi.StringOutput)
}

// The requirements that must be met to deliver keys with this configuration
func (o ContentKeyPolicyOptionResponseOutput) Restriction() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyOptionResponse) interface{} { return v.Restriction }).(pulumi.AnyOutput)
}

type ContentKeyPolicyOptionResponseArrayOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyOptionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyOptionResponse)(nil)).Elem()
}

func (o ContentKeyPolicyOptionResponseArrayOutput) ToContentKeyPolicyOptionResponseArrayOutput() ContentKeyPolicyOptionResponseArrayOutput {
	return o
}

func (o ContentKeyPolicyOptionResponseArrayOutput) ToContentKeyPolicyOptionResponseArrayOutputWithContext(ctx context.Context) ContentKeyPolicyOptionResponseArrayOutput {
	return o
}

func (o ContentKeyPolicyOptionResponseArrayOutput) Index(i pulumi.IntInput) ContentKeyPolicyOptionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentKeyPolicyOptionResponse {
		return vs[0].([]ContentKeyPolicyOptionResponse)[vs[1].(int)]
	}).(ContentKeyPolicyOptionResponseOutput)
}

// Specifies a configuration for PlayReady licenses.
type ContentKeyPolicyPlayReadyConfiguration struct {
	// The PlayReady licenses.
	Licenses []ContentKeyPolicyPlayReadyLicense `pulumi:"licenses"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration'.
	OdataType string `pulumi:"odataType"`
	// The custom response data.
	ResponseCustomData *string `pulumi:"responseCustomData"`
}

// ContentKeyPolicyPlayReadyConfigurationInput is an input type that accepts ContentKeyPolicyPlayReadyConfigurationArgs and ContentKeyPolicyPlayReadyConfigurationOutput values.
// You can construct a concrete instance of `ContentKeyPolicyPlayReadyConfigurationInput` via:
//
//	ContentKeyPolicyPlayReadyConfigurationArgs{...}
type ContentKeyPolicyPlayReadyConfigurationInput interface {
	pulumi.Input

	ToContentKeyPolicyPlayReadyConfigurationOutput() ContentKeyPolicyPlayReadyConfigurationOutput
	ToContentKeyPolicyPlayReadyConfigurationOutputWithContext(context.Context) ContentKeyPolicyPlayReadyConfigurationOutput
}

// Specifies a configuration for PlayReady licenses.
type ContentKeyPolicyPlayReadyConfigurationArgs struct {
	// The PlayReady licenses.
	Licenses ContentKeyPolicyPlayReadyLicenseArrayInput `pulumi:"licenses"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The custom response data.
	ResponseCustomData pulumi.StringPtrInput `pulumi:"responseCustomData"`
}

func (ContentKeyPolicyPlayReadyConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyConfiguration)(nil)).Elem()
}

func (i ContentKeyPolicyPlayReadyConfigurationArgs) ToContentKeyPolicyPlayReadyConfigurationOutput() ContentKeyPolicyPlayReadyConfigurationOutput {
	return i.ToContentKeyPolicyPlayReadyConfigurationOutputWithContext(context.Background())
}

func (i ContentKeyPolicyPlayReadyConfigurationArgs) ToContentKeyPolicyPlayReadyConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyPlayReadyConfigurationOutput)
}

// Specifies a configuration for PlayReady licenses.
type ContentKeyPolicyPlayReadyConfigurationOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyConfiguration)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyConfigurationOutput) ToContentKeyPolicyPlayReadyConfigurationOutput() ContentKeyPolicyPlayReadyConfigurationOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyConfigurationOutput) ToContentKeyPolicyPlayReadyConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyConfigurationOutput {
	return o
}

// The PlayReady licenses.
func (o ContentKeyPolicyPlayReadyConfigurationOutput) Licenses() ContentKeyPolicyPlayReadyLicenseArrayOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyConfiguration) []ContentKeyPolicyPlayReadyLicense { return v.Licenses }).(ContentKeyPolicyPlayReadyLicenseArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration'.
func (o ContentKeyPolicyPlayReadyConfigurationOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyConfiguration) string { return v.OdataType }).(pulumi.StringOutput)
}

// The custom response data.
func (o ContentKeyPolicyPlayReadyConfigurationOutput) ResponseCustomData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyConfiguration) *string { return v.ResponseCustomData }).(pulumi.StringPtrOutput)
}

// Specifies a configuration for PlayReady licenses.
type ContentKeyPolicyPlayReadyConfigurationResponse struct {
	// The PlayReady licenses.
	Licenses []ContentKeyPolicyPlayReadyLicenseResponse `pulumi:"licenses"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration'.
	OdataType string `pulumi:"odataType"`
	// The custom response data.
	ResponseCustomData *string `pulumi:"responseCustomData"`
}

// Specifies a configuration for PlayReady licenses.
type ContentKeyPolicyPlayReadyConfigurationResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyConfigurationResponse)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyConfigurationResponseOutput) ToContentKeyPolicyPlayReadyConfigurationResponseOutput() ContentKeyPolicyPlayReadyConfigurationResponseOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyConfigurationResponseOutput) ToContentKeyPolicyPlayReadyConfigurationResponseOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyConfigurationResponseOutput {
	return o
}

// The PlayReady licenses.
func (o ContentKeyPolicyPlayReadyConfigurationResponseOutput) Licenses() ContentKeyPolicyPlayReadyLicenseResponseArrayOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyConfigurationResponse) []ContentKeyPolicyPlayReadyLicenseResponse {
		return v.Licenses
	}).(ContentKeyPolicyPlayReadyLicenseResponseArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration'.
func (o ContentKeyPolicyPlayReadyConfigurationResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyConfigurationResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The custom response data.
func (o ContentKeyPolicyPlayReadyConfigurationResponseOutput) ResponseCustomData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyConfigurationResponse) *string { return v.ResponseCustomData }).(pulumi.StringPtrOutput)
}

// Specifies that the content key ID is in the PlayReady header.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader'.
	OdataType string `pulumi:"odataType"`
}

// ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderInput is an input type that accepts ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderArgs and ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput values.
// You can construct a concrete instance of `ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderInput` via:
//
//	ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderArgs{...}
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderInput interface {
	pulumi.Input

	ToContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput() ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput
	ToContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutputWithContext(context.Context) ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput
}

// Specifies that the content key ID is in the PlayReady header.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader)(nil)).Elem()
}

func (i ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderArgs) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput() ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput {
	return i.ToContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutputWithContext(context.Background())
}

func (i ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderArgs) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput)
}

// Specifies that the content key ID is in the PlayReady header.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput() ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader'.
func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies that the content key ID is in the PlayReady header.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader'.
	OdataType string `pulumi:"odataType"`
}

// Specifies that the content key ID is in the PlayReady header.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponse)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponseOutput) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponseOutput() ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponseOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponseOutput) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponseOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader'.
func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies that the content key ID is specified in the PlayReady configuration.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier struct {
	// The content key ID.
	KeyId string `pulumi:"keyId"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'.
	OdataType string `pulumi:"odataType"`
}

// ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierInput is an input type that accepts ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierArgs and ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput values.
// You can construct a concrete instance of `ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierInput` via:
//
//	ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierArgs{...}
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierInput interface {
	pulumi.Input

	ToContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput() ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput
	ToContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutputWithContext(context.Context) ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput
}

// Specifies that the content key ID is specified in the PlayReady configuration.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierArgs struct {
	// The content key ID.
	KeyId pulumi.StringInput `pulumi:"keyId"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier)(nil)).Elem()
}

func (i ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierArgs) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput() ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput {
	return i.ToContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutputWithContext(context.Background())
}

func (i ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierArgs) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput)
}

// Specifies that the content key ID is specified in the PlayReady configuration.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput() ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput {
	return o
}

// The content key ID.
func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) string { return v.KeyId }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'.
func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies that the content key ID is specified in the PlayReady configuration.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponse struct {
	// The content key ID.
	KeyId string `pulumi:"keyId"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'.
	OdataType string `pulumi:"odataType"`
}

// Specifies that the content key ID is specified in the PlayReady configuration.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponse)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponseOutput) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponseOutput() ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponseOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponseOutput) ToContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponseOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponseOutput {
	return o
}

// The content key ID.
func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponseOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponse) string { return v.KeyId }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'.
func (o ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponse) string {
		return v.OdataType
	}).(pulumi.StringOutput)
}

// Configures the Explicit Analog Television Output Restriction control bits. For further details see the PlayReady Compliance Rules.
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction struct {
	// Indicates whether this restriction is enforced on a Best Effort basis.
	BestEffort bool `pulumi:"bestEffort"`
	// Configures the restriction control bits. Must be between 0 and 3 inclusive.
	ConfigurationData int `pulumi:"configurationData"`
}

// ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionInput is an input type that accepts ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs and ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput values.
// You can construct a concrete instance of `ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionInput` via:
//
//	ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs{...}
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionInput interface {
	pulumi.Input

	ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput
	ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutputWithContext(context.Context) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput
}

// Configures the Explicit Analog Television Output Restriction control bits. For further details see the PlayReady Compliance Rules.
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs struct {
	// Indicates whether this restriction is enforced on a Best Effort basis.
	BestEffort pulumi.BoolInput `pulumi:"bestEffort"`
	// Configures the restriction control bits. Must be between 0 and 3 inclusive.
	ConfigurationData pulumi.IntInput `pulumi:"configurationData"`
}

func (ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction)(nil)).Elem()
}

func (i ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput {
	return i.ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutputWithContext(context.Background())
}

func (i ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput)
}

func (i ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput {
	return i.ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutputWithContext(context.Background())
}

func (i ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput).ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutputWithContext(ctx)
}

// ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrInput is an input type that accepts ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs, ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtr and ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput values.
// You can construct a concrete instance of `ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrInput` via:
//
//	        ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs{...}
//
//	or:
//
//	        nil
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrInput interface {
	pulumi.Input

	ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput
	ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutputWithContext(context.Context) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput
}

type contentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrType ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs

func ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtr(v *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionArgs) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrInput {
	return (*contentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrType)(v)
}

func (*contentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction)(nil)).Elem()
}

func (i *contentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrType) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput {
	return i.ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutputWithContext(context.Background())
}

func (i *contentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrType) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput)
}

// Configures the Explicit Analog Television Output Restriction control bits. For further details see the PlayReady Compliance Rules.
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput {
	return o.ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutputWithContext(context.Background())
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction) *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction {
		return &v
	}).(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput)
}

// Indicates whether this restriction is enforced on a Best Effort basis.
func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput) BestEffort() pulumi.BoolOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction) bool { return v.BestEffort }).(pulumi.BoolOutput)
}

// Configures the restriction control bits. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput) ConfigurationData() pulumi.IntOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction) int { return v.ConfigurationData }).(pulumi.IntOutput)
}

type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput) Elem() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction {
		if v != nil {
			return *v
		}
		var ret ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction
		return ret
	}).(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput)
}

// Indicates whether this restriction is enforced on a Best Effort basis.
func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput) BestEffort() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction) *bool {
		if v == nil {
			return nil
		}
		return &v.BestEffort
	}).(pulumi.BoolPtrOutput)
}

// Configures the restriction control bits. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput) ConfigurationData() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction) *int {
		if v == nil {
			return nil
		}
		return &v.ConfigurationData
	}).(pulumi.IntPtrOutput)
}

// Configures the Explicit Analog Television Output Restriction control bits. For further details see the PlayReady Compliance Rules.
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse struct {
	// Indicates whether this restriction is enforced on a Best Effort basis.
	BestEffort bool `pulumi:"bestEffort"`
	// Configures the restriction control bits. Must be between 0 and 3 inclusive.
	ConfigurationData int `pulumi:"configurationData"`
}

// Configures the Explicit Analog Television Output Restriction control bits. For further details see the PlayReady Compliance Rules.
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput {
	return o
}

// Indicates whether this restriction is enforced on a Best Effort basis.
func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput) BestEffort() pulumi.BoolOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse) bool { return v.BestEffort }).(pulumi.BoolOutput)
}

// Configures the restriction control bits. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput) ConfigurationData() pulumi.IntOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse) int {
		return v.ConfigurationData
	}).(pulumi.IntOutput)
}

type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput) ToContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput) Elem() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse) ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse {
		if v != nil {
			return *v
		}
		var ret ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse
		return ret
	}).(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput)
}

// Indicates whether this restriction is enforced on a Best Effort basis.
func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput) BestEffort() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.BestEffort
	}).(pulumi.BoolPtrOutput)
}

// Configures the restriction control bits. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput) ConfigurationData() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse) *int {
		if v == nil {
			return nil
		}
		return &v.ConfigurationData
	}).(pulumi.IntPtrOutput)
}

// The PlayReady license
type ContentKeyPolicyPlayReadyLicense struct {
	// A flag indicating whether test devices can use the license.
	AllowTestDevices bool `pulumi:"allowTestDevices"`
	// The begin date of license
	BeginDate *string `pulumi:"beginDate"`
	// The content key location.
	ContentKeyLocation interface{} `pulumi:"contentKeyLocation"`
	// The PlayReady content type.
	ContentType string `pulumi:"contentType"`
	// The expiration date of license.
	ExpirationDate *string `pulumi:"expirationDate"`
	// The grace period of license.
	GracePeriod *string `pulumi:"gracePeriod"`
	// The license type.
	LicenseType string `pulumi:"licenseType"`
	// The license PlayRight
	PlayRight *ContentKeyPolicyPlayReadyPlayRight `pulumi:"playRight"`
	// The relative begin date of license.
	RelativeBeginDate *string `pulumi:"relativeBeginDate"`
	// The relative expiration date of license.
	RelativeExpirationDate *string `pulumi:"relativeExpirationDate"`
	// The security level.
	SecurityLevel *string `pulumi:"securityLevel"`
}

// ContentKeyPolicyPlayReadyLicenseInput is an input type that accepts ContentKeyPolicyPlayReadyLicenseArgs and ContentKeyPolicyPlayReadyLicenseOutput values.
// You can construct a concrete instance of `ContentKeyPolicyPlayReadyLicenseInput` via:
//
//	ContentKeyPolicyPlayReadyLicenseArgs{...}
type ContentKeyPolicyPlayReadyLicenseInput interface {
	pulumi.Input

	ToContentKeyPolicyPlayReadyLicenseOutput() ContentKeyPolicyPlayReadyLicenseOutput
	ToContentKeyPolicyPlayReadyLicenseOutputWithContext(context.Context) ContentKeyPolicyPlayReadyLicenseOutput
}

// The PlayReady license
type ContentKeyPolicyPlayReadyLicenseArgs struct {
	// A flag indicating whether test devices can use the license.
	AllowTestDevices pulumi.BoolInput `pulumi:"allowTestDevices"`
	// The begin date of license
	BeginDate pulumi.StringPtrInput `pulumi:"beginDate"`
	// The content key location.
	ContentKeyLocation pulumi.Input `pulumi:"contentKeyLocation"`
	// The PlayReady content type.
	ContentType pulumi.StringInput `pulumi:"contentType"`
	// The expiration date of license.
	ExpirationDate pulumi.StringPtrInput `pulumi:"expirationDate"`
	// The grace period of license.
	GracePeriod pulumi.StringPtrInput `pulumi:"gracePeriod"`
	// The license type.
	LicenseType pulumi.StringInput `pulumi:"licenseType"`
	// The license PlayRight
	PlayRight ContentKeyPolicyPlayReadyPlayRightPtrInput `pulumi:"playRight"`
	// The relative begin date of license.
	RelativeBeginDate pulumi.StringPtrInput `pulumi:"relativeBeginDate"`
	// The relative expiration date of license.
	RelativeExpirationDate pulumi.StringPtrInput `pulumi:"relativeExpirationDate"`
	// The security level.
	SecurityLevel pulumi.StringPtrInput `pulumi:"securityLevel"`
}

func (ContentKeyPolicyPlayReadyLicenseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyLicense)(nil)).Elem()
}

func (i ContentKeyPolicyPlayReadyLicenseArgs) ToContentKeyPolicyPlayReadyLicenseOutput() ContentKeyPolicyPlayReadyLicenseOutput {
	return i.ToContentKeyPolicyPlayReadyLicenseOutputWithContext(context.Background())
}

func (i ContentKeyPolicyPlayReadyLicenseArgs) ToContentKeyPolicyPlayReadyLicenseOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyLicenseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyPlayReadyLicenseOutput)
}

// ContentKeyPolicyPlayReadyLicenseArrayInput is an input type that accepts ContentKeyPolicyPlayReadyLicenseArray and ContentKeyPolicyPlayReadyLicenseArrayOutput values.
// You can construct a concrete instance of `ContentKeyPolicyPlayReadyLicenseArrayInput` via:
//
//	ContentKeyPolicyPlayReadyLicenseArray{ ContentKeyPolicyPlayReadyLicenseArgs{...} }
type ContentKeyPolicyPlayReadyLicenseArrayInput interface {
	pulumi.Input

	ToContentKeyPolicyPlayReadyLicenseArrayOutput() ContentKeyPolicyPlayReadyLicenseArrayOutput
	ToContentKeyPolicyPlayReadyLicenseArrayOutputWithContext(context.Context) ContentKeyPolicyPlayReadyLicenseArrayOutput
}

type ContentKeyPolicyPlayReadyLicenseArray []ContentKeyPolicyPlayReadyLicenseInput

func (ContentKeyPolicyPlayReadyLicenseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyPlayReadyLicense)(nil)).Elem()
}

func (i ContentKeyPolicyPlayReadyLicenseArray) ToContentKeyPolicyPlayReadyLicenseArrayOutput() ContentKeyPolicyPlayReadyLicenseArrayOutput {
	return i.ToContentKeyPolicyPlayReadyLicenseArrayOutputWithContext(context.Background())
}

func (i ContentKeyPolicyPlayReadyLicenseArray) ToContentKeyPolicyPlayReadyLicenseArrayOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyLicenseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyPlayReadyLicenseArrayOutput)
}

// The PlayReady license
type ContentKeyPolicyPlayReadyLicenseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyLicenseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyLicense)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyLicenseOutput) ToContentKeyPolicyPlayReadyLicenseOutput() ContentKeyPolicyPlayReadyLicenseOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyLicenseOutput) ToContentKeyPolicyPlayReadyLicenseOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyLicenseOutput {
	return o
}

// A flag indicating whether test devices can use the license.
func (o ContentKeyPolicyPlayReadyLicenseOutput) AllowTestDevices() pulumi.BoolOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicense) bool { return v.AllowTestDevices }).(pulumi.BoolOutput)
}

// The begin date of license
func (o ContentKeyPolicyPlayReadyLicenseOutput) BeginDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicense) *string { return v.BeginDate }).(pulumi.StringPtrOutput)
}

// The content key location.
func (o ContentKeyPolicyPlayReadyLicenseOutput) ContentKeyLocation() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicense) interface{} { return v.ContentKeyLocation }).(pulumi.AnyOutput)
}

// The PlayReady content type.
func (o ContentKeyPolicyPlayReadyLicenseOutput) ContentType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicense) string { return v.ContentType }).(pulumi.StringOutput)
}

// The expiration date of license.
func (o ContentKeyPolicyPlayReadyLicenseOutput) ExpirationDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicense) *string { return v.ExpirationDate }).(pulumi.StringPtrOutput)
}

// The grace period of license.
func (o ContentKeyPolicyPlayReadyLicenseOutput) GracePeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicense) *string { return v.GracePeriod }).(pulumi.StringPtrOutput)
}

// The license type.
func (o ContentKeyPolicyPlayReadyLicenseOutput) LicenseType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicense) string { return v.LicenseType }).(pulumi.StringOutput)
}

// The license PlayRight
func (o ContentKeyPolicyPlayReadyLicenseOutput) PlayRight() ContentKeyPolicyPlayReadyPlayRightPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicense) *ContentKeyPolicyPlayReadyPlayRight { return v.PlayRight }).(ContentKeyPolicyPlayReadyPlayRightPtrOutput)
}

// The relative begin date of license.
func (o ContentKeyPolicyPlayReadyLicenseOutput) RelativeBeginDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicense) *string { return v.RelativeBeginDate }).(pulumi.StringPtrOutput)
}

// The relative expiration date of license.
func (o ContentKeyPolicyPlayReadyLicenseOutput) RelativeExpirationDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicense) *string { return v.RelativeExpirationDate }).(pulumi.StringPtrOutput)
}

// The security level.
func (o ContentKeyPolicyPlayReadyLicenseOutput) SecurityLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicense) *string { return v.SecurityLevel }).(pulumi.StringPtrOutput)
}

type ContentKeyPolicyPlayReadyLicenseArrayOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyLicenseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyPlayReadyLicense)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyLicenseArrayOutput) ToContentKeyPolicyPlayReadyLicenseArrayOutput() ContentKeyPolicyPlayReadyLicenseArrayOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyLicenseArrayOutput) ToContentKeyPolicyPlayReadyLicenseArrayOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyLicenseArrayOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyLicenseArrayOutput) Index(i pulumi.IntInput) ContentKeyPolicyPlayReadyLicenseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentKeyPolicyPlayReadyLicense {
		return vs[0].([]ContentKeyPolicyPlayReadyLicense)[vs[1].(int)]
	}).(ContentKeyPolicyPlayReadyLicenseOutput)
}

// The PlayReady license
type ContentKeyPolicyPlayReadyLicenseResponse struct {
	// A flag indicating whether test devices can use the license.
	AllowTestDevices bool `pulumi:"allowTestDevices"`
	// The begin date of license
	BeginDate *string `pulumi:"beginDate"`
	// The content key location.
	ContentKeyLocation interface{} `pulumi:"contentKeyLocation"`
	// The PlayReady content type.
	ContentType string `pulumi:"contentType"`
	// The expiration date of license.
	ExpirationDate *string `pulumi:"expirationDate"`
	// The grace period of license.
	GracePeriod *string `pulumi:"gracePeriod"`
	// The license type.
	LicenseType string `pulumi:"licenseType"`
	// The license PlayRight
	PlayRight *ContentKeyPolicyPlayReadyPlayRightResponse `pulumi:"playRight"`
	// The relative begin date of license.
	RelativeBeginDate *string `pulumi:"relativeBeginDate"`
	// The relative expiration date of license.
	RelativeExpirationDate *string `pulumi:"relativeExpirationDate"`
	// The security level.
	SecurityLevel *string `pulumi:"securityLevel"`
}

// The PlayReady license
type ContentKeyPolicyPlayReadyLicenseResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyLicenseResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyLicenseResponse)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) ToContentKeyPolicyPlayReadyLicenseResponseOutput() ContentKeyPolicyPlayReadyLicenseResponseOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) ToContentKeyPolicyPlayReadyLicenseResponseOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyLicenseResponseOutput {
	return o
}

// A flag indicating whether test devices can use the license.
func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) AllowTestDevices() pulumi.BoolOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicenseResponse) bool { return v.AllowTestDevices }).(pulumi.BoolOutput)
}

// The begin date of license
func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) BeginDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicenseResponse) *string { return v.BeginDate }).(pulumi.StringPtrOutput)
}

// The content key location.
func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) ContentKeyLocation() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicenseResponse) interface{} { return v.ContentKeyLocation }).(pulumi.AnyOutput)
}

// The PlayReady content type.
func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) ContentType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicenseResponse) string { return v.ContentType }).(pulumi.StringOutput)
}

// The expiration date of license.
func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) ExpirationDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicenseResponse) *string { return v.ExpirationDate }).(pulumi.StringPtrOutput)
}

// The grace period of license.
func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) GracePeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicenseResponse) *string { return v.GracePeriod }).(pulumi.StringPtrOutput)
}

// The license type.
func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) LicenseType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicenseResponse) string { return v.LicenseType }).(pulumi.StringOutput)
}

// The license PlayRight
func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) PlayRight() ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicenseResponse) *ContentKeyPolicyPlayReadyPlayRightResponse {
		return v.PlayRight
	}).(ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput)
}

// The relative begin date of license.
func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) RelativeBeginDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicenseResponse) *string { return v.RelativeBeginDate }).(pulumi.StringPtrOutput)
}

// The relative expiration date of license.
func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) RelativeExpirationDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicenseResponse) *string { return v.RelativeExpirationDate }).(pulumi.StringPtrOutput)
}

// The security level.
func (o ContentKeyPolicyPlayReadyLicenseResponseOutput) SecurityLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyLicenseResponse) *string { return v.SecurityLevel }).(pulumi.StringPtrOutput)
}

type ContentKeyPolicyPlayReadyLicenseResponseArrayOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyLicenseResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyPlayReadyLicenseResponse)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyLicenseResponseArrayOutput) ToContentKeyPolicyPlayReadyLicenseResponseArrayOutput() ContentKeyPolicyPlayReadyLicenseResponseArrayOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyLicenseResponseArrayOutput) ToContentKeyPolicyPlayReadyLicenseResponseArrayOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyLicenseResponseArrayOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyLicenseResponseArrayOutput) Index(i pulumi.IntInput) ContentKeyPolicyPlayReadyLicenseResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentKeyPolicyPlayReadyLicenseResponse {
		return vs[0].([]ContentKeyPolicyPlayReadyLicenseResponse)[vs[1].(int)]
	}).(ContentKeyPolicyPlayReadyLicenseResponseOutput)
}

// Configures the Play Right in the PlayReady license.
type ContentKeyPolicyPlayReadyPlayRight struct {
	// Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
	AgcAndColorStripeRestriction *int `pulumi:"agcAndColorStripeRestriction"`
	// Configures Unknown output handling settings of the license.
	AllowPassingVideoContentToUnknownOutput string `pulumi:"allowPassingVideoContentToUnknownOutput"`
	// Specifies the output protection level for compressed digital audio.
	AnalogVideoOpl *int `pulumi:"analogVideoOpl"`
	// Specifies the output protection level for compressed digital audio.
	CompressedDigitalAudioOpl *int `pulumi:"compressedDigitalAudioOpl"`
	// Specifies the output protection level for compressed digital video.
	CompressedDigitalVideoOpl *int `pulumi:"compressedDigitalVideoOpl"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	DigitalVideoOnlyContentRestriction bool `pulumi:"digitalVideoOnlyContentRestriction"`
	// Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
	ExplicitAnalogTelevisionOutputRestriction *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction `pulumi:"explicitAnalogTelevisionOutputRestriction"`
	// The amount of time that the license is valid after the license is first used to play content.
	FirstPlayExpiration *string `pulumi:"firstPlayExpiration"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComponentVideoRestriction bool `pulumi:"imageConstraintForAnalogComponentVideoRestriction"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComputerMonitorRestriction bool `pulumi:"imageConstraintForAnalogComputerMonitorRestriction"`
	// Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
	ScmsRestriction *int `pulumi:"scmsRestriction"`
	// Specifies the output protection level for uncompressed digital audio.
	UncompressedDigitalAudioOpl *int `pulumi:"uncompressedDigitalAudioOpl"`
	// Specifies the output protection level for uncompressed digital video.
	UncompressedDigitalVideoOpl *int `pulumi:"uncompressedDigitalVideoOpl"`
}

// ContentKeyPolicyPlayReadyPlayRightInput is an input type that accepts ContentKeyPolicyPlayReadyPlayRightArgs and ContentKeyPolicyPlayReadyPlayRightOutput values.
// You can construct a concrete instance of `ContentKeyPolicyPlayReadyPlayRightInput` via:
//
//	ContentKeyPolicyPlayReadyPlayRightArgs{...}
type ContentKeyPolicyPlayReadyPlayRightInput interface {
	pulumi.Input

	ToContentKeyPolicyPlayReadyPlayRightOutput() ContentKeyPolicyPlayReadyPlayRightOutput
	ToContentKeyPolicyPlayReadyPlayRightOutputWithContext(context.Context) ContentKeyPolicyPlayReadyPlayRightOutput
}

// Configures the Play Right in the PlayReady license.
type ContentKeyPolicyPlayReadyPlayRightArgs struct {
	// Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
	AgcAndColorStripeRestriction pulumi.IntPtrInput `pulumi:"agcAndColorStripeRestriction"`
	// Configures Unknown output handling settings of the license.
	AllowPassingVideoContentToUnknownOutput pulumi.StringInput `pulumi:"allowPassingVideoContentToUnknownOutput"`
	// Specifies the output protection level for compressed digital audio.
	AnalogVideoOpl pulumi.IntPtrInput `pulumi:"analogVideoOpl"`
	// Specifies the output protection level for compressed digital audio.
	CompressedDigitalAudioOpl pulumi.IntPtrInput `pulumi:"compressedDigitalAudioOpl"`
	// Specifies the output protection level for compressed digital video.
	CompressedDigitalVideoOpl pulumi.IntPtrInput `pulumi:"compressedDigitalVideoOpl"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	DigitalVideoOnlyContentRestriction pulumi.BoolInput `pulumi:"digitalVideoOnlyContentRestriction"`
	// Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
	ExplicitAnalogTelevisionOutputRestriction ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrInput `pulumi:"explicitAnalogTelevisionOutputRestriction"`
	// The amount of time that the license is valid after the license is first used to play content.
	FirstPlayExpiration pulumi.StringPtrInput `pulumi:"firstPlayExpiration"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComponentVideoRestriction pulumi.BoolInput `pulumi:"imageConstraintForAnalogComponentVideoRestriction"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComputerMonitorRestriction pulumi.BoolInput `pulumi:"imageConstraintForAnalogComputerMonitorRestriction"`
	// Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
	ScmsRestriction pulumi.IntPtrInput `pulumi:"scmsRestriction"`
	// Specifies the output protection level for uncompressed digital audio.
	UncompressedDigitalAudioOpl pulumi.IntPtrInput `pulumi:"uncompressedDigitalAudioOpl"`
	// Specifies the output protection level for uncompressed digital video.
	UncompressedDigitalVideoOpl pulumi.IntPtrInput `pulumi:"uncompressedDigitalVideoOpl"`
}

func (ContentKeyPolicyPlayReadyPlayRightArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyPlayRight)(nil)).Elem()
}

func (i ContentKeyPolicyPlayReadyPlayRightArgs) ToContentKeyPolicyPlayReadyPlayRightOutput() ContentKeyPolicyPlayReadyPlayRightOutput {
	return i.ToContentKeyPolicyPlayReadyPlayRightOutputWithContext(context.Background())
}

func (i ContentKeyPolicyPlayReadyPlayRightArgs) ToContentKeyPolicyPlayReadyPlayRightOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyPlayRightOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyPlayReadyPlayRightOutput)
}

func (i ContentKeyPolicyPlayReadyPlayRightArgs) ToContentKeyPolicyPlayReadyPlayRightPtrOutput() ContentKeyPolicyPlayReadyPlayRightPtrOutput {
	return i.ToContentKeyPolicyPlayReadyPlayRightPtrOutputWithContext(context.Background())
}

func (i ContentKeyPolicyPlayReadyPlayRightArgs) ToContentKeyPolicyPlayReadyPlayRightPtrOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyPlayRightPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyPlayReadyPlayRightOutput).ToContentKeyPolicyPlayReadyPlayRightPtrOutputWithContext(ctx)
}

// ContentKeyPolicyPlayReadyPlayRightPtrInput is an input type that accepts ContentKeyPolicyPlayReadyPlayRightArgs, ContentKeyPolicyPlayReadyPlayRightPtr and ContentKeyPolicyPlayReadyPlayRightPtrOutput values.
// You can construct a concrete instance of `ContentKeyPolicyPlayReadyPlayRightPtrInput` via:
//
//	        ContentKeyPolicyPlayReadyPlayRightArgs{...}
//
//	or:
//
//	        nil
type ContentKeyPolicyPlayReadyPlayRightPtrInput interface {
	pulumi.Input

	ToContentKeyPolicyPlayReadyPlayRightPtrOutput() ContentKeyPolicyPlayReadyPlayRightPtrOutput
	ToContentKeyPolicyPlayReadyPlayRightPtrOutputWithContext(context.Context) ContentKeyPolicyPlayReadyPlayRightPtrOutput
}

type contentKeyPolicyPlayReadyPlayRightPtrType ContentKeyPolicyPlayReadyPlayRightArgs

func ContentKeyPolicyPlayReadyPlayRightPtr(v *ContentKeyPolicyPlayReadyPlayRightArgs) ContentKeyPolicyPlayReadyPlayRightPtrInput {
	return (*contentKeyPolicyPlayReadyPlayRightPtrType)(v)
}

func (*contentKeyPolicyPlayReadyPlayRightPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContentKeyPolicyPlayReadyPlayRight)(nil)).Elem()
}

func (i *contentKeyPolicyPlayReadyPlayRightPtrType) ToContentKeyPolicyPlayReadyPlayRightPtrOutput() ContentKeyPolicyPlayReadyPlayRightPtrOutput {
	return i.ToContentKeyPolicyPlayReadyPlayRightPtrOutputWithContext(context.Background())
}

func (i *contentKeyPolicyPlayReadyPlayRightPtrType) ToContentKeyPolicyPlayReadyPlayRightPtrOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyPlayRightPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyPlayReadyPlayRightPtrOutput)
}

// Configures the Play Right in the PlayReady license.
type ContentKeyPolicyPlayReadyPlayRightOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyPlayRightOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyPlayRight)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyPlayRightOutput) ToContentKeyPolicyPlayReadyPlayRightOutput() ContentKeyPolicyPlayReadyPlayRightOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyPlayRightOutput) ToContentKeyPolicyPlayReadyPlayRightOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyPlayRightOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyPlayRightOutput) ToContentKeyPolicyPlayReadyPlayRightPtrOutput() ContentKeyPolicyPlayReadyPlayRightPtrOutput {
	return o.ToContentKeyPolicyPlayReadyPlayRightPtrOutputWithContext(context.Background())
}

func (o ContentKeyPolicyPlayReadyPlayRightOutput) ToContentKeyPolicyPlayReadyPlayRightPtrOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyPlayRightPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContentKeyPolicyPlayReadyPlayRight) *ContentKeyPolicyPlayReadyPlayRight {
		return &v
	}).(ContentKeyPolicyPlayReadyPlayRightPtrOutput)
}

// Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) AgcAndColorStripeRestriction() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) *int { return v.AgcAndColorStripeRestriction }).(pulumi.IntPtrOutput)
}

// Configures Unknown output handling settings of the license.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) AllowPassingVideoContentToUnknownOutput() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) string { return v.AllowPassingVideoContentToUnknownOutput }).(pulumi.StringOutput)
}

// Specifies the output protection level for compressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) AnalogVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) *int { return v.AnalogVideoOpl }).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for compressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) CompressedDigitalAudioOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) *int { return v.CompressedDigitalAudioOpl }).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for compressed digital video.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) CompressedDigitalVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) *int { return v.CompressedDigitalVideoOpl }).(pulumi.IntPtrOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) DigitalVideoOnlyContentRestriction() pulumi.BoolOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) bool { return v.DigitalVideoOnlyContentRestriction }).(pulumi.BoolOutput)
}

// Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) ExplicitAnalogTelevisionOutputRestriction() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction {
		return v.ExplicitAnalogTelevisionOutputRestriction
	}).(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput)
}

// The amount of time that the license is valid after the license is first used to play content.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) FirstPlayExpiration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) *string { return v.FirstPlayExpiration }).(pulumi.StringPtrOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) ImageConstraintForAnalogComponentVideoRestriction() pulumi.BoolOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) bool {
		return v.ImageConstraintForAnalogComponentVideoRestriction
	}).(pulumi.BoolOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) ImageConstraintForAnalogComputerMonitorRestriction() pulumi.BoolOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) bool {
		return v.ImageConstraintForAnalogComputerMonitorRestriction
	}).(pulumi.BoolOutput)
}

// Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) ScmsRestriction() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) *int { return v.ScmsRestriction }).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for uncompressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) UncompressedDigitalAudioOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) *int { return v.UncompressedDigitalAudioOpl }).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for uncompressed digital video.
func (o ContentKeyPolicyPlayReadyPlayRightOutput) UncompressedDigitalVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRight) *int { return v.UncompressedDigitalVideoOpl }).(pulumi.IntPtrOutput)
}

type ContentKeyPolicyPlayReadyPlayRightPtrOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyPlayRightPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContentKeyPolicyPlayReadyPlayRight)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) ToContentKeyPolicyPlayReadyPlayRightPtrOutput() ContentKeyPolicyPlayReadyPlayRightPtrOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) ToContentKeyPolicyPlayReadyPlayRightPtrOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyPlayRightPtrOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) Elem() ContentKeyPolicyPlayReadyPlayRightOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) ContentKeyPolicyPlayReadyPlayRight {
		if v != nil {
			return *v
		}
		var ret ContentKeyPolicyPlayReadyPlayRight
		return ret
	}).(ContentKeyPolicyPlayReadyPlayRightOutput)
}

// Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) AgcAndColorStripeRestriction() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *int {
		if v == nil {
			return nil
		}
		return v.AgcAndColorStripeRestriction
	}).(pulumi.IntPtrOutput)
}

// Configures Unknown output handling settings of the license.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) AllowPassingVideoContentToUnknownOutput() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *string {
		if v == nil {
			return nil
		}
		return &v.AllowPassingVideoContentToUnknownOutput
	}).(pulumi.StringPtrOutput)
}

// Specifies the output protection level for compressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) AnalogVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *int {
		if v == nil {
			return nil
		}
		return v.AnalogVideoOpl
	}).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for compressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) CompressedDigitalAudioOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *int {
		if v == nil {
			return nil
		}
		return v.CompressedDigitalAudioOpl
	}).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for compressed digital video.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) CompressedDigitalVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *int {
		if v == nil {
			return nil
		}
		return v.CompressedDigitalVideoOpl
	}).(pulumi.IntPtrOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) DigitalVideoOnlyContentRestriction() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *bool {
		if v == nil {
			return nil
		}
		return &v.DigitalVideoOnlyContentRestriction
	}).(pulumi.BoolPtrOutput)
}

// Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) ExplicitAnalogTelevisionOutputRestriction() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction {
		if v == nil {
			return nil
		}
		return v.ExplicitAnalogTelevisionOutputRestriction
	}).(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput)
}

// The amount of time that the license is valid after the license is first used to play content.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) FirstPlayExpiration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *string {
		if v == nil {
			return nil
		}
		return v.FirstPlayExpiration
	}).(pulumi.StringPtrOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) ImageConstraintForAnalogComponentVideoRestriction() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *bool {
		if v == nil {
			return nil
		}
		return &v.ImageConstraintForAnalogComponentVideoRestriction
	}).(pulumi.BoolPtrOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) ImageConstraintForAnalogComputerMonitorRestriction() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *bool {
		if v == nil {
			return nil
		}
		return &v.ImageConstraintForAnalogComputerMonitorRestriction
	}).(pulumi.BoolPtrOutput)
}

// Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) ScmsRestriction() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *int {
		if v == nil {
			return nil
		}
		return v.ScmsRestriction
	}).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for uncompressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) UncompressedDigitalAudioOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *int {
		if v == nil {
			return nil
		}
		return v.UncompressedDigitalAudioOpl
	}).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for uncompressed digital video.
func (o ContentKeyPolicyPlayReadyPlayRightPtrOutput) UncompressedDigitalVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRight) *int {
		if v == nil {
			return nil
		}
		return v.UncompressedDigitalVideoOpl
	}).(pulumi.IntPtrOutput)
}

// Configures the Play Right in the PlayReady license.
type ContentKeyPolicyPlayReadyPlayRightResponse struct {
	// Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
	AgcAndColorStripeRestriction *int `pulumi:"agcAndColorStripeRestriction"`
	// Configures Unknown output handling settings of the license.
	AllowPassingVideoContentToUnknownOutput string `pulumi:"allowPassingVideoContentToUnknownOutput"`
	// Specifies the output protection level for compressed digital audio.
	AnalogVideoOpl *int `pulumi:"analogVideoOpl"`
	// Specifies the output protection level for compressed digital audio.
	CompressedDigitalAudioOpl *int `pulumi:"compressedDigitalAudioOpl"`
	// Specifies the output protection level for compressed digital video.
	CompressedDigitalVideoOpl *int `pulumi:"compressedDigitalVideoOpl"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	DigitalVideoOnlyContentRestriction bool `pulumi:"digitalVideoOnlyContentRestriction"`
	// Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
	ExplicitAnalogTelevisionOutputRestriction *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse `pulumi:"explicitAnalogTelevisionOutputRestriction"`
	// The amount of time that the license is valid after the license is first used to play content.
	FirstPlayExpiration *string `pulumi:"firstPlayExpiration"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComponentVideoRestriction bool `pulumi:"imageConstraintForAnalogComponentVideoRestriction"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComputerMonitorRestriction bool `pulumi:"imageConstraintForAnalogComputerMonitorRestriction"`
	// Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
	ScmsRestriction *int `pulumi:"scmsRestriction"`
	// Specifies the output protection level for uncompressed digital audio.
	UncompressedDigitalAudioOpl *int `pulumi:"uncompressedDigitalAudioOpl"`
	// Specifies the output protection level for uncompressed digital video.
	UncompressedDigitalVideoOpl *int `pulumi:"uncompressedDigitalVideoOpl"`
}

// Configures the Play Right in the PlayReady license.
type ContentKeyPolicyPlayReadyPlayRightResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyPlayRightResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyPlayReadyPlayRightResponse)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) ToContentKeyPolicyPlayReadyPlayRightResponseOutput() ContentKeyPolicyPlayReadyPlayRightResponseOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) ToContentKeyPolicyPlayReadyPlayRightResponseOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyPlayRightResponseOutput {
	return o
}

// Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) AgcAndColorStripeRestriction() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) *int { return v.AgcAndColorStripeRestriction }).(pulumi.IntPtrOutput)
}

// Configures Unknown output handling settings of the license.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) AllowPassingVideoContentToUnknownOutput() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) string {
		return v.AllowPassingVideoContentToUnknownOutput
	}).(pulumi.StringOutput)
}

// Specifies the output protection level for compressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) AnalogVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) *int { return v.AnalogVideoOpl }).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for compressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) CompressedDigitalAudioOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) *int { return v.CompressedDigitalAudioOpl }).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for compressed digital video.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) CompressedDigitalVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) *int { return v.CompressedDigitalVideoOpl }).(pulumi.IntPtrOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) DigitalVideoOnlyContentRestriction() pulumi.BoolOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) bool { return v.DigitalVideoOnlyContentRestriction }).(pulumi.BoolOutput)
}

// Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) ExplicitAnalogTelevisionOutputRestriction() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse {
		return v.ExplicitAnalogTelevisionOutputRestriction
	}).(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput)
}

// The amount of time that the license is valid after the license is first used to play content.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) FirstPlayExpiration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) *string { return v.FirstPlayExpiration }).(pulumi.StringPtrOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) ImageConstraintForAnalogComponentVideoRestriction() pulumi.BoolOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) bool {
		return v.ImageConstraintForAnalogComponentVideoRestriction
	}).(pulumi.BoolOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) ImageConstraintForAnalogComputerMonitorRestriction() pulumi.BoolOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) bool {
		return v.ImageConstraintForAnalogComputerMonitorRestriction
	}).(pulumi.BoolOutput)
}

// Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) ScmsRestriction() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) *int { return v.ScmsRestriction }).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for uncompressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) UncompressedDigitalAudioOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) *int { return v.UncompressedDigitalAudioOpl }).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for uncompressed digital video.
func (o ContentKeyPolicyPlayReadyPlayRightResponseOutput) UncompressedDigitalVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyPlayReadyPlayRightResponse) *int { return v.UncompressedDigitalVideoOpl }).(pulumi.IntPtrOutput)
}

type ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContentKeyPolicyPlayReadyPlayRightResponse)(nil)).Elem()
}

func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) ToContentKeyPolicyPlayReadyPlayRightResponsePtrOutput() ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) ToContentKeyPolicyPlayReadyPlayRightResponsePtrOutputWithContext(ctx context.Context) ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput {
	return o
}

func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) Elem() ContentKeyPolicyPlayReadyPlayRightResponseOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) ContentKeyPolicyPlayReadyPlayRightResponse {
		if v != nil {
			return *v
		}
		var ret ContentKeyPolicyPlayReadyPlayRightResponse
		return ret
	}).(ContentKeyPolicyPlayReadyPlayRightResponseOutput)
}

// Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) AgcAndColorStripeRestriction() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *int {
		if v == nil {
			return nil
		}
		return v.AgcAndColorStripeRestriction
	}).(pulumi.IntPtrOutput)
}

// Configures Unknown output handling settings of the license.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) AllowPassingVideoContentToUnknownOutput() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *string {
		if v == nil {
			return nil
		}
		return &v.AllowPassingVideoContentToUnknownOutput
	}).(pulumi.StringPtrOutput)
}

// Specifies the output protection level for compressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) AnalogVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *int {
		if v == nil {
			return nil
		}
		return v.AnalogVideoOpl
	}).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for compressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) CompressedDigitalAudioOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *int {
		if v == nil {
			return nil
		}
		return v.CompressedDigitalAudioOpl
	}).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for compressed digital video.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) CompressedDigitalVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *int {
		if v == nil {
			return nil
		}
		return v.CompressedDigitalVideoOpl
	}).(pulumi.IntPtrOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) DigitalVideoOnlyContentRestriction() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.DigitalVideoOnlyContentRestriction
	}).(pulumi.BoolPtrOutput)
}

// Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) ExplicitAnalogTelevisionOutputRestriction() ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse {
		if v == nil {
			return nil
		}
		return v.ExplicitAnalogTelevisionOutputRestriction
	}).(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput)
}

// The amount of time that the license is valid after the license is first used to play content.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) FirstPlayExpiration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *string {
		if v == nil {
			return nil
		}
		return v.FirstPlayExpiration
	}).(pulumi.StringPtrOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) ImageConstraintForAnalogComponentVideoRestriction() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.ImageConstraintForAnalogComponentVideoRestriction
	}).(pulumi.BoolPtrOutput)
}

// Enables the Image Constraint For Analog Component Video Restriction in the license.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) ImageConstraintForAnalogComputerMonitorRestriction() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.ImageConstraintForAnalogComputerMonitorRestriction
	}).(pulumi.BoolPtrOutput)
}

// Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) ScmsRestriction() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *int {
		if v == nil {
			return nil
		}
		return v.ScmsRestriction
	}).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for uncompressed digital audio.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) UncompressedDigitalAudioOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *int {
		if v == nil {
			return nil
		}
		return v.UncompressedDigitalAudioOpl
	}).(pulumi.IntPtrOutput)
}

// Specifies the output protection level for uncompressed digital video.
func (o ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput) UncompressedDigitalVideoOpl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContentKeyPolicyPlayReadyPlayRightResponse) *int {
		if v == nil {
			return nil
		}
		return v.UncompressedDigitalVideoOpl
	}).(pulumi.IntPtrOutput)
}

// Specifies a RSA key for token validation
type ContentKeyPolicyRsaTokenKey struct {
	// The RSA Parameter exponent
	Exponent string `pulumi:"exponent"`
	// The RSA Parameter modulus
	Modulus string `pulumi:"modulus"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyRsaTokenKey'.
	OdataType string `pulumi:"odataType"`
}

// ContentKeyPolicyRsaTokenKeyInput is an input type that accepts ContentKeyPolicyRsaTokenKeyArgs and ContentKeyPolicyRsaTokenKeyOutput values.
// You can construct a concrete instance of `ContentKeyPolicyRsaTokenKeyInput` via:
//
//	ContentKeyPolicyRsaTokenKeyArgs{...}
type ContentKeyPolicyRsaTokenKeyInput interface {
	pulumi.Input

	ToContentKeyPolicyRsaTokenKeyOutput() ContentKeyPolicyRsaTokenKeyOutput
	ToContentKeyPolicyRsaTokenKeyOutputWithContext(context.Context) ContentKeyPolicyRsaTokenKeyOutput
}

// Specifies a RSA key for token validation
type ContentKeyPolicyRsaTokenKeyArgs struct {
	// The RSA Parameter exponent
	Exponent pulumi.StringInput `pulumi:"exponent"`
	// The RSA Parameter modulus
	Modulus pulumi.StringInput `pulumi:"modulus"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyRsaTokenKey'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (ContentKeyPolicyRsaTokenKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyRsaTokenKey)(nil)).Elem()
}

func (i ContentKeyPolicyRsaTokenKeyArgs) ToContentKeyPolicyRsaTokenKeyOutput() ContentKeyPolicyRsaTokenKeyOutput {
	return i.ToContentKeyPolicyRsaTokenKeyOutputWithContext(context.Background())
}

func (i ContentKeyPolicyRsaTokenKeyArgs) ToContentKeyPolicyRsaTokenKeyOutputWithContext(ctx context.Context) ContentKeyPolicyRsaTokenKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyRsaTokenKeyOutput)
}

// Specifies a RSA key for token validation
type ContentKeyPolicyRsaTokenKeyOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyRsaTokenKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyRsaTokenKey)(nil)).Elem()
}

func (o ContentKeyPolicyRsaTokenKeyOutput) ToContentKeyPolicyRsaTokenKeyOutput() ContentKeyPolicyRsaTokenKeyOutput {
	return o
}

func (o ContentKeyPolicyRsaTokenKeyOutput) ToContentKeyPolicyRsaTokenKeyOutputWithContext(ctx context.Context) ContentKeyPolicyRsaTokenKeyOutput {
	return o
}

// The RSA Parameter exponent
func (o ContentKeyPolicyRsaTokenKeyOutput) Exponent() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyRsaTokenKey) string { return v.Exponent }).(pulumi.StringOutput)
}

// The RSA Parameter modulus
func (o ContentKeyPolicyRsaTokenKeyOutput) Modulus() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyRsaTokenKey) string { return v.Modulus }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyRsaTokenKey'.
func (o ContentKeyPolicyRsaTokenKeyOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyRsaTokenKey) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies a RSA key for token validation
type ContentKeyPolicyRsaTokenKeyResponse struct {
	// The RSA Parameter exponent
	Exponent string `pulumi:"exponent"`
	// The RSA Parameter modulus
	Modulus string `pulumi:"modulus"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyRsaTokenKey'.
	OdataType string `pulumi:"odataType"`
}

// Specifies a RSA key for token validation
type ContentKeyPolicyRsaTokenKeyResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyRsaTokenKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyRsaTokenKeyResponse)(nil)).Elem()
}

func (o ContentKeyPolicyRsaTokenKeyResponseOutput) ToContentKeyPolicyRsaTokenKeyResponseOutput() ContentKeyPolicyRsaTokenKeyResponseOutput {
	return o
}

func (o ContentKeyPolicyRsaTokenKeyResponseOutput) ToContentKeyPolicyRsaTokenKeyResponseOutputWithContext(ctx context.Context) ContentKeyPolicyRsaTokenKeyResponseOutput {
	return o
}

// The RSA Parameter exponent
func (o ContentKeyPolicyRsaTokenKeyResponseOutput) Exponent() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyRsaTokenKeyResponse) string { return v.Exponent }).(pulumi.StringOutput)
}

// The RSA Parameter modulus
func (o ContentKeyPolicyRsaTokenKeyResponseOutput) Modulus() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyRsaTokenKeyResponse) string { return v.Modulus }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyRsaTokenKey'.
func (o ContentKeyPolicyRsaTokenKeyResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyRsaTokenKeyResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies a symmetric key for token validation.
type ContentKeyPolicySymmetricTokenKey struct {
	// The key value of the key
	KeyValue string `pulumi:"keyValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicySymmetricTokenKey'.
	OdataType string `pulumi:"odataType"`
}

// ContentKeyPolicySymmetricTokenKeyInput is an input type that accepts ContentKeyPolicySymmetricTokenKeyArgs and ContentKeyPolicySymmetricTokenKeyOutput values.
// You can construct a concrete instance of `ContentKeyPolicySymmetricTokenKeyInput` via:
//
//	ContentKeyPolicySymmetricTokenKeyArgs{...}
type ContentKeyPolicySymmetricTokenKeyInput interface {
	pulumi.Input

	ToContentKeyPolicySymmetricTokenKeyOutput() ContentKeyPolicySymmetricTokenKeyOutput
	ToContentKeyPolicySymmetricTokenKeyOutputWithContext(context.Context) ContentKeyPolicySymmetricTokenKeyOutput
}

// Specifies a symmetric key for token validation.
type ContentKeyPolicySymmetricTokenKeyArgs struct {
	// The key value of the key
	KeyValue pulumi.StringInput `pulumi:"keyValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicySymmetricTokenKey'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (ContentKeyPolicySymmetricTokenKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicySymmetricTokenKey)(nil)).Elem()
}

func (i ContentKeyPolicySymmetricTokenKeyArgs) ToContentKeyPolicySymmetricTokenKeyOutput() ContentKeyPolicySymmetricTokenKeyOutput {
	return i.ToContentKeyPolicySymmetricTokenKeyOutputWithContext(context.Background())
}

func (i ContentKeyPolicySymmetricTokenKeyArgs) ToContentKeyPolicySymmetricTokenKeyOutputWithContext(ctx context.Context) ContentKeyPolicySymmetricTokenKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicySymmetricTokenKeyOutput)
}

// Specifies a symmetric key for token validation.
type ContentKeyPolicySymmetricTokenKeyOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicySymmetricTokenKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicySymmetricTokenKey)(nil)).Elem()
}

func (o ContentKeyPolicySymmetricTokenKeyOutput) ToContentKeyPolicySymmetricTokenKeyOutput() ContentKeyPolicySymmetricTokenKeyOutput {
	return o
}

func (o ContentKeyPolicySymmetricTokenKeyOutput) ToContentKeyPolicySymmetricTokenKeyOutputWithContext(ctx context.Context) ContentKeyPolicySymmetricTokenKeyOutput {
	return o
}

// The key value of the key
func (o ContentKeyPolicySymmetricTokenKeyOutput) KeyValue() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicySymmetricTokenKey) string { return v.KeyValue }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicySymmetricTokenKey'.
func (o ContentKeyPolicySymmetricTokenKeyOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicySymmetricTokenKey) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies a symmetric key for token validation.
type ContentKeyPolicySymmetricTokenKeyResponse struct {
	// The key value of the key
	KeyValue string `pulumi:"keyValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicySymmetricTokenKey'.
	OdataType string `pulumi:"odataType"`
}

// Specifies a symmetric key for token validation.
type ContentKeyPolicySymmetricTokenKeyResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicySymmetricTokenKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicySymmetricTokenKeyResponse)(nil)).Elem()
}

func (o ContentKeyPolicySymmetricTokenKeyResponseOutput) ToContentKeyPolicySymmetricTokenKeyResponseOutput() ContentKeyPolicySymmetricTokenKeyResponseOutput {
	return o
}

func (o ContentKeyPolicySymmetricTokenKeyResponseOutput) ToContentKeyPolicySymmetricTokenKeyResponseOutputWithContext(ctx context.Context) ContentKeyPolicySymmetricTokenKeyResponseOutput {
	return o
}

// The key value of the key
func (o ContentKeyPolicySymmetricTokenKeyResponseOutput) KeyValue() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicySymmetricTokenKeyResponse) string { return v.KeyValue }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicySymmetricTokenKey'.
func (o ContentKeyPolicySymmetricTokenKeyResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicySymmetricTokenKeyResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Represents a token claim.
type ContentKeyPolicyTokenClaim struct {
	// Token claim type.
	ClaimType *string `pulumi:"claimType"`
	// Token claim value.
	ClaimValue *string `pulumi:"claimValue"`
}

// ContentKeyPolicyTokenClaimInput is an input type that accepts ContentKeyPolicyTokenClaimArgs and ContentKeyPolicyTokenClaimOutput values.
// You can construct a concrete instance of `ContentKeyPolicyTokenClaimInput` via:
//
//	ContentKeyPolicyTokenClaimArgs{...}
type ContentKeyPolicyTokenClaimInput interface {
	pulumi.Input

	ToContentKeyPolicyTokenClaimOutput() ContentKeyPolicyTokenClaimOutput
	ToContentKeyPolicyTokenClaimOutputWithContext(context.Context) ContentKeyPolicyTokenClaimOutput
}

// Represents a token claim.
type ContentKeyPolicyTokenClaimArgs struct {
	// Token claim type.
	ClaimType pulumi.StringPtrInput `pulumi:"claimType"`
	// Token claim value.
	ClaimValue pulumi.StringPtrInput `pulumi:"claimValue"`
}

func (ContentKeyPolicyTokenClaimArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyTokenClaim)(nil)).Elem()
}

func (i ContentKeyPolicyTokenClaimArgs) ToContentKeyPolicyTokenClaimOutput() ContentKeyPolicyTokenClaimOutput {
	return i.ToContentKeyPolicyTokenClaimOutputWithContext(context.Background())
}

func (i ContentKeyPolicyTokenClaimArgs) ToContentKeyPolicyTokenClaimOutputWithContext(ctx context.Context) ContentKeyPolicyTokenClaimOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyTokenClaimOutput)
}

// ContentKeyPolicyTokenClaimArrayInput is an input type that accepts ContentKeyPolicyTokenClaimArray and ContentKeyPolicyTokenClaimArrayOutput values.
// You can construct a concrete instance of `ContentKeyPolicyTokenClaimArrayInput` via:
//
//	ContentKeyPolicyTokenClaimArray{ ContentKeyPolicyTokenClaimArgs{...} }
type ContentKeyPolicyTokenClaimArrayInput interface {
	pulumi.Input

	ToContentKeyPolicyTokenClaimArrayOutput() ContentKeyPolicyTokenClaimArrayOutput
	ToContentKeyPolicyTokenClaimArrayOutputWithContext(context.Context) ContentKeyPolicyTokenClaimArrayOutput
}

type ContentKeyPolicyTokenClaimArray []ContentKeyPolicyTokenClaimInput

func (ContentKeyPolicyTokenClaimArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyTokenClaim)(nil)).Elem()
}

func (i ContentKeyPolicyTokenClaimArray) ToContentKeyPolicyTokenClaimArrayOutput() ContentKeyPolicyTokenClaimArrayOutput {
	return i.ToContentKeyPolicyTokenClaimArrayOutputWithContext(context.Background())
}

func (i ContentKeyPolicyTokenClaimArray) ToContentKeyPolicyTokenClaimArrayOutputWithContext(ctx context.Context) ContentKeyPolicyTokenClaimArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyTokenClaimArrayOutput)
}

// Represents a token claim.
type ContentKeyPolicyTokenClaimOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyTokenClaimOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyTokenClaim)(nil)).Elem()
}

func (o ContentKeyPolicyTokenClaimOutput) ToContentKeyPolicyTokenClaimOutput() ContentKeyPolicyTokenClaimOutput {
	return o
}

func (o ContentKeyPolicyTokenClaimOutput) ToContentKeyPolicyTokenClaimOutputWithContext(ctx context.Context) ContentKeyPolicyTokenClaimOutput {
	return o
}

// Token claim type.
func (o ContentKeyPolicyTokenClaimOutput) ClaimType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenClaim) *string { return v.ClaimType }).(pulumi.StringPtrOutput)
}

// Token claim value.
func (o ContentKeyPolicyTokenClaimOutput) ClaimValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenClaim) *string { return v.ClaimValue }).(pulumi.StringPtrOutput)
}

type ContentKeyPolicyTokenClaimArrayOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyTokenClaimArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyTokenClaim)(nil)).Elem()
}

func (o ContentKeyPolicyTokenClaimArrayOutput) ToContentKeyPolicyTokenClaimArrayOutput() ContentKeyPolicyTokenClaimArrayOutput {
	return o
}

func (o ContentKeyPolicyTokenClaimArrayOutput) ToContentKeyPolicyTokenClaimArrayOutputWithContext(ctx context.Context) ContentKeyPolicyTokenClaimArrayOutput {
	return o
}

func (o ContentKeyPolicyTokenClaimArrayOutput) Index(i pulumi.IntInput) ContentKeyPolicyTokenClaimOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentKeyPolicyTokenClaim {
		return vs[0].([]ContentKeyPolicyTokenClaim)[vs[1].(int)]
	}).(ContentKeyPolicyTokenClaimOutput)
}

// Represents a token claim.
type ContentKeyPolicyTokenClaimResponse struct {
	// Token claim type.
	ClaimType *string `pulumi:"claimType"`
	// Token claim value.
	ClaimValue *string `pulumi:"claimValue"`
}

// Represents a token claim.
type ContentKeyPolicyTokenClaimResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyTokenClaimResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyTokenClaimResponse)(nil)).Elem()
}

func (o ContentKeyPolicyTokenClaimResponseOutput) ToContentKeyPolicyTokenClaimResponseOutput() ContentKeyPolicyTokenClaimResponseOutput {
	return o
}

func (o ContentKeyPolicyTokenClaimResponseOutput) ToContentKeyPolicyTokenClaimResponseOutputWithContext(ctx context.Context) ContentKeyPolicyTokenClaimResponseOutput {
	return o
}

// Token claim type.
func (o ContentKeyPolicyTokenClaimResponseOutput) ClaimType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenClaimResponse) *string { return v.ClaimType }).(pulumi.StringPtrOutput)
}

// Token claim value.
func (o ContentKeyPolicyTokenClaimResponseOutput) ClaimValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenClaimResponse) *string { return v.ClaimValue }).(pulumi.StringPtrOutput)
}

type ContentKeyPolicyTokenClaimResponseArrayOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyTokenClaimResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyTokenClaimResponse)(nil)).Elem()
}

func (o ContentKeyPolicyTokenClaimResponseArrayOutput) ToContentKeyPolicyTokenClaimResponseArrayOutput() ContentKeyPolicyTokenClaimResponseArrayOutput {
	return o
}

func (o ContentKeyPolicyTokenClaimResponseArrayOutput) ToContentKeyPolicyTokenClaimResponseArrayOutputWithContext(ctx context.Context) ContentKeyPolicyTokenClaimResponseArrayOutput {
	return o
}

func (o ContentKeyPolicyTokenClaimResponseArrayOutput) Index(i pulumi.IntInput) ContentKeyPolicyTokenClaimResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentKeyPolicyTokenClaimResponse {
		return vs[0].([]ContentKeyPolicyTokenClaimResponse)[vs[1].(int)]
	}).(ContentKeyPolicyTokenClaimResponseOutput)
}

// Represents a token restriction. Provided token must match these requirements for successful license or key delivery.
type ContentKeyPolicyTokenRestriction struct {
	// A list of alternative verification keys.
	AlternateVerificationKeys []interface{} `pulumi:"alternateVerificationKeys"`
	// The audience for the token.
	Audience string `pulumi:"audience"`
	// The token issuer.
	Issuer string `pulumi:"issuer"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyTokenRestriction'.
	OdataType string `pulumi:"odataType"`
	// The OpenID connect discovery document.
	OpenIdConnectDiscoveryDocument *string `pulumi:"openIdConnectDiscoveryDocument"`
	// The primary verification key.
	PrimaryVerificationKey interface{} `pulumi:"primaryVerificationKey"`
	// A list of required token claims.
	RequiredClaims []ContentKeyPolicyTokenClaim `pulumi:"requiredClaims"`
	// The type of token.
	RestrictionTokenType string `pulumi:"restrictionTokenType"`
}

// ContentKeyPolicyTokenRestrictionInput is an input type that accepts ContentKeyPolicyTokenRestrictionArgs and ContentKeyPolicyTokenRestrictionOutput values.
// You can construct a concrete instance of `ContentKeyPolicyTokenRestrictionInput` via:
//
//	ContentKeyPolicyTokenRestrictionArgs{...}
type ContentKeyPolicyTokenRestrictionInput interface {
	pulumi.Input

	ToContentKeyPolicyTokenRestrictionOutput() ContentKeyPolicyTokenRestrictionOutput
	ToContentKeyPolicyTokenRestrictionOutputWithContext(context.Context) ContentKeyPolicyTokenRestrictionOutput
}

// Represents a token restriction. Provided token must match these requirements for successful license or key delivery.
type ContentKeyPolicyTokenRestrictionArgs struct {
	// A list of alternative verification keys.
	AlternateVerificationKeys pulumi.ArrayInput `pulumi:"alternateVerificationKeys"`
	// The audience for the token.
	Audience pulumi.StringInput `pulumi:"audience"`
	// The token issuer.
	Issuer pulumi.StringInput `pulumi:"issuer"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyTokenRestriction'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The OpenID connect discovery document.
	OpenIdConnectDiscoveryDocument pulumi.StringPtrInput `pulumi:"openIdConnectDiscoveryDocument"`
	// The primary verification key.
	PrimaryVerificationKey pulumi.Input `pulumi:"primaryVerificationKey"`
	// A list of required token claims.
	RequiredClaims ContentKeyPolicyTokenClaimArrayInput `pulumi:"requiredClaims"`
	// The type of token.
	RestrictionTokenType pulumi.StringInput `pulumi:"restrictionTokenType"`
}

func (ContentKeyPolicyTokenRestrictionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyTokenRestriction)(nil)).Elem()
}

func (i ContentKeyPolicyTokenRestrictionArgs) ToContentKeyPolicyTokenRestrictionOutput() ContentKeyPolicyTokenRestrictionOutput {
	return i.ToContentKeyPolicyTokenRestrictionOutputWithContext(context.Background())
}

func (i ContentKeyPolicyTokenRestrictionArgs) ToContentKeyPolicyTokenRestrictionOutputWithContext(ctx context.Context) ContentKeyPolicyTokenRestrictionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyTokenRestrictionOutput)
}

// Represents a token restriction. Provided token must match these requirements for successful license or key delivery.
type ContentKeyPolicyTokenRestrictionOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyTokenRestrictionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyTokenRestriction)(nil)).Elem()
}

func (o ContentKeyPolicyTokenRestrictionOutput) ToContentKeyPolicyTokenRestrictionOutput() ContentKeyPolicyTokenRestrictionOutput {
	return o
}

func (o ContentKeyPolicyTokenRestrictionOutput) ToContentKeyPolicyTokenRestrictionOutputWithContext(ctx context.Context) ContentKeyPolicyTokenRestrictionOutput {
	return o
}

// A list of alternative verification keys.
func (o ContentKeyPolicyTokenRestrictionOutput) AlternateVerificationKeys() pulumi.ArrayOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestriction) []interface{} { return v.AlternateVerificationKeys }).(pulumi.ArrayOutput)
}

// The audience for the token.
func (o ContentKeyPolicyTokenRestrictionOutput) Audience() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestriction) string { return v.Audience }).(pulumi.StringOutput)
}

// The token issuer.
func (o ContentKeyPolicyTokenRestrictionOutput) Issuer() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestriction) string { return v.Issuer }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyTokenRestriction'.
func (o ContentKeyPolicyTokenRestrictionOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestriction) string { return v.OdataType }).(pulumi.StringOutput)
}

// The OpenID connect discovery document.
func (o ContentKeyPolicyTokenRestrictionOutput) OpenIdConnectDiscoveryDocument() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestriction) *string { return v.OpenIdConnectDiscoveryDocument }).(pulumi.StringPtrOutput)
}

// The primary verification key.
func (o ContentKeyPolicyTokenRestrictionOutput) PrimaryVerificationKey() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestriction) interface{} { return v.PrimaryVerificationKey }).(pulumi.AnyOutput)
}

// A list of required token claims.
func (o ContentKeyPolicyTokenRestrictionOutput) RequiredClaims() ContentKeyPolicyTokenClaimArrayOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestriction) []ContentKeyPolicyTokenClaim { return v.RequiredClaims }).(ContentKeyPolicyTokenClaimArrayOutput)
}

// The type of token.
func (o ContentKeyPolicyTokenRestrictionOutput) RestrictionTokenType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestriction) string { return v.RestrictionTokenType }).(pulumi.StringOutput)
}

// Represents a token restriction. Provided token must match these requirements for successful license or key delivery.
type ContentKeyPolicyTokenRestrictionResponse struct {
	// A list of alternative verification keys.
	AlternateVerificationKeys []interface{} `pulumi:"alternateVerificationKeys"`
	// The audience for the token.
	Audience string `pulumi:"audience"`
	// The token issuer.
	Issuer string `pulumi:"issuer"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyTokenRestriction'.
	OdataType string `pulumi:"odataType"`
	// The OpenID connect discovery document.
	OpenIdConnectDiscoveryDocument *string `pulumi:"openIdConnectDiscoveryDocument"`
	// The primary verification key.
	PrimaryVerificationKey interface{} `pulumi:"primaryVerificationKey"`
	// A list of required token claims.
	RequiredClaims []ContentKeyPolicyTokenClaimResponse `pulumi:"requiredClaims"`
	// The type of token.
	RestrictionTokenType string `pulumi:"restrictionTokenType"`
}

// Represents a token restriction. Provided token must match these requirements for successful license or key delivery.
type ContentKeyPolicyTokenRestrictionResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyTokenRestrictionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyTokenRestrictionResponse)(nil)).Elem()
}

func (o ContentKeyPolicyTokenRestrictionResponseOutput) ToContentKeyPolicyTokenRestrictionResponseOutput() ContentKeyPolicyTokenRestrictionResponseOutput {
	return o
}

func (o ContentKeyPolicyTokenRestrictionResponseOutput) ToContentKeyPolicyTokenRestrictionResponseOutputWithContext(ctx context.Context) ContentKeyPolicyTokenRestrictionResponseOutput {
	return o
}

// A list of alternative verification keys.
func (o ContentKeyPolicyTokenRestrictionResponseOutput) AlternateVerificationKeys() pulumi.ArrayOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestrictionResponse) []interface{} { return v.AlternateVerificationKeys }).(pulumi.ArrayOutput)
}

// The audience for the token.
func (o ContentKeyPolicyTokenRestrictionResponseOutput) Audience() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestrictionResponse) string { return v.Audience }).(pulumi.StringOutput)
}

// The token issuer.
func (o ContentKeyPolicyTokenRestrictionResponseOutput) Issuer() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestrictionResponse) string { return v.Issuer }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyTokenRestriction'.
func (o ContentKeyPolicyTokenRestrictionResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestrictionResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The OpenID connect discovery document.
func (o ContentKeyPolicyTokenRestrictionResponseOutput) OpenIdConnectDiscoveryDocument() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestrictionResponse) *string { return v.OpenIdConnectDiscoveryDocument }).(pulumi.StringPtrOutput)
}

// The primary verification key.
func (o ContentKeyPolicyTokenRestrictionResponseOutput) PrimaryVerificationKey() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestrictionResponse) interface{} { return v.PrimaryVerificationKey }).(pulumi.AnyOutput)
}

// A list of required token claims.
func (o ContentKeyPolicyTokenRestrictionResponseOutput) RequiredClaims() ContentKeyPolicyTokenClaimResponseArrayOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestrictionResponse) []ContentKeyPolicyTokenClaimResponse {
		return v.RequiredClaims
	}).(ContentKeyPolicyTokenClaimResponseArrayOutput)
}

// The type of token.
func (o ContentKeyPolicyTokenRestrictionResponseOutput) RestrictionTokenType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyTokenRestrictionResponse) string { return v.RestrictionTokenType }).(pulumi.StringOutput)
}

// Represents a ContentKeyPolicyConfiguration that is unavailable in the current API version.
type ContentKeyPolicyUnknownConfiguration struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownConfiguration'.
	OdataType string `pulumi:"odataType"`
}

// ContentKeyPolicyUnknownConfigurationInput is an input type that accepts ContentKeyPolicyUnknownConfigurationArgs and ContentKeyPolicyUnknownConfigurationOutput values.
// You can construct a concrete instance of `ContentKeyPolicyUnknownConfigurationInput` via:
//
//	ContentKeyPolicyUnknownConfigurationArgs{...}
type ContentKeyPolicyUnknownConfigurationInput interface {
	pulumi.Input

	ToContentKeyPolicyUnknownConfigurationOutput() ContentKeyPolicyUnknownConfigurationOutput
	ToContentKeyPolicyUnknownConfigurationOutputWithContext(context.Context) ContentKeyPolicyUnknownConfigurationOutput
}

// Represents a ContentKeyPolicyConfiguration that is unavailable in the current API version.
type ContentKeyPolicyUnknownConfigurationArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownConfiguration'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (ContentKeyPolicyUnknownConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyUnknownConfiguration)(nil)).Elem()
}

func (i ContentKeyPolicyUnknownConfigurationArgs) ToContentKeyPolicyUnknownConfigurationOutput() ContentKeyPolicyUnknownConfigurationOutput {
	return i.ToContentKeyPolicyUnknownConfigurationOutputWithContext(context.Background())
}

func (i ContentKeyPolicyUnknownConfigurationArgs) ToContentKeyPolicyUnknownConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyUnknownConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyUnknownConfigurationOutput)
}

// Represents a ContentKeyPolicyConfiguration that is unavailable in the current API version.
type ContentKeyPolicyUnknownConfigurationOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyUnknownConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyUnknownConfiguration)(nil)).Elem()
}

func (o ContentKeyPolicyUnknownConfigurationOutput) ToContentKeyPolicyUnknownConfigurationOutput() ContentKeyPolicyUnknownConfigurationOutput {
	return o
}

func (o ContentKeyPolicyUnknownConfigurationOutput) ToContentKeyPolicyUnknownConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyUnknownConfigurationOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownConfiguration'.
func (o ContentKeyPolicyUnknownConfigurationOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyUnknownConfiguration) string { return v.OdataType }).(pulumi.StringOutput)
}

// Represents a ContentKeyPolicyConfiguration that is unavailable in the current API version.
type ContentKeyPolicyUnknownConfigurationResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownConfiguration'.
	OdataType string `pulumi:"odataType"`
}

// Represents a ContentKeyPolicyConfiguration that is unavailable in the current API version.
type ContentKeyPolicyUnknownConfigurationResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyUnknownConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyUnknownConfigurationResponse)(nil)).Elem()
}

func (o ContentKeyPolicyUnknownConfigurationResponseOutput) ToContentKeyPolicyUnknownConfigurationResponseOutput() ContentKeyPolicyUnknownConfigurationResponseOutput {
	return o
}

func (o ContentKeyPolicyUnknownConfigurationResponseOutput) ToContentKeyPolicyUnknownConfigurationResponseOutputWithContext(ctx context.Context) ContentKeyPolicyUnknownConfigurationResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownConfiguration'.
func (o ContentKeyPolicyUnknownConfigurationResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyUnknownConfigurationResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Represents a ContentKeyPolicyRestriction that is unavailable in the current API version.
type ContentKeyPolicyUnknownRestriction struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownRestriction'.
	OdataType string `pulumi:"odataType"`
}

// ContentKeyPolicyUnknownRestrictionInput is an input type that accepts ContentKeyPolicyUnknownRestrictionArgs and ContentKeyPolicyUnknownRestrictionOutput values.
// You can construct a concrete instance of `ContentKeyPolicyUnknownRestrictionInput` via:
//
//	ContentKeyPolicyUnknownRestrictionArgs{...}
type ContentKeyPolicyUnknownRestrictionInput interface {
	pulumi.Input

	ToContentKeyPolicyUnknownRestrictionOutput() ContentKeyPolicyUnknownRestrictionOutput
	ToContentKeyPolicyUnknownRestrictionOutputWithContext(context.Context) ContentKeyPolicyUnknownRestrictionOutput
}

// Represents a ContentKeyPolicyRestriction that is unavailable in the current API version.
type ContentKeyPolicyUnknownRestrictionArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownRestriction'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (ContentKeyPolicyUnknownRestrictionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyUnknownRestriction)(nil)).Elem()
}

func (i ContentKeyPolicyUnknownRestrictionArgs) ToContentKeyPolicyUnknownRestrictionOutput() ContentKeyPolicyUnknownRestrictionOutput {
	return i.ToContentKeyPolicyUnknownRestrictionOutputWithContext(context.Background())
}

func (i ContentKeyPolicyUnknownRestrictionArgs) ToContentKeyPolicyUnknownRestrictionOutputWithContext(ctx context.Context) ContentKeyPolicyUnknownRestrictionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyUnknownRestrictionOutput)
}

// Represents a ContentKeyPolicyRestriction that is unavailable in the current API version.
type ContentKeyPolicyUnknownRestrictionOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyUnknownRestrictionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyUnknownRestriction)(nil)).Elem()
}

func (o ContentKeyPolicyUnknownRestrictionOutput) ToContentKeyPolicyUnknownRestrictionOutput() ContentKeyPolicyUnknownRestrictionOutput {
	return o
}

func (o ContentKeyPolicyUnknownRestrictionOutput) ToContentKeyPolicyUnknownRestrictionOutputWithContext(ctx context.Context) ContentKeyPolicyUnknownRestrictionOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownRestriction'.
func (o ContentKeyPolicyUnknownRestrictionOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyUnknownRestriction) string { return v.OdataType }).(pulumi.StringOutput)
}

// Represents a ContentKeyPolicyRestriction that is unavailable in the current API version.
type ContentKeyPolicyUnknownRestrictionResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownRestriction'.
	OdataType string `pulumi:"odataType"`
}

// Represents a ContentKeyPolicyRestriction that is unavailable in the current API version.
type ContentKeyPolicyUnknownRestrictionResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyUnknownRestrictionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyUnknownRestrictionResponse)(nil)).Elem()
}

func (o ContentKeyPolicyUnknownRestrictionResponseOutput) ToContentKeyPolicyUnknownRestrictionResponseOutput() ContentKeyPolicyUnknownRestrictionResponseOutput {
	return o
}

func (o ContentKeyPolicyUnknownRestrictionResponseOutput) ToContentKeyPolicyUnknownRestrictionResponseOutputWithContext(ctx context.Context) ContentKeyPolicyUnknownRestrictionResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownRestriction'.
func (o ContentKeyPolicyUnknownRestrictionResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyUnknownRestrictionResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies a configuration for Widevine licenses.
type ContentKeyPolicyWidevineConfiguration struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyWidevineConfiguration'.
	OdataType string `pulumi:"odataType"`
	// The Widevine template.
	WidevineTemplate string `pulumi:"widevineTemplate"`
}

// ContentKeyPolicyWidevineConfigurationInput is an input type that accepts ContentKeyPolicyWidevineConfigurationArgs and ContentKeyPolicyWidevineConfigurationOutput values.
// You can construct a concrete instance of `ContentKeyPolicyWidevineConfigurationInput` via:
//
//	ContentKeyPolicyWidevineConfigurationArgs{...}
type ContentKeyPolicyWidevineConfigurationInput interface {
	pulumi.Input

	ToContentKeyPolicyWidevineConfigurationOutput() ContentKeyPolicyWidevineConfigurationOutput
	ToContentKeyPolicyWidevineConfigurationOutputWithContext(context.Context) ContentKeyPolicyWidevineConfigurationOutput
}

// Specifies a configuration for Widevine licenses.
type ContentKeyPolicyWidevineConfigurationArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyWidevineConfiguration'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The Widevine template.
	WidevineTemplate pulumi.StringInput `pulumi:"widevineTemplate"`
}

func (ContentKeyPolicyWidevineConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyWidevineConfiguration)(nil)).Elem()
}

func (i ContentKeyPolicyWidevineConfigurationArgs) ToContentKeyPolicyWidevineConfigurationOutput() ContentKeyPolicyWidevineConfigurationOutput {
	return i.ToContentKeyPolicyWidevineConfigurationOutputWithContext(context.Background())
}

func (i ContentKeyPolicyWidevineConfigurationArgs) ToContentKeyPolicyWidevineConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyWidevineConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyWidevineConfigurationOutput)
}

// Specifies a configuration for Widevine licenses.
type ContentKeyPolicyWidevineConfigurationOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyWidevineConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyWidevineConfiguration)(nil)).Elem()
}

func (o ContentKeyPolicyWidevineConfigurationOutput) ToContentKeyPolicyWidevineConfigurationOutput() ContentKeyPolicyWidevineConfigurationOutput {
	return o
}

func (o ContentKeyPolicyWidevineConfigurationOutput) ToContentKeyPolicyWidevineConfigurationOutputWithContext(ctx context.Context) ContentKeyPolicyWidevineConfigurationOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyWidevineConfiguration'.
func (o ContentKeyPolicyWidevineConfigurationOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyWidevineConfiguration) string { return v.OdataType }).(pulumi.StringOutput)
}

// The Widevine template.
func (o ContentKeyPolicyWidevineConfigurationOutput) WidevineTemplate() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyWidevineConfiguration) string { return v.WidevineTemplate }).(pulumi.StringOutput)
}

// Specifies a configuration for Widevine licenses.
type ContentKeyPolicyWidevineConfigurationResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyWidevineConfiguration'.
	OdataType string `pulumi:"odataType"`
	// The Widevine template.
	WidevineTemplate string `pulumi:"widevineTemplate"`
}

// Specifies a configuration for Widevine licenses.
type ContentKeyPolicyWidevineConfigurationResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyWidevineConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyWidevineConfigurationResponse)(nil)).Elem()
}

func (o ContentKeyPolicyWidevineConfigurationResponseOutput) ToContentKeyPolicyWidevineConfigurationResponseOutput() ContentKeyPolicyWidevineConfigurationResponseOutput {
	return o
}

func (o ContentKeyPolicyWidevineConfigurationResponseOutput) ToContentKeyPolicyWidevineConfigurationResponseOutputWithContext(ctx context.Context) ContentKeyPolicyWidevineConfigurationResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyWidevineConfiguration'.
func (o ContentKeyPolicyWidevineConfigurationResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyWidevineConfigurationResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The Widevine template.
func (o ContentKeyPolicyWidevineConfigurationResponseOutput) WidevineTemplate() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyWidevineConfigurationResponse) string { return v.WidevineTemplate }).(pulumi.StringOutput)
}

// Specifies a certificate for token validation.
type ContentKeyPolicyX509CertificateTokenKey struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey'.
	OdataType string `pulumi:"odataType"`
	// The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET)
	RawBody string `pulumi:"rawBody"`
}

// ContentKeyPolicyX509CertificateTokenKeyInput is an input type that accepts ContentKeyPolicyX509CertificateTokenKeyArgs and ContentKeyPolicyX509CertificateTokenKeyOutput values.
// You can construct a concrete instance of `ContentKeyPolicyX509CertificateTokenKeyInput` via:
//
//	ContentKeyPolicyX509CertificateTokenKeyArgs{...}
type ContentKeyPolicyX509CertificateTokenKeyInput interface {
	pulumi.Input

	ToContentKeyPolicyX509CertificateTokenKeyOutput() ContentKeyPolicyX509CertificateTokenKeyOutput
	ToContentKeyPolicyX509CertificateTokenKeyOutputWithContext(context.Context) ContentKeyPolicyX509CertificateTokenKeyOutput
}

// Specifies a certificate for token validation.
type ContentKeyPolicyX509CertificateTokenKeyArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET)
	RawBody pulumi.StringInput `pulumi:"rawBody"`
}

func (ContentKeyPolicyX509CertificateTokenKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyX509CertificateTokenKey)(nil)).Elem()
}

func (i ContentKeyPolicyX509CertificateTokenKeyArgs) ToContentKeyPolicyX509CertificateTokenKeyOutput() ContentKeyPolicyX509CertificateTokenKeyOutput {
	return i.ToContentKeyPolicyX509CertificateTokenKeyOutputWithContext(context.Background())
}

func (i ContentKeyPolicyX509CertificateTokenKeyArgs) ToContentKeyPolicyX509CertificateTokenKeyOutputWithContext(ctx context.Context) ContentKeyPolicyX509CertificateTokenKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyX509CertificateTokenKeyOutput)
}

// Specifies a certificate for token validation.
type ContentKeyPolicyX509CertificateTokenKeyOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyX509CertificateTokenKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyX509CertificateTokenKey)(nil)).Elem()
}

func (o ContentKeyPolicyX509CertificateTokenKeyOutput) ToContentKeyPolicyX509CertificateTokenKeyOutput() ContentKeyPolicyX509CertificateTokenKeyOutput {
	return o
}

func (o ContentKeyPolicyX509CertificateTokenKeyOutput) ToContentKeyPolicyX509CertificateTokenKeyOutputWithContext(ctx context.Context) ContentKeyPolicyX509CertificateTokenKeyOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey'.
func (o ContentKeyPolicyX509CertificateTokenKeyOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyX509CertificateTokenKey) string { return v.OdataType }).(pulumi.StringOutput)
}

// The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET)
func (o ContentKeyPolicyX509CertificateTokenKeyOutput) RawBody() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyX509CertificateTokenKey) string { return v.RawBody }).(pulumi.StringOutput)
}

// Specifies a certificate for token validation.
type ContentKeyPolicyX509CertificateTokenKeyResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey'.
	OdataType string `pulumi:"odataType"`
	// The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET)
	RawBody string `pulumi:"rawBody"`
}

// Specifies a certificate for token validation.
type ContentKeyPolicyX509CertificateTokenKeyResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyX509CertificateTokenKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyX509CertificateTokenKeyResponse)(nil)).Elem()
}

func (o ContentKeyPolicyX509CertificateTokenKeyResponseOutput) ToContentKeyPolicyX509CertificateTokenKeyResponseOutput() ContentKeyPolicyX509CertificateTokenKeyResponseOutput {
	return o
}

func (o ContentKeyPolicyX509CertificateTokenKeyResponseOutput) ToContentKeyPolicyX509CertificateTokenKeyResponseOutputWithContext(ctx context.Context) ContentKeyPolicyX509CertificateTokenKeyResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey'.
func (o ContentKeyPolicyX509CertificateTokenKeyResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyX509CertificateTokenKeyResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET)
func (o ContentKeyPolicyX509CertificateTokenKeyResponseOutput) RawBody() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyX509CertificateTokenKeyResponse) string { return v.RawBody }).(pulumi.StringOutput)
}

// A codec flag, which tells the encoder to copy the input audio bitstream.
type CopyAudio struct {
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.CopyAudio'.
	OdataType string `pulumi:"odataType"`
}

// CopyAudioInput is an input type that accepts CopyAudioArgs and CopyAudioOutput values.
// You can construct a concrete instance of `CopyAudioInput` via:
//
//	CopyAudioArgs{...}
type CopyAudioInput interface {
	pulumi.Input

	ToCopyAudioOutput() CopyAudioOutput
	ToCopyAudioOutputWithContext(context.Context) CopyAudioOutput
}

// A codec flag, which tells the encoder to copy the input audio bitstream.
type CopyAudioArgs struct {
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.CopyAudio'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (CopyAudioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CopyAudio)(nil)).Elem()
}

func (i CopyAudioArgs) ToCopyAudioOutput() CopyAudioOutput {
	return i.ToCopyAudioOutputWithContext(context.Background())
}

func (i CopyAudioArgs) ToCopyAudioOutputWithContext(ctx context.Context) CopyAudioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CopyAudioOutput)
}

// A codec flag, which tells the encoder to copy the input audio bitstream.
type CopyAudioOutput struct{ *pulumi.OutputState }

func (CopyAudioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CopyAudio)(nil)).Elem()
}

func (o CopyAudioOutput) ToCopyAudioOutput() CopyAudioOutput {
	return o
}

func (o CopyAudioOutput) ToCopyAudioOutputWithContext(ctx context.Context) CopyAudioOutput {
	return o
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o CopyAudioOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CopyAudio) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.CopyAudio'.
func (o CopyAudioOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v CopyAudio) string { return v.OdataType }).(pulumi.StringOutput)
}

// A codec flag, which tells the encoder to copy the input audio bitstream.
type CopyAudioResponse struct {
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.CopyAudio'.
	OdataType string `pulumi:"odataType"`
}

// A codec flag, which tells the encoder to copy the input audio bitstream.
type CopyAudioResponseOutput struct{ *pulumi.OutputState }

func (CopyAudioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CopyAudioResponse)(nil)).Elem()
}

func (o CopyAudioResponseOutput) ToCopyAudioResponseOutput() CopyAudioResponseOutput {
	return o
}

func (o CopyAudioResponseOutput) ToCopyAudioResponseOutputWithContext(ctx context.Context) CopyAudioResponseOutput {
	return o
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o CopyAudioResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CopyAudioResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.CopyAudio'.
func (o CopyAudioResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v CopyAudioResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// A codec flag, which tells the encoder to copy the input video bitstream without re-encoding.
type CopyVideo struct {
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.CopyVideo'.
	OdataType string `pulumi:"odataType"`
}

// CopyVideoInput is an input type that accepts CopyVideoArgs and CopyVideoOutput values.
// You can construct a concrete instance of `CopyVideoInput` via:
//
//	CopyVideoArgs{...}
type CopyVideoInput interface {
	pulumi.Input

	ToCopyVideoOutput() CopyVideoOutput
	ToCopyVideoOutputWithContext(context.Context) CopyVideoOutput
}

// A codec flag, which tells the encoder to copy the input video bitstream without re-encoding.
type CopyVideoArgs struct {
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.CopyVideo'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (CopyVideoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CopyVideo)(nil)).Elem()
}

func (i CopyVideoArgs) ToCopyVideoOutput() CopyVideoOutput {
	return i.ToCopyVideoOutputWithContext(context.Background())
}

func (i CopyVideoArgs) ToCopyVideoOutputWithContext(ctx context.Context) CopyVideoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CopyVideoOutput)
}

// A codec flag, which tells the encoder to copy the input video bitstream without re-encoding.
type CopyVideoOutput struct{ *pulumi.OutputState }

func (CopyVideoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CopyVideo)(nil)).Elem()
}

func (o CopyVideoOutput) ToCopyVideoOutput() CopyVideoOutput {
	return o
}

func (o CopyVideoOutput) ToCopyVideoOutputWithContext(ctx context.Context) CopyVideoOutput {
	return o
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o CopyVideoOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CopyVideo) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.CopyVideo'.
func (o CopyVideoOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v CopyVideo) string { return v.OdataType }).(pulumi.StringOutput)
}

// A codec flag, which tells the encoder to copy the input video bitstream without re-encoding.
type CopyVideoResponse struct {
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.CopyVideo'.
	OdataType string `pulumi:"odataType"`
}

// A codec flag, which tells the encoder to copy the input video bitstream without re-encoding.
type CopyVideoResponseOutput struct{ *pulumi.OutputState }

func (CopyVideoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CopyVideoResponse)(nil)).Elem()
}

func (o CopyVideoResponseOutput) ToCopyVideoResponseOutput() CopyVideoResponseOutput {
	return o
}

func (o CopyVideoResponseOutput) ToCopyVideoResponseOutputWithContext(ctx context.Context) CopyVideoResponseOutput {
	return o
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o CopyVideoResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CopyVideoResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.CopyVideo'.
func (o CopyVideoResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v CopyVideoResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The client access policy.
type CrossSiteAccessPolicies struct {
	// The content of clientaccesspolicy.xml used by Silverlight.
	ClientAccessPolicy *string `pulumi:"clientAccessPolicy"`
	// The content of crossdomain.xml used by Silverlight.
	CrossDomainPolicy *string `pulumi:"crossDomainPolicy"`
}

// CrossSiteAccessPoliciesInput is an input type that accepts CrossSiteAccessPoliciesArgs and CrossSiteAccessPoliciesOutput values.
// You can construct a concrete instance of `CrossSiteAccessPoliciesInput` via:
//
//	CrossSiteAccessPoliciesArgs{...}
type CrossSiteAccessPoliciesInput interface {
	pulumi.Input

	ToCrossSiteAccessPoliciesOutput() CrossSiteAccessPoliciesOutput
	ToCrossSiteAccessPoliciesOutputWithContext(context.Context) CrossSiteAccessPoliciesOutput
}

// The client access policy.
type CrossSiteAccessPoliciesArgs struct {
	// The content of clientaccesspolicy.xml used by Silverlight.
	ClientAccessPolicy pulumi.StringPtrInput `pulumi:"clientAccessPolicy"`
	// The content of crossdomain.xml used by Silverlight.
	CrossDomainPolicy pulumi.StringPtrInput `pulumi:"crossDomainPolicy"`
}

func (CrossSiteAccessPoliciesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CrossSiteAccessPolicies)(nil)).Elem()
}

func (i CrossSiteAccessPoliciesArgs) ToCrossSiteAccessPoliciesOutput() CrossSiteAccessPoliciesOutput {
	return i.ToCrossSiteAccessPoliciesOutputWithContext(context.Background())
}

func (i CrossSiteAccessPoliciesArgs) ToCrossSiteAccessPoliciesOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrossSiteAccessPoliciesOutput)
}

func (i CrossSiteAccessPoliciesArgs) ToCrossSiteAccessPoliciesPtrOutput() CrossSiteAccessPoliciesPtrOutput {
	return i.ToCrossSiteAccessPoliciesPtrOutputWithContext(context.Background())
}

func (i CrossSiteAccessPoliciesArgs) ToCrossSiteAccessPoliciesPtrOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrossSiteAccessPoliciesOutput).ToCrossSiteAccessPoliciesPtrOutputWithContext(ctx)
}

// CrossSiteAccessPoliciesPtrInput is an input type that accepts CrossSiteAccessPoliciesArgs, CrossSiteAccessPoliciesPtr and CrossSiteAccessPoliciesPtrOutput values.
// You can construct a concrete instance of `CrossSiteAccessPoliciesPtrInput` via:
//
//	        CrossSiteAccessPoliciesArgs{...}
//
//	or:
//
//	        nil
type CrossSiteAccessPoliciesPtrInput interface {
	pulumi.Input

	ToCrossSiteAccessPoliciesPtrOutput() CrossSiteAccessPoliciesPtrOutput
	ToCrossSiteAccessPoliciesPtrOutputWithContext(context.Context) CrossSiteAccessPoliciesPtrOutput
}

type crossSiteAccessPoliciesPtrType CrossSiteAccessPoliciesArgs

func CrossSiteAccessPoliciesPtr(v *CrossSiteAccessPoliciesArgs) CrossSiteAccessPoliciesPtrInput {
	return (*crossSiteAccessPoliciesPtrType)(v)
}

func (*crossSiteAccessPoliciesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CrossSiteAccessPolicies)(nil)).Elem()
}

func (i *crossSiteAccessPoliciesPtrType) ToCrossSiteAccessPoliciesPtrOutput() CrossSiteAccessPoliciesPtrOutput {
	return i.ToCrossSiteAccessPoliciesPtrOutputWithContext(context.Background())
}

func (i *crossSiteAccessPoliciesPtrType) ToCrossSiteAccessPoliciesPtrOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrossSiteAccessPoliciesPtrOutput)
}

// The client access policy.
type CrossSiteAccessPoliciesOutput struct{ *pulumi.OutputState }

func (CrossSiteAccessPoliciesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CrossSiteAccessPolicies)(nil)).Elem()
}

func (o CrossSiteAccessPoliciesOutput) ToCrossSiteAccessPoliciesOutput() CrossSiteAccessPoliciesOutput {
	return o
}

func (o CrossSiteAccessPoliciesOutput) ToCrossSiteAccessPoliciesOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesOutput {
	return o
}

func (o CrossSiteAccessPoliciesOutput) ToCrossSiteAccessPoliciesPtrOutput() CrossSiteAccessPoliciesPtrOutput {
	return o.ToCrossSiteAccessPoliciesPtrOutputWithContext(context.Background())
}

func (o CrossSiteAccessPoliciesOutput) ToCrossSiteAccessPoliciesPtrOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CrossSiteAccessPolicies) *CrossSiteAccessPolicies {
		return &v
	}).(CrossSiteAccessPoliciesPtrOutput)
}

// The content of clientaccesspolicy.xml used by Silverlight.
func (o CrossSiteAccessPoliciesOutput) ClientAccessPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossSiteAccessPolicies) *string { return v.ClientAccessPolicy }).(pulumi.StringPtrOutput)
}

// The content of crossdomain.xml used by Silverlight.
func (o CrossSiteAccessPoliciesOutput) CrossDomainPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossSiteAccessPolicies) *string { return v.CrossDomainPolicy }).(pulumi.StringPtrOutput)
}

type CrossSiteAccessPoliciesPtrOutput struct{ *pulumi.OutputState }

func (CrossSiteAccessPoliciesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CrossSiteAccessPolicies)(nil)).Elem()
}

func (o CrossSiteAccessPoliciesPtrOutput) ToCrossSiteAccessPoliciesPtrOutput() CrossSiteAccessPoliciesPtrOutput {
	return o
}

func (o CrossSiteAccessPoliciesPtrOutput) ToCrossSiteAccessPoliciesPtrOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesPtrOutput {
	return o
}

func (o CrossSiteAccessPoliciesPtrOutput) Elem() CrossSiteAccessPoliciesOutput {
	return o.ApplyT(func(v *CrossSiteAccessPolicies) CrossSiteAccessPolicies {
		if v != nil {
			return *v
		}
		var ret CrossSiteAccessPolicies
		return ret
	}).(CrossSiteAccessPoliciesOutput)
}

// The content of clientaccesspolicy.xml used by Silverlight.
func (o CrossSiteAccessPoliciesPtrOutput) ClientAccessPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CrossSiteAccessPolicies) *string {
		if v == nil {
			return nil
		}
		return v.ClientAccessPolicy
	}).(pulumi.StringPtrOutput)
}

// The content of crossdomain.xml used by Silverlight.
func (o CrossSiteAccessPoliciesPtrOutput) CrossDomainPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CrossSiteAccessPolicies) *string {
		if v == nil {
			return nil
		}
		return v.CrossDomainPolicy
	}).(pulumi.StringPtrOutput)
}

// The client access policy.
type CrossSiteAccessPoliciesResponse struct {
	// The content of clientaccesspolicy.xml used by Silverlight.
	ClientAccessPolicy *string `pulumi:"clientAccessPolicy"`
	// The content of crossdomain.xml used by Silverlight.
	CrossDomainPolicy *string `pulumi:"crossDomainPolicy"`
}

// The client access policy.
type CrossSiteAccessPoliciesResponseOutput struct{ *pulumi.OutputState }

func (CrossSiteAccessPoliciesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CrossSiteAccessPoliciesResponse)(nil)).Elem()
}

func (o CrossSiteAccessPoliciesResponseOutput) ToCrossSiteAccessPoliciesResponseOutput() CrossSiteAccessPoliciesResponseOutput {
	return o
}

func (o CrossSiteAccessPoliciesResponseOutput) ToCrossSiteAccessPoliciesResponseOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesResponseOutput {
	return o
}

// The content of clientaccesspolicy.xml used by Silverlight.
func (o CrossSiteAccessPoliciesResponseOutput) ClientAccessPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossSiteAccessPoliciesResponse) *string { return v.ClientAccessPolicy }).(pulumi.StringPtrOutput)
}

// The content of crossdomain.xml used by Silverlight.
func (o CrossSiteAccessPoliciesResponseOutput) CrossDomainPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossSiteAccessPoliciesResponse) *string { return v.CrossDomainPolicy }).(pulumi.StringPtrOutput)
}

type CrossSiteAccessPoliciesResponsePtrOutput struct{ *pulumi.OutputState }

func (CrossSiteAccessPoliciesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CrossSiteAccessPoliciesResponse)(nil)).Elem()
}

func (o CrossSiteAccessPoliciesResponsePtrOutput) ToCrossSiteAccessPoliciesResponsePtrOutput() CrossSiteAccessPoliciesResponsePtrOutput {
	return o
}

func (o CrossSiteAccessPoliciesResponsePtrOutput) ToCrossSiteAccessPoliciesResponsePtrOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesResponsePtrOutput {
	return o
}

func (o CrossSiteAccessPoliciesResponsePtrOutput) Elem() CrossSiteAccessPoliciesResponseOutput {
	return o.ApplyT(func(v *CrossSiteAccessPoliciesResponse) CrossSiteAccessPoliciesResponse {
		if v != nil {
			return *v
		}
		var ret CrossSiteAccessPoliciesResponse
		return ret
	}).(CrossSiteAccessPoliciesResponseOutput)
}

// The content of clientaccesspolicy.xml used by Silverlight.
func (o CrossSiteAccessPoliciesResponsePtrOutput) ClientAccessPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CrossSiteAccessPoliciesResponse) *string {
		if v == nil {
			return nil
		}
		return v.ClientAccessPolicy
	}).(pulumi.StringPtrOutput)
}

// The content of crossdomain.xml used by Silverlight.
func (o CrossSiteAccessPoliciesResponsePtrOutput) CrossDomainPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CrossSiteAccessPoliciesResponse) *string {
		if v == nil {
			return nil
		}
		return v.CrossDomainPolicy
	}).(pulumi.StringPtrOutput)
}

// Describes Dolby Digital Audio Codec (AC3) audio encoding settings. The current implementation for Dolby Digital Audio support are: Audio channel numbers at 1((mono), 2(stereo), 6(5.1side); Audio sampling frequency rates at: 32K/44.1K/48K Hz; Audio bitrate values as AC3 specification supports: 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000, 384000, 448000, 512000, 576000, 640000 bps.
type DDAudio struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels *int `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.DDAudio'.
	OdataType string `pulumi:"odataType"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate *int `pulumi:"samplingRate"`
}

// DDAudioInput is an input type that accepts DDAudioArgs and DDAudioOutput values.
// You can construct a concrete instance of `DDAudioInput` via:
//
//	DDAudioArgs{...}
type DDAudioInput interface {
	pulumi.Input

	ToDDAudioOutput() DDAudioOutput
	ToDDAudioOutputWithContext(context.Context) DDAudioOutput
}

// Describes Dolby Digital Audio Codec (AC3) audio encoding settings. The current implementation for Dolby Digital Audio support are: Audio channel numbers at 1((mono), 2(stereo), 6(5.1side); Audio sampling frequency rates at: 32K/44.1K/48K Hz; Audio bitrate values as AC3 specification supports: 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000, 384000, 448000, 512000, 576000, 640000 bps.
type DDAudioArgs struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate pulumi.IntPtrInput `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels pulumi.IntPtrInput `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.DDAudio'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate pulumi.IntPtrInput `pulumi:"samplingRate"`
}

func (DDAudioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DDAudio)(nil)).Elem()
}

func (i DDAudioArgs) ToDDAudioOutput() DDAudioOutput {
	return i.ToDDAudioOutputWithContext(context.Background())
}

func (i DDAudioArgs) ToDDAudioOutputWithContext(ctx context.Context) DDAudioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DDAudioOutput)
}

// Describes Dolby Digital Audio Codec (AC3) audio encoding settings. The current implementation for Dolby Digital Audio support are: Audio channel numbers at 1((mono), 2(stereo), 6(5.1side); Audio sampling frequency rates at: 32K/44.1K/48K Hz; Audio bitrate values as AC3 specification supports: 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000, 384000, 448000, 512000, 576000, 640000 bps.
type DDAudioOutput struct{ *pulumi.OutputState }

func (DDAudioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DDAudio)(nil)).Elem()
}

func (o DDAudioOutput) ToDDAudioOutput() DDAudioOutput {
	return o
}

func (o DDAudioOutput) ToDDAudioOutputWithContext(ctx context.Context) DDAudioOutput {
	return o
}

// The bitrate, in bits per second, of the output encoded audio.
func (o DDAudioOutput) Bitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DDAudio) *int { return v.Bitrate }).(pulumi.IntPtrOutput)
}

// The number of channels in the audio.
func (o DDAudioOutput) Channels() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DDAudio) *int { return v.Channels }).(pulumi.IntPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o DDAudioOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DDAudio) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.DDAudio'.
func (o DDAudioOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v DDAudio) string { return v.OdataType }).(pulumi.StringOutput)
}

// The sampling rate to use for encoding in hertz.
func (o DDAudioOutput) SamplingRate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DDAudio) *int { return v.SamplingRate }).(pulumi.IntPtrOutput)
}

// Describes Dolby Digital Audio Codec (AC3) audio encoding settings. The current implementation for Dolby Digital Audio support are: Audio channel numbers at 1((mono), 2(stereo), 6(5.1side); Audio sampling frequency rates at: 32K/44.1K/48K Hz; Audio bitrate values as AC3 specification supports: 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000, 384000, 448000, 512000, 576000, 640000 bps.
type DDAudioResponse struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels *int `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.DDAudio'.
	OdataType string `pulumi:"odataType"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate *int `pulumi:"samplingRate"`
}

// Describes Dolby Digital Audio Codec (AC3) audio encoding settings. The current implementation for Dolby Digital Audio support are: Audio channel numbers at 1((mono), 2(stereo), 6(5.1side); Audio sampling frequency rates at: 32K/44.1K/48K Hz; Audio bitrate values as AC3 specification supports: 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000, 384000, 448000, 512000, 576000, 640000 bps.
type DDAudioResponseOutput struct{ *pulumi.OutputState }

func (DDAudioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DDAudioResponse)(nil)).Elem()
}

func (o DDAudioResponseOutput) ToDDAudioResponseOutput() DDAudioResponseOutput {
	return o
}

func (o DDAudioResponseOutput) ToDDAudioResponseOutputWithContext(ctx context.Context) DDAudioResponseOutput {
	return o
}

// The bitrate, in bits per second, of the output encoded audio.
func (o DDAudioResponseOutput) Bitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DDAudioResponse) *int { return v.Bitrate }).(pulumi.IntPtrOutput)
}

// The number of channels in the audio.
func (o DDAudioResponseOutput) Channels() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DDAudioResponse) *int { return v.Channels }).(pulumi.IntPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o DDAudioResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DDAudioResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.DDAudio'.
func (o DDAudioResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v DDAudioResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The sampling rate to use for encoding in hertz.
func (o DDAudioResponseOutput) SamplingRate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DDAudioResponse) *int { return v.SamplingRate }).(pulumi.IntPtrOutput)
}

// The DASH setting for a track.
type DashSettings struct {
	// The role for the DASH setting.
	Role *string `pulumi:"role"`
}

// DashSettingsInput is an input type that accepts DashSettingsArgs and DashSettingsOutput values.
// You can construct a concrete instance of `DashSettingsInput` via:
//
//	DashSettingsArgs{...}
type DashSettingsInput interface {
	pulumi.Input

	ToDashSettingsOutput() DashSettingsOutput
	ToDashSettingsOutputWithContext(context.Context) DashSettingsOutput
}

// The DASH setting for a track.
type DashSettingsArgs struct {
	// The role for the DASH setting.
	Role pulumi.StringPtrInput `pulumi:"role"`
}

func (DashSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DashSettings)(nil)).Elem()
}

func (i DashSettingsArgs) ToDashSettingsOutput() DashSettingsOutput {
	return i.ToDashSettingsOutputWithContext(context.Background())
}

func (i DashSettingsArgs) ToDashSettingsOutputWithContext(ctx context.Context) DashSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DashSettingsOutput)
}

func (i DashSettingsArgs) ToDashSettingsPtrOutput() DashSettingsPtrOutput {
	return i.ToDashSettingsPtrOutputWithContext(context.Background())
}

func (i DashSettingsArgs) ToDashSettingsPtrOutputWithContext(ctx context.Context) DashSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DashSettingsOutput).ToDashSettingsPtrOutputWithContext(ctx)
}

// DashSettingsPtrInput is an input type that accepts DashSettingsArgs, DashSettingsPtr and DashSettingsPtrOutput values.
// You can construct a concrete instance of `DashSettingsPtrInput` via:
//
//	        DashSettingsArgs{...}
//
//	or:
//
//	        nil
type DashSettingsPtrInput interface {
	pulumi.Input

	ToDashSettingsPtrOutput() DashSettingsPtrOutput
	ToDashSettingsPtrOutputWithContext(context.Context) DashSettingsPtrOutput
}

type dashSettingsPtrType DashSettingsArgs

func DashSettingsPtr(v *DashSettingsArgs) DashSettingsPtrInput {
	return (*dashSettingsPtrType)(v)
}

func (*dashSettingsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DashSettings)(nil)).Elem()
}

func (i *dashSettingsPtrType) ToDashSettingsPtrOutput() DashSettingsPtrOutput {
	return i.ToDashSettingsPtrOutputWithContext(context.Background())
}

func (i *dashSettingsPtrType) ToDashSettingsPtrOutputWithContext(ctx context.Context) DashSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DashSettingsPtrOutput)
}

// The DASH setting for a track.
type DashSettingsOutput struct{ *pulumi.OutputState }

func (DashSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DashSettings)(nil)).Elem()
}

func (o DashSettingsOutput) ToDashSettingsOutput() DashSettingsOutput {
	return o
}

func (o DashSettingsOutput) ToDashSettingsOutputWithContext(ctx context.Context) DashSettingsOutput {
	return o
}

func (o DashSettingsOutput) ToDashSettingsPtrOutput() DashSettingsPtrOutput {
	return o.ToDashSettingsPtrOutputWithContext(context.Background())
}

func (o DashSettingsOutput) ToDashSettingsPtrOutputWithContext(ctx context.Context) DashSettingsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DashSettings) *DashSettings {
		return &v
	}).(DashSettingsPtrOutput)
}

// The role for the DASH setting.
func (o DashSettingsOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DashSettings) *string { return v.Role }).(pulumi.StringPtrOutput)
}

type DashSettingsPtrOutput struct{ *pulumi.OutputState }

func (DashSettingsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DashSettings)(nil)).Elem()
}

func (o DashSettingsPtrOutput) ToDashSettingsPtrOutput() DashSettingsPtrOutput {
	return o
}

func (o DashSettingsPtrOutput) ToDashSettingsPtrOutputWithContext(ctx context.Context) DashSettingsPtrOutput {
	return o
}

func (o DashSettingsPtrOutput) Elem() DashSettingsOutput {
	return o.ApplyT(func(v *DashSettings) DashSettings {
		if v != nil {
			return *v
		}
		var ret DashSettings
		return ret
	}).(DashSettingsOutput)
}

// The role for the DASH setting.
func (o DashSettingsPtrOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DashSettings) *string {
		if v == nil {
			return nil
		}
		return v.Role
	}).(pulumi.StringPtrOutput)
}

// The DASH setting for a track.
type DashSettingsResponse struct {
	// The role for the DASH setting.
	Role *string `pulumi:"role"`
}

// The DASH setting for a track.
type DashSettingsResponseOutput struct{ *pulumi.OutputState }

func (DashSettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DashSettingsResponse)(nil)).Elem()
}

func (o DashSettingsResponseOutput) ToDashSettingsResponseOutput() DashSettingsResponseOutput {
	return o
}

func (o DashSettingsResponseOutput) ToDashSettingsResponseOutputWithContext(ctx context.Context) DashSettingsResponseOutput {
	return o
}

// The role for the DASH setting.
func (o DashSettingsResponseOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DashSettingsResponse) *string { return v.Role }).(pulumi.StringPtrOutput)
}

type DashSettingsResponsePtrOutput struct{ *pulumi.OutputState }

func (DashSettingsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DashSettingsResponse)(nil)).Elem()
}

func (o DashSettingsResponsePtrOutput) ToDashSettingsResponsePtrOutput() DashSettingsResponsePtrOutput {
	return o
}

func (o DashSettingsResponsePtrOutput) ToDashSettingsResponsePtrOutputWithContext(ctx context.Context) DashSettingsResponsePtrOutput {
	return o
}

func (o DashSettingsResponsePtrOutput) Elem() DashSettingsResponseOutput {
	return o.ApplyT(func(v *DashSettingsResponse) DashSettingsResponse {
		if v != nil {
			return *v
		}
		var ret DashSettingsResponse
		return ret
	}).(DashSettingsResponseOutput)
}

// The role for the DASH setting.
func (o DashSettingsResponsePtrOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DashSettingsResponse) *string {
		if v == nil {
			return nil
		}
		return v.Role
	}).(pulumi.StringPtrOutput)
}

// Class to specify properties of default content key for each encryption scheme
type DefaultKey struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `pulumi:"label"`
	// Policy used by Default Key
	PolicyName *string `pulumi:"policyName"`
}

// DefaultKeyInput is an input type that accepts DefaultKeyArgs and DefaultKeyOutput values.
// You can construct a concrete instance of `DefaultKeyInput` via:
//
//	DefaultKeyArgs{...}
type DefaultKeyInput interface {
	pulumi.Input

	ToDefaultKeyOutput() DefaultKeyOutput
	ToDefaultKeyOutputWithContext(context.Context) DefaultKeyOutput
}

// Class to specify properties of default content key for each encryption scheme
type DefaultKeyArgs struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label pulumi.StringPtrInput `pulumi:"label"`
	// Policy used by Default Key
	PolicyName pulumi.StringPtrInput `pulumi:"policyName"`
}

func (DefaultKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DefaultKey)(nil)).Elem()
}

func (i DefaultKeyArgs) ToDefaultKeyOutput() DefaultKeyOutput {
	return i.ToDefaultKeyOutputWithContext(context.Background())
}

func (i DefaultKeyArgs) ToDefaultKeyOutputWithContext(ctx context.Context) DefaultKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DefaultKeyOutput)
}

func (i DefaultKeyArgs) ToDefaultKeyPtrOutput() DefaultKeyPtrOutput {
	return i.ToDefaultKeyPtrOutputWithContext(context.Background())
}

func (i DefaultKeyArgs) ToDefaultKeyPtrOutputWithContext(ctx context.Context) DefaultKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DefaultKeyOutput).ToDefaultKeyPtrOutputWithContext(ctx)
}

// DefaultKeyPtrInput is an input type that accepts DefaultKeyArgs, DefaultKeyPtr and DefaultKeyPtrOutput values.
// You can construct a concrete instance of `DefaultKeyPtrInput` via:
//
//	        DefaultKeyArgs{...}
//
//	or:
//
//	        nil
type DefaultKeyPtrInput interface {
	pulumi.Input

	ToDefaultKeyPtrOutput() DefaultKeyPtrOutput
	ToDefaultKeyPtrOutputWithContext(context.Context) DefaultKeyPtrOutput
}

type defaultKeyPtrType DefaultKeyArgs

func DefaultKeyPtr(v *DefaultKeyArgs) DefaultKeyPtrInput {
	return (*defaultKeyPtrType)(v)
}

func (*defaultKeyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DefaultKey)(nil)).Elem()
}

func (i *defaultKeyPtrType) ToDefaultKeyPtrOutput() DefaultKeyPtrOutput {
	return i.ToDefaultKeyPtrOutputWithContext(context.Background())
}

func (i *defaultKeyPtrType) ToDefaultKeyPtrOutputWithContext(ctx context.Context) DefaultKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DefaultKeyPtrOutput)
}

// Class to specify properties of default content key for each encryption scheme
type DefaultKeyOutput struct{ *pulumi.OutputState }

func (DefaultKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DefaultKey)(nil)).Elem()
}

func (o DefaultKeyOutput) ToDefaultKeyOutput() DefaultKeyOutput {
	return o
}

func (o DefaultKeyOutput) ToDefaultKeyOutputWithContext(ctx context.Context) DefaultKeyOutput {
	return o
}

func (o DefaultKeyOutput) ToDefaultKeyPtrOutput() DefaultKeyPtrOutput {
	return o.ToDefaultKeyPtrOutputWithContext(context.Background())
}

func (o DefaultKeyOutput) ToDefaultKeyPtrOutputWithContext(ctx context.Context) DefaultKeyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DefaultKey) *DefaultKey {
		return &v
	}).(DefaultKeyPtrOutput)
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o DefaultKeyOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DefaultKey) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// Policy used by Default Key
func (o DefaultKeyOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DefaultKey) *string { return v.PolicyName }).(pulumi.StringPtrOutput)
}

type DefaultKeyPtrOutput struct{ *pulumi.OutputState }

func (DefaultKeyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DefaultKey)(nil)).Elem()
}

func (o DefaultKeyPtrOutput) ToDefaultKeyPtrOutput() DefaultKeyPtrOutput {
	return o
}

func (o DefaultKeyPtrOutput) ToDefaultKeyPtrOutputWithContext(ctx context.Context) DefaultKeyPtrOutput {
	return o
}

func (o DefaultKeyPtrOutput) Elem() DefaultKeyOutput {
	return o.ApplyT(func(v *DefaultKey) DefaultKey {
		if v != nil {
			return *v
		}
		var ret DefaultKey
		return ret
	}).(DefaultKeyOutput)
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o DefaultKeyPtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DefaultKey) *string {
		if v == nil {
			return nil
		}
		return v.Label
	}).(pulumi.StringPtrOutput)
}

// Policy used by Default Key
func (o DefaultKeyPtrOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DefaultKey) *string {
		if v == nil {
			return nil
		}
		return v.PolicyName
	}).(pulumi.StringPtrOutput)
}

// Class to specify properties of default content key for each encryption scheme
type DefaultKeyResponse struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `pulumi:"label"`
	// Policy used by Default Key
	PolicyName *string `pulumi:"policyName"`
}

// Class to specify properties of default content key for each encryption scheme
type DefaultKeyResponseOutput struct{ *pulumi.OutputState }

func (DefaultKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DefaultKeyResponse)(nil)).Elem()
}

func (o DefaultKeyResponseOutput) ToDefaultKeyResponseOutput() DefaultKeyResponseOutput {
	return o
}

func (o DefaultKeyResponseOutput) ToDefaultKeyResponseOutputWithContext(ctx context.Context) DefaultKeyResponseOutput {
	return o
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o DefaultKeyResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DefaultKeyResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// Policy used by Default Key
func (o DefaultKeyResponseOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DefaultKeyResponse) *string { return v.PolicyName }).(pulumi.StringPtrOutput)
}

type DefaultKeyResponsePtrOutput struct{ *pulumi.OutputState }

func (DefaultKeyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DefaultKeyResponse)(nil)).Elem()
}

func (o DefaultKeyResponsePtrOutput) ToDefaultKeyResponsePtrOutput() DefaultKeyResponsePtrOutput {
	return o
}

func (o DefaultKeyResponsePtrOutput) ToDefaultKeyResponsePtrOutputWithContext(ctx context.Context) DefaultKeyResponsePtrOutput {
	return o
}

func (o DefaultKeyResponsePtrOutput) Elem() DefaultKeyResponseOutput {
	return o.ApplyT(func(v *DefaultKeyResponse) DefaultKeyResponse {
		if v != nil {
			return *v
		}
		var ret DefaultKeyResponse
		return ret
	}).(DefaultKeyResponseOutput)
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o DefaultKeyResponsePtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DefaultKeyResponse) *string {
		if v == nil {
			return nil
		}
		return v.Label
	}).(pulumi.StringPtrOutput)
}

// Policy used by Default Key
func (o DefaultKeyResponsePtrOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DefaultKeyResponse) *string {
		if v == nil {
			return nil
		}
		return v.PolicyName
	}).(pulumi.StringPtrOutput)
}

// Describes the de-interlacing settings.
type Deinterlace struct {
	// The deinterlacing mode. Defaults to AutoPixelAdaptive.
	Mode *string `pulumi:"mode"`
	// The field parity for de-interlacing, defaults to Auto.
	Parity *string `pulumi:"parity"`
}

// DeinterlaceInput is an input type that accepts DeinterlaceArgs and DeinterlaceOutput values.
// You can construct a concrete instance of `DeinterlaceInput` via:
//
//	DeinterlaceArgs{...}
type DeinterlaceInput interface {
	pulumi.Input

	ToDeinterlaceOutput() DeinterlaceOutput
	ToDeinterlaceOutputWithContext(context.Context) DeinterlaceOutput
}

// Describes the de-interlacing settings.
type DeinterlaceArgs struct {
	// The deinterlacing mode. Defaults to AutoPixelAdaptive.
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// The field parity for de-interlacing, defaults to Auto.
	Parity pulumi.StringPtrInput `pulumi:"parity"`
}

func (DeinterlaceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Deinterlace)(nil)).Elem()
}

func (i DeinterlaceArgs) ToDeinterlaceOutput() DeinterlaceOutput {
	return i.ToDeinterlaceOutputWithContext(context.Background())
}

func (i DeinterlaceArgs) ToDeinterlaceOutputWithContext(ctx context.Context) DeinterlaceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeinterlaceOutput)
}

func (i DeinterlaceArgs) ToDeinterlacePtrOutput() DeinterlacePtrOutput {
	return i.ToDeinterlacePtrOutputWithContext(context.Background())
}

func (i DeinterlaceArgs) ToDeinterlacePtrOutputWithContext(ctx context.Context) DeinterlacePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeinterlaceOutput).ToDeinterlacePtrOutputWithContext(ctx)
}

// DeinterlacePtrInput is an input type that accepts DeinterlaceArgs, DeinterlacePtr and DeinterlacePtrOutput values.
// You can construct a concrete instance of `DeinterlacePtrInput` via:
//
//	        DeinterlaceArgs{...}
//
//	or:
//
//	        nil
type DeinterlacePtrInput interface {
	pulumi.Input

	ToDeinterlacePtrOutput() DeinterlacePtrOutput
	ToDeinterlacePtrOutputWithContext(context.Context) DeinterlacePtrOutput
}

type deinterlacePtrType DeinterlaceArgs

func DeinterlacePtr(v *DeinterlaceArgs) DeinterlacePtrInput {
	return (*deinterlacePtrType)(v)
}

func (*deinterlacePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Deinterlace)(nil)).Elem()
}

func (i *deinterlacePtrType) ToDeinterlacePtrOutput() DeinterlacePtrOutput {
	return i.ToDeinterlacePtrOutputWithContext(context.Background())
}

func (i *deinterlacePtrType) ToDeinterlacePtrOutputWithContext(ctx context.Context) DeinterlacePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeinterlacePtrOutput)
}

// Describes the de-interlacing settings.
type DeinterlaceOutput struct{ *pulumi.OutputState }

func (DeinterlaceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Deinterlace)(nil)).Elem()
}

func (o DeinterlaceOutput) ToDeinterlaceOutput() DeinterlaceOutput {
	return o
}

func (o DeinterlaceOutput) ToDeinterlaceOutputWithContext(ctx context.Context) DeinterlaceOutput {
	return o
}

func (o DeinterlaceOutput) ToDeinterlacePtrOutput() DeinterlacePtrOutput {
	return o.ToDeinterlacePtrOutputWithContext(context.Background())
}

func (o DeinterlaceOutput) ToDeinterlacePtrOutputWithContext(ctx context.Context) DeinterlacePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Deinterlace) *Deinterlace {
		return &v
	}).(DeinterlacePtrOutput)
}

// The deinterlacing mode. Defaults to AutoPixelAdaptive.
func (o DeinterlaceOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Deinterlace) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// The field parity for de-interlacing, defaults to Auto.
func (o DeinterlaceOutput) Parity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Deinterlace) *string { return v.Parity }).(pulumi.StringPtrOutput)
}

type DeinterlacePtrOutput struct{ *pulumi.OutputState }

func (DeinterlacePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Deinterlace)(nil)).Elem()
}

func (o DeinterlacePtrOutput) ToDeinterlacePtrOutput() DeinterlacePtrOutput {
	return o
}

func (o DeinterlacePtrOutput) ToDeinterlacePtrOutputWithContext(ctx context.Context) DeinterlacePtrOutput {
	return o
}

func (o DeinterlacePtrOutput) Elem() DeinterlaceOutput {
	return o.ApplyT(func(v *Deinterlace) Deinterlace {
		if v != nil {
			return *v
		}
		var ret Deinterlace
		return ret
	}).(DeinterlaceOutput)
}

// The deinterlacing mode. Defaults to AutoPixelAdaptive.
func (o DeinterlacePtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Deinterlace) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// The field parity for de-interlacing, defaults to Auto.
func (o DeinterlacePtrOutput) Parity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Deinterlace) *string {
		if v == nil {
			return nil
		}
		return v.Parity
	}).(pulumi.StringPtrOutput)
}

// Describes the de-interlacing settings.
type DeinterlaceResponse struct {
	// The deinterlacing mode. Defaults to AutoPixelAdaptive.
	Mode *string `pulumi:"mode"`
	// The field parity for de-interlacing, defaults to Auto.
	Parity *string `pulumi:"parity"`
}

// Describes the de-interlacing settings.
type DeinterlaceResponseOutput struct{ *pulumi.OutputState }

func (DeinterlaceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeinterlaceResponse)(nil)).Elem()
}

func (o DeinterlaceResponseOutput) ToDeinterlaceResponseOutput() DeinterlaceResponseOutput {
	return o
}

func (o DeinterlaceResponseOutput) ToDeinterlaceResponseOutputWithContext(ctx context.Context) DeinterlaceResponseOutput {
	return o
}

// The deinterlacing mode. Defaults to AutoPixelAdaptive.
func (o DeinterlaceResponseOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeinterlaceResponse) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// The field parity for de-interlacing, defaults to Auto.
func (o DeinterlaceResponseOutput) Parity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeinterlaceResponse) *string { return v.Parity }).(pulumi.StringPtrOutput)
}

type DeinterlaceResponsePtrOutput struct{ *pulumi.OutputState }

func (DeinterlaceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeinterlaceResponse)(nil)).Elem()
}

func (o DeinterlaceResponsePtrOutput) ToDeinterlaceResponsePtrOutput() DeinterlaceResponsePtrOutput {
	return o
}

func (o DeinterlaceResponsePtrOutput) ToDeinterlaceResponsePtrOutputWithContext(ctx context.Context) DeinterlaceResponsePtrOutput {
	return o
}

func (o DeinterlaceResponsePtrOutput) Elem() DeinterlaceResponseOutput {
	return o.ApplyT(func(v *DeinterlaceResponse) DeinterlaceResponse {
		if v != nil {
			return *v
		}
		var ret DeinterlaceResponse
		return ret
	}).(DeinterlaceResponseOutput)
}

// The deinterlacing mode. Defaults to AutoPixelAdaptive.
func (o DeinterlaceResponsePtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeinterlaceResponse) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// The field parity for de-interlacing, defaults to Auto.
func (o DeinterlaceResponsePtrOutput) Parity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeinterlaceResponse) *string {
		if v == nil {
			return nil
		}
		return v.Parity
	}).(pulumi.StringPtrOutput)
}

type EdgeUsageDataCollectionPolicyResponse struct {
	// Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
	DataCollectionFrequency *string `pulumi:"dataCollectionFrequency"`
	// Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
	DataReportingFrequency *string `pulumi:"dataReportingFrequency"`
	// Details of Event Hub where the usage will be reported.
	EventHubDetails *EdgeUsageDataEventHubResponse `pulumi:"eventHubDetails"`
	// Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
	MaxAllowedUnreportedUsageDuration *string `pulumi:"maxAllowedUnreportedUsageDuration"`
}

type EdgeUsageDataCollectionPolicyResponseOutput struct{ *pulumi.OutputState }

func (EdgeUsageDataCollectionPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EdgeUsageDataCollectionPolicyResponse)(nil)).Elem()
}

func (o EdgeUsageDataCollectionPolicyResponseOutput) ToEdgeUsageDataCollectionPolicyResponseOutput() EdgeUsageDataCollectionPolicyResponseOutput {
	return o
}

func (o EdgeUsageDataCollectionPolicyResponseOutput) ToEdgeUsageDataCollectionPolicyResponseOutputWithContext(ctx context.Context) EdgeUsageDataCollectionPolicyResponseOutput {
	return o
}

// Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
func (o EdgeUsageDataCollectionPolicyResponseOutput) DataCollectionFrequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataCollectionPolicyResponse) *string { return v.DataCollectionFrequency }).(pulumi.StringPtrOutput)
}

// Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
func (o EdgeUsageDataCollectionPolicyResponseOutput) DataReportingFrequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataCollectionPolicyResponse) *string { return v.DataReportingFrequency }).(pulumi.StringPtrOutput)
}

// Details of Event Hub where the usage will be reported.
func (o EdgeUsageDataCollectionPolicyResponseOutput) EventHubDetails() EdgeUsageDataEventHubResponsePtrOutput {
	return o.ApplyT(func(v EdgeUsageDataCollectionPolicyResponse) *EdgeUsageDataEventHubResponse { return v.EventHubDetails }).(EdgeUsageDataEventHubResponsePtrOutput)
}

// Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
func (o EdgeUsageDataCollectionPolicyResponseOutput) MaxAllowedUnreportedUsageDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataCollectionPolicyResponse) *string { return v.MaxAllowedUnreportedUsageDuration }).(pulumi.StringPtrOutput)
}

type EdgeUsageDataCollectionPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (EdgeUsageDataCollectionPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EdgeUsageDataCollectionPolicyResponse)(nil)).Elem()
}

func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) ToEdgeUsageDataCollectionPolicyResponsePtrOutput() EdgeUsageDataCollectionPolicyResponsePtrOutput {
	return o
}

func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) ToEdgeUsageDataCollectionPolicyResponsePtrOutputWithContext(ctx context.Context) EdgeUsageDataCollectionPolicyResponsePtrOutput {
	return o
}

func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) Elem() EdgeUsageDataCollectionPolicyResponseOutput {
	return o.ApplyT(func(v *EdgeUsageDataCollectionPolicyResponse) EdgeUsageDataCollectionPolicyResponse {
		if v != nil {
			return *v
		}
		var ret EdgeUsageDataCollectionPolicyResponse
		return ret
	}).(EdgeUsageDataCollectionPolicyResponseOutput)
}

// Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) DataCollectionFrequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataCollectionPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return v.DataCollectionFrequency
	}).(pulumi.StringPtrOutput)
}

// Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) DataReportingFrequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataCollectionPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return v.DataReportingFrequency
	}).(pulumi.StringPtrOutput)
}

// Details of Event Hub where the usage will be reported.
func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) EventHubDetails() EdgeUsageDataEventHubResponsePtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataCollectionPolicyResponse) *EdgeUsageDataEventHubResponse {
		if v == nil {
			return nil
		}
		return v.EventHubDetails
	}).(EdgeUsageDataEventHubResponsePtrOutput)
}

// Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) MaxAllowedUnreportedUsageDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataCollectionPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return v.MaxAllowedUnreportedUsageDuration
	}).(pulumi.StringPtrOutput)
}

type EdgeUsageDataEventHubResponse struct {
	// Name of the Event Hub where usage will be reported.
	Name *string `pulumi:"name"`
	// Namespace of the Event Hub where usage will be reported.
	Namespace *string `pulumi:"namespace"`
	// SAS token needed to interact with Event Hub.
	Token *string `pulumi:"token"`
}

type EdgeUsageDataEventHubResponseOutput struct{ *pulumi.OutputState }

func (EdgeUsageDataEventHubResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EdgeUsageDataEventHubResponse)(nil)).Elem()
}

func (o EdgeUsageDataEventHubResponseOutput) ToEdgeUsageDataEventHubResponseOutput() EdgeUsageDataEventHubResponseOutput {
	return o
}

func (o EdgeUsageDataEventHubResponseOutput) ToEdgeUsageDataEventHubResponseOutputWithContext(ctx context.Context) EdgeUsageDataEventHubResponseOutput {
	return o
}

// Name of the Event Hub where usage will be reported.
func (o EdgeUsageDataEventHubResponseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataEventHubResponse) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Event Hub where usage will be reported.
func (o EdgeUsageDataEventHubResponseOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataEventHubResponse) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SAS token needed to interact with Event Hub.
func (o EdgeUsageDataEventHubResponseOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataEventHubResponse) *string { return v.Token }).(pulumi.StringPtrOutput)
}

type EdgeUsageDataEventHubResponsePtrOutput struct{ *pulumi.OutputState }

func (EdgeUsageDataEventHubResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EdgeUsageDataEventHubResponse)(nil)).Elem()
}

func (o EdgeUsageDataEventHubResponsePtrOutput) ToEdgeUsageDataEventHubResponsePtrOutput() EdgeUsageDataEventHubResponsePtrOutput {
	return o
}

func (o EdgeUsageDataEventHubResponsePtrOutput) ToEdgeUsageDataEventHubResponsePtrOutputWithContext(ctx context.Context) EdgeUsageDataEventHubResponsePtrOutput {
	return o
}

func (o EdgeUsageDataEventHubResponsePtrOutput) Elem() EdgeUsageDataEventHubResponseOutput {
	return o.ApplyT(func(v *EdgeUsageDataEventHubResponse) EdgeUsageDataEventHubResponse {
		if v != nil {
			return *v
		}
		var ret EdgeUsageDataEventHubResponse
		return ret
	}).(EdgeUsageDataEventHubResponseOutput)
}

// Name of the Event Hub where usage will be reported.
func (o EdgeUsageDataEventHubResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataEventHubResponse) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the Event Hub where usage will be reported.
func (o EdgeUsageDataEventHubResponsePtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataEventHubResponse) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// SAS token needed to interact with Event Hub.
func (o EdgeUsageDataEventHubResponsePtrOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataEventHubResponse) *string {
		if v == nil {
			return nil
		}
		return v.Token
	}).(pulumi.StringPtrOutput)
}

// Class to specify which protocols are enabled
type EnabledProtocols struct {
	// Enable DASH protocol or not
	Dash bool `pulumi:"dash"`
	// Enable Download protocol or not
	Download bool `pulumi:"download"`
	// Enable HLS protocol or not
	Hls bool `pulumi:"hls"`
	// Enable SmoothStreaming protocol or not
	SmoothStreaming bool `pulumi:"smoothStreaming"`
}

// EnabledProtocolsInput is an input type that accepts EnabledProtocolsArgs and EnabledProtocolsOutput values.
// You can construct a concrete instance of `EnabledProtocolsInput` via:
//
//	EnabledProtocolsArgs{...}
type EnabledProtocolsInput interface {
	pulumi.Input

	ToEnabledProtocolsOutput() EnabledProtocolsOutput
	ToEnabledProtocolsOutputWithContext(context.Context) EnabledProtocolsOutput
}

// Class to specify which protocols are enabled
type EnabledProtocolsArgs struct {
	// Enable DASH protocol or not
	Dash pulumi.BoolInput `pulumi:"dash"`
	// Enable Download protocol or not
	Download pulumi.BoolInput `pulumi:"download"`
	// Enable HLS protocol or not
	Hls pulumi.BoolInput `pulumi:"hls"`
	// Enable SmoothStreaming protocol or not
	SmoothStreaming pulumi.BoolInput `pulumi:"smoothStreaming"`
}

func (EnabledProtocolsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnabledProtocols)(nil)).Elem()
}

func (i EnabledProtocolsArgs) ToEnabledProtocolsOutput() EnabledProtocolsOutput {
	return i.ToEnabledProtocolsOutputWithContext(context.Background())
}

func (i EnabledProtocolsArgs) ToEnabledProtocolsOutputWithContext(ctx context.Context) EnabledProtocolsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnabledProtocolsOutput)
}

func (i EnabledProtocolsArgs) ToEnabledProtocolsPtrOutput() EnabledProtocolsPtrOutput {
	return i.ToEnabledProtocolsPtrOutputWithContext(context.Background())
}

func (i EnabledProtocolsArgs) ToEnabledProtocolsPtrOutputWithContext(ctx context.Context) EnabledProtocolsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnabledProtocolsOutput).ToEnabledProtocolsPtrOutputWithContext(ctx)
}

// EnabledProtocolsPtrInput is an input type that accepts EnabledProtocolsArgs, EnabledProtocolsPtr and EnabledProtocolsPtrOutput values.
// You can construct a concrete instance of `EnabledProtocolsPtrInput` via:
//
//	        EnabledProtocolsArgs{...}
//
//	or:
//
//	        nil
type EnabledProtocolsPtrInput interface {
	pulumi.Input

	ToEnabledProtocolsPtrOutput() EnabledProtocolsPtrOutput
	ToEnabledProtocolsPtrOutputWithContext(context.Context) EnabledProtocolsPtrOutput
}

type enabledProtocolsPtrType EnabledProtocolsArgs

func EnabledProtocolsPtr(v *EnabledProtocolsArgs) EnabledProtocolsPtrInput {
	return (*enabledProtocolsPtrType)(v)
}

func (*enabledProtocolsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EnabledProtocols)(nil)).Elem()
}

func (i *enabledProtocolsPtrType) ToEnabledProtocolsPtrOutput() EnabledProtocolsPtrOutput {
	return i.ToEnabledProtocolsPtrOutputWithContext(context.Background())
}

func (i *enabledProtocolsPtrType) ToEnabledProtocolsPtrOutputWithContext(ctx context.Context) EnabledProtocolsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnabledProtocolsPtrOutput)
}

// Class to specify which protocols are enabled
type EnabledProtocolsOutput struct{ *pulumi.OutputState }

func (EnabledProtocolsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnabledProtocols)(nil)).Elem()
}

func (o EnabledProtocolsOutput) ToEnabledProtocolsOutput() EnabledProtocolsOutput {
	return o
}

func (o EnabledProtocolsOutput) ToEnabledProtocolsOutputWithContext(ctx context.Context) EnabledProtocolsOutput {
	return o
}

func (o EnabledProtocolsOutput) ToEnabledProtocolsPtrOutput() EnabledProtocolsPtrOutput {
	return o.ToEnabledProtocolsPtrOutputWithContext(context.Background())
}

func (o EnabledProtocolsOutput) ToEnabledProtocolsPtrOutputWithContext(ctx context.Context) EnabledProtocolsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EnabledProtocols) *EnabledProtocols {
		return &v
	}).(EnabledProtocolsPtrOutput)
}

// Enable DASH protocol or not
func (o EnabledProtocolsOutput) Dash() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocols) bool { return v.Dash }).(pulumi.BoolOutput)
}

// Enable Download protocol or not
func (o EnabledProtocolsOutput) Download() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocols) bool { return v.Download }).(pulumi.BoolOutput)
}

// Enable HLS protocol or not
func (o EnabledProtocolsOutput) Hls() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocols) bool { return v.Hls }).(pulumi.BoolOutput)
}

// Enable SmoothStreaming protocol or not
func (o EnabledProtocolsOutput) SmoothStreaming() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocols) bool { return v.SmoothStreaming }).(pulumi.BoolOutput)
}

type EnabledProtocolsPtrOutput struct{ *pulumi.OutputState }

func (EnabledProtocolsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EnabledProtocols)(nil)).Elem()
}

func (o EnabledProtocolsPtrOutput) ToEnabledProtocolsPtrOutput() EnabledProtocolsPtrOutput {
	return o
}

func (o EnabledProtocolsPtrOutput) ToEnabledProtocolsPtrOutputWithContext(ctx context.Context) EnabledProtocolsPtrOutput {
	return o
}

func (o EnabledProtocolsPtrOutput) Elem() EnabledProtocolsOutput {
	return o.ApplyT(func(v *EnabledProtocols) EnabledProtocols {
		if v != nil {
			return *v
		}
		var ret EnabledProtocols
		return ret
	}).(EnabledProtocolsOutput)
}

// Enable DASH protocol or not
func (o EnabledProtocolsPtrOutput) Dash() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocols) *bool {
		if v == nil {
			return nil
		}
		return &v.Dash
	}).(pulumi.BoolPtrOutput)
}

// Enable Download protocol or not
func (o EnabledProtocolsPtrOutput) Download() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocols) *bool {
		if v == nil {
			return nil
		}
		return &v.Download
	}).(pulumi.BoolPtrOutput)
}

// Enable HLS protocol or not
func (o EnabledProtocolsPtrOutput) Hls() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocols) *bool {
		if v == nil {
			return nil
		}
		return &v.Hls
	}).(pulumi.BoolPtrOutput)
}

// Enable SmoothStreaming protocol or not
func (o EnabledProtocolsPtrOutput) SmoothStreaming() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocols) *bool {
		if v == nil {
			return nil
		}
		return &v.SmoothStreaming
	}).(pulumi.BoolPtrOutput)
}

// Class to specify which protocols are enabled
type EnabledProtocolsResponse struct {
	// Enable DASH protocol or not
	Dash bool `pulumi:"dash"`
	// Enable Download protocol or not
	Download bool `pulumi:"download"`
	// Enable HLS protocol or not
	Hls bool `pulumi:"hls"`
	// Enable SmoothStreaming protocol or not
	SmoothStreaming bool `pulumi:"smoothStreaming"`
}

// Class to specify which protocols are enabled
type EnabledProtocolsResponseOutput struct{ *pulumi.OutputState }

func (EnabledProtocolsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnabledProtocolsResponse)(nil)).Elem()
}

func (o EnabledProtocolsResponseOutput) ToEnabledProtocolsResponseOutput() EnabledProtocolsResponseOutput {
	return o
}

func (o EnabledProtocolsResponseOutput) ToEnabledProtocolsResponseOutputWithContext(ctx context.Context) EnabledProtocolsResponseOutput {
	return o
}

// Enable DASH protocol or not
func (o EnabledProtocolsResponseOutput) Dash() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocolsResponse) bool { return v.Dash }).(pulumi.BoolOutput)
}

// Enable Download protocol or not
func (o EnabledProtocolsResponseOutput) Download() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocolsResponse) bool { return v.Download }).(pulumi.BoolOutput)
}

// Enable HLS protocol or not
func (o EnabledProtocolsResponseOutput) Hls() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocolsResponse) bool { return v.Hls }).(pulumi.BoolOutput)
}

// Enable SmoothStreaming protocol or not
func (o EnabledProtocolsResponseOutput) SmoothStreaming() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocolsResponse) bool { return v.SmoothStreaming }).(pulumi.BoolOutput)
}

type EnabledProtocolsResponsePtrOutput struct{ *pulumi.OutputState }

func (EnabledProtocolsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EnabledProtocolsResponse)(nil)).Elem()
}

func (o EnabledProtocolsResponsePtrOutput) ToEnabledProtocolsResponsePtrOutput() EnabledProtocolsResponsePtrOutput {
	return o
}

func (o EnabledProtocolsResponsePtrOutput) ToEnabledProtocolsResponsePtrOutputWithContext(ctx context.Context) EnabledProtocolsResponsePtrOutput {
	return o
}

func (o EnabledProtocolsResponsePtrOutput) Elem() EnabledProtocolsResponseOutput {
	return o.ApplyT(func(v *EnabledProtocolsResponse) EnabledProtocolsResponse {
		if v != nil {
			return *v
		}
		var ret EnabledProtocolsResponse
		return ret
	}).(EnabledProtocolsResponseOutput)
}

// Enable DASH protocol or not
func (o EnabledProtocolsResponsePtrOutput) Dash() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocolsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.Dash
	}).(pulumi.BoolPtrOutput)
}

// Enable Download protocol or not
func (o EnabledProtocolsResponsePtrOutput) Download() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocolsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.Download
	}).(pulumi.BoolPtrOutput)
}

// Enable HLS protocol or not
func (o EnabledProtocolsResponsePtrOutput) Hls() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocolsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.Hls
	}).(pulumi.BoolPtrOutput)
}

// Enable SmoothStreaming protocol or not
func (o EnabledProtocolsResponsePtrOutput) SmoothStreaming() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocolsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.SmoothStreaming
	}).(pulumi.BoolPtrOutput)
}

// Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryption struct {
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelection `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `pulumi:"contentKeys"`
	// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomKeyAcquisitionUrlTemplate *string `pulumi:"customKeyAcquisitionUrlTemplate"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `pulumi:"enabledProtocols"`
}

// EnvelopeEncryptionInput is an input type that accepts EnvelopeEncryptionArgs and EnvelopeEncryptionOutput values.
// You can construct a concrete instance of `EnvelopeEncryptionInput` via:
//
//	EnvelopeEncryptionArgs{...}
type EnvelopeEncryptionInput interface {
	pulumi.Input

	ToEnvelopeEncryptionOutput() EnvelopeEncryptionOutput
	ToEnvelopeEncryptionOutputWithContext(context.Context) EnvelopeEncryptionOutput
}

// Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryptionArgs struct {
	// Representing which tracks should not be encrypted
	ClearTracks TrackSelectionArrayInput `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys StreamingPolicyContentKeysPtrInput `pulumi:"contentKeys"`
	// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomKeyAcquisitionUrlTemplate pulumi.StringPtrInput `pulumi:"customKeyAcquisitionUrlTemplate"`
	// Representing supported protocols
	EnabledProtocols EnabledProtocolsPtrInput `pulumi:"enabledProtocols"`
}

func (EnvelopeEncryptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvelopeEncryption)(nil)).Elem()
}

func (i EnvelopeEncryptionArgs) ToEnvelopeEncryptionOutput() EnvelopeEncryptionOutput {
	return i.ToEnvelopeEncryptionOutputWithContext(context.Background())
}

func (i EnvelopeEncryptionArgs) ToEnvelopeEncryptionOutputWithContext(ctx context.Context) EnvelopeEncryptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvelopeEncryptionOutput)
}

func (i EnvelopeEncryptionArgs) ToEnvelopeEncryptionPtrOutput() EnvelopeEncryptionPtrOutput {
	return i.ToEnvelopeEncryptionPtrOutputWithContext(context.Background())
}

func (i EnvelopeEncryptionArgs) ToEnvelopeEncryptionPtrOutputWithContext(ctx context.Context) EnvelopeEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvelopeEncryptionOutput).ToEnvelopeEncryptionPtrOutputWithContext(ctx)
}

// EnvelopeEncryptionPtrInput is an input type that accepts EnvelopeEncryptionArgs, EnvelopeEncryptionPtr and EnvelopeEncryptionPtrOutput values.
// You can construct a concrete instance of `EnvelopeEncryptionPtrInput` via:
//
//	        EnvelopeEncryptionArgs{...}
//
//	or:
//
//	        nil
type EnvelopeEncryptionPtrInput interface {
	pulumi.Input

	ToEnvelopeEncryptionPtrOutput() EnvelopeEncryptionPtrOutput
	ToEnvelopeEncryptionPtrOutputWithContext(context.Context) EnvelopeEncryptionPtrOutput
}

type envelopeEncryptionPtrType EnvelopeEncryptionArgs

func EnvelopeEncryptionPtr(v *EnvelopeEncryptionArgs) EnvelopeEncryptionPtrInput {
	return (*envelopeEncryptionPtrType)(v)
}

func (*envelopeEncryptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvelopeEncryption)(nil)).Elem()
}

func (i *envelopeEncryptionPtrType) ToEnvelopeEncryptionPtrOutput() EnvelopeEncryptionPtrOutput {
	return i.ToEnvelopeEncryptionPtrOutputWithContext(context.Background())
}

func (i *envelopeEncryptionPtrType) ToEnvelopeEncryptionPtrOutputWithContext(ctx context.Context) EnvelopeEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvelopeEncryptionPtrOutput)
}

// Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryptionOutput struct{ *pulumi.OutputState }

func (EnvelopeEncryptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvelopeEncryption)(nil)).Elem()
}

func (o EnvelopeEncryptionOutput) ToEnvelopeEncryptionOutput() EnvelopeEncryptionOutput {
	return o
}

func (o EnvelopeEncryptionOutput) ToEnvelopeEncryptionOutputWithContext(ctx context.Context) EnvelopeEncryptionOutput {
	return o
}

func (o EnvelopeEncryptionOutput) ToEnvelopeEncryptionPtrOutput() EnvelopeEncryptionPtrOutput {
	return o.ToEnvelopeEncryptionPtrOutputWithContext(context.Background())
}

func (o EnvelopeEncryptionOutput) ToEnvelopeEncryptionPtrOutputWithContext(ctx context.Context) EnvelopeEncryptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EnvelopeEncryption) *EnvelopeEncryption {
		return &v
	}).(EnvelopeEncryptionPtrOutput)
}

// Representing which tracks should not be encrypted
func (o EnvelopeEncryptionOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v EnvelopeEncryption) []TrackSelection { return v.ClearTracks }).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o EnvelopeEncryptionOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v EnvelopeEncryption) *StreamingPolicyContentKeys { return v.ContentKeys }).(StreamingPolicyContentKeysPtrOutput)
}

// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o EnvelopeEncryptionOutput) CustomKeyAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvelopeEncryption) *string { return v.CustomKeyAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

// Representing supported protocols
func (o EnvelopeEncryptionOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v EnvelopeEncryption) *EnabledProtocols { return v.EnabledProtocols }).(EnabledProtocolsPtrOutput)
}

type EnvelopeEncryptionPtrOutput struct{ *pulumi.OutputState }

func (EnvelopeEncryptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvelopeEncryption)(nil)).Elem()
}

func (o EnvelopeEncryptionPtrOutput) ToEnvelopeEncryptionPtrOutput() EnvelopeEncryptionPtrOutput {
	return o
}

func (o EnvelopeEncryptionPtrOutput) ToEnvelopeEncryptionPtrOutputWithContext(ctx context.Context) EnvelopeEncryptionPtrOutput {
	return o
}

func (o EnvelopeEncryptionPtrOutput) Elem() EnvelopeEncryptionOutput {
	return o.ApplyT(func(v *EnvelopeEncryption) EnvelopeEncryption {
		if v != nil {
			return *v
		}
		var ret EnvelopeEncryption
		return ret
	}).(EnvelopeEncryptionOutput)
}

// Representing which tracks should not be encrypted
func (o EnvelopeEncryptionPtrOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v *EnvelopeEncryption) []TrackSelection {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o EnvelopeEncryptionPtrOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryption) *StreamingPolicyContentKeys {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysPtrOutput)
}

// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o EnvelopeEncryptionPtrOutput) CustomKeyAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryption) *string {
		if v == nil {
			return nil
		}
		return v.CustomKeyAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Representing supported protocols
func (o EnvelopeEncryptionPtrOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryption) *EnabledProtocols {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsPtrOutput)
}

// Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryptionResponse struct {
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelectionResponse `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeysResponse `pulumi:"contentKeys"`
	// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomKeyAcquisitionUrlTemplate *string `pulumi:"customKeyAcquisitionUrlTemplate"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocolsResponse `pulumi:"enabledProtocols"`
}

// Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryptionResponseOutput struct{ *pulumi.OutputState }

func (EnvelopeEncryptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvelopeEncryptionResponse)(nil)).Elem()
}

func (o EnvelopeEncryptionResponseOutput) ToEnvelopeEncryptionResponseOutput() EnvelopeEncryptionResponseOutput {
	return o
}

func (o EnvelopeEncryptionResponseOutput) ToEnvelopeEncryptionResponseOutputWithContext(ctx context.Context) EnvelopeEncryptionResponseOutput {
	return o
}

// Representing which tracks should not be encrypted
func (o EnvelopeEncryptionResponseOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v EnvelopeEncryptionResponse) []TrackSelectionResponse { return v.ClearTracks }).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o EnvelopeEncryptionResponseOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v EnvelopeEncryptionResponse) *StreamingPolicyContentKeysResponse { return v.ContentKeys }).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o EnvelopeEncryptionResponseOutput) CustomKeyAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvelopeEncryptionResponse) *string { return v.CustomKeyAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

// Representing supported protocols
func (o EnvelopeEncryptionResponseOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v EnvelopeEncryptionResponse) *EnabledProtocolsResponse { return v.EnabledProtocols }).(EnabledProtocolsResponsePtrOutput)
}

type EnvelopeEncryptionResponsePtrOutput struct{ *pulumi.OutputState }

func (EnvelopeEncryptionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvelopeEncryptionResponse)(nil)).Elem()
}

func (o EnvelopeEncryptionResponsePtrOutput) ToEnvelopeEncryptionResponsePtrOutput() EnvelopeEncryptionResponsePtrOutput {
	return o
}

func (o EnvelopeEncryptionResponsePtrOutput) ToEnvelopeEncryptionResponsePtrOutputWithContext(ctx context.Context) EnvelopeEncryptionResponsePtrOutput {
	return o
}

func (o EnvelopeEncryptionResponsePtrOutput) Elem() EnvelopeEncryptionResponseOutput {
	return o.ApplyT(func(v *EnvelopeEncryptionResponse) EnvelopeEncryptionResponse {
		if v != nil {
			return *v
		}
		var ret EnvelopeEncryptionResponse
		return ret
	}).(EnvelopeEncryptionResponseOutput)
}

// Representing which tracks should not be encrypted
func (o EnvelopeEncryptionResponsePtrOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v *EnvelopeEncryptionResponse) []TrackSelectionResponse {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o EnvelopeEncryptionResponsePtrOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryptionResponse) *StreamingPolicyContentKeysResponse {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o EnvelopeEncryptionResponsePtrOutput) CustomKeyAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryptionResponse) *string {
		if v == nil {
			return nil
		}
		return v.CustomKeyAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Representing supported protocols
func (o EnvelopeEncryptionResponsePtrOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryptionResponse) *EnabledProtocolsResponse {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsResponsePtrOutput)
}

// Describes all the settings to be used when analyzing a video in order to detect (and optionally redact) all the faces present.
type FaceDetectorPreset struct {
	// Blur type
	BlurType *string `pulumi:"blurType"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// This mode provides the ability to choose between the following settings: 1) Analyze - For detection only.This mode generates a metadata JSON file marking appearances of faces throughout the video.Where possible, appearances of the same person are assigned the same ID. 2) Combined - Additionally redacts(blurs) detected faces. 3) Redact - This enables a 2-pass process, allowing for selective redaction of a subset of detected faces.It takes in the metadata file from a prior analyze pass, along with the source video, and a user-selected subset of IDs that require redaction.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FaceDetectorPreset'.
	OdataType string `pulumi:"odataType"`
	// Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will keep the input video at its original resolution when analyzed. Using "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
	Resolution *string `pulumi:"resolution"`
}

// FaceDetectorPresetInput is an input type that accepts FaceDetectorPresetArgs and FaceDetectorPresetOutput values.
// You can construct a concrete instance of `FaceDetectorPresetInput` via:
//
//	FaceDetectorPresetArgs{...}
type FaceDetectorPresetInput interface {
	pulumi.Input

	ToFaceDetectorPresetOutput() FaceDetectorPresetOutput
	ToFaceDetectorPresetOutputWithContext(context.Context) FaceDetectorPresetOutput
}

// Describes all the settings to be used when analyzing a video in order to detect (and optionally redact) all the faces present.
type FaceDetectorPresetArgs struct {
	// Blur type
	BlurType pulumi.StringPtrInput `pulumi:"blurType"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions pulumi.StringMapInput `pulumi:"experimentalOptions"`
	// This mode provides the ability to choose between the following settings: 1) Analyze - For detection only.This mode generates a metadata JSON file marking appearances of faces throughout the video.Where possible, appearances of the same person are assigned the same ID. 2) Combined - Additionally redacts(blurs) detected faces. 3) Redact - This enables a 2-pass process, allowing for selective redaction of a subset of detected faces.It takes in the metadata file from a prior analyze pass, along with the source video, and a user-selected subset of IDs that require redaction.
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FaceDetectorPreset'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will keep the input video at its original resolution when analyzed. Using "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
	Resolution pulumi.StringPtrInput `pulumi:"resolution"`
}

func (FaceDetectorPresetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FaceDetectorPreset)(nil)).Elem()
}

func (i FaceDetectorPresetArgs) ToFaceDetectorPresetOutput() FaceDetectorPresetOutput {
	return i.ToFaceDetectorPresetOutputWithContext(context.Background())
}

func (i FaceDetectorPresetArgs) ToFaceDetectorPresetOutputWithContext(ctx context.Context) FaceDetectorPresetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FaceDetectorPresetOutput)
}

func (i FaceDetectorPresetArgs) ToFaceDetectorPresetPtrOutput() FaceDetectorPresetPtrOutput {
	return i.ToFaceDetectorPresetPtrOutputWithContext(context.Background())
}

func (i FaceDetectorPresetArgs) ToFaceDetectorPresetPtrOutputWithContext(ctx context.Context) FaceDetectorPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FaceDetectorPresetOutput).ToFaceDetectorPresetPtrOutputWithContext(ctx)
}

// FaceDetectorPresetPtrInput is an input type that accepts FaceDetectorPresetArgs, FaceDetectorPresetPtr and FaceDetectorPresetPtrOutput values.
// You can construct a concrete instance of `FaceDetectorPresetPtrInput` via:
//
//	        FaceDetectorPresetArgs{...}
//
//	or:
//
//	        nil
type FaceDetectorPresetPtrInput interface {
	pulumi.Input

	ToFaceDetectorPresetPtrOutput() FaceDetectorPresetPtrOutput
	ToFaceDetectorPresetPtrOutputWithContext(context.Context) FaceDetectorPresetPtrOutput
}

type faceDetectorPresetPtrType FaceDetectorPresetArgs

func FaceDetectorPresetPtr(v *FaceDetectorPresetArgs) FaceDetectorPresetPtrInput {
	return (*faceDetectorPresetPtrType)(v)
}

func (*faceDetectorPresetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FaceDetectorPreset)(nil)).Elem()
}

func (i *faceDetectorPresetPtrType) ToFaceDetectorPresetPtrOutput() FaceDetectorPresetPtrOutput {
	return i.ToFaceDetectorPresetPtrOutputWithContext(context.Background())
}

func (i *faceDetectorPresetPtrType) ToFaceDetectorPresetPtrOutputWithContext(ctx context.Context) FaceDetectorPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FaceDetectorPresetPtrOutput)
}

// Describes all the settings to be used when analyzing a video in order to detect (and optionally redact) all the faces present.
type FaceDetectorPresetOutput struct{ *pulumi.OutputState }

func (FaceDetectorPresetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FaceDetectorPreset)(nil)).Elem()
}

func (o FaceDetectorPresetOutput) ToFaceDetectorPresetOutput() FaceDetectorPresetOutput {
	return o
}

func (o FaceDetectorPresetOutput) ToFaceDetectorPresetOutputWithContext(ctx context.Context) FaceDetectorPresetOutput {
	return o
}

func (o FaceDetectorPresetOutput) ToFaceDetectorPresetPtrOutput() FaceDetectorPresetPtrOutput {
	return o.ToFaceDetectorPresetPtrOutputWithContext(context.Background())
}

func (o FaceDetectorPresetOutput) ToFaceDetectorPresetPtrOutputWithContext(ctx context.Context) FaceDetectorPresetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FaceDetectorPreset) *FaceDetectorPreset {
		return &v
	}).(FaceDetectorPresetPtrOutput)
}

// Blur type
func (o FaceDetectorPresetOutput) BlurType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FaceDetectorPreset) *string { return v.BlurType }).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o FaceDetectorPresetOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v FaceDetectorPreset) map[string]string { return v.ExperimentalOptions }).(pulumi.StringMapOutput)
}

// This mode provides the ability to choose between the following settings: 1) Analyze - For detection only.This mode generates a metadata JSON file marking appearances of faces throughout the video.Where possible, appearances of the same person are assigned the same ID. 2) Combined - Additionally redacts(blurs) detected faces. 3) Redact - This enables a 2-pass process, allowing for selective redaction of a subset of detected faces.It takes in the metadata file from a prior analyze pass, along with the source video, and a user-selected subset of IDs that require redaction.
func (o FaceDetectorPresetOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FaceDetectorPreset) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.FaceDetectorPreset'.
func (o FaceDetectorPresetOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v FaceDetectorPreset) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will keep the input video at its original resolution when analyzed. Using "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
func (o FaceDetectorPresetOutput) Resolution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FaceDetectorPreset) *string { return v.Resolution }).(pulumi.StringPtrOutput)
}

type FaceDetectorPresetPtrOutput struct{ *pulumi.OutputState }

func (FaceDetectorPresetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FaceDetectorPreset)(nil)).Elem()
}

func (o FaceDetectorPresetPtrOutput) ToFaceDetectorPresetPtrOutput() FaceDetectorPresetPtrOutput {
	return o
}

func (o FaceDetectorPresetPtrOutput) ToFaceDetectorPresetPtrOutputWithContext(ctx context.Context) FaceDetectorPresetPtrOutput {
	return o
}

func (o FaceDetectorPresetPtrOutput) Elem() FaceDetectorPresetOutput {
	return o.ApplyT(func(v *FaceDetectorPreset) FaceDetectorPreset {
		if v != nil {
			return *v
		}
		var ret FaceDetectorPreset
		return ret
	}).(FaceDetectorPresetOutput)
}

// Blur type
func (o FaceDetectorPresetPtrOutput) BlurType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FaceDetectorPreset) *string {
		if v == nil {
			return nil
		}
		return v.BlurType
	}).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o FaceDetectorPresetPtrOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *FaceDetectorPreset) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExperimentalOptions
	}).(pulumi.StringMapOutput)
}

// This mode provides the ability to choose between the following settings: 1) Analyze - For detection only.This mode generates a metadata JSON file marking appearances of faces throughout the video.Where possible, appearances of the same person are assigned the same ID. 2) Combined - Additionally redacts(blurs) detected faces. 3) Redact - This enables a 2-pass process, allowing for selective redaction of a subset of detected faces.It takes in the metadata file from a prior analyze pass, along with the source video, and a user-selected subset of IDs that require redaction.
func (o FaceDetectorPresetPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FaceDetectorPreset) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.FaceDetectorPreset'.
func (o FaceDetectorPresetPtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FaceDetectorPreset) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will keep the input video at its original resolution when analyzed. Using "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
func (o FaceDetectorPresetPtrOutput) Resolution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FaceDetectorPreset) *string {
		if v == nil {
			return nil
		}
		return v.Resolution
	}).(pulumi.StringPtrOutput)
}

// Describes all the settings to be used when analyzing a video in order to detect (and optionally redact) all the faces present.
type FaceDetectorPresetResponse struct {
	// Blur type
	BlurType *string `pulumi:"blurType"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// This mode provides the ability to choose between the following settings: 1) Analyze - For detection only.This mode generates a metadata JSON file marking appearances of faces throughout the video.Where possible, appearances of the same person are assigned the same ID. 2) Combined - Additionally redacts(blurs) detected faces. 3) Redact - This enables a 2-pass process, allowing for selective redaction of a subset of detected faces.It takes in the metadata file from a prior analyze pass, along with the source video, and a user-selected subset of IDs that require redaction.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FaceDetectorPreset'.
	OdataType string `pulumi:"odataType"`
	// Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will keep the input video at its original resolution when analyzed. Using "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
	Resolution *string `pulumi:"resolution"`
}

// Describes all the settings to be used when analyzing a video in order to detect (and optionally redact) all the faces present.
type FaceDetectorPresetResponseOutput struct{ *pulumi.OutputState }

func (FaceDetectorPresetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FaceDetectorPresetResponse)(nil)).Elem()
}

func (o FaceDetectorPresetResponseOutput) ToFaceDetectorPresetResponseOutput() FaceDetectorPresetResponseOutput {
	return o
}

func (o FaceDetectorPresetResponseOutput) ToFaceDetectorPresetResponseOutputWithContext(ctx context.Context) FaceDetectorPresetResponseOutput {
	return o
}

// Blur type
func (o FaceDetectorPresetResponseOutput) BlurType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FaceDetectorPresetResponse) *string { return v.BlurType }).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o FaceDetectorPresetResponseOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v FaceDetectorPresetResponse) map[string]string { return v.ExperimentalOptions }).(pulumi.StringMapOutput)
}

// This mode provides the ability to choose between the following settings: 1) Analyze - For detection only.This mode generates a metadata JSON file marking appearances of faces throughout the video.Where possible, appearances of the same person are assigned the same ID. 2) Combined - Additionally redacts(blurs) detected faces. 3) Redact - This enables a 2-pass process, allowing for selective redaction of a subset of detected faces.It takes in the metadata file from a prior analyze pass, along with the source video, and a user-selected subset of IDs that require redaction.
func (o FaceDetectorPresetResponseOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FaceDetectorPresetResponse) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.FaceDetectorPreset'.
func (o FaceDetectorPresetResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v FaceDetectorPresetResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will keep the input video at its original resolution when analyzed. Using "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
func (o FaceDetectorPresetResponseOutput) Resolution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FaceDetectorPresetResponse) *string { return v.Resolution }).(pulumi.StringPtrOutput)
}

type FaceDetectorPresetResponsePtrOutput struct{ *pulumi.OutputState }

func (FaceDetectorPresetResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FaceDetectorPresetResponse)(nil)).Elem()
}

func (o FaceDetectorPresetResponsePtrOutput) ToFaceDetectorPresetResponsePtrOutput() FaceDetectorPresetResponsePtrOutput {
	return o
}

func (o FaceDetectorPresetResponsePtrOutput) ToFaceDetectorPresetResponsePtrOutputWithContext(ctx context.Context) FaceDetectorPresetResponsePtrOutput {
	return o
}

func (o FaceDetectorPresetResponsePtrOutput) Elem() FaceDetectorPresetResponseOutput {
	return o.ApplyT(func(v *FaceDetectorPresetResponse) FaceDetectorPresetResponse {
		if v != nil {
			return *v
		}
		var ret FaceDetectorPresetResponse
		return ret
	}).(FaceDetectorPresetResponseOutput)
}

// Blur type
func (o FaceDetectorPresetResponsePtrOutput) BlurType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FaceDetectorPresetResponse) *string {
		if v == nil {
			return nil
		}
		return v.BlurType
	}).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o FaceDetectorPresetResponsePtrOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *FaceDetectorPresetResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExperimentalOptions
	}).(pulumi.StringMapOutput)
}

// This mode provides the ability to choose between the following settings: 1) Analyze - For detection only.This mode generates a metadata JSON file marking appearances of faces throughout the video.Where possible, appearances of the same person are assigned the same ID. 2) Combined - Additionally redacts(blurs) detected faces. 3) Redact - This enables a 2-pass process, allowing for selective redaction of a subset of detected faces.It takes in the metadata file from a prior analyze pass, along with the source video, and a user-selected subset of IDs that require redaction.
func (o FaceDetectorPresetResponsePtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FaceDetectorPresetResponse) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.FaceDetectorPreset'.
func (o FaceDetectorPresetResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FaceDetectorPresetResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will keep the input video at its original resolution when analyzed. Using "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
func (o FaceDetectorPresetResponsePtrOutput) Resolution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FaceDetectorPresetResponse) *string {
		if v == nil {
			return nil
		}
		return v.Resolution
	}).(pulumi.StringPtrOutput)
}

// Describes the properties of a Fade effect applied to the input media.
type Fade struct {
	// The Duration of the fade effect in the video. The value can be in ISO 8601 format (For example, PT05S to fade In/Out a color during 5 seconds), or a frame count (For example, 10 to fade 10 frames from the start time), or a relative value to stream duration (For example, 10% to fade 10% of stream duration)
	Duration string `pulumi:"duration"`
	// The Color for the fade In/Out. it can be on the CSS Level1 colors https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color_keywords or an RGB/hex value: e.g: rgb(255,0,0), 0xFF0000 or #FF0000
	FadeColor string `pulumi:"fadeColor"`
	// The position in the input video from where to start fade. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Default is 0
	Start *string `pulumi:"start"`
}

// FadeInput is an input type that accepts FadeArgs and FadeOutput values.
// You can construct a concrete instance of `FadeInput` via:
//
//	FadeArgs{...}
type FadeInput interface {
	pulumi.Input

	ToFadeOutput() FadeOutput
	ToFadeOutputWithContext(context.Context) FadeOutput
}

// Describes the properties of a Fade effect applied to the input media.
type FadeArgs struct {
	// The Duration of the fade effect in the video. The value can be in ISO 8601 format (For example, PT05S to fade In/Out a color during 5 seconds), or a frame count (For example, 10 to fade 10 frames from the start time), or a relative value to stream duration (For example, 10% to fade 10% of stream duration)
	Duration pulumi.StringInput `pulumi:"duration"`
	// The Color for the fade In/Out. it can be on the CSS Level1 colors https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color_keywords or an RGB/hex value: e.g: rgb(255,0,0), 0xFF0000 or #FF0000
	FadeColor pulumi.StringInput `pulumi:"fadeColor"`
	// The position in the input video from where to start fade. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Default is 0
	Start pulumi.StringPtrInput `pulumi:"start"`
}

func (FadeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Fade)(nil)).Elem()
}

func (i FadeArgs) ToFadeOutput() FadeOutput {
	return i.ToFadeOutputWithContext(context.Background())
}

func (i FadeArgs) ToFadeOutputWithContext(ctx context.Context) FadeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FadeOutput)
}

func (i FadeArgs) ToFadePtrOutput() FadePtrOutput {
	return i.ToFadePtrOutputWithContext(context.Background())
}

func (i FadeArgs) ToFadePtrOutputWithContext(ctx context.Context) FadePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FadeOutput).ToFadePtrOutputWithContext(ctx)
}

// FadePtrInput is an input type that accepts FadeArgs, FadePtr and FadePtrOutput values.
// You can construct a concrete instance of `FadePtrInput` via:
//
//	        FadeArgs{...}
//
//	or:
//
//	        nil
type FadePtrInput interface {
	pulumi.Input

	ToFadePtrOutput() FadePtrOutput
	ToFadePtrOutputWithContext(context.Context) FadePtrOutput
}

type fadePtrType FadeArgs

func FadePtr(v *FadeArgs) FadePtrInput {
	return (*fadePtrType)(v)
}

func (*fadePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Fade)(nil)).Elem()
}

func (i *fadePtrType) ToFadePtrOutput() FadePtrOutput {
	return i.ToFadePtrOutputWithContext(context.Background())
}

func (i *fadePtrType) ToFadePtrOutputWithContext(ctx context.Context) FadePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FadePtrOutput)
}

// Describes the properties of a Fade effect applied to the input media.
type FadeOutput struct{ *pulumi.OutputState }

func (FadeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Fade)(nil)).Elem()
}

func (o FadeOutput) ToFadeOutput() FadeOutput {
	return o
}

func (o FadeOutput) ToFadeOutputWithContext(ctx context.Context) FadeOutput {
	return o
}

func (o FadeOutput) ToFadePtrOutput() FadePtrOutput {
	return o.ToFadePtrOutputWithContext(context.Background())
}

func (o FadeOutput) ToFadePtrOutputWithContext(ctx context.Context) FadePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Fade) *Fade {
		return &v
	}).(FadePtrOutput)
}

// The Duration of the fade effect in the video. The value can be in ISO 8601 format (For example, PT05S to fade In/Out a color during 5 seconds), or a frame count (For example, 10 to fade 10 frames from the start time), or a relative value to stream duration (For example, 10% to fade 10% of stream duration)
func (o FadeOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v Fade) string { return v.Duration }).(pulumi.StringOutput)
}

// The Color for the fade In/Out. it can be on the CSS Level1 colors https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color_keywords or an RGB/hex value: e.g: rgb(255,0,0), 0xFF0000 or #FF0000
func (o FadeOutput) FadeColor() pulumi.StringOutput {
	return o.ApplyT(func(v Fade) string { return v.FadeColor }).(pulumi.StringOutput)
}

// The position in the input video from where to start fade. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Default is 0
func (o FadeOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Fade) *string { return v.Start }).(pulumi.StringPtrOutput)
}

type FadePtrOutput struct{ *pulumi.OutputState }

func (FadePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Fade)(nil)).Elem()
}

func (o FadePtrOutput) ToFadePtrOutput() FadePtrOutput {
	return o
}

func (o FadePtrOutput) ToFadePtrOutputWithContext(ctx context.Context) FadePtrOutput {
	return o
}

func (o FadePtrOutput) Elem() FadeOutput {
	return o.ApplyT(func(v *Fade) Fade {
		if v != nil {
			return *v
		}
		var ret Fade
		return ret
	}).(FadeOutput)
}

// The Duration of the fade effect in the video. The value can be in ISO 8601 format (For example, PT05S to fade In/Out a color during 5 seconds), or a frame count (For example, 10 to fade 10 frames from the start time), or a relative value to stream duration (For example, 10% to fade 10% of stream duration)
func (o FadePtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Fade) *string {
		if v == nil {
			return nil
		}
		return &v.Duration
	}).(pulumi.StringPtrOutput)
}

// The Color for the fade In/Out. it can be on the CSS Level1 colors https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color_keywords or an RGB/hex value: e.g: rgb(255,0,0), 0xFF0000 or #FF0000
func (o FadePtrOutput) FadeColor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Fade) *string {
		if v == nil {
			return nil
		}
		return &v.FadeColor
	}).(pulumi.StringPtrOutput)
}

// The position in the input video from where to start fade. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Default is 0
func (o FadePtrOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Fade) *string {
		if v == nil {
			return nil
		}
		return v.Start
	}).(pulumi.StringPtrOutput)
}

// Describes the properties of a Fade effect applied to the input media.
type FadeResponse struct {
	// The Duration of the fade effect in the video. The value can be in ISO 8601 format (For example, PT05S to fade In/Out a color during 5 seconds), or a frame count (For example, 10 to fade 10 frames from the start time), or a relative value to stream duration (For example, 10% to fade 10% of stream duration)
	Duration string `pulumi:"duration"`
	// The Color for the fade In/Out. it can be on the CSS Level1 colors https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color_keywords or an RGB/hex value: e.g: rgb(255,0,0), 0xFF0000 or #FF0000
	FadeColor string `pulumi:"fadeColor"`
	// The position in the input video from where to start fade. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Default is 0
	Start *string `pulumi:"start"`
}

// Describes the properties of a Fade effect applied to the input media.
type FadeResponseOutput struct{ *pulumi.OutputState }

func (FadeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FadeResponse)(nil)).Elem()
}

func (o FadeResponseOutput) ToFadeResponseOutput() FadeResponseOutput {
	return o
}

func (o FadeResponseOutput) ToFadeResponseOutputWithContext(ctx context.Context) FadeResponseOutput {
	return o
}

// The Duration of the fade effect in the video. The value can be in ISO 8601 format (For example, PT05S to fade In/Out a color during 5 seconds), or a frame count (For example, 10 to fade 10 frames from the start time), or a relative value to stream duration (For example, 10% to fade 10% of stream duration)
func (o FadeResponseOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v FadeResponse) string { return v.Duration }).(pulumi.StringOutput)
}

// The Color for the fade In/Out. it can be on the CSS Level1 colors https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color_keywords or an RGB/hex value: e.g: rgb(255,0,0), 0xFF0000 or #FF0000
func (o FadeResponseOutput) FadeColor() pulumi.StringOutput {
	return o.ApplyT(func(v FadeResponse) string { return v.FadeColor }).(pulumi.StringOutput)
}

// The position in the input video from where to start fade. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Default is 0
func (o FadeResponseOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FadeResponse) *string { return v.Start }).(pulumi.StringPtrOutput)
}

type FadeResponsePtrOutput struct{ *pulumi.OutputState }

func (FadeResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FadeResponse)(nil)).Elem()
}

func (o FadeResponsePtrOutput) ToFadeResponsePtrOutput() FadeResponsePtrOutput {
	return o
}

func (o FadeResponsePtrOutput) ToFadeResponsePtrOutputWithContext(ctx context.Context) FadeResponsePtrOutput {
	return o
}

func (o FadeResponsePtrOutput) Elem() FadeResponseOutput {
	return o.ApplyT(func(v *FadeResponse) FadeResponse {
		if v != nil {
			return *v
		}
		var ret FadeResponse
		return ret
	}).(FadeResponseOutput)
}

// The Duration of the fade effect in the video. The value can be in ISO 8601 format (For example, PT05S to fade In/Out a color during 5 seconds), or a frame count (For example, 10 to fade 10 frames from the start time), or a relative value to stream duration (For example, 10% to fade 10% of stream duration)
func (o FadeResponsePtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FadeResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Duration
	}).(pulumi.StringPtrOutput)
}

// The Color for the fade In/Out. it can be on the CSS Level1 colors https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color_keywords or an RGB/hex value: e.g: rgb(255,0,0), 0xFF0000 or #FF0000
func (o FadeResponsePtrOutput) FadeColor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FadeResponse) *string {
		if v == nil {
			return nil
		}
		return &v.FadeColor
	}).(pulumi.StringPtrOutput)
}

// The position in the input video from where to start fade. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Default is 0
func (o FadeResponsePtrOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FadeResponse) *string {
		if v == nil {
			return nil
		}
		return v.Start
	}).(pulumi.StringPtrOutput)
}

// The class to specify one track property condition.
type FilterTrackPropertyCondition struct {
	// The track property condition operation.
	Operation string `pulumi:"operation"`
	// The track property type.
	Property string `pulumi:"property"`
	// The track property value.
	Value string `pulumi:"value"`
}

// FilterTrackPropertyConditionInput is an input type that accepts FilterTrackPropertyConditionArgs and FilterTrackPropertyConditionOutput values.
// You can construct a concrete instance of `FilterTrackPropertyConditionInput` via:
//
//	FilterTrackPropertyConditionArgs{...}
type FilterTrackPropertyConditionInput interface {
	pulumi.Input

	ToFilterTrackPropertyConditionOutput() FilterTrackPropertyConditionOutput
	ToFilterTrackPropertyConditionOutputWithContext(context.Context) FilterTrackPropertyConditionOutput
}

// The class to specify one track property condition.
type FilterTrackPropertyConditionArgs struct {
	// The track property condition operation.
	Operation pulumi.StringInput `pulumi:"operation"`
	// The track property type.
	Property pulumi.StringInput `pulumi:"property"`
	// The track property value.
	Value pulumi.StringInput `pulumi:"value"`
}

func (FilterTrackPropertyConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackPropertyCondition)(nil)).Elem()
}

func (i FilterTrackPropertyConditionArgs) ToFilterTrackPropertyConditionOutput() FilterTrackPropertyConditionOutput {
	return i.ToFilterTrackPropertyConditionOutputWithContext(context.Background())
}

func (i FilterTrackPropertyConditionArgs) ToFilterTrackPropertyConditionOutputWithContext(ctx context.Context) FilterTrackPropertyConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterTrackPropertyConditionOutput)
}

// FilterTrackPropertyConditionArrayInput is an input type that accepts FilterTrackPropertyConditionArray and FilterTrackPropertyConditionArrayOutput values.
// You can construct a concrete instance of `FilterTrackPropertyConditionArrayInput` via:
//
//	FilterTrackPropertyConditionArray{ FilterTrackPropertyConditionArgs{...} }
type FilterTrackPropertyConditionArrayInput interface {
	pulumi.Input

	ToFilterTrackPropertyConditionArrayOutput() FilterTrackPropertyConditionArrayOutput
	ToFilterTrackPropertyConditionArrayOutputWithContext(context.Context) FilterTrackPropertyConditionArrayOutput
}

type FilterTrackPropertyConditionArray []FilterTrackPropertyConditionInput

func (FilterTrackPropertyConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackPropertyCondition)(nil)).Elem()
}

func (i FilterTrackPropertyConditionArray) ToFilterTrackPropertyConditionArrayOutput() FilterTrackPropertyConditionArrayOutput {
	return i.ToFilterTrackPropertyConditionArrayOutputWithContext(context.Background())
}

func (i FilterTrackPropertyConditionArray) ToFilterTrackPropertyConditionArrayOutputWithContext(ctx context.Context) FilterTrackPropertyConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterTrackPropertyConditionArrayOutput)
}

// The class to specify one track property condition.
type FilterTrackPropertyConditionOutput struct{ *pulumi.OutputState }

func (FilterTrackPropertyConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackPropertyCondition)(nil)).Elem()
}

func (o FilterTrackPropertyConditionOutput) ToFilterTrackPropertyConditionOutput() FilterTrackPropertyConditionOutput {
	return o
}

func (o FilterTrackPropertyConditionOutput) ToFilterTrackPropertyConditionOutputWithContext(ctx context.Context) FilterTrackPropertyConditionOutput {
	return o
}

// The track property condition operation.
func (o FilterTrackPropertyConditionOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyCondition) string { return v.Operation }).(pulumi.StringOutput)
}

// The track property type.
func (o FilterTrackPropertyConditionOutput) Property() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyCondition) string { return v.Property }).(pulumi.StringOutput)
}

// The track property value.
func (o FilterTrackPropertyConditionOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyCondition) string { return v.Value }).(pulumi.StringOutput)
}

type FilterTrackPropertyConditionArrayOutput struct{ *pulumi.OutputState }

func (FilterTrackPropertyConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackPropertyCondition)(nil)).Elem()
}

func (o FilterTrackPropertyConditionArrayOutput) ToFilterTrackPropertyConditionArrayOutput() FilterTrackPropertyConditionArrayOutput {
	return o
}

func (o FilterTrackPropertyConditionArrayOutput) ToFilterTrackPropertyConditionArrayOutputWithContext(ctx context.Context) FilterTrackPropertyConditionArrayOutput {
	return o
}

func (o FilterTrackPropertyConditionArrayOutput) Index(i pulumi.IntInput) FilterTrackPropertyConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FilterTrackPropertyCondition {
		return vs[0].([]FilterTrackPropertyCondition)[vs[1].(int)]
	}).(FilterTrackPropertyConditionOutput)
}

// The class to specify one track property condition.
type FilterTrackPropertyConditionResponse struct {
	// The track property condition operation.
	Operation string `pulumi:"operation"`
	// The track property type.
	Property string `pulumi:"property"`
	// The track property value.
	Value string `pulumi:"value"`
}

// The class to specify one track property condition.
type FilterTrackPropertyConditionResponseOutput struct{ *pulumi.OutputState }

func (FilterTrackPropertyConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackPropertyConditionResponse)(nil)).Elem()
}

func (o FilterTrackPropertyConditionResponseOutput) ToFilterTrackPropertyConditionResponseOutput() FilterTrackPropertyConditionResponseOutput {
	return o
}

func (o FilterTrackPropertyConditionResponseOutput) ToFilterTrackPropertyConditionResponseOutputWithContext(ctx context.Context) FilterTrackPropertyConditionResponseOutput {
	return o
}

// The track property condition operation.
func (o FilterTrackPropertyConditionResponseOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyConditionResponse) string { return v.Operation }).(pulumi.StringOutput)
}

// The track property type.
func (o FilterTrackPropertyConditionResponseOutput) Property() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyConditionResponse) string { return v.Property }).(pulumi.StringOutput)
}

// The track property value.
func (o FilterTrackPropertyConditionResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyConditionResponse) string { return v.Value }).(pulumi.StringOutput)
}

type FilterTrackPropertyConditionResponseArrayOutput struct{ *pulumi.OutputState }

func (FilterTrackPropertyConditionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackPropertyConditionResponse)(nil)).Elem()
}

func (o FilterTrackPropertyConditionResponseArrayOutput) ToFilterTrackPropertyConditionResponseArrayOutput() FilterTrackPropertyConditionResponseArrayOutput {
	return o
}

func (o FilterTrackPropertyConditionResponseArrayOutput) ToFilterTrackPropertyConditionResponseArrayOutputWithContext(ctx context.Context) FilterTrackPropertyConditionResponseArrayOutput {
	return o
}

func (o FilterTrackPropertyConditionResponseArrayOutput) Index(i pulumi.IntInput) FilterTrackPropertyConditionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FilterTrackPropertyConditionResponse {
		return vs[0].([]FilterTrackPropertyConditionResponse)[vs[1].(int)]
	}).(FilterTrackPropertyConditionResponseOutput)
}

// Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
type FilterTrackSelection struct {
	// The track selections.
	TrackSelections []FilterTrackPropertyCondition `pulumi:"trackSelections"`
}

// FilterTrackSelectionInput is an input type that accepts FilterTrackSelectionArgs and FilterTrackSelectionOutput values.
// You can construct a concrete instance of `FilterTrackSelectionInput` via:
//
//	FilterTrackSelectionArgs{...}
type FilterTrackSelectionInput interface {
	pulumi.Input

	ToFilterTrackSelectionOutput() FilterTrackSelectionOutput
	ToFilterTrackSelectionOutputWithContext(context.Context) FilterTrackSelectionOutput
}

// Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
type FilterTrackSelectionArgs struct {
	// The track selections.
	TrackSelections FilterTrackPropertyConditionArrayInput `pulumi:"trackSelections"`
}

func (FilterTrackSelectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackSelection)(nil)).Elem()
}

func (i FilterTrackSelectionArgs) ToFilterTrackSelectionOutput() FilterTrackSelectionOutput {
	return i.ToFilterTrackSelectionOutputWithContext(context.Background())
}

func (i FilterTrackSelectionArgs) ToFilterTrackSelectionOutputWithContext(ctx context.Context) FilterTrackSelectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterTrackSelectionOutput)
}

// FilterTrackSelectionArrayInput is an input type that accepts FilterTrackSelectionArray and FilterTrackSelectionArrayOutput values.
// You can construct a concrete instance of `FilterTrackSelectionArrayInput` via:
//
//	FilterTrackSelectionArray{ FilterTrackSelectionArgs{...} }
type FilterTrackSelectionArrayInput interface {
	pulumi.Input

	ToFilterTrackSelectionArrayOutput() FilterTrackSelectionArrayOutput
	ToFilterTrackSelectionArrayOutputWithContext(context.Context) FilterTrackSelectionArrayOutput
}

type FilterTrackSelectionArray []FilterTrackSelectionInput

func (FilterTrackSelectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackSelection)(nil)).Elem()
}

func (i FilterTrackSelectionArray) ToFilterTrackSelectionArrayOutput() FilterTrackSelectionArrayOutput {
	return i.ToFilterTrackSelectionArrayOutputWithContext(context.Background())
}

func (i FilterTrackSelectionArray) ToFilterTrackSelectionArrayOutputWithContext(ctx context.Context) FilterTrackSelectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterTrackSelectionArrayOutput)
}

// Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
type FilterTrackSelectionOutput struct{ *pulumi.OutputState }

func (FilterTrackSelectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackSelection)(nil)).Elem()
}

func (o FilterTrackSelectionOutput) ToFilterTrackSelectionOutput() FilterTrackSelectionOutput {
	return o
}

func (o FilterTrackSelectionOutput) ToFilterTrackSelectionOutputWithContext(ctx context.Context) FilterTrackSelectionOutput {
	return o
}

// The track selections.
func (o FilterTrackSelectionOutput) TrackSelections() FilterTrackPropertyConditionArrayOutput {
	return o.ApplyT(func(v FilterTrackSelection) []FilterTrackPropertyCondition { return v.TrackSelections }).(FilterTrackPropertyConditionArrayOutput)
}

type FilterTrackSelectionArrayOutput struct{ *pulumi.OutputState }

func (FilterTrackSelectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackSelection)(nil)).Elem()
}

func (o FilterTrackSelectionArrayOutput) ToFilterTrackSelectionArrayOutput() FilterTrackSelectionArrayOutput {
	return o
}

func (o FilterTrackSelectionArrayOutput) ToFilterTrackSelectionArrayOutputWithContext(ctx context.Context) FilterTrackSelectionArrayOutput {
	return o
}

func (o FilterTrackSelectionArrayOutput) Index(i pulumi.IntInput) FilterTrackSelectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FilterTrackSelection {
		return vs[0].([]FilterTrackSelection)[vs[1].(int)]
	}).(FilterTrackSelectionOutput)
}

// Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
type FilterTrackSelectionResponse struct {
	// The track selections.
	TrackSelections []FilterTrackPropertyConditionResponse `pulumi:"trackSelections"`
}

// Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
type FilterTrackSelectionResponseOutput struct{ *pulumi.OutputState }

func (FilterTrackSelectionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackSelectionResponse)(nil)).Elem()
}

func (o FilterTrackSelectionResponseOutput) ToFilterTrackSelectionResponseOutput() FilterTrackSelectionResponseOutput {
	return o
}

func (o FilterTrackSelectionResponseOutput) ToFilterTrackSelectionResponseOutputWithContext(ctx context.Context) FilterTrackSelectionResponseOutput {
	return o
}

// The track selections.
func (o FilterTrackSelectionResponseOutput) TrackSelections() FilterTrackPropertyConditionResponseArrayOutput {
	return o.ApplyT(func(v FilterTrackSelectionResponse) []FilterTrackPropertyConditionResponse { return v.TrackSelections }).(FilterTrackPropertyConditionResponseArrayOutput)
}

type FilterTrackSelectionResponseArrayOutput struct{ *pulumi.OutputState }

func (FilterTrackSelectionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackSelectionResponse)(nil)).Elem()
}

func (o FilterTrackSelectionResponseArrayOutput) ToFilterTrackSelectionResponseArrayOutput() FilterTrackSelectionResponseArrayOutput {
	return o
}

func (o FilterTrackSelectionResponseArrayOutput) ToFilterTrackSelectionResponseArrayOutputWithContext(ctx context.Context) FilterTrackSelectionResponseArrayOutput {
	return o
}

func (o FilterTrackSelectionResponseArrayOutput) Index(i pulumi.IntInput) FilterTrackSelectionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FilterTrackSelectionResponse {
		return vs[0].([]FilterTrackSelectionResponse)[vs[1].(int)]
	}).(FilterTrackSelectionResponseOutput)
}

// Describes all the filtering operations, such as de-interlacing, rotation etc. that are to be applied to the input media before encoding.
type Filters struct {
	// The parameters for the rectangular window with which to crop the input video.
	Crop *Rectangle `pulumi:"crop"`
	// The de-interlacing settings.
	Deinterlace *Deinterlace `pulumi:"deinterlace"`
	// Describes the properties of a Fade effect applied to the input media.
	FadeIn *Fade `pulumi:"fadeIn"`
	// Describes the properties of a Fade effect applied to the input media.
	FadeOut *Fade `pulumi:"fadeOut"`
	// The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
	Overlays []interface{} `pulumi:"overlays"`
	// The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto
	Rotation *string `pulumi:"rotation"`
}

// FiltersInput is an input type that accepts FiltersArgs and FiltersOutput values.
// You can construct a concrete instance of `FiltersInput` via:
//
//	FiltersArgs{...}
type FiltersInput interface {
	pulumi.Input

	ToFiltersOutput() FiltersOutput
	ToFiltersOutputWithContext(context.Context) FiltersOutput
}

// Describes all the filtering operations, such as de-interlacing, rotation etc. that are to be applied to the input media before encoding.
type FiltersArgs struct {
	// The parameters for the rectangular window with which to crop the input video.
	Crop RectanglePtrInput `pulumi:"crop"`
	// The de-interlacing settings.
	Deinterlace DeinterlacePtrInput `pulumi:"deinterlace"`
	// Describes the properties of a Fade effect applied to the input media.
	FadeIn FadePtrInput `pulumi:"fadeIn"`
	// Describes the properties of a Fade effect applied to the input media.
	FadeOut FadePtrInput `pulumi:"fadeOut"`
	// The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
	Overlays pulumi.ArrayInput `pulumi:"overlays"`
	// The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto
	Rotation pulumi.StringPtrInput `pulumi:"rotation"`
}

func (FiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Filters)(nil)).Elem()
}

func (i FiltersArgs) ToFiltersOutput() FiltersOutput {
	return i.ToFiltersOutputWithContext(context.Background())
}

func (i FiltersArgs) ToFiltersOutputWithContext(ctx context.Context) FiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FiltersOutput)
}

func (i FiltersArgs) ToFiltersPtrOutput() FiltersPtrOutput {
	return i.ToFiltersPtrOutputWithContext(context.Background())
}

func (i FiltersArgs) ToFiltersPtrOutputWithContext(ctx context.Context) FiltersPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FiltersOutput).ToFiltersPtrOutputWithContext(ctx)
}

// FiltersPtrInput is an input type that accepts FiltersArgs, FiltersPtr and FiltersPtrOutput values.
// You can construct a concrete instance of `FiltersPtrInput` via:
//
//	        FiltersArgs{...}
//
//	or:
//
//	        nil
type FiltersPtrInput interface {
	pulumi.Input

	ToFiltersPtrOutput() FiltersPtrOutput
	ToFiltersPtrOutputWithContext(context.Context) FiltersPtrOutput
}

type filtersPtrType FiltersArgs

func FiltersPtr(v *FiltersArgs) FiltersPtrInput {
	return (*filtersPtrType)(v)
}

func (*filtersPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Filters)(nil)).Elem()
}

func (i *filtersPtrType) ToFiltersPtrOutput() FiltersPtrOutput {
	return i.ToFiltersPtrOutputWithContext(context.Background())
}

func (i *filtersPtrType) ToFiltersPtrOutputWithContext(ctx context.Context) FiltersPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FiltersPtrOutput)
}

// Describes all the filtering operations, such as de-interlacing, rotation etc. that are to be applied to the input media before encoding.
type FiltersOutput struct{ *pulumi.OutputState }

func (FiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Filters)(nil)).Elem()
}

func (o FiltersOutput) ToFiltersOutput() FiltersOutput {
	return o
}

func (o FiltersOutput) ToFiltersOutputWithContext(ctx context.Context) FiltersOutput {
	return o
}

func (o FiltersOutput) ToFiltersPtrOutput() FiltersPtrOutput {
	return o.ToFiltersPtrOutputWithContext(context.Background())
}

func (o FiltersOutput) ToFiltersPtrOutputWithContext(ctx context.Context) FiltersPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Filters) *Filters {
		return &v
	}).(FiltersPtrOutput)
}

// The parameters for the rectangular window with which to crop the input video.
func (o FiltersOutput) Crop() RectanglePtrOutput {
	return o.ApplyT(func(v Filters) *Rectangle { return v.Crop }).(RectanglePtrOutput)
}

// The de-interlacing settings.
func (o FiltersOutput) Deinterlace() DeinterlacePtrOutput {
	return o.ApplyT(func(v Filters) *Deinterlace { return v.Deinterlace }).(DeinterlacePtrOutput)
}

// Describes the properties of a Fade effect applied to the input media.
func (o FiltersOutput) FadeIn() FadePtrOutput {
	return o.ApplyT(func(v Filters) *Fade { return v.FadeIn }).(FadePtrOutput)
}

// Describes the properties of a Fade effect applied to the input media.
func (o FiltersOutput) FadeOut() FadePtrOutput {
	return o.ApplyT(func(v Filters) *Fade { return v.FadeOut }).(FadePtrOutput)
}

// The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
func (o FiltersOutput) Overlays() pulumi.ArrayOutput {
	return o.ApplyT(func(v Filters) []interface{} { return v.Overlays }).(pulumi.ArrayOutput)
}

// The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto
func (o FiltersOutput) Rotation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Filters) *string { return v.Rotation }).(pulumi.StringPtrOutput)
}

type FiltersPtrOutput struct{ *pulumi.OutputState }

func (FiltersPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Filters)(nil)).Elem()
}

func (o FiltersPtrOutput) ToFiltersPtrOutput() FiltersPtrOutput {
	return o
}

func (o FiltersPtrOutput) ToFiltersPtrOutputWithContext(ctx context.Context) FiltersPtrOutput {
	return o
}

func (o FiltersPtrOutput) Elem() FiltersOutput {
	return o.ApplyT(func(v *Filters) Filters {
		if v != nil {
			return *v
		}
		var ret Filters
		return ret
	}).(FiltersOutput)
}

// The parameters for the rectangular window with which to crop the input video.
func (o FiltersPtrOutput) Crop() RectanglePtrOutput {
	return o.ApplyT(func(v *Filters) *Rectangle {
		if v == nil {
			return nil
		}
		return v.Crop
	}).(RectanglePtrOutput)
}

// The de-interlacing settings.
func (o FiltersPtrOutput) Deinterlace() DeinterlacePtrOutput {
	return o.ApplyT(func(v *Filters) *Deinterlace {
		if v == nil {
			return nil
		}
		return v.Deinterlace
	}).(DeinterlacePtrOutput)
}

// Describes the properties of a Fade effect applied to the input media.
func (o FiltersPtrOutput) FadeIn() FadePtrOutput {
	return o.ApplyT(func(v *Filters) *Fade {
		if v == nil {
			return nil
		}
		return v.FadeIn
	}).(FadePtrOutput)
}

// Describes the properties of a Fade effect applied to the input media.
func (o FiltersPtrOutput) FadeOut() FadePtrOutput {
	return o.ApplyT(func(v *Filters) *Fade {
		if v == nil {
			return nil
		}
		return v.FadeOut
	}).(FadePtrOutput)
}

// The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
func (o FiltersPtrOutput) Overlays() pulumi.ArrayOutput {
	return o.ApplyT(func(v *Filters) []interface{} {
		if v == nil {
			return nil
		}
		return v.Overlays
	}).(pulumi.ArrayOutput)
}

// The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto
func (o FiltersPtrOutput) Rotation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Filters) *string {
		if v == nil {
			return nil
		}
		return v.Rotation
	}).(pulumi.StringPtrOutput)
}

// Describes all the filtering operations, such as de-interlacing, rotation etc. that are to be applied to the input media before encoding.
type FiltersResponse struct {
	// The parameters for the rectangular window with which to crop the input video.
	Crop *RectangleResponse `pulumi:"crop"`
	// The de-interlacing settings.
	Deinterlace *DeinterlaceResponse `pulumi:"deinterlace"`
	// Describes the properties of a Fade effect applied to the input media.
	FadeIn *FadeResponse `pulumi:"fadeIn"`
	// Describes the properties of a Fade effect applied to the input media.
	FadeOut *FadeResponse `pulumi:"fadeOut"`
	// The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
	Overlays []interface{} `pulumi:"overlays"`
	// The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto
	Rotation *string `pulumi:"rotation"`
}

// Describes all the filtering operations, such as de-interlacing, rotation etc. that are to be applied to the input media before encoding.
type FiltersResponseOutput struct{ *pulumi.OutputState }

func (FiltersResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FiltersResponse)(nil)).Elem()
}

func (o FiltersResponseOutput) ToFiltersResponseOutput() FiltersResponseOutput {
	return o
}

func (o FiltersResponseOutput) ToFiltersResponseOutputWithContext(ctx context.Context) FiltersResponseOutput {
	return o
}

// The parameters for the rectangular window with which to crop the input video.
func (o FiltersResponseOutput) Crop() RectangleResponsePtrOutput {
	return o.ApplyT(func(v FiltersResponse) *RectangleResponse { return v.Crop }).(RectangleResponsePtrOutput)
}

// The de-interlacing settings.
func (o FiltersResponseOutput) Deinterlace() DeinterlaceResponsePtrOutput {
	return o.ApplyT(func(v FiltersResponse) *DeinterlaceResponse { return v.Deinterlace }).(DeinterlaceResponsePtrOutput)
}

// Describes the properties of a Fade effect applied to the input media.
func (o FiltersResponseOutput) FadeIn() FadeResponsePtrOutput {
	return o.ApplyT(func(v FiltersResponse) *FadeResponse { return v.FadeIn }).(FadeResponsePtrOutput)
}

// Describes the properties of a Fade effect applied to the input media.
func (o FiltersResponseOutput) FadeOut() FadeResponsePtrOutput {
	return o.ApplyT(func(v FiltersResponse) *FadeResponse { return v.FadeOut }).(FadeResponsePtrOutput)
}

// The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
func (o FiltersResponseOutput) Overlays() pulumi.ArrayOutput {
	return o.ApplyT(func(v FiltersResponse) []interface{} { return v.Overlays }).(pulumi.ArrayOutput)
}

// The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto
func (o FiltersResponseOutput) Rotation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FiltersResponse) *string { return v.Rotation }).(pulumi.StringPtrOutput)
}

type FiltersResponsePtrOutput struct{ *pulumi.OutputState }

func (FiltersResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FiltersResponse)(nil)).Elem()
}

func (o FiltersResponsePtrOutput) ToFiltersResponsePtrOutput() FiltersResponsePtrOutput {
	return o
}

func (o FiltersResponsePtrOutput) ToFiltersResponsePtrOutputWithContext(ctx context.Context) FiltersResponsePtrOutput {
	return o
}

func (o FiltersResponsePtrOutput) Elem() FiltersResponseOutput {
	return o.ApplyT(func(v *FiltersResponse) FiltersResponse {
		if v != nil {
			return *v
		}
		var ret FiltersResponse
		return ret
	}).(FiltersResponseOutput)
}

// The parameters for the rectangular window with which to crop the input video.
func (o FiltersResponsePtrOutput) Crop() RectangleResponsePtrOutput {
	return o.ApplyT(func(v *FiltersResponse) *RectangleResponse {
		if v == nil {
			return nil
		}
		return v.Crop
	}).(RectangleResponsePtrOutput)
}

// The de-interlacing settings.
func (o FiltersResponsePtrOutput) Deinterlace() DeinterlaceResponsePtrOutput {
	return o.ApplyT(func(v *FiltersResponse) *DeinterlaceResponse {
		if v == nil {
			return nil
		}
		return v.Deinterlace
	}).(DeinterlaceResponsePtrOutput)
}

// Describes the properties of a Fade effect applied to the input media.
func (o FiltersResponsePtrOutput) FadeIn() FadeResponsePtrOutput {
	return o.ApplyT(func(v *FiltersResponse) *FadeResponse {
		if v == nil {
			return nil
		}
		return v.FadeIn
	}).(FadeResponsePtrOutput)
}

// Describes the properties of a Fade effect applied to the input media.
func (o FiltersResponsePtrOutput) FadeOut() FadeResponsePtrOutput {
	return o.ApplyT(func(v *FiltersResponse) *FadeResponse {
		if v == nil {
			return nil
		}
		return v.FadeOut
	}).(FadeResponsePtrOutput)
}

// The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
func (o FiltersResponsePtrOutput) Overlays() pulumi.ArrayOutput {
	return o.ApplyT(func(v *FiltersResponse) []interface{} {
		if v == nil {
			return nil
		}
		return v.Overlays
	}).(pulumi.ArrayOutput)
}

// The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto
func (o FiltersResponsePtrOutput) Rotation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FiltersResponse) *string {
		if v == nil {
			return nil
		}
		return v.Rotation
	}).(pulumi.StringPtrOutput)
}

// Filter First Quality
type FirstQuality struct {
	// The first quality bitrate.
	Bitrate int `pulumi:"bitrate"`
}

// FirstQualityInput is an input type that accepts FirstQualityArgs and FirstQualityOutput values.
// You can construct a concrete instance of `FirstQualityInput` via:
//
//	FirstQualityArgs{...}
type FirstQualityInput interface {
	pulumi.Input

	ToFirstQualityOutput() FirstQualityOutput
	ToFirstQualityOutputWithContext(context.Context) FirstQualityOutput
}

// Filter First Quality
type FirstQualityArgs struct {
	// The first quality bitrate.
	Bitrate pulumi.IntInput `pulumi:"bitrate"`
}

func (FirstQualityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirstQuality)(nil)).Elem()
}

func (i FirstQualityArgs) ToFirstQualityOutput() FirstQualityOutput {
	return i.ToFirstQualityOutputWithContext(context.Background())
}

func (i FirstQualityArgs) ToFirstQualityOutputWithContext(ctx context.Context) FirstQualityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirstQualityOutput)
}

func (i FirstQualityArgs) ToFirstQualityPtrOutput() FirstQualityPtrOutput {
	return i.ToFirstQualityPtrOutputWithContext(context.Background())
}

func (i FirstQualityArgs) ToFirstQualityPtrOutputWithContext(ctx context.Context) FirstQualityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirstQualityOutput).ToFirstQualityPtrOutputWithContext(ctx)
}

// FirstQualityPtrInput is an input type that accepts FirstQualityArgs, FirstQualityPtr and FirstQualityPtrOutput values.
// You can construct a concrete instance of `FirstQualityPtrInput` via:
//
//	        FirstQualityArgs{...}
//
//	or:
//
//	        nil
type FirstQualityPtrInput interface {
	pulumi.Input

	ToFirstQualityPtrOutput() FirstQualityPtrOutput
	ToFirstQualityPtrOutputWithContext(context.Context) FirstQualityPtrOutput
}

type firstQualityPtrType FirstQualityArgs

func FirstQualityPtr(v *FirstQualityArgs) FirstQualityPtrInput {
	return (*firstQualityPtrType)(v)
}

func (*firstQualityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FirstQuality)(nil)).Elem()
}

func (i *firstQualityPtrType) ToFirstQualityPtrOutput() FirstQualityPtrOutput {
	return i.ToFirstQualityPtrOutputWithContext(context.Background())
}

func (i *firstQualityPtrType) ToFirstQualityPtrOutputWithContext(ctx context.Context) FirstQualityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirstQualityPtrOutput)
}

// Filter First Quality
type FirstQualityOutput struct{ *pulumi.OutputState }

func (FirstQualityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirstQuality)(nil)).Elem()
}

func (o FirstQualityOutput) ToFirstQualityOutput() FirstQualityOutput {
	return o
}

func (o FirstQualityOutput) ToFirstQualityOutputWithContext(ctx context.Context) FirstQualityOutput {
	return o
}

func (o FirstQualityOutput) ToFirstQualityPtrOutput() FirstQualityPtrOutput {
	return o.ToFirstQualityPtrOutputWithContext(context.Background())
}

func (o FirstQualityOutput) ToFirstQualityPtrOutputWithContext(ctx context.Context) FirstQualityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FirstQuality) *FirstQuality {
		return &v
	}).(FirstQualityPtrOutput)
}

// The first quality bitrate.
func (o FirstQualityOutput) Bitrate() pulumi.IntOutput {
	return o.ApplyT(func(v FirstQuality) int { return v.Bitrate }).(pulumi.IntOutput)
}

type FirstQualityPtrOutput struct{ *pulumi.OutputState }

func (FirstQualityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirstQuality)(nil)).Elem()
}

func (o FirstQualityPtrOutput) ToFirstQualityPtrOutput() FirstQualityPtrOutput {
	return o
}

func (o FirstQualityPtrOutput) ToFirstQualityPtrOutputWithContext(ctx context.Context) FirstQualityPtrOutput {
	return o
}

func (o FirstQualityPtrOutput) Elem() FirstQualityOutput {
	return o.ApplyT(func(v *FirstQuality) FirstQuality {
		if v != nil {
			return *v
		}
		var ret FirstQuality
		return ret
	}).(FirstQualityOutput)
}

// The first quality bitrate.
func (o FirstQualityPtrOutput) Bitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FirstQuality) *int {
		if v == nil {
			return nil
		}
		return &v.Bitrate
	}).(pulumi.IntPtrOutput)
}

// Filter First Quality
type FirstQualityResponse struct {
	// The first quality bitrate.
	Bitrate int `pulumi:"bitrate"`
}

// Filter First Quality
type FirstQualityResponseOutput struct{ *pulumi.OutputState }

func (FirstQualityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirstQualityResponse)(nil)).Elem()
}

func (o FirstQualityResponseOutput) ToFirstQualityResponseOutput() FirstQualityResponseOutput {
	return o
}

func (o FirstQualityResponseOutput) ToFirstQualityResponseOutputWithContext(ctx context.Context) FirstQualityResponseOutput {
	return o
}

// The first quality bitrate.
func (o FirstQualityResponseOutput) Bitrate() pulumi.IntOutput {
	return o.ApplyT(func(v FirstQualityResponse) int { return v.Bitrate }).(pulumi.IntOutput)
}

type FirstQualityResponsePtrOutput struct{ *pulumi.OutputState }

func (FirstQualityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirstQualityResponse)(nil)).Elem()
}

func (o FirstQualityResponsePtrOutput) ToFirstQualityResponsePtrOutput() FirstQualityResponsePtrOutput {
	return o
}

func (o FirstQualityResponsePtrOutput) ToFirstQualityResponsePtrOutputWithContext(ctx context.Context) FirstQualityResponsePtrOutput {
	return o
}

func (o FirstQualityResponsePtrOutput) Elem() FirstQualityResponseOutput {
	return o.ApplyT(func(v *FirstQualityResponse) FirstQualityResponse {
		if v != nil {
			return *v
		}
		var ret FirstQualityResponse
		return ret
	}).(FirstQualityResponseOutput)
}

// The first quality bitrate.
func (o FirstQualityResponsePtrOutput) Bitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FirstQualityResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Bitrate
	}).(pulumi.IntPtrOutput)
}

// An InputDefinition that looks across all of the files provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to allow selection of a single track across a set of input files.
type FromAllInputFile struct {
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FromAllInputFile'.
	OdataType string `pulumi:"odataType"`
}

// FromAllInputFileInput is an input type that accepts FromAllInputFileArgs and FromAllInputFileOutput values.
// You can construct a concrete instance of `FromAllInputFileInput` via:
//
//	FromAllInputFileArgs{...}
type FromAllInputFileInput interface {
	pulumi.Input

	ToFromAllInputFileOutput() FromAllInputFileOutput
	ToFromAllInputFileOutputWithContext(context.Context) FromAllInputFileOutput
}

// An InputDefinition that looks across all of the files provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to allow selection of a single track across a set of input files.
type FromAllInputFileArgs struct {
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks pulumi.ArrayInput `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FromAllInputFile'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (FromAllInputFileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FromAllInputFile)(nil)).Elem()
}

func (i FromAllInputFileArgs) ToFromAllInputFileOutput() FromAllInputFileOutput {
	return i.ToFromAllInputFileOutputWithContext(context.Background())
}

func (i FromAllInputFileArgs) ToFromAllInputFileOutputWithContext(ctx context.Context) FromAllInputFileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FromAllInputFileOutput)
}

// An InputDefinition that looks across all of the files provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to allow selection of a single track across a set of input files.
type FromAllInputFileOutput struct{ *pulumi.OutputState }

func (FromAllInputFileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FromAllInputFile)(nil)).Elem()
}

func (o FromAllInputFileOutput) ToFromAllInputFileOutput() FromAllInputFileOutput {
	return o
}

func (o FromAllInputFileOutput) ToFromAllInputFileOutputWithContext(ctx context.Context) FromAllInputFileOutput {
	return o
}

// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
func (o FromAllInputFileOutput) IncludedTracks() pulumi.ArrayOutput {
	return o.ApplyT(func(v FromAllInputFile) []interface{} { return v.IncludedTracks }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.FromAllInputFile'.
func (o FromAllInputFileOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v FromAllInputFile) string { return v.OdataType }).(pulumi.StringOutput)
}

// An InputDefinition that looks across all of the files provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to allow selection of a single track across a set of input files.
type FromAllInputFileResponse struct {
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FromAllInputFile'.
	OdataType string `pulumi:"odataType"`
}

// An InputDefinition that looks across all of the files provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to allow selection of a single track across a set of input files.
type FromAllInputFileResponseOutput struct{ *pulumi.OutputState }

func (FromAllInputFileResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FromAllInputFileResponse)(nil)).Elem()
}

func (o FromAllInputFileResponseOutput) ToFromAllInputFileResponseOutput() FromAllInputFileResponseOutput {
	return o
}

func (o FromAllInputFileResponseOutput) ToFromAllInputFileResponseOutputWithContext(ctx context.Context) FromAllInputFileResponseOutput {
	return o
}

// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
func (o FromAllInputFileResponseOutput) IncludedTracks() pulumi.ArrayOutput {
	return o.ApplyT(func(v FromAllInputFileResponse) []interface{} { return v.IncludedTracks }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.FromAllInputFile'.
func (o FromAllInputFileResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v FromAllInputFileResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// An InputDefinition that looks at each input file provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to select tracks from each file given.
type FromEachInputFile struct {
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FromEachInputFile'.
	OdataType string `pulumi:"odataType"`
}

// FromEachInputFileInput is an input type that accepts FromEachInputFileArgs and FromEachInputFileOutput values.
// You can construct a concrete instance of `FromEachInputFileInput` via:
//
//	FromEachInputFileArgs{...}
type FromEachInputFileInput interface {
	pulumi.Input

	ToFromEachInputFileOutput() FromEachInputFileOutput
	ToFromEachInputFileOutputWithContext(context.Context) FromEachInputFileOutput
}

// An InputDefinition that looks at each input file provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to select tracks from each file given.
type FromEachInputFileArgs struct {
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks pulumi.ArrayInput `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FromEachInputFile'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (FromEachInputFileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FromEachInputFile)(nil)).Elem()
}

func (i FromEachInputFileArgs) ToFromEachInputFileOutput() FromEachInputFileOutput {
	return i.ToFromEachInputFileOutputWithContext(context.Background())
}

func (i FromEachInputFileArgs) ToFromEachInputFileOutputWithContext(ctx context.Context) FromEachInputFileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FromEachInputFileOutput)
}

// An InputDefinition that looks at each input file provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to select tracks from each file given.
type FromEachInputFileOutput struct{ *pulumi.OutputState }

func (FromEachInputFileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FromEachInputFile)(nil)).Elem()
}

func (o FromEachInputFileOutput) ToFromEachInputFileOutput() FromEachInputFileOutput {
	return o
}

func (o FromEachInputFileOutput) ToFromEachInputFileOutputWithContext(ctx context.Context) FromEachInputFileOutput {
	return o
}

// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
func (o FromEachInputFileOutput) IncludedTracks() pulumi.ArrayOutput {
	return o.ApplyT(func(v FromEachInputFile) []interface{} { return v.IncludedTracks }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.FromEachInputFile'.
func (o FromEachInputFileOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v FromEachInputFile) string { return v.OdataType }).(pulumi.StringOutput)
}

// An InputDefinition that looks at each input file provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to select tracks from each file given.
type FromEachInputFileResponse struct {
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FromEachInputFile'.
	OdataType string `pulumi:"odataType"`
}

// An InputDefinition that looks at each input file provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to select tracks from each file given.
type FromEachInputFileResponseOutput struct{ *pulumi.OutputState }

func (FromEachInputFileResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FromEachInputFileResponse)(nil)).Elem()
}

func (o FromEachInputFileResponseOutput) ToFromEachInputFileResponseOutput() FromEachInputFileResponseOutput {
	return o
}

func (o FromEachInputFileResponseOutput) ToFromEachInputFileResponseOutputWithContext(ctx context.Context) FromEachInputFileResponseOutput {
	return o
}

// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
func (o FromEachInputFileResponseOutput) IncludedTracks() pulumi.ArrayOutput {
	return o.ApplyT(func(v FromEachInputFileResponse) []interface{} { return v.IncludedTracks }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.FromEachInputFile'.
func (o FromEachInputFileResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v FromEachInputFileResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.264 video codec.
type H264Layer struct {
	// Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `pulumi:"adaptiveBFrame"`
	// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames *int `pulumi:"bFrames"`
	// The average bitrate in bits per second at which to encode the input video when generating this layer. This is a required field.
	Bitrate int `pulumi:"bitrate"`
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
	BufferWindow *string `pulumi:"bufferWindow"`
	// The value of CRF to be used when encoding this layer. This setting takes effect when RateControlMode of video codec is set at CRF mode. The range of CRF value is between 0 and 51, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default value is 23.
	Crf *float64 `pulumi:"crf"`
	// The entropy mode to be used for this layer. If not specified, the encoder chooses the mode that is appropriate for the profile and level.
	EntropyMode *string `pulumi:"entropyMode"`
	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate *string `pulumi:"frameRate"`
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.264 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
	Level *string `pulumi:"level"`
	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int `pulumi:"maxBitrate"`
	// We currently support Baseline, Main, High, High422, High444. Default is Auto.
	Profile *string `pulumi:"profile"`
	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
	ReferenceFrames *int `pulumi:"referenceFrames"`
	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices *int `pulumi:"slices"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// H264LayerInput is an input type that accepts H264LayerArgs and H264LayerOutput values.
// You can construct a concrete instance of `H264LayerInput` via:
//
//	H264LayerArgs{...}
type H264LayerInput interface {
	pulumi.Input

	ToH264LayerOutput() H264LayerOutput
	ToH264LayerOutputWithContext(context.Context) H264LayerOutput
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.264 video codec.
type H264LayerArgs struct {
	// Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame pulumi.BoolPtrInput `pulumi:"adaptiveBFrame"`
	// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames pulumi.IntPtrInput `pulumi:"bFrames"`
	// The average bitrate in bits per second at which to encode the input video when generating this layer. This is a required field.
	Bitrate pulumi.IntInput `pulumi:"bitrate"`
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
	BufferWindow pulumi.StringPtrInput `pulumi:"bufferWindow"`
	// The value of CRF to be used when encoding this layer. This setting takes effect when RateControlMode of video codec is set at CRF mode. The range of CRF value is between 0 and 51, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default value is 23.
	Crf pulumi.Float64PtrInput `pulumi:"crf"`
	// The entropy mode to be used for this layer. If not specified, the encoder chooses the mode that is appropriate for the profile and level.
	EntropyMode pulumi.StringPtrInput `pulumi:"entropyMode"`
	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate pulumi.StringPtrInput `pulumi:"frameRate"`
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height pulumi.StringPtrInput `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.264 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
	Level pulumi.StringPtrInput `pulumi:"level"`
	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate pulumi.IntPtrInput `pulumi:"maxBitrate"`
	// We currently support Baseline, Main, High, High422, High444. Default is Auto.
	Profile pulumi.StringPtrInput `pulumi:"profile"`
	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
	ReferenceFrames pulumi.IntPtrInput `pulumi:"referenceFrames"`
	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices pulumi.IntPtrInput `pulumi:"slices"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width pulumi.StringPtrInput `pulumi:"width"`
}

func (H264LayerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*H264Layer)(nil)).Elem()
}

func (i H264LayerArgs) ToH264LayerOutput() H264LayerOutput {
	return i.ToH264LayerOutputWithContext(context.Background())
}

func (i H264LayerArgs) ToH264LayerOutputWithContext(ctx context.Context) H264LayerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(H264LayerOutput)
}

// H264LayerArrayInput is an input type that accepts H264LayerArray and H264LayerArrayOutput values.
// You can construct a concrete instance of `H264LayerArrayInput` via:
//
//	H264LayerArray{ H264LayerArgs{...} }
type H264LayerArrayInput interface {
	pulumi.Input

	ToH264LayerArrayOutput() H264LayerArrayOutput
	ToH264LayerArrayOutputWithContext(context.Context) H264LayerArrayOutput
}

type H264LayerArray []H264LayerInput

func (H264LayerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]H264Layer)(nil)).Elem()
}

func (i H264LayerArray) ToH264LayerArrayOutput() H264LayerArrayOutput {
	return i.ToH264LayerArrayOutputWithContext(context.Background())
}

func (i H264LayerArray) ToH264LayerArrayOutputWithContext(ctx context.Context) H264LayerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(H264LayerArrayOutput)
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.264 video codec.
type H264LayerOutput struct{ *pulumi.OutputState }

func (H264LayerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*H264Layer)(nil)).Elem()
}

func (o H264LayerOutput) ToH264LayerOutput() H264LayerOutput {
	return o
}

func (o H264LayerOutput) ToH264LayerOutputWithContext(ctx context.Context) H264LayerOutput {
	return o
}

// Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
func (o H264LayerOutput) AdaptiveBFrame() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v H264Layer) *bool { return v.AdaptiveBFrame }).(pulumi.BoolPtrOutput)
}

// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
func (o H264LayerOutput) BFrames() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H264Layer) *int { return v.BFrames }).(pulumi.IntPtrOutput)
}

// The average bitrate in bits per second at which to encode the input video when generating this layer. This is a required field.
func (o H264LayerOutput) Bitrate() pulumi.IntOutput {
	return o.ApplyT(func(v H264Layer) int { return v.Bitrate }).(pulumi.IntOutput)
}

// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
func (o H264LayerOutput) BufferWindow() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Layer) *string { return v.BufferWindow }).(pulumi.StringPtrOutput)
}

// The value of CRF to be used when encoding this layer. This setting takes effect when RateControlMode of video codec is set at CRF mode. The range of CRF value is between 0 and 51, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default value is 23.
func (o H264LayerOutput) Crf() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v H264Layer) *float64 { return v.Crf }).(pulumi.Float64PtrOutput)
}

// The entropy mode to be used for this layer. If not specified, the encoder chooses the mode that is appropriate for the profile and level.
func (o H264LayerOutput) EntropyMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Layer) *string { return v.EntropyMode }).(pulumi.StringPtrOutput)
}

// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
func (o H264LayerOutput) FrameRate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Layer) *string { return v.FrameRate }).(pulumi.StringPtrOutput)
}

// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
func (o H264LayerOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Layer) *string { return v.Height }).(pulumi.StringPtrOutput)
}

// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
func (o H264LayerOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Layer) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.264 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
func (o H264LayerOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Layer) *string { return v.Level }).(pulumi.StringPtrOutput)
}

// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
func (o H264LayerOutput) MaxBitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H264Layer) *int { return v.MaxBitrate }).(pulumi.IntPtrOutput)
}

// We currently support Baseline, Main, High, High422, High444. Default is Auto.
func (o H264LayerOutput) Profile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Layer) *string { return v.Profile }).(pulumi.StringPtrOutput)
}

// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
func (o H264LayerOutput) ReferenceFrames() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H264Layer) *int { return v.ReferenceFrames }).(pulumi.IntPtrOutput)
}

// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
func (o H264LayerOutput) Slices() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H264Layer) *int { return v.Slices }).(pulumi.IntPtrOutput)
}

// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
func (o H264LayerOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Layer) *string { return v.Width }).(pulumi.StringPtrOutput)
}

type H264LayerArrayOutput struct{ *pulumi.OutputState }

func (H264LayerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]H264Layer)(nil)).Elem()
}

func (o H264LayerArrayOutput) ToH264LayerArrayOutput() H264LayerArrayOutput {
	return o
}

func (o H264LayerArrayOutput) ToH264LayerArrayOutputWithContext(ctx context.Context) H264LayerArrayOutput {
	return o
}

func (o H264LayerArrayOutput) Index(i pulumi.IntInput) H264LayerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) H264Layer {
		return vs[0].([]H264Layer)[vs[1].(int)]
	}).(H264LayerOutput)
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.264 video codec.
type H264LayerResponse struct {
	// Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `pulumi:"adaptiveBFrame"`
	// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames *int `pulumi:"bFrames"`
	// The average bitrate in bits per second at which to encode the input video when generating this layer. This is a required field.
	Bitrate int `pulumi:"bitrate"`
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
	BufferWindow *string `pulumi:"bufferWindow"`
	// The value of CRF to be used when encoding this layer. This setting takes effect when RateControlMode of video codec is set at CRF mode. The range of CRF value is between 0 and 51, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default value is 23.
	Crf *float64 `pulumi:"crf"`
	// The entropy mode to be used for this layer. If not specified, the encoder chooses the mode that is appropriate for the profile and level.
	EntropyMode *string `pulumi:"entropyMode"`
	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate *string `pulumi:"frameRate"`
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.264 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
	Level *string `pulumi:"level"`
	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int `pulumi:"maxBitrate"`
	// We currently support Baseline, Main, High, High422, High444. Default is Auto.
	Profile *string `pulumi:"profile"`
	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
	ReferenceFrames *int `pulumi:"referenceFrames"`
	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices *int `pulumi:"slices"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.264 video codec.
type H264LayerResponseOutput struct{ *pulumi.OutputState }

func (H264LayerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*H264LayerResponse)(nil)).Elem()
}

func (o H264LayerResponseOutput) ToH264LayerResponseOutput() H264LayerResponseOutput {
	return o
}

func (o H264LayerResponseOutput) ToH264LayerResponseOutputWithContext(ctx context.Context) H264LayerResponseOutput {
	return o
}

// Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
func (o H264LayerResponseOutput) AdaptiveBFrame() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *bool { return v.AdaptiveBFrame }).(pulumi.BoolPtrOutput)
}

// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
func (o H264LayerResponseOutput) BFrames() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *int { return v.BFrames }).(pulumi.IntPtrOutput)
}

// The average bitrate in bits per second at which to encode the input video when generating this layer. This is a required field.
func (o H264LayerResponseOutput) Bitrate() pulumi.IntOutput {
	return o.ApplyT(func(v H264LayerResponse) int { return v.Bitrate }).(pulumi.IntOutput)
}

// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
func (o H264LayerResponseOutput) BufferWindow() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *string { return v.BufferWindow }).(pulumi.StringPtrOutput)
}

// The value of CRF to be used when encoding this layer. This setting takes effect when RateControlMode of video codec is set at CRF mode. The range of CRF value is between 0 and 51, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default value is 23.
func (o H264LayerResponseOutput) Crf() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *float64 { return v.Crf }).(pulumi.Float64PtrOutput)
}

// The entropy mode to be used for this layer. If not specified, the encoder chooses the mode that is appropriate for the profile and level.
func (o H264LayerResponseOutput) EntropyMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *string { return v.EntropyMode }).(pulumi.StringPtrOutput)
}

// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
func (o H264LayerResponseOutput) FrameRate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *string { return v.FrameRate }).(pulumi.StringPtrOutput)
}

// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
func (o H264LayerResponseOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *string { return v.Height }).(pulumi.StringPtrOutput)
}

// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
func (o H264LayerResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.264 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
func (o H264LayerResponseOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *string { return v.Level }).(pulumi.StringPtrOutput)
}

// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
func (o H264LayerResponseOutput) MaxBitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *int { return v.MaxBitrate }).(pulumi.IntPtrOutput)
}

// We currently support Baseline, Main, High, High422, High444. Default is Auto.
func (o H264LayerResponseOutput) Profile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *string { return v.Profile }).(pulumi.StringPtrOutput)
}

// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
func (o H264LayerResponseOutput) ReferenceFrames() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *int { return v.ReferenceFrames }).(pulumi.IntPtrOutput)
}

// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
func (o H264LayerResponseOutput) Slices() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *int { return v.Slices }).(pulumi.IntPtrOutput)
}

// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
func (o H264LayerResponseOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264LayerResponse) *string { return v.Width }).(pulumi.StringPtrOutput)
}

type H264LayerResponseArrayOutput struct{ *pulumi.OutputState }

func (H264LayerResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]H264LayerResponse)(nil)).Elem()
}

func (o H264LayerResponseArrayOutput) ToH264LayerResponseArrayOutput() H264LayerResponseArrayOutput {
	return o
}

func (o H264LayerResponseArrayOutput) ToH264LayerResponseArrayOutputWithContext(ctx context.Context) H264LayerResponseArrayOutput {
	return o
}

func (o H264LayerResponseArrayOutput) Index(i pulumi.IntInput) H264LayerResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) H264LayerResponse {
		return vs[0].([]H264LayerResponse)[vs[1].(int)]
	}).(H264LayerResponseOutput)
}

// Describes all the properties for encoding a video with the H.264 codec.
type H264Video struct {
	// Tells the encoder how to choose its encoding settings. The default value is Balanced.
	Complexity *string `pulumi:"complexity"`
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The collection of output H.264 layers to be produced by the encoder.
	Layers []H264Layer `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H264Video'.
	OdataType string `pulumi:"odataType"`
	// The video rate control mode
	RateControlMode *string `pulumi:"rateControlMode"`
	// Whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
	SceneChangeDetection *bool `pulumi:"sceneChangeDetection"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// H264VideoInput is an input type that accepts H264VideoArgs and H264VideoOutput values.
// You can construct a concrete instance of `H264VideoInput` via:
//
//	H264VideoArgs{...}
type H264VideoInput interface {
	pulumi.Input

	ToH264VideoOutput() H264VideoOutput
	ToH264VideoOutputWithContext(context.Context) H264VideoOutput
}

// Describes all the properties for encoding a video with the H.264 codec.
type H264VideoArgs struct {
	// Tells the encoder how to choose its encoding settings. The default value is Balanced.
	Complexity pulumi.StringPtrInput `pulumi:"complexity"`
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval pulumi.StringPtrInput `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The collection of output H.264 layers to be produced by the encoder.
	Layers H264LayerArrayInput `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H264Video'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The video rate control mode
	RateControlMode pulumi.StringPtrInput `pulumi:"rateControlMode"`
	// Whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
	SceneChangeDetection pulumi.BoolPtrInput `pulumi:"sceneChangeDetection"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode pulumi.StringPtrInput `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode pulumi.StringPtrInput `pulumi:"syncMode"`
}

func (H264VideoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*H264Video)(nil)).Elem()
}

func (i H264VideoArgs) ToH264VideoOutput() H264VideoOutput {
	return i.ToH264VideoOutputWithContext(context.Background())
}

func (i H264VideoArgs) ToH264VideoOutputWithContext(ctx context.Context) H264VideoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(H264VideoOutput)
}

// Describes all the properties for encoding a video with the H.264 codec.
type H264VideoOutput struct{ *pulumi.OutputState }

func (H264VideoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*H264Video)(nil)).Elem()
}

func (o H264VideoOutput) ToH264VideoOutput() H264VideoOutput {
	return o
}

func (o H264VideoOutput) ToH264VideoOutputWithContext(ctx context.Context) H264VideoOutput {
	return o
}

// Tells the encoder how to choose its encoding settings. The default value is Balanced.
func (o H264VideoOutput) Complexity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Video) *string { return v.Complexity }).(pulumi.StringPtrOutput)
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o H264VideoOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Video) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o H264VideoOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Video) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The collection of output H.264 layers to be produced by the encoder.
func (o H264VideoOutput) Layers() H264LayerArrayOutput {
	return o.ApplyT(func(v H264Video) []H264Layer { return v.Layers }).(H264LayerArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.H264Video'.
func (o H264VideoOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v H264Video) string { return v.OdataType }).(pulumi.StringOutput)
}

// The video rate control mode
func (o H264VideoOutput) RateControlMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Video) *string { return v.RateControlMode }).(pulumi.StringPtrOutput)
}

// Whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
func (o H264VideoOutput) SceneChangeDetection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v H264Video) *bool { return v.SceneChangeDetection }).(pulumi.BoolPtrOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o H264VideoOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Video) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o H264VideoOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264Video) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// Describes all the properties for encoding a video with the H.264 codec.
type H264VideoResponse struct {
	// Tells the encoder how to choose its encoding settings. The default value is Balanced.
	Complexity *string `pulumi:"complexity"`
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The collection of output H.264 layers to be produced by the encoder.
	Layers []H264LayerResponse `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H264Video'.
	OdataType string `pulumi:"odataType"`
	// The video rate control mode
	RateControlMode *string `pulumi:"rateControlMode"`
	// Whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
	SceneChangeDetection *bool `pulumi:"sceneChangeDetection"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes all the properties for encoding a video with the H.264 codec.
type H264VideoResponseOutput struct{ *pulumi.OutputState }

func (H264VideoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*H264VideoResponse)(nil)).Elem()
}

func (o H264VideoResponseOutput) ToH264VideoResponseOutput() H264VideoResponseOutput {
	return o
}

func (o H264VideoResponseOutput) ToH264VideoResponseOutputWithContext(ctx context.Context) H264VideoResponseOutput {
	return o
}

// Tells the encoder how to choose its encoding settings. The default value is Balanced.
func (o H264VideoResponseOutput) Complexity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264VideoResponse) *string { return v.Complexity }).(pulumi.StringPtrOutput)
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o H264VideoResponseOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264VideoResponse) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o H264VideoResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264VideoResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The collection of output H.264 layers to be produced by the encoder.
func (o H264VideoResponseOutput) Layers() H264LayerResponseArrayOutput {
	return o.ApplyT(func(v H264VideoResponse) []H264LayerResponse { return v.Layers }).(H264LayerResponseArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.H264Video'.
func (o H264VideoResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v H264VideoResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The video rate control mode
func (o H264VideoResponseOutput) RateControlMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264VideoResponse) *string { return v.RateControlMode }).(pulumi.StringPtrOutput)
}

// Whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
func (o H264VideoResponseOutput) SceneChangeDetection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v H264VideoResponse) *bool { return v.SceneChangeDetection }).(pulumi.BoolPtrOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o H264VideoResponseOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264VideoResponse) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o H264VideoResponseOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H264VideoResponse) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.265 video codec.
type H265Layer struct {
	// Specifies whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `pulumi:"adaptiveBFrame"`
	// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames *int `pulumi:"bFrames"`
	// The average bitrate in bits per second at which to encode the input video when generating this layer. For example: a target bitrate of 3000Kbps or 3Mbps means this value should be 3000000 This is a required field.
	Bitrate int `pulumi:"bitrate"`
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
	BufferWindow *string `pulumi:"bufferWindow"`
	// The value of CRF to be used when encoding this layer. This setting takes effect when RateControlMode of video codec is set at CRF mode. The range of CRF value is between 0 and 51, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default value is 28.
	Crf *float64 `pulumi:"crf"`
	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate *string `pulumi:"frameRate"`
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.265 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
	Level *string `pulumi:"level"`
	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int `pulumi:"maxBitrate"`
	// We currently support Main. Default is Auto.
	Profile *string `pulumi:"profile"`
	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
	ReferenceFrames *int `pulumi:"referenceFrames"`
	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices *int `pulumi:"slices"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// H265LayerInput is an input type that accepts H265LayerArgs and H265LayerOutput values.
// You can construct a concrete instance of `H265LayerInput` via:
//
//	H265LayerArgs{...}
type H265LayerInput interface {
	pulumi.Input

	ToH265LayerOutput() H265LayerOutput
	ToH265LayerOutputWithContext(context.Context) H265LayerOutput
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.265 video codec.
type H265LayerArgs struct {
	// Specifies whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame pulumi.BoolPtrInput `pulumi:"adaptiveBFrame"`
	// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames pulumi.IntPtrInput `pulumi:"bFrames"`
	// The average bitrate in bits per second at which to encode the input video when generating this layer. For example: a target bitrate of 3000Kbps or 3Mbps means this value should be 3000000 This is a required field.
	Bitrate pulumi.IntInput `pulumi:"bitrate"`
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
	BufferWindow pulumi.StringPtrInput `pulumi:"bufferWindow"`
	// The value of CRF to be used when encoding this layer. This setting takes effect when RateControlMode of video codec is set at CRF mode. The range of CRF value is between 0 and 51, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default value is 28.
	Crf pulumi.Float64PtrInput `pulumi:"crf"`
	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate pulumi.StringPtrInput `pulumi:"frameRate"`
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height pulumi.StringPtrInput `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.265 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
	Level pulumi.StringPtrInput `pulumi:"level"`
	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate pulumi.IntPtrInput `pulumi:"maxBitrate"`
	// We currently support Main. Default is Auto.
	Profile pulumi.StringPtrInput `pulumi:"profile"`
	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
	ReferenceFrames pulumi.IntPtrInput `pulumi:"referenceFrames"`
	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices pulumi.IntPtrInput `pulumi:"slices"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width pulumi.StringPtrInput `pulumi:"width"`
}

func (H265LayerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*H265Layer)(nil)).Elem()
}

func (i H265LayerArgs) ToH265LayerOutput() H265LayerOutput {
	return i.ToH265LayerOutputWithContext(context.Background())
}

func (i H265LayerArgs) ToH265LayerOutputWithContext(ctx context.Context) H265LayerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(H265LayerOutput)
}

// H265LayerArrayInput is an input type that accepts H265LayerArray and H265LayerArrayOutput values.
// You can construct a concrete instance of `H265LayerArrayInput` via:
//
//	H265LayerArray{ H265LayerArgs{...} }
type H265LayerArrayInput interface {
	pulumi.Input

	ToH265LayerArrayOutput() H265LayerArrayOutput
	ToH265LayerArrayOutputWithContext(context.Context) H265LayerArrayOutput
}

type H265LayerArray []H265LayerInput

func (H265LayerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]H265Layer)(nil)).Elem()
}

func (i H265LayerArray) ToH265LayerArrayOutput() H265LayerArrayOutput {
	return i.ToH265LayerArrayOutputWithContext(context.Background())
}

func (i H265LayerArray) ToH265LayerArrayOutputWithContext(ctx context.Context) H265LayerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(H265LayerArrayOutput)
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.265 video codec.
type H265LayerOutput struct{ *pulumi.OutputState }

func (H265LayerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*H265Layer)(nil)).Elem()
}

func (o H265LayerOutput) ToH265LayerOutput() H265LayerOutput {
	return o
}

func (o H265LayerOutput) ToH265LayerOutputWithContext(ctx context.Context) H265LayerOutput {
	return o
}

// Specifies whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
func (o H265LayerOutput) AdaptiveBFrame() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v H265Layer) *bool { return v.AdaptiveBFrame }).(pulumi.BoolPtrOutput)
}

// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
func (o H265LayerOutput) BFrames() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H265Layer) *int { return v.BFrames }).(pulumi.IntPtrOutput)
}

// The average bitrate in bits per second at which to encode the input video when generating this layer. For example: a target bitrate of 3000Kbps or 3Mbps means this value should be 3000000 This is a required field.
func (o H265LayerOutput) Bitrate() pulumi.IntOutput {
	return o.ApplyT(func(v H265Layer) int { return v.Bitrate }).(pulumi.IntOutput)
}

// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
func (o H265LayerOutput) BufferWindow() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Layer) *string { return v.BufferWindow }).(pulumi.StringPtrOutput)
}

// The value of CRF to be used when encoding this layer. This setting takes effect when RateControlMode of video codec is set at CRF mode. The range of CRF value is between 0 and 51, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default value is 28.
func (o H265LayerOutput) Crf() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v H265Layer) *float64 { return v.Crf }).(pulumi.Float64PtrOutput)
}

// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
func (o H265LayerOutput) FrameRate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Layer) *string { return v.FrameRate }).(pulumi.StringPtrOutput)
}

// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
func (o H265LayerOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Layer) *string { return v.Height }).(pulumi.StringPtrOutput)
}

// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
func (o H265LayerOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Layer) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.265 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
func (o H265LayerOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Layer) *string { return v.Level }).(pulumi.StringPtrOutput)
}

// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
func (o H265LayerOutput) MaxBitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H265Layer) *int { return v.MaxBitrate }).(pulumi.IntPtrOutput)
}

// We currently support Main. Default is Auto.
func (o H265LayerOutput) Profile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Layer) *string { return v.Profile }).(pulumi.StringPtrOutput)
}

// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
func (o H265LayerOutput) ReferenceFrames() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H265Layer) *int { return v.ReferenceFrames }).(pulumi.IntPtrOutput)
}

// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
func (o H265LayerOutput) Slices() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H265Layer) *int { return v.Slices }).(pulumi.IntPtrOutput)
}

// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
func (o H265LayerOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Layer) *string { return v.Width }).(pulumi.StringPtrOutput)
}

type H265LayerArrayOutput struct{ *pulumi.OutputState }

func (H265LayerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]H265Layer)(nil)).Elem()
}

func (o H265LayerArrayOutput) ToH265LayerArrayOutput() H265LayerArrayOutput {
	return o
}

func (o H265LayerArrayOutput) ToH265LayerArrayOutputWithContext(ctx context.Context) H265LayerArrayOutput {
	return o
}

func (o H265LayerArrayOutput) Index(i pulumi.IntInput) H265LayerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) H265Layer {
		return vs[0].([]H265Layer)[vs[1].(int)]
	}).(H265LayerOutput)
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.265 video codec.
type H265LayerResponse struct {
	// Specifies whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `pulumi:"adaptiveBFrame"`
	// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames *int `pulumi:"bFrames"`
	// The average bitrate in bits per second at which to encode the input video when generating this layer. For example: a target bitrate of 3000Kbps or 3Mbps means this value should be 3000000 This is a required field.
	Bitrate int `pulumi:"bitrate"`
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
	BufferWindow *string `pulumi:"bufferWindow"`
	// The value of CRF to be used when encoding this layer. This setting takes effect when RateControlMode of video codec is set at CRF mode. The range of CRF value is between 0 and 51, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default value is 28.
	Crf *float64 `pulumi:"crf"`
	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate *string `pulumi:"frameRate"`
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.265 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
	Level *string `pulumi:"level"`
	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int `pulumi:"maxBitrate"`
	// We currently support Main. Default is Auto.
	Profile *string `pulumi:"profile"`
	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
	ReferenceFrames *int `pulumi:"referenceFrames"`
	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices *int `pulumi:"slices"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.265 video codec.
type H265LayerResponseOutput struct{ *pulumi.OutputState }

func (H265LayerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*H265LayerResponse)(nil)).Elem()
}

func (o H265LayerResponseOutput) ToH265LayerResponseOutput() H265LayerResponseOutput {
	return o
}

func (o H265LayerResponseOutput) ToH265LayerResponseOutputWithContext(ctx context.Context) H265LayerResponseOutput {
	return o
}

// Specifies whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
func (o H265LayerResponseOutput) AdaptiveBFrame() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *bool { return v.AdaptiveBFrame }).(pulumi.BoolPtrOutput)
}

// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
func (o H265LayerResponseOutput) BFrames() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *int { return v.BFrames }).(pulumi.IntPtrOutput)
}

// The average bitrate in bits per second at which to encode the input video when generating this layer. For example: a target bitrate of 3000Kbps or 3Mbps means this value should be 3000000 This is a required field.
func (o H265LayerResponseOutput) Bitrate() pulumi.IntOutput {
	return o.ApplyT(func(v H265LayerResponse) int { return v.Bitrate }).(pulumi.IntOutput)
}

// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
func (o H265LayerResponseOutput) BufferWindow() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *string { return v.BufferWindow }).(pulumi.StringPtrOutput)
}

// The value of CRF to be used when encoding this layer. This setting takes effect when RateControlMode of video codec is set at CRF mode. The range of CRF value is between 0 and 51, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default value is 28.
func (o H265LayerResponseOutput) Crf() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *float64 { return v.Crf }).(pulumi.Float64PtrOutput)
}

// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
func (o H265LayerResponseOutput) FrameRate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *string { return v.FrameRate }).(pulumi.StringPtrOutput)
}

// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
func (o H265LayerResponseOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *string { return v.Height }).(pulumi.StringPtrOutput)
}

// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
func (o H265LayerResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.265 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
func (o H265LayerResponseOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *string { return v.Level }).(pulumi.StringPtrOutput)
}

// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
func (o H265LayerResponseOutput) MaxBitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *int { return v.MaxBitrate }).(pulumi.IntPtrOutput)
}

// We currently support Main. Default is Auto.
func (o H265LayerResponseOutput) Profile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *string { return v.Profile }).(pulumi.StringPtrOutput)
}

// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
func (o H265LayerResponseOutput) ReferenceFrames() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *int { return v.ReferenceFrames }).(pulumi.IntPtrOutput)
}

// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
func (o H265LayerResponseOutput) Slices() pulumi.IntPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *int { return v.Slices }).(pulumi.IntPtrOutput)
}

// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
func (o H265LayerResponseOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265LayerResponse) *string { return v.Width }).(pulumi.StringPtrOutput)
}

type H265LayerResponseArrayOutput struct{ *pulumi.OutputState }

func (H265LayerResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]H265LayerResponse)(nil)).Elem()
}

func (o H265LayerResponseArrayOutput) ToH265LayerResponseArrayOutput() H265LayerResponseArrayOutput {
	return o
}

func (o H265LayerResponseArrayOutput) ToH265LayerResponseArrayOutputWithContext(ctx context.Context) H265LayerResponseArrayOutput {
	return o
}

func (o H265LayerResponseArrayOutput) Index(i pulumi.IntInput) H265LayerResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) H265LayerResponse {
		return vs[0].([]H265LayerResponse)[vs[1].(int)]
	}).(H265LayerResponseOutput)
}

// Describes all the properties for encoding a video with the H.265 codec.
type H265Video struct {
	// Tells the encoder how to choose its encoding settings.  Quality will provide for a higher compression ratio but at a higher cost and longer compute time.  Speed will produce a relatively larger file but is faster and more economical. The default value is Balanced.
	Complexity *string `pulumi:"complexity"`
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The collection of output H.265 layers to be produced by the encoder.
	Layers []H265Layer `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H265Video'.
	OdataType string `pulumi:"odataType"`
	// Specifies whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
	SceneChangeDetection *bool `pulumi:"sceneChangeDetection"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// H265VideoInput is an input type that accepts H265VideoArgs and H265VideoOutput values.
// You can construct a concrete instance of `H265VideoInput` via:
//
//	H265VideoArgs{...}
type H265VideoInput interface {
	pulumi.Input

	ToH265VideoOutput() H265VideoOutput
	ToH265VideoOutputWithContext(context.Context) H265VideoOutput
}

// Describes all the properties for encoding a video with the H.265 codec.
type H265VideoArgs struct {
	// Tells the encoder how to choose its encoding settings.  Quality will provide for a higher compression ratio but at a higher cost and longer compute time.  Speed will produce a relatively larger file but is faster and more economical. The default value is Balanced.
	Complexity pulumi.StringPtrInput `pulumi:"complexity"`
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval pulumi.StringPtrInput `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The collection of output H.265 layers to be produced by the encoder.
	Layers H265LayerArrayInput `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H265Video'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Specifies whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
	SceneChangeDetection pulumi.BoolPtrInput `pulumi:"sceneChangeDetection"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode pulumi.StringPtrInput `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode pulumi.StringPtrInput `pulumi:"syncMode"`
}

func (H265VideoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*H265Video)(nil)).Elem()
}

func (i H265VideoArgs) ToH265VideoOutput() H265VideoOutput {
	return i.ToH265VideoOutputWithContext(context.Background())
}

func (i H265VideoArgs) ToH265VideoOutputWithContext(ctx context.Context) H265VideoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(H265VideoOutput)
}

// Describes all the properties for encoding a video with the H.265 codec.
type H265VideoOutput struct{ *pulumi.OutputState }

func (H265VideoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*H265Video)(nil)).Elem()
}

func (o H265VideoOutput) ToH265VideoOutput() H265VideoOutput {
	return o
}

func (o H265VideoOutput) ToH265VideoOutputWithContext(ctx context.Context) H265VideoOutput {
	return o
}

// Tells the encoder how to choose its encoding settings.  Quality will provide for a higher compression ratio but at a higher cost and longer compute time.  Speed will produce a relatively larger file but is faster and more economical. The default value is Balanced.
func (o H265VideoOutput) Complexity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Video) *string { return v.Complexity }).(pulumi.StringPtrOutput)
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o H265VideoOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Video) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o H265VideoOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Video) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The collection of output H.265 layers to be produced by the encoder.
func (o H265VideoOutput) Layers() H265LayerArrayOutput {
	return o.ApplyT(func(v H265Video) []H265Layer { return v.Layers }).(H265LayerArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.H265Video'.
func (o H265VideoOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v H265Video) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
func (o H265VideoOutput) SceneChangeDetection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v H265Video) *bool { return v.SceneChangeDetection }).(pulumi.BoolPtrOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o H265VideoOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Video) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o H265VideoOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265Video) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// Describes all the properties for encoding a video with the H.265 codec.
type H265VideoResponse struct {
	// Tells the encoder how to choose its encoding settings.  Quality will provide for a higher compression ratio but at a higher cost and longer compute time.  Speed will produce a relatively larger file but is faster and more economical. The default value is Balanced.
	Complexity *string `pulumi:"complexity"`
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The collection of output H.265 layers to be produced by the encoder.
	Layers []H265LayerResponse `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H265Video'.
	OdataType string `pulumi:"odataType"`
	// Specifies whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
	SceneChangeDetection *bool `pulumi:"sceneChangeDetection"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes all the properties for encoding a video with the H.265 codec.
type H265VideoResponseOutput struct{ *pulumi.OutputState }

func (H265VideoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*H265VideoResponse)(nil)).Elem()
}

func (o H265VideoResponseOutput) ToH265VideoResponseOutput() H265VideoResponseOutput {
	return o
}

func (o H265VideoResponseOutput) ToH265VideoResponseOutputWithContext(ctx context.Context) H265VideoResponseOutput {
	return o
}

// Tells the encoder how to choose its encoding settings.  Quality will provide for a higher compression ratio but at a higher cost and longer compute time.  Speed will produce a relatively larger file but is faster and more economical. The default value is Balanced.
func (o H265VideoResponseOutput) Complexity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265VideoResponse) *string { return v.Complexity }).(pulumi.StringPtrOutput)
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o H265VideoResponseOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265VideoResponse) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o H265VideoResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265VideoResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The collection of output H.265 layers to be produced by the encoder.
func (o H265VideoResponseOutput) Layers() H265LayerResponseArrayOutput {
	return o.ApplyT(func(v H265VideoResponse) []H265LayerResponse { return v.Layers }).(H265LayerResponseArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.H265Video'.
func (o H265VideoResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v H265VideoResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Specifies whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
func (o H265VideoResponseOutput) SceneChangeDetection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v H265VideoResponse) *bool { return v.SceneChangeDetection }).(pulumi.BoolPtrOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o H265VideoResponseOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265VideoResponse) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o H265VideoResponseOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v H265VideoResponse) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// HTTP Live Streaming (HLS) packing setting for the live output.
type Hls struct {
	// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
	FragmentsPerTsSegment *int `pulumi:"fragmentsPerTsSegment"`
}

// HlsInput is an input type that accepts HlsArgs and HlsOutput values.
// You can construct a concrete instance of `HlsInput` via:
//
//	HlsArgs{...}
type HlsInput interface {
	pulumi.Input

	ToHlsOutput() HlsOutput
	ToHlsOutputWithContext(context.Context) HlsOutput
}

// HTTP Live Streaming (HLS) packing setting for the live output.
type HlsArgs struct {
	// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
	FragmentsPerTsSegment pulumi.IntPtrInput `pulumi:"fragmentsPerTsSegment"`
}

func (HlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hls)(nil)).Elem()
}

func (i HlsArgs) ToHlsOutput() HlsOutput {
	return i.ToHlsOutputWithContext(context.Background())
}

func (i HlsArgs) ToHlsOutputWithContext(ctx context.Context) HlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HlsOutput)
}

func (i HlsArgs) ToHlsPtrOutput() HlsPtrOutput {
	return i.ToHlsPtrOutputWithContext(context.Background())
}

func (i HlsArgs) ToHlsPtrOutputWithContext(ctx context.Context) HlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HlsOutput).ToHlsPtrOutputWithContext(ctx)
}

// HlsPtrInput is an input type that accepts HlsArgs, HlsPtr and HlsPtrOutput values.
// You can construct a concrete instance of `HlsPtrInput` via:
//
//	        HlsArgs{...}
//
//	or:
//
//	        nil
type HlsPtrInput interface {
	pulumi.Input

	ToHlsPtrOutput() HlsPtrOutput
	ToHlsPtrOutputWithContext(context.Context) HlsPtrOutput
}

type hlsPtrType HlsArgs

func HlsPtr(v *HlsArgs) HlsPtrInput {
	return (*hlsPtrType)(v)
}

func (*hlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Hls)(nil)).Elem()
}

func (i *hlsPtrType) ToHlsPtrOutput() HlsPtrOutput {
	return i.ToHlsPtrOutputWithContext(context.Background())
}

func (i *hlsPtrType) ToHlsPtrOutputWithContext(ctx context.Context) HlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HlsPtrOutput)
}

// HTTP Live Streaming (HLS) packing setting for the live output.
type HlsOutput struct{ *pulumi.OutputState }

func (HlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hls)(nil)).Elem()
}

func (o HlsOutput) ToHlsOutput() HlsOutput {
	return o
}

func (o HlsOutput) ToHlsOutputWithContext(ctx context.Context) HlsOutput {
	return o
}

func (o HlsOutput) ToHlsPtrOutput() HlsPtrOutput {
	return o.ToHlsPtrOutputWithContext(context.Background())
}

func (o HlsOutput) ToHlsPtrOutputWithContext(ctx context.Context) HlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Hls) *Hls {
		return &v
	}).(HlsPtrOutput)
}

// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
func (o HlsOutput) FragmentsPerTsSegment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Hls) *int { return v.FragmentsPerTsSegment }).(pulumi.IntPtrOutput)
}

type HlsPtrOutput struct{ *pulumi.OutputState }

func (HlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Hls)(nil)).Elem()
}

func (o HlsPtrOutput) ToHlsPtrOutput() HlsPtrOutput {
	return o
}

func (o HlsPtrOutput) ToHlsPtrOutputWithContext(ctx context.Context) HlsPtrOutput {
	return o
}

func (o HlsPtrOutput) Elem() HlsOutput {
	return o.ApplyT(func(v *Hls) Hls {
		if v != nil {
			return *v
		}
		var ret Hls
		return ret
	}).(HlsOutput)
}

// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
func (o HlsPtrOutput) FragmentsPerTsSegment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Hls) *int {
		if v == nil {
			return nil
		}
		return v.FragmentsPerTsSegment
	}).(pulumi.IntPtrOutput)
}

// HTTP Live Streaming (HLS) packing setting for the live output.
type HlsResponse struct {
	// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
	FragmentsPerTsSegment *int `pulumi:"fragmentsPerTsSegment"`
}

// HTTP Live Streaming (HLS) packing setting for the live output.
type HlsResponseOutput struct{ *pulumi.OutputState }

func (HlsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HlsResponse)(nil)).Elem()
}

func (o HlsResponseOutput) ToHlsResponseOutput() HlsResponseOutput {
	return o
}

func (o HlsResponseOutput) ToHlsResponseOutputWithContext(ctx context.Context) HlsResponseOutput {
	return o
}

// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
func (o HlsResponseOutput) FragmentsPerTsSegment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HlsResponse) *int { return v.FragmentsPerTsSegment }).(pulumi.IntPtrOutput)
}

type HlsResponsePtrOutput struct{ *pulumi.OutputState }

func (HlsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HlsResponse)(nil)).Elem()
}

func (o HlsResponsePtrOutput) ToHlsResponsePtrOutput() HlsResponsePtrOutput {
	return o
}

func (o HlsResponsePtrOutput) ToHlsResponsePtrOutputWithContext(ctx context.Context) HlsResponsePtrOutput {
	return o
}

func (o HlsResponsePtrOutput) Elem() HlsResponseOutput {
	return o.ApplyT(func(v *HlsResponse) HlsResponse {
		if v != nil {
			return *v
		}
		var ret HlsResponse
		return ret
	}).(HlsResponseOutput)
}

// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
func (o HlsResponsePtrOutput) FragmentsPerTsSegment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HlsResponse) *int {
		if v == nil {
			return nil
		}
		return v.FragmentsPerTsSegment
	}).(pulumi.IntPtrOutput)
}

// The HLS setting for a track.
type HlsSettings struct {
	// The characteristics for the HLS setting.
	Characteristics *string `pulumi:"characteristics"`
	// The default for the HLS setting.
	Default *bool `pulumi:"default"`
	// The forced for the HLS setting.
	Forced *bool `pulumi:"forced"`
}

// HlsSettingsInput is an input type that accepts HlsSettingsArgs and HlsSettingsOutput values.
// You can construct a concrete instance of `HlsSettingsInput` via:
//
//	HlsSettingsArgs{...}
type HlsSettingsInput interface {
	pulumi.Input

	ToHlsSettingsOutput() HlsSettingsOutput
	ToHlsSettingsOutputWithContext(context.Context) HlsSettingsOutput
}

// The HLS setting for a track.
type HlsSettingsArgs struct {
	// The characteristics for the HLS setting.
	Characteristics pulumi.StringPtrInput `pulumi:"characteristics"`
	// The default for the HLS setting.
	Default pulumi.BoolPtrInput `pulumi:"default"`
	// The forced for the HLS setting.
	Forced pulumi.BoolPtrInput `pulumi:"forced"`
}

func (HlsSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HlsSettings)(nil)).Elem()
}

func (i HlsSettingsArgs) ToHlsSettingsOutput() HlsSettingsOutput {
	return i.ToHlsSettingsOutputWithContext(context.Background())
}

func (i HlsSettingsArgs) ToHlsSettingsOutputWithContext(ctx context.Context) HlsSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HlsSettingsOutput)
}

func (i HlsSettingsArgs) ToHlsSettingsPtrOutput() HlsSettingsPtrOutput {
	return i.ToHlsSettingsPtrOutputWithContext(context.Background())
}

func (i HlsSettingsArgs) ToHlsSettingsPtrOutputWithContext(ctx context.Context) HlsSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HlsSettingsOutput).ToHlsSettingsPtrOutputWithContext(ctx)
}

// HlsSettingsPtrInput is an input type that accepts HlsSettingsArgs, HlsSettingsPtr and HlsSettingsPtrOutput values.
// You can construct a concrete instance of `HlsSettingsPtrInput` via:
//
//	        HlsSettingsArgs{...}
//
//	or:
//
//	        nil
type HlsSettingsPtrInput interface {
	pulumi.Input

	ToHlsSettingsPtrOutput() HlsSettingsPtrOutput
	ToHlsSettingsPtrOutputWithContext(context.Context) HlsSettingsPtrOutput
}

type hlsSettingsPtrType HlsSettingsArgs

func HlsSettingsPtr(v *HlsSettingsArgs) HlsSettingsPtrInput {
	return (*hlsSettingsPtrType)(v)
}

func (*hlsSettingsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HlsSettings)(nil)).Elem()
}

func (i *hlsSettingsPtrType) ToHlsSettingsPtrOutput() HlsSettingsPtrOutput {
	return i.ToHlsSettingsPtrOutputWithContext(context.Background())
}

func (i *hlsSettingsPtrType) ToHlsSettingsPtrOutputWithContext(ctx context.Context) HlsSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HlsSettingsPtrOutput)
}

// The HLS setting for a track.
type HlsSettingsOutput struct{ *pulumi.OutputState }

func (HlsSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HlsSettings)(nil)).Elem()
}

func (o HlsSettingsOutput) ToHlsSettingsOutput() HlsSettingsOutput {
	return o
}

func (o HlsSettingsOutput) ToHlsSettingsOutputWithContext(ctx context.Context) HlsSettingsOutput {
	return o
}

func (o HlsSettingsOutput) ToHlsSettingsPtrOutput() HlsSettingsPtrOutput {
	return o.ToHlsSettingsPtrOutputWithContext(context.Background())
}

func (o HlsSettingsOutput) ToHlsSettingsPtrOutputWithContext(ctx context.Context) HlsSettingsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HlsSettings) *HlsSettings {
		return &v
	}).(HlsSettingsPtrOutput)
}

// The characteristics for the HLS setting.
func (o HlsSettingsOutput) Characteristics() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HlsSettings) *string { return v.Characteristics }).(pulumi.StringPtrOutput)
}

// The default for the HLS setting.
func (o HlsSettingsOutput) Default() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HlsSettings) *bool { return v.Default }).(pulumi.BoolPtrOutput)
}

// The forced for the HLS setting.
func (o HlsSettingsOutput) Forced() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HlsSettings) *bool { return v.Forced }).(pulumi.BoolPtrOutput)
}

type HlsSettingsPtrOutput struct{ *pulumi.OutputState }

func (HlsSettingsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HlsSettings)(nil)).Elem()
}

func (o HlsSettingsPtrOutput) ToHlsSettingsPtrOutput() HlsSettingsPtrOutput {
	return o
}

func (o HlsSettingsPtrOutput) ToHlsSettingsPtrOutputWithContext(ctx context.Context) HlsSettingsPtrOutput {
	return o
}

func (o HlsSettingsPtrOutput) Elem() HlsSettingsOutput {
	return o.ApplyT(func(v *HlsSettings) HlsSettings {
		if v != nil {
			return *v
		}
		var ret HlsSettings
		return ret
	}).(HlsSettingsOutput)
}

// The characteristics for the HLS setting.
func (o HlsSettingsPtrOutput) Characteristics() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HlsSettings) *string {
		if v == nil {
			return nil
		}
		return v.Characteristics
	}).(pulumi.StringPtrOutput)
}

// The default for the HLS setting.
func (o HlsSettingsPtrOutput) Default() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HlsSettings) *bool {
		if v == nil {
			return nil
		}
		return v.Default
	}).(pulumi.BoolPtrOutput)
}

// The forced for the HLS setting.
func (o HlsSettingsPtrOutput) Forced() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HlsSettings) *bool {
		if v == nil {
			return nil
		}
		return v.Forced
	}).(pulumi.BoolPtrOutput)
}

// The HLS setting for a track.
type HlsSettingsResponse struct {
	// The characteristics for the HLS setting.
	Characteristics *string `pulumi:"characteristics"`
	// The default for the HLS setting.
	Default *bool `pulumi:"default"`
	// The forced for the HLS setting.
	Forced *bool `pulumi:"forced"`
}

// The HLS setting for a track.
type HlsSettingsResponseOutput struct{ *pulumi.OutputState }

func (HlsSettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HlsSettingsResponse)(nil)).Elem()
}

func (o HlsSettingsResponseOutput) ToHlsSettingsResponseOutput() HlsSettingsResponseOutput {
	return o
}

func (o HlsSettingsResponseOutput) ToHlsSettingsResponseOutputWithContext(ctx context.Context) HlsSettingsResponseOutput {
	return o
}

// The characteristics for the HLS setting.
func (o HlsSettingsResponseOutput) Characteristics() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HlsSettingsResponse) *string { return v.Characteristics }).(pulumi.StringPtrOutput)
}

// The default for the HLS setting.
func (o HlsSettingsResponseOutput) Default() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HlsSettingsResponse) *bool { return v.Default }).(pulumi.BoolPtrOutput)
}

// The forced for the HLS setting.
func (o HlsSettingsResponseOutput) Forced() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HlsSettingsResponse) *bool { return v.Forced }).(pulumi.BoolPtrOutput)
}

type HlsSettingsResponsePtrOutput struct{ *pulumi.OutputState }

func (HlsSettingsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HlsSettingsResponse)(nil)).Elem()
}

func (o HlsSettingsResponsePtrOutput) ToHlsSettingsResponsePtrOutput() HlsSettingsResponsePtrOutput {
	return o
}

func (o HlsSettingsResponsePtrOutput) ToHlsSettingsResponsePtrOutputWithContext(ctx context.Context) HlsSettingsResponsePtrOutput {
	return o
}

func (o HlsSettingsResponsePtrOutput) Elem() HlsSettingsResponseOutput {
	return o.ApplyT(func(v *HlsSettingsResponse) HlsSettingsResponse {
		if v != nil {
			return *v
		}
		var ret HlsSettingsResponse
		return ret
	}).(HlsSettingsResponseOutput)
}

// The characteristics for the HLS setting.
func (o HlsSettingsResponsePtrOutput) Characteristics() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HlsSettingsResponse) *string {
		if v == nil {
			return nil
		}
		return v.Characteristics
	}).(pulumi.StringPtrOutput)
}

// The default for the HLS setting.
func (o HlsSettingsResponsePtrOutput) Default() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HlsSettingsResponse) *bool {
		if v == nil {
			return nil
		}
		return v.Default
	}).(pulumi.BoolPtrOutput)
}

// The forced for the HLS setting.
func (o HlsSettingsResponsePtrOutput) Forced() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HlsSettingsResponse) *bool {
		if v == nil {
			return nil
		}
		return v.Forced
	}).(pulumi.BoolPtrOutput)
}

// The IP access control.
type IPAccessControl struct {
	// The IP allow list.
	Allow []IPRange `pulumi:"allow"`
}

// IPAccessControlInput is an input type that accepts IPAccessControlArgs and IPAccessControlOutput values.
// You can construct a concrete instance of `IPAccessControlInput` via:
//
//	IPAccessControlArgs{...}
type IPAccessControlInput interface {
	pulumi.Input

	ToIPAccessControlOutput() IPAccessControlOutput
	ToIPAccessControlOutputWithContext(context.Context) IPAccessControlOutput
}

// The IP access control.
type IPAccessControlArgs struct {
	// The IP allow list.
	Allow IPRangeArrayInput `pulumi:"allow"`
}

func (IPAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IPAccessControl)(nil)).Elem()
}

func (i IPAccessControlArgs) ToIPAccessControlOutput() IPAccessControlOutput {
	return i.ToIPAccessControlOutputWithContext(context.Background())
}

func (i IPAccessControlArgs) ToIPAccessControlOutputWithContext(ctx context.Context) IPAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPAccessControlOutput)
}

func (i IPAccessControlArgs) ToIPAccessControlPtrOutput() IPAccessControlPtrOutput {
	return i.ToIPAccessControlPtrOutputWithContext(context.Background())
}

func (i IPAccessControlArgs) ToIPAccessControlPtrOutputWithContext(ctx context.Context) IPAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPAccessControlOutput).ToIPAccessControlPtrOutputWithContext(ctx)
}

// IPAccessControlPtrInput is an input type that accepts IPAccessControlArgs, IPAccessControlPtr and IPAccessControlPtrOutput values.
// You can construct a concrete instance of `IPAccessControlPtrInput` via:
//
//	        IPAccessControlArgs{...}
//
//	or:
//
//	        nil
type IPAccessControlPtrInput interface {
	pulumi.Input

	ToIPAccessControlPtrOutput() IPAccessControlPtrOutput
	ToIPAccessControlPtrOutputWithContext(context.Context) IPAccessControlPtrOutput
}

type ipaccessControlPtrType IPAccessControlArgs

func IPAccessControlPtr(v *IPAccessControlArgs) IPAccessControlPtrInput {
	return (*ipaccessControlPtrType)(v)
}

func (*ipaccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IPAccessControl)(nil)).Elem()
}

func (i *ipaccessControlPtrType) ToIPAccessControlPtrOutput() IPAccessControlPtrOutput {
	return i.ToIPAccessControlPtrOutputWithContext(context.Background())
}

func (i *ipaccessControlPtrType) ToIPAccessControlPtrOutputWithContext(ctx context.Context) IPAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPAccessControlPtrOutput)
}

// The IP access control.
type IPAccessControlOutput struct{ *pulumi.OutputState }

func (IPAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPAccessControl)(nil)).Elem()
}

func (o IPAccessControlOutput) ToIPAccessControlOutput() IPAccessControlOutput {
	return o
}

func (o IPAccessControlOutput) ToIPAccessControlOutputWithContext(ctx context.Context) IPAccessControlOutput {
	return o
}

func (o IPAccessControlOutput) ToIPAccessControlPtrOutput() IPAccessControlPtrOutput {
	return o.ToIPAccessControlPtrOutputWithContext(context.Background())
}

func (o IPAccessControlOutput) ToIPAccessControlPtrOutputWithContext(ctx context.Context) IPAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IPAccessControl) *IPAccessControl {
		return &v
	}).(IPAccessControlPtrOutput)
}

// The IP allow list.
func (o IPAccessControlOutput) Allow() IPRangeArrayOutput {
	return o.ApplyT(func(v IPAccessControl) []IPRange { return v.Allow }).(IPRangeArrayOutput)
}

type IPAccessControlPtrOutput struct{ *pulumi.OutputState }

func (IPAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IPAccessControl)(nil)).Elem()
}

func (o IPAccessControlPtrOutput) ToIPAccessControlPtrOutput() IPAccessControlPtrOutput {
	return o
}

func (o IPAccessControlPtrOutput) ToIPAccessControlPtrOutputWithContext(ctx context.Context) IPAccessControlPtrOutput {
	return o
}

func (o IPAccessControlPtrOutput) Elem() IPAccessControlOutput {
	return o.ApplyT(func(v *IPAccessControl) IPAccessControl {
		if v != nil {
			return *v
		}
		var ret IPAccessControl
		return ret
	}).(IPAccessControlOutput)
}

// The IP allow list.
func (o IPAccessControlPtrOutput) Allow() IPRangeArrayOutput {
	return o.ApplyT(func(v *IPAccessControl) []IPRange {
		if v == nil {
			return nil
		}
		return v.Allow
	}).(IPRangeArrayOutput)
}

// The IP access control.
type IPAccessControlResponse struct {
	// The IP allow list.
	Allow []IPRangeResponse `pulumi:"allow"`
}

// The IP access control.
type IPAccessControlResponseOutput struct{ *pulumi.OutputState }

func (IPAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPAccessControlResponse)(nil)).Elem()
}

func (o IPAccessControlResponseOutput) ToIPAccessControlResponseOutput() IPAccessControlResponseOutput {
	return o
}

func (o IPAccessControlResponseOutput) ToIPAccessControlResponseOutputWithContext(ctx context.Context) IPAccessControlResponseOutput {
	return o
}

// The IP allow list.
func (o IPAccessControlResponseOutput) Allow() IPRangeResponseArrayOutput {
	return o.ApplyT(func(v IPAccessControlResponse) []IPRangeResponse { return v.Allow }).(IPRangeResponseArrayOutput)
}

type IPAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (IPAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IPAccessControlResponse)(nil)).Elem()
}

func (o IPAccessControlResponsePtrOutput) ToIPAccessControlResponsePtrOutput() IPAccessControlResponsePtrOutput {
	return o
}

func (o IPAccessControlResponsePtrOutput) ToIPAccessControlResponsePtrOutputWithContext(ctx context.Context) IPAccessControlResponsePtrOutput {
	return o
}

func (o IPAccessControlResponsePtrOutput) Elem() IPAccessControlResponseOutput {
	return o.ApplyT(func(v *IPAccessControlResponse) IPAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret IPAccessControlResponse
		return ret
	}).(IPAccessControlResponseOutput)
}

// The IP allow list.
func (o IPAccessControlResponsePtrOutput) Allow() IPRangeResponseArrayOutput {
	return o.ApplyT(func(v *IPAccessControlResponse) []IPRangeResponse {
		if v == nil {
			return nil
		}
		return v.Allow
	}).(IPRangeResponseArrayOutput)
}

// The IP address range in the CIDR scheme.
type IPRange struct {
	// The IP address.
	Address *string `pulumi:"address"`
	// The friendly name for the IP address range.
	Name *string `pulumi:"name"`
	// The subnet mask prefix length (see CIDR notation).
	SubnetPrefixLength *int `pulumi:"subnetPrefixLength"`
}

// IPRangeInput is an input type that accepts IPRangeArgs and IPRangeOutput values.
// You can construct a concrete instance of `IPRangeInput` via:
//
//	IPRangeArgs{...}
type IPRangeInput interface {
	pulumi.Input

	ToIPRangeOutput() IPRangeOutput
	ToIPRangeOutputWithContext(context.Context) IPRangeOutput
}

// The IP address range in the CIDR scheme.
type IPRangeArgs struct {
	// The IP address.
	Address pulumi.StringPtrInput `pulumi:"address"`
	// The friendly name for the IP address range.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The subnet mask prefix length (see CIDR notation).
	SubnetPrefixLength pulumi.IntPtrInput `pulumi:"subnetPrefixLength"`
}

func (IPRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IPRange)(nil)).Elem()
}

func (i IPRangeArgs) ToIPRangeOutput() IPRangeOutput {
	return i.ToIPRangeOutputWithContext(context.Background())
}

func (i IPRangeArgs) ToIPRangeOutputWithContext(ctx context.Context) IPRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPRangeOutput)
}

// IPRangeArrayInput is an input type that accepts IPRangeArray and IPRangeArrayOutput values.
// You can construct a concrete instance of `IPRangeArrayInput` via:
//
//	IPRangeArray{ IPRangeArgs{...} }
type IPRangeArrayInput interface {
	pulumi.Input

	ToIPRangeArrayOutput() IPRangeArrayOutput
	ToIPRangeArrayOutputWithContext(context.Context) IPRangeArrayOutput
}

type IPRangeArray []IPRangeInput

func (IPRangeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPRange)(nil)).Elem()
}

func (i IPRangeArray) ToIPRangeArrayOutput() IPRangeArrayOutput {
	return i.ToIPRangeArrayOutputWithContext(context.Background())
}

func (i IPRangeArray) ToIPRangeArrayOutputWithContext(ctx context.Context) IPRangeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPRangeArrayOutput)
}

// The IP address range in the CIDR scheme.
type IPRangeOutput struct{ *pulumi.OutputState }

func (IPRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPRange)(nil)).Elem()
}

func (o IPRangeOutput) ToIPRangeOutput() IPRangeOutput {
	return o
}

func (o IPRangeOutput) ToIPRangeOutputWithContext(ctx context.Context) IPRangeOutput {
	return o
}

// The IP address.
func (o IPRangeOutput) Address() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPRange) *string { return v.Address }).(pulumi.StringPtrOutput)
}

// The friendly name for the IP address range.
func (o IPRangeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPRange) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The subnet mask prefix length (see CIDR notation).
func (o IPRangeOutput) SubnetPrefixLength() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IPRange) *int { return v.SubnetPrefixLength }).(pulumi.IntPtrOutput)
}

type IPRangeArrayOutput struct{ *pulumi.OutputState }

func (IPRangeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPRange)(nil)).Elem()
}

func (o IPRangeArrayOutput) ToIPRangeArrayOutput() IPRangeArrayOutput {
	return o
}

func (o IPRangeArrayOutput) ToIPRangeArrayOutputWithContext(ctx context.Context) IPRangeArrayOutput {
	return o
}

func (o IPRangeArrayOutput) Index(i pulumi.IntInput) IPRangeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IPRange {
		return vs[0].([]IPRange)[vs[1].(int)]
	}).(IPRangeOutput)
}

// The IP address range in the CIDR scheme.
type IPRangeResponse struct {
	// The IP address.
	Address *string `pulumi:"address"`
	// The friendly name for the IP address range.
	Name *string `pulumi:"name"`
	// The subnet mask prefix length (see CIDR notation).
	SubnetPrefixLength *int `pulumi:"subnetPrefixLength"`
}

// The IP address range in the CIDR scheme.
type IPRangeResponseOutput struct{ *pulumi.OutputState }

func (IPRangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPRangeResponse)(nil)).Elem()
}

func (o IPRangeResponseOutput) ToIPRangeResponseOutput() IPRangeResponseOutput {
	return o
}

func (o IPRangeResponseOutput) ToIPRangeResponseOutputWithContext(ctx context.Context) IPRangeResponseOutput {
	return o
}

// The IP address.
func (o IPRangeResponseOutput) Address() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPRangeResponse) *string { return v.Address }).(pulumi.StringPtrOutput)
}

// The friendly name for the IP address range.
func (o IPRangeResponseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPRangeResponse) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The subnet mask prefix length (see CIDR notation).
func (o IPRangeResponseOutput) SubnetPrefixLength() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IPRangeResponse) *int { return v.SubnetPrefixLength }).(pulumi.IntPtrOutput)
}

type IPRangeResponseArrayOutput struct{ *pulumi.OutputState }

func (IPRangeResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPRangeResponse)(nil)).Elem()
}

func (o IPRangeResponseArrayOutput) ToIPRangeResponseArrayOutput() IPRangeResponseArrayOutput {
	return o
}

func (o IPRangeResponseArrayOutput) ToIPRangeResponseArrayOutputWithContext(ctx context.Context) IPRangeResponseArrayOutput {
	return o
}

func (o IPRangeResponseArrayOutput) Index(i pulumi.IntInput) IPRangeResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IPRangeResponse {
		return vs[0].([]IPRangeResponse)[vs[1].(int)]
	}).(IPRangeResponseOutput)
}

// Describes the basic properties for generating thumbnails from the input video
type Image struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Image'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// ImageInput is an input type that accepts ImageArgs and ImageOutput values.
// You can construct a concrete instance of `ImageInput` via:
//
//	ImageArgs{...}
type ImageInput interface {
	pulumi.Input

	ToImageOutput() ImageOutput
	ToImageOutputWithContext(context.Context) ImageOutput
}

// Describes the basic properties for generating thumbnails from the input video
type ImageArgs struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval pulumi.StringPtrInput `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Image'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range pulumi.StringPtrInput `pulumi:"range"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start pulumi.StringInput `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step pulumi.StringPtrInput `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode pulumi.StringPtrInput `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode pulumi.StringPtrInput `pulumi:"syncMode"`
}

func (ImageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Image)(nil)).Elem()
}

func (i ImageArgs) ToImageOutput() ImageOutput {
	return i.ToImageOutputWithContext(context.Background())
}

func (i ImageArgs) ToImageOutputWithContext(ctx context.Context) ImageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageOutput)
}

// Describes the basic properties for generating thumbnails from the input video
type ImageOutput struct{ *pulumi.OutputState }

func (ImageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Image)(nil)).Elem()
}

func (o ImageOutput) ToImageOutput() ImageOutput {
	return o
}

func (o ImageOutput) ToImageOutputWithContext(ctx context.Context) ImageOutput {
	return o
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o ImageOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Image) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o ImageOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Image) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.Image'.
func (o ImageOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v Image) string { return v.OdataType }).(pulumi.StringOutput)
}

// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
func (o ImageOutput) Range() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Image) *string { return v.Range }).(pulumi.StringPtrOutput)
}

// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
func (o ImageOutput) Start() pulumi.StringOutput {
	return o.ApplyT(func(v Image) string { return v.Start }).(pulumi.StringOutput)
}

// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
func (o ImageOutput) Step() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Image) *string { return v.Step }).(pulumi.StringPtrOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o ImageOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Image) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o ImageOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Image) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// Describes the properties for an output image file.
type ImageFormat struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ImageFormat'.
	OdataType string `pulumi:"odataType"`
}

// ImageFormatInput is an input type that accepts ImageFormatArgs and ImageFormatOutput values.
// You can construct a concrete instance of `ImageFormatInput` via:
//
//	ImageFormatArgs{...}
type ImageFormatInput interface {
	pulumi.Input

	ToImageFormatOutput() ImageFormatOutput
	ToImageFormatOutputWithContext(context.Context) ImageFormatOutput
}

// Describes the properties for an output image file.
type ImageFormatArgs struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern pulumi.StringInput `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ImageFormat'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (ImageFormatArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageFormat)(nil)).Elem()
}

func (i ImageFormatArgs) ToImageFormatOutput() ImageFormatOutput {
	return i.ToImageFormatOutputWithContext(context.Background())
}

func (i ImageFormatArgs) ToImageFormatOutputWithContext(ctx context.Context) ImageFormatOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageFormatOutput)
}

// Describes the properties for an output image file.
type ImageFormatOutput struct{ *pulumi.OutputState }

func (ImageFormatOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageFormat)(nil)).Elem()
}

func (o ImageFormatOutput) ToImageFormatOutput() ImageFormatOutput {
	return o
}

func (o ImageFormatOutput) ToImageFormatOutputWithContext(ctx context.Context) ImageFormatOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o ImageFormatOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v ImageFormat) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ImageFormat'.
func (o ImageFormatOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ImageFormat) string { return v.OdataType }).(pulumi.StringOutput)
}

// Describes the properties for an output image file.
type ImageFormatResponse struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ImageFormat'.
	OdataType string `pulumi:"odataType"`
}

// Describes the properties for an output image file.
type ImageFormatResponseOutput struct{ *pulumi.OutputState }

func (ImageFormatResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageFormatResponse)(nil)).Elem()
}

func (o ImageFormatResponseOutput) ToImageFormatResponseOutput() ImageFormatResponseOutput {
	return o
}

func (o ImageFormatResponseOutput) ToImageFormatResponseOutputWithContext(ctx context.Context) ImageFormatResponseOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o ImageFormatResponseOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v ImageFormatResponse) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.ImageFormat'.
func (o ImageFormatResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ImageFormatResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Describes the basic properties for generating thumbnails from the input video
type ImageResponse struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Image'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes the basic properties for generating thumbnails from the input video
type ImageResponseOutput struct{ *pulumi.OutputState }

func (ImageResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageResponse)(nil)).Elem()
}

func (o ImageResponseOutput) ToImageResponseOutput() ImageResponseOutput {
	return o
}

func (o ImageResponseOutput) ToImageResponseOutputWithContext(ctx context.Context) ImageResponseOutput {
	return o
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o ImageResponseOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ImageResponse) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o ImageResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ImageResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.Image'.
func (o ImageResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ImageResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
func (o ImageResponseOutput) Range() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ImageResponse) *string { return v.Range }).(pulumi.StringPtrOutput)
}

// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
func (o ImageResponseOutput) Start() pulumi.StringOutput {
	return o.ApplyT(func(v ImageResponse) string { return v.Start }).(pulumi.StringOutput)
}

// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
func (o ImageResponseOutput) Step() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ImageResponse) *string { return v.Step }).(pulumi.StringPtrOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o ImageResponseOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ImageResponse) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o ImageResponseOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ImageResponse) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// An InputDefinition for a single file.  TrackSelections are scoped to the file specified.
type InputFile struct {
	// Name of the file that this input definition applies to.
	Filename *string `pulumi:"filename"`
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.InputFile'.
	OdataType string `pulumi:"odataType"`
}

// InputFileInput is an input type that accepts InputFileArgs and InputFileOutput values.
// You can construct a concrete instance of `InputFileInput` via:
//
//	InputFileArgs{...}
type InputFileInput interface {
	pulumi.Input

	ToInputFileOutput() InputFileOutput
	ToInputFileOutputWithContext(context.Context) InputFileOutput
}

// An InputDefinition for a single file.  TrackSelections are scoped to the file specified.
type InputFileArgs struct {
	// Name of the file that this input definition applies to.
	Filename pulumi.StringPtrInput `pulumi:"filename"`
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks pulumi.ArrayInput `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.InputFile'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (InputFileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InputFile)(nil)).Elem()
}

func (i InputFileArgs) ToInputFileOutput() InputFileOutput {
	return i.ToInputFileOutputWithContext(context.Background())
}

func (i InputFileArgs) ToInputFileOutputWithContext(ctx context.Context) InputFileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InputFileOutput)
}

// An InputDefinition for a single file.  TrackSelections are scoped to the file specified.
type InputFileOutput struct{ *pulumi.OutputState }

func (InputFileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InputFile)(nil)).Elem()
}

func (o InputFileOutput) ToInputFileOutput() InputFileOutput {
	return o
}

func (o InputFileOutput) ToInputFileOutputWithContext(ctx context.Context) InputFileOutput {
	return o
}

// Name of the file that this input definition applies to.
func (o InputFileOutput) Filename() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InputFile) *string { return v.Filename }).(pulumi.StringPtrOutput)
}

// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
func (o InputFileOutput) IncludedTracks() pulumi.ArrayOutput {
	return o.ApplyT(func(v InputFile) []interface{} { return v.IncludedTracks }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.InputFile'.
func (o InputFileOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v InputFile) string { return v.OdataType }).(pulumi.StringOutput)
}

// An InputDefinition for a single file.  TrackSelections are scoped to the file specified.
type InputFileResponse struct {
	// Name of the file that this input definition applies to.
	Filename *string `pulumi:"filename"`
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.InputFile'.
	OdataType string `pulumi:"odataType"`
}

// An InputDefinition for a single file.  TrackSelections are scoped to the file specified.
type InputFileResponseOutput struct{ *pulumi.OutputState }

func (InputFileResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InputFileResponse)(nil)).Elem()
}

func (o InputFileResponseOutput) ToInputFileResponseOutput() InputFileResponseOutput {
	return o
}

func (o InputFileResponseOutput) ToInputFileResponseOutputWithContext(ctx context.Context) InputFileResponseOutput {
	return o
}

// Name of the file that this input definition applies to.
func (o InputFileResponseOutput) Filename() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InputFileResponse) *string { return v.Filename }).(pulumi.StringPtrOutput)
}

// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
func (o InputFileResponseOutput) IncludedTracks() pulumi.ArrayOutput {
	return o.ApplyT(func(v InputFileResponse) []interface{} { return v.IncludedTracks }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.InputFile'.
func (o InputFileResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v InputFileResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Details of JobOutput errors.
type JobErrorDetailResponse struct {
	// Code describing the error detail.
	Code string `pulumi:"code"`
	// A human-readable representation of the error.
	Message string `pulumi:"message"`
}

// Details of JobOutput errors.
type JobErrorDetailResponseOutput struct{ *pulumi.OutputState }

func (JobErrorDetailResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobErrorDetailResponse)(nil)).Elem()
}

func (o JobErrorDetailResponseOutput) ToJobErrorDetailResponseOutput() JobErrorDetailResponseOutput {
	return o
}

func (o JobErrorDetailResponseOutput) ToJobErrorDetailResponseOutputWithContext(ctx context.Context) JobErrorDetailResponseOutput {
	return o
}

// Code describing the error detail.
func (o JobErrorDetailResponseOutput) Code() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorDetailResponse) string { return v.Code }).(pulumi.StringOutput)
}

// A human-readable representation of the error.
func (o JobErrorDetailResponseOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorDetailResponse) string { return v.Message }).(pulumi.StringOutput)
}

type JobErrorDetailResponseArrayOutput struct{ *pulumi.OutputState }

func (JobErrorDetailResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobErrorDetailResponse)(nil)).Elem()
}

func (o JobErrorDetailResponseArrayOutput) ToJobErrorDetailResponseArrayOutput() JobErrorDetailResponseArrayOutput {
	return o
}

func (o JobErrorDetailResponseArrayOutput) ToJobErrorDetailResponseArrayOutputWithContext(ctx context.Context) JobErrorDetailResponseArrayOutput {
	return o
}

func (o JobErrorDetailResponseArrayOutput) Index(i pulumi.IntInput) JobErrorDetailResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobErrorDetailResponse {
		return vs[0].([]JobErrorDetailResponse)[vs[1].(int)]
	}).(JobErrorDetailResponseOutput)
}

// Details of JobOutput errors.
type JobErrorResponse struct {
	// Helps with categorization of errors.
	Category string `pulumi:"category"`
	// Error code describing the error.
	Code string `pulumi:"code"`
	// An array of details about specific errors that led to this reported error.
	Details []JobErrorDetailResponse `pulumi:"details"`
	// A human-readable language-dependent representation of the error.
	Message string `pulumi:"message"`
	// Indicates that it may be possible to retry the Job. If retry is unsuccessful, please contact Azure support via Azure Portal.
	Retry string `pulumi:"retry"`
}

// Details of JobOutput errors.
type JobErrorResponseOutput struct{ *pulumi.OutputState }

func (JobErrorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobErrorResponse)(nil)).Elem()
}

func (o JobErrorResponseOutput) ToJobErrorResponseOutput() JobErrorResponseOutput {
	return o
}

func (o JobErrorResponseOutput) ToJobErrorResponseOutputWithContext(ctx context.Context) JobErrorResponseOutput {
	return o
}

// Helps with categorization of errors.
func (o JobErrorResponseOutput) Category() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorResponse) string { return v.Category }).(pulumi.StringOutput)
}

// Error code describing the error.
func (o JobErrorResponseOutput) Code() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorResponse) string { return v.Code }).(pulumi.StringOutput)
}

// An array of details about specific errors that led to this reported error.
func (o JobErrorResponseOutput) Details() JobErrorDetailResponseArrayOutput {
	return o.ApplyT(func(v JobErrorResponse) []JobErrorDetailResponse { return v.Details }).(JobErrorDetailResponseArrayOutput)
}

// A human-readable language-dependent representation of the error.
func (o JobErrorResponseOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorResponse) string { return v.Message }).(pulumi.StringOutput)
}

// Indicates that it may be possible to retry the Job. If retry is unsuccessful, please contact Azure support via Azure Portal.
func (o JobErrorResponseOutput) Retry() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorResponse) string { return v.Retry }).(pulumi.StringOutput)
}

// Represents an Asset for input into a Job.
type JobInputAsset struct {
	// The name of the input Asset.
	AssetName string `pulumi:"assetName"`
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputAsset'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// JobInputAssetInput is an input type that accepts JobInputAssetArgs and JobInputAssetOutput values.
// You can construct a concrete instance of `JobInputAssetInput` via:
//
//	JobInputAssetArgs{...}
type JobInputAssetInput interface {
	pulumi.Input

	ToJobInputAssetOutput() JobInputAssetOutput
	ToJobInputAssetOutputWithContext(context.Context) JobInputAssetOutput
}

// Represents an Asset for input into a Job.
type JobInputAssetArgs struct {
	// The name of the input Asset.
	AssetName pulumi.StringInput `pulumi:"assetName"`
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End pulumi.Input `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
	Files pulumi.StringArrayInput `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions pulumi.ArrayInput `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputAsset'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start pulumi.Input `pulumi:"start"`
}

func (JobInputAssetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputAsset)(nil)).Elem()
}

func (i JobInputAssetArgs) ToJobInputAssetOutput() JobInputAssetOutput {
	return i.ToJobInputAssetOutputWithContext(context.Background())
}

func (i JobInputAssetArgs) ToJobInputAssetOutputWithContext(ctx context.Context) JobInputAssetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobInputAssetOutput)
}

// Represents an Asset for input into a Job.
type JobInputAssetOutput struct{ *pulumi.OutputState }

func (JobInputAssetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputAsset)(nil)).Elem()
}

func (o JobInputAssetOutput) ToJobInputAssetOutput() JobInputAssetOutput {
	return o
}

func (o JobInputAssetOutput) ToJobInputAssetOutputWithContext(ctx context.Context) JobInputAssetOutput {
	return o
}

// The name of the input Asset.
func (o JobInputAssetOutput) AssetName() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputAsset) string { return v.AssetName }).(pulumi.StringOutput)
}

// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
func (o JobInputAssetOutput) End() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputAsset) interface{} { return v.End }).(pulumi.AnyOutput)
}

// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
func (o JobInputAssetOutput) Files() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobInputAsset) []string { return v.Files }).(pulumi.StringArrayOutput)
}

// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
func (o JobInputAssetOutput) InputDefinitions() pulumi.ArrayOutput {
	return o.ApplyT(func(v JobInputAsset) []interface{} { return v.InputDefinitions }).(pulumi.ArrayOutput)
}

// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
func (o JobInputAssetOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobInputAsset) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobInputAsset'.
func (o JobInputAssetOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputAsset) string { return v.OdataType }).(pulumi.StringOutput)
}

// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
func (o JobInputAssetOutput) Start() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputAsset) interface{} { return v.Start }).(pulumi.AnyOutput)
}

// Represents an Asset for input into a Job.
type JobInputAssetResponse struct {
	// The name of the input Asset.
	AssetName string `pulumi:"assetName"`
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputAsset'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// Represents an Asset for input into a Job.
type JobInputAssetResponseOutput struct{ *pulumi.OutputState }

func (JobInputAssetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputAssetResponse)(nil)).Elem()
}

func (o JobInputAssetResponseOutput) ToJobInputAssetResponseOutput() JobInputAssetResponseOutput {
	return o
}

func (o JobInputAssetResponseOutput) ToJobInputAssetResponseOutputWithContext(ctx context.Context) JobInputAssetResponseOutput {
	return o
}

// The name of the input Asset.
func (o JobInputAssetResponseOutput) AssetName() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputAssetResponse) string { return v.AssetName }).(pulumi.StringOutput)
}

// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
func (o JobInputAssetResponseOutput) End() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputAssetResponse) interface{} { return v.End }).(pulumi.AnyOutput)
}

// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
func (o JobInputAssetResponseOutput) Files() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobInputAssetResponse) []string { return v.Files }).(pulumi.StringArrayOutput)
}

// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
func (o JobInputAssetResponseOutput) InputDefinitions() pulumi.ArrayOutput {
	return o.ApplyT(func(v JobInputAssetResponse) []interface{} { return v.InputDefinitions }).(pulumi.ArrayOutput)
}

// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
func (o JobInputAssetResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobInputAssetResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobInputAsset'.
func (o JobInputAssetResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputAssetResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
func (o JobInputAssetResponseOutput) Start() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputAssetResponse) interface{} { return v.Start }).(pulumi.AnyOutput)
}

// Represents input files for a Job.
type JobInputClip struct {
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputClip'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// JobInputClipInput is an input type that accepts JobInputClipArgs and JobInputClipOutput values.
// You can construct a concrete instance of `JobInputClipInput` via:
//
//	JobInputClipArgs{...}
type JobInputClipInput interface {
	pulumi.Input

	ToJobInputClipOutput() JobInputClipOutput
	ToJobInputClipOutputWithContext(context.Context) JobInputClipOutput
}

// Represents input files for a Job.
type JobInputClipArgs struct {
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End pulumi.Input `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
	Files pulumi.StringArrayInput `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions pulumi.ArrayInput `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputClip'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start pulumi.Input `pulumi:"start"`
}

func (JobInputClipArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputClip)(nil)).Elem()
}

func (i JobInputClipArgs) ToJobInputClipOutput() JobInputClipOutput {
	return i.ToJobInputClipOutputWithContext(context.Background())
}

func (i JobInputClipArgs) ToJobInputClipOutputWithContext(ctx context.Context) JobInputClipOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobInputClipOutput)
}

// JobInputClipArrayInput is an input type that accepts JobInputClipArray and JobInputClipArrayOutput values.
// You can construct a concrete instance of `JobInputClipArrayInput` via:
//
//	JobInputClipArray{ JobInputClipArgs{...} }
type JobInputClipArrayInput interface {
	pulumi.Input

	ToJobInputClipArrayOutput() JobInputClipArrayOutput
	ToJobInputClipArrayOutputWithContext(context.Context) JobInputClipArrayOutput
}

type JobInputClipArray []JobInputClipInput

func (JobInputClipArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobInputClip)(nil)).Elem()
}

func (i JobInputClipArray) ToJobInputClipArrayOutput() JobInputClipArrayOutput {
	return i.ToJobInputClipArrayOutputWithContext(context.Background())
}

func (i JobInputClipArray) ToJobInputClipArrayOutputWithContext(ctx context.Context) JobInputClipArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobInputClipArrayOutput)
}

// Represents input files for a Job.
type JobInputClipOutput struct{ *pulumi.OutputState }

func (JobInputClipOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputClip)(nil)).Elem()
}

func (o JobInputClipOutput) ToJobInputClipOutput() JobInputClipOutput {
	return o
}

func (o JobInputClipOutput) ToJobInputClipOutputWithContext(ctx context.Context) JobInputClipOutput {
	return o
}

// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
func (o JobInputClipOutput) End() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputClip) interface{} { return v.End }).(pulumi.AnyOutput)
}

// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
func (o JobInputClipOutput) Files() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobInputClip) []string { return v.Files }).(pulumi.StringArrayOutput)
}

// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
func (o JobInputClipOutput) InputDefinitions() pulumi.ArrayOutput {
	return o.ApplyT(func(v JobInputClip) []interface{} { return v.InputDefinitions }).(pulumi.ArrayOutput)
}

// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
func (o JobInputClipOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobInputClip) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobInputClip'.
func (o JobInputClipOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputClip) string { return v.OdataType }).(pulumi.StringOutput)
}

// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
func (o JobInputClipOutput) Start() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputClip) interface{} { return v.Start }).(pulumi.AnyOutput)
}

type JobInputClipArrayOutput struct{ *pulumi.OutputState }

func (JobInputClipArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobInputClip)(nil)).Elem()
}

func (o JobInputClipArrayOutput) ToJobInputClipArrayOutput() JobInputClipArrayOutput {
	return o
}

func (o JobInputClipArrayOutput) ToJobInputClipArrayOutputWithContext(ctx context.Context) JobInputClipArrayOutput {
	return o
}

func (o JobInputClipArrayOutput) Index(i pulumi.IntInput) JobInputClipOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobInputClip {
		return vs[0].([]JobInputClip)[vs[1].(int)]
	}).(JobInputClipOutput)
}

// Represents input files for a Job.
type JobInputClipResponse struct {
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputClip'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// Represents input files for a Job.
type JobInputClipResponseOutput struct{ *pulumi.OutputState }

func (JobInputClipResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputClipResponse)(nil)).Elem()
}

func (o JobInputClipResponseOutput) ToJobInputClipResponseOutput() JobInputClipResponseOutput {
	return o
}

func (o JobInputClipResponseOutput) ToJobInputClipResponseOutputWithContext(ctx context.Context) JobInputClipResponseOutput {
	return o
}

// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
func (o JobInputClipResponseOutput) End() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputClipResponse) interface{} { return v.End }).(pulumi.AnyOutput)
}

// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
func (o JobInputClipResponseOutput) Files() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobInputClipResponse) []string { return v.Files }).(pulumi.StringArrayOutput)
}

// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
func (o JobInputClipResponseOutput) InputDefinitions() pulumi.ArrayOutput {
	return o.ApplyT(func(v JobInputClipResponse) []interface{} { return v.InputDefinitions }).(pulumi.ArrayOutput)
}

// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
func (o JobInputClipResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobInputClipResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobInputClip'.
func (o JobInputClipResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputClipResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
func (o JobInputClipResponseOutput) Start() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputClipResponse) interface{} { return v.Start }).(pulumi.AnyOutput)
}

type JobInputClipResponseArrayOutput struct{ *pulumi.OutputState }

func (JobInputClipResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobInputClipResponse)(nil)).Elem()
}

func (o JobInputClipResponseArrayOutput) ToJobInputClipResponseArrayOutput() JobInputClipResponseArrayOutput {
	return o
}

func (o JobInputClipResponseArrayOutput) ToJobInputClipResponseArrayOutputWithContext(ctx context.Context) JobInputClipResponseArrayOutput {
	return o
}

func (o JobInputClipResponseArrayOutput) Index(i pulumi.IntInput) JobInputClipResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobInputClipResponse {
		return vs[0].([]JobInputClipResponse)[vs[1].(int)]
	}).(JobInputClipResponseOutput)
}

// Represents HTTPS job input.
type JobInputHttp struct {
	// Base URI for HTTPS job input. It will be concatenated with provided file names. If no base uri is given, then the provided file list is assumed to be fully qualified uris. Maximum length of 4000 characters. The query strings will not be returned in service responses to prevent sensitive data exposure.
	BaseUri *string `pulumi:"baseUri"`
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputHttp'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// JobInputHttpInput is an input type that accepts JobInputHttpArgs and JobInputHttpOutput values.
// You can construct a concrete instance of `JobInputHttpInput` via:
//
//	JobInputHttpArgs{...}
type JobInputHttpInput interface {
	pulumi.Input

	ToJobInputHttpOutput() JobInputHttpOutput
	ToJobInputHttpOutputWithContext(context.Context) JobInputHttpOutput
}

// Represents HTTPS job input.
type JobInputHttpArgs struct {
	// Base URI for HTTPS job input. It will be concatenated with provided file names. If no base uri is given, then the provided file list is assumed to be fully qualified uris. Maximum length of 4000 characters. The query strings will not be returned in service responses to prevent sensitive data exposure.
	BaseUri pulumi.StringPtrInput `pulumi:"baseUri"`
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End pulumi.Input `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
	Files pulumi.StringArrayInput `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions pulumi.ArrayInput `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputHttp'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start pulumi.Input `pulumi:"start"`
}

func (JobInputHttpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputHttp)(nil)).Elem()
}

func (i JobInputHttpArgs) ToJobInputHttpOutput() JobInputHttpOutput {
	return i.ToJobInputHttpOutputWithContext(context.Background())
}

func (i JobInputHttpArgs) ToJobInputHttpOutputWithContext(ctx context.Context) JobInputHttpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobInputHttpOutput)
}

// Represents HTTPS job input.
type JobInputHttpOutput struct{ *pulumi.OutputState }

func (JobInputHttpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputHttp)(nil)).Elem()
}

func (o JobInputHttpOutput) ToJobInputHttpOutput() JobInputHttpOutput {
	return o
}

func (o JobInputHttpOutput) ToJobInputHttpOutputWithContext(ctx context.Context) JobInputHttpOutput {
	return o
}

// Base URI for HTTPS job input. It will be concatenated with provided file names. If no base uri is given, then the provided file list is assumed to be fully qualified uris. Maximum length of 4000 characters. The query strings will not be returned in service responses to prevent sensitive data exposure.
func (o JobInputHttpOutput) BaseUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobInputHttp) *string { return v.BaseUri }).(pulumi.StringPtrOutput)
}

// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
func (o JobInputHttpOutput) End() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputHttp) interface{} { return v.End }).(pulumi.AnyOutput)
}

// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
func (o JobInputHttpOutput) Files() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobInputHttp) []string { return v.Files }).(pulumi.StringArrayOutput)
}

// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
func (o JobInputHttpOutput) InputDefinitions() pulumi.ArrayOutput {
	return o.ApplyT(func(v JobInputHttp) []interface{} { return v.InputDefinitions }).(pulumi.ArrayOutput)
}

// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
func (o JobInputHttpOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobInputHttp) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobInputHttp'.
func (o JobInputHttpOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputHttp) string { return v.OdataType }).(pulumi.StringOutput)
}

// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
func (o JobInputHttpOutput) Start() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputHttp) interface{} { return v.Start }).(pulumi.AnyOutput)
}

// Represents HTTPS job input.
type JobInputHttpResponse struct {
	// Base URI for HTTPS job input. It will be concatenated with provided file names. If no base uri is given, then the provided file list is assumed to be fully qualified uris. Maximum length of 4000 characters. The query strings will not be returned in service responses to prevent sensitive data exposure.
	BaseUri *string `pulumi:"baseUri"`
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputHttp'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// Represents HTTPS job input.
type JobInputHttpResponseOutput struct{ *pulumi.OutputState }

func (JobInputHttpResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputHttpResponse)(nil)).Elem()
}

func (o JobInputHttpResponseOutput) ToJobInputHttpResponseOutput() JobInputHttpResponseOutput {
	return o
}

func (o JobInputHttpResponseOutput) ToJobInputHttpResponseOutputWithContext(ctx context.Context) JobInputHttpResponseOutput {
	return o
}

// Base URI for HTTPS job input. It will be concatenated with provided file names. If no base uri is given, then the provided file list is assumed to be fully qualified uris. Maximum length of 4000 characters. The query strings will not be returned in service responses to prevent sensitive data exposure.
func (o JobInputHttpResponseOutput) BaseUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobInputHttpResponse) *string { return v.BaseUri }).(pulumi.StringPtrOutput)
}

// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
func (o JobInputHttpResponseOutput) End() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputHttpResponse) interface{} { return v.End }).(pulumi.AnyOutput)
}

// List of files. Required for JobInputHttp. Maximum of 4000 characters each. Query strings will not be returned in service responses to prevent sensitive data exposure.
func (o JobInputHttpResponseOutput) Files() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobInputHttpResponse) []string { return v.Files }).(pulumi.StringArrayOutput)
}

// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
func (o JobInputHttpResponseOutput) InputDefinitions() pulumi.ArrayOutput {
	return o.ApplyT(func(v JobInputHttpResponse) []interface{} { return v.InputDefinitions }).(pulumi.ArrayOutput)
}

// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
func (o JobInputHttpResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobInputHttpResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobInputHttp'.
func (o JobInputHttpResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputHttpResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
func (o JobInputHttpResponseOutput) Start() pulumi.AnyOutput {
	return o.ApplyT(func(v JobInputHttpResponse) interface{} { return v.Start }).(pulumi.AnyOutput)
}

// A Sequence contains an ordered list of Clips where each clip is a JobInput.  The Sequence will be treated as a single input.
type JobInputSequence struct {
	// JobInputs that make up the timeline.
	Inputs []JobInputClip `pulumi:"inputs"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputSequence'.
	OdataType string `pulumi:"odataType"`
}

// JobInputSequenceInput is an input type that accepts JobInputSequenceArgs and JobInputSequenceOutput values.
// You can construct a concrete instance of `JobInputSequenceInput` via:
//
//	JobInputSequenceArgs{...}
type JobInputSequenceInput interface {
	pulumi.Input

	ToJobInputSequenceOutput() JobInputSequenceOutput
	ToJobInputSequenceOutputWithContext(context.Context) JobInputSequenceOutput
}

// A Sequence contains an ordered list of Clips where each clip is a JobInput.  The Sequence will be treated as a single input.
type JobInputSequenceArgs struct {
	// JobInputs that make up the timeline.
	Inputs JobInputClipArrayInput `pulumi:"inputs"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputSequence'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (JobInputSequenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputSequence)(nil)).Elem()
}

func (i JobInputSequenceArgs) ToJobInputSequenceOutput() JobInputSequenceOutput {
	return i.ToJobInputSequenceOutputWithContext(context.Background())
}

func (i JobInputSequenceArgs) ToJobInputSequenceOutputWithContext(ctx context.Context) JobInputSequenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobInputSequenceOutput)
}

// A Sequence contains an ordered list of Clips where each clip is a JobInput.  The Sequence will be treated as a single input.
type JobInputSequenceOutput struct{ *pulumi.OutputState }

func (JobInputSequenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputSequence)(nil)).Elem()
}

func (o JobInputSequenceOutput) ToJobInputSequenceOutput() JobInputSequenceOutput {
	return o
}

func (o JobInputSequenceOutput) ToJobInputSequenceOutputWithContext(ctx context.Context) JobInputSequenceOutput {
	return o
}

// JobInputs that make up the timeline.
func (o JobInputSequenceOutput) Inputs() JobInputClipArrayOutput {
	return o.ApplyT(func(v JobInputSequence) []JobInputClip { return v.Inputs }).(JobInputClipArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobInputSequence'.
func (o JobInputSequenceOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputSequence) string { return v.OdataType }).(pulumi.StringOutput)
}

// A Sequence contains an ordered list of Clips where each clip is a JobInput.  The Sequence will be treated as a single input.
type JobInputSequenceResponse struct {
	// JobInputs that make up the timeline.
	Inputs []JobInputClipResponse `pulumi:"inputs"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputSequence'.
	OdataType string `pulumi:"odataType"`
}

// A Sequence contains an ordered list of Clips where each clip is a JobInput.  The Sequence will be treated as a single input.
type JobInputSequenceResponseOutput struct{ *pulumi.OutputState }

func (JobInputSequenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputSequenceResponse)(nil)).Elem()
}

func (o JobInputSequenceResponseOutput) ToJobInputSequenceResponseOutput() JobInputSequenceResponseOutput {
	return o
}

func (o JobInputSequenceResponseOutput) ToJobInputSequenceResponseOutputWithContext(ctx context.Context) JobInputSequenceResponseOutput {
	return o
}

// JobInputs that make up the timeline.
func (o JobInputSequenceResponseOutput) Inputs() JobInputClipResponseArrayOutput {
	return o.ApplyT(func(v JobInputSequenceResponse) []JobInputClipResponse { return v.Inputs }).(JobInputClipResponseArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobInputSequence'.
func (o JobInputSequenceResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputSequenceResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Describes a list of inputs to a Job.
type JobInputs struct {
	// List of inputs to a Job.
	Inputs []interface{} `pulumi:"inputs"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputs'.
	OdataType string `pulumi:"odataType"`
}

// JobInputsInput is an input type that accepts JobInputsArgs and JobInputsOutput values.
// You can construct a concrete instance of `JobInputsInput` via:
//
//	JobInputsArgs{...}
type JobInputsInput interface {
	pulumi.Input

	ToJobInputsOutput() JobInputsOutput
	ToJobInputsOutputWithContext(context.Context) JobInputsOutput
}

// Describes a list of inputs to a Job.
type JobInputsArgs struct {
	// List of inputs to a Job.
	Inputs pulumi.ArrayInput `pulumi:"inputs"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputs'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (JobInputsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputs)(nil)).Elem()
}

func (i JobInputsArgs) ToJobInputsOutput() JobInputsOutput {
	return i.ToJobInputsOutputWithContext(context.Background())
}

func (i JobInputsArgs) ToJobInputsOutputWithContext(ctx context.Context) JobInputsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobInputsOutput)
}

// Describes a list of inputs to a Job.
type JobInputsOutput struct{ *pulumi.OutputState }

func (JobInputsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputs)(nil)).Elem()
}

func (o JobInputsOutput) ToJobInputsOutput() JobInputsOutput {
	return o
}

func (o JobInputsOutput) ToJobInputsOutputWithContext(ctx context.Context) JobInputsOutput {
	return o
}

// List of inputs to a Job.
func (o JobInputsOutput) Inputs() pulumi.ArrayOutput {
	return o.ApplyT(func(v JobInputs) []interface{} { return v.Inputs }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobInputs'.
func (o JobInputsOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputs) string { return v.OdataType }).(pulumi.StringOutput)
}

// Describes a list of inputs to a Job.
type JobInputsResponse struct {
	// List of inputs to a Job.
	Inputs []interface{} `pulumi:"inputs"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputs'.
	OdataType string `pulumi:"odataType"`
}

// Describes a list of inputs to a Job.
type JobInputsResponseOutput struct{ *pulumi.OutputState }

func (JobInputsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobInputsResponse)(nil)).Elem()
}

func (o JobInputsResponseOutput) ToJobInputsResponseOutput() JobInputsResponseOutput {
	return o
}

func (o JobInputsResponseOutput) ToJobInputsResponseOutputWithContext(ctx context.Context) JobInputsResponseOutput {
	return o
}

// List of inputs to a Job.
func (o JobInputsResponseOutput) Inputs() pulumi.ArrayOutput {
	return o.ApplyT(func(v JobInputsResponse) []interface{} { return v.Inputs }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobInputs'.
func (o JobInputsResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobInputsResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Represents an Asset used as a JobOutput.
type JobOutputAsset struct {
	// The name of the output Asset.
	AssetName string `pulumi:"assetName"`
	// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobOutputAsset'.
	OdataType string `pulumi:"odataType"`
	// A preset used to override the preset in the corresponding transform output.
	PresetOverride interface{} `pulumi:"presetOverride"`
}

// JobOutputAssetInput is an input type that accepts JobOutputAssetArgs and JobOutputAssetOutput values.
// You can construct a concrete instance of `JobOutputAssetInput` via:
//
//	JobOutputAssetArgs{...}
type JobOutputAssetInput interface {
	pulumi.Input

	ToJobOutputAssetOutput() JobOutputAssetOutput
	ToJobOutputAssetOutputWithContext(context.Context) JobOutputAssetOutput
}

// Represents an Asset used as a JobOutput.
type JobOutputAssetArgs struct {
	// The name of the output Asset.
	AssetName pulumi.StringInput `pulumi:"assetName"`
	// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobOutputAsset'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// A preset used to override the preset in the corresponding transform output.
	PresetOverride pulumi.Input `pulumi:"presetOverride"`
}

func (JobOutputAssetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobOutputAsset)(nil)).Elem()
}

func (i JobOutputAssetArgs) ToJobOutputAssetOutput() JobOutputAssetOutput {
	return i.ToJobOutputAssetOutputWithContext(context.Background())
}

func (i JobOutputAssetArgs) ToJobOutputAssetOutputWithContext(ctx context.Context) JobOutputAssetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobOutputAssetOutput)
}

// JobOutputAssetArrayInput is an input type that accepts JobOutputAssetArray and JobOutputAssetArrayOutput values.
// You can construct a concrete instance of `JobOutputAssetArrayInput` via:
//
//	JobOutputAssetArray{ JobOutputAssetArgs{...} }
type JobOutputAssetArrayInput interface {
	pulumi.Input

	ToJobOutputAssetArrayOutput() JobOutputAssetArrayOutput
	ToJobOutputAssetArrayOutputWithContext(context.Context) JobOutputAssetArrayOutput
}

type JobOutputAssetArray []JobOutputAssetInput

func (JobOutputAssetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobOutputAsset)(nil)).Elem()
}

func (i JobOutputAssetArray) ToJobOutputAssetArrayOutput() JobOutputAssetArrayOutput {
	return i.ToJobOutputAssetArrayOutputWithContext(context.Background())
}

func (i JobOutputAssetArray) ToJobOutputAssetArrayOutputWithContext(ctx context.Context) JobOutputAssetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobOutputAssetArrayOutput)
}

// Represents an Asset used as a JobOutput.
type JobOutputAssetOutput struct{ *pulumi.OutputState }

func (JobOutputAssetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobOutputAsset)(nil)).Elem()
}

func (o JobOutputAssetOutput) ToJobOutputAssetOutput() JobOutputAssetOutput {
	return o
}

func (o JobOutputAssetOutput) ToJobOutputAssetOutputWithContext(ctx context.Context) JobOutputAssetOutput {
	return o
}

// The name of the output Asset.
func (o JobOutputAssetOutput) AssetName() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAsset) string { return v.AssetName }).(pulumi.StringOutput)
}

// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
func (o JobOutputAssetOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobOutputAsset) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobOutputAsset'.
func (o JobOutputAssetOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAsset) string { return v.OdataType }).(pulumi.StringOutput)
}

// A preset used to override the preset in the corresponding transform output.
func (o JobOutputAssetOutput) PresetOverride() pulumi.AnyOutput {
	return o.ApplyT(func(v JobOutputAsset) interface{} { return v.PresetOverride }).(pulumi.AnyOutput)
}

type JobOutputAssetArrayOutput struct{ *pulumi.OutputState }

func (JobOutputAssetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobOutputAsset)(nil)).Elem()
}

func (o JobOutputAssetArrayOutput) ToJobOutputAssetArrayOutput() JobOutputAssetArrayOutput {
	return o
}

func (o JobOutputAssetArrayOutput) ToJobOutputAssetArrayOutputWithContext(ctx context.Context) JobOutputAssetArrayOutput {
	return o
}

func (o JobOutputAssetArrayOutput) Index(i pulumi.IntInput) JobOutputAssetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobOutputAsset {
		return vs[0].([]JobOutputAsset)[vs[1].(int)]
	}).(JobOutputAssetOutput)
}

// Represents an Asset used as a JobOutput.
type JobOutputAssetResponse struct {
	// The name of the output Asset.
	AssetName string `pulumi:"assetName"`
	// The UTC date and time at which this Job Output finished processing.
	EndTime string `pulumi:"endTime"`
	// If the JobOutput is in the Error state, it contains the details of the error.
	Error JobErrorResponse `pulumi:"error"`
	// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobOutputAsset'.
	OdataType string `pulumi:"odataType"`
	// A preset used to override the preset in the corresponding transform output.
	PresetOverride interface{} `pulumi:"presetOverride"`
	// If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate and not intended to be used to predict Job completion times. To determine if the JobOutput is complete, use the State property.
	Progress int `pulumi:"progress"`
	// The UTC date and time at which this Job Output began processing.
	StartTime string `pulumi:"startTime"`
	// Describes the state of the JobOutput.
	State string `pulumi:"state"`
}

// Represents an Asset used as a JobOutput.
type JobOutputAssetResponseOutput struct{ *pulumi.OutputState }

func (JobOutputAssetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobOutputAssetResponse)(nil)).Elem()
}

func (o JobOutputAssetResponseOutput) ToJobOutputAssetResponseOutput() JobOutputAssetResponseOutput {
	return o
}

func (o JobOutputAssetResponseOutput) ToJobOutputAssetResponseOutputWithContext(ctx context.Context) JobOutputAssetResponseOutput {
	return o
}

// The name of the output Asset.
func (o JobOutputAssetResponseOutput) AssetName() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) string { return v.AssetName }).(pulumi.StringOutput)
}

// The UTC date and time at which this Job Output finished processing.
func (o JobOutputAssetResponseOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) string { return v.EndTime }).(pulumi.StringOutput)
}

// If the JobOutput is in the Error state, it contains the details of the error.
func (o JobOutputAssetResponseOutput) Error() JobErrorResponseOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) JobErrorResponse { return v.Error }).(JobErrorResponseOutput)
}

// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
func (o JobOutputAssetResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobOutputAsset'.
func (o JobOutputAssetResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// A preset used to override the preset in the corresponding transform output.
func (o JobOutputAssetResponseOutput) PresetOverride() pulumi.AnyOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) interface{} { return v.PresetOverride }).(pulumi.AnyOutput)
}

// If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate and not intended to be used to predict Job completion times. To determine if the JobOutput is complete, use the State property.
func (o JobOutputAssetResponseOutput) Progress() pulumi.IntOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) int { return v.Progress }).(pulumi.IntOutput)
}

// The UTC date and time at which this Job Output began processing.
func (o JobOutputAssetResponseOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) string { return v.StartTime }).(pulumi.StringOutput)
}

// Describes the state of the JobOutput.
func (o JobOutputAssetResponseOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) string { return v.State }).(pulumi.StringOutput)
}

type JobOutputAssetResponseArrayOutput struct{ *pulumi.OutputState }

func (JobOutputAssetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobOutputAssetResponse)(nil)).Elem()
}

func (o JobOutputAssetResponseArrayOutput) ToJobOutputAssetResponseArrayOutput() JobOutputAssetResponseArrayOutput {
	return o
}

func (o JobOutputAssetResponseArrayOutput) ToJobOutputAssetResponseArrayOutputWithContext(ctx context.Context) JobOutputAssetResponseArrayOutput {
	return o
}

func (o JobOutputAssetResponseArrayOutput) Index(i pulumi.IntInput) JobOutputAssetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobOutputAssetResponse {
		return vs[0].([]JobOutputAssetResponse)[vs[1].(int)]
	}).(JobOutputAssetResponseOutput)
}

// Describes the settings for producing JPEG thumbnails.
type JpgFormat struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgFormat'.
	OdataType string `pulumi:"odataType"`
}

// JpgFormatInput is an input type that accepts JpgFormatArgs and JpgFormatOutput values.
// You can construct a concrete instance of `JpgFormatInput` via:
//
//	JpgFormatArgs{...}
type JpgFormatInput interface {
	pulumi.Input

	ToJpgFormatOutput() JpgFormatOutput
	ToJpgFormatOutputWithContext(context.Context) JpgFormatOutput
}

// Describes the settings for producing JPEG thumbnails.
type JpgFormatArgs struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern pulumi.StringInput `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgFormat'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (JpgFormatArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JpgFormat)(nil)).Elem()
}

func (i JpgFormatArgs) ToJpgFormatOutput() JpgFormatOutput {
	return i.ToJpgFormatOutputWithContext(context.Background())
}

func (i JpgFormatArgs) ToJpgFormatOutputWithContext(ctx context.Context) JpgFormatOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JpgFormatOutput)
}

// Describes the settings for producing JPEG thumbnails.
type JpgFormatOutput struct{ *pulumi.OutputState }

func (JpgFormatOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JpgFormat)(nil)).Elem()
}

func (o JpgFormatOutput) ToJpgFormatOutput() JpgFormatOutput {
	return o
}

func (o JpgFormatOutput) ToJpgFormatOutputWithContext(ctx context.Context) JpgFormatOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o JpgFormatOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v JpgFormat) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JpgFormat'.
func (o JpgFormatOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JpgFormat) string { return v.OdataType }).(pulumi.StringOutput)
}

// Describes the settings for producing JPEG thumbnails.
type JpgFormatResponse struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgFormat'.
	OdataType string `pulumi:"odataType"`
}

// Describes the settings for producing JPEG thumbnails.
type JpgFormatResponseOutput struct{ *pulumi.OutputState }

func (JpgFormatResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JpgFormatResponse)(nil)).Elem()
}

func (o JpgFormatResponseOutput) ToJpgFormatResponseOutput() JpgFormatResponseOutput {
	return o
}

func (o JpgFormatResponseOutput) ToJpgFormatResponseOutputWithContext(ctx context.Context) JpgFormatResponseOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o JpgFormatResponseOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v JpgFormatResponse) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JpgFormat'.
func (o JpgFormatResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JpgFormatResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Describes the properties for producing a series of JPEG images from the input video.
type JpgImage struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// A collection of output JPEG image layers to be produced by the encoder.
	Layers []JpgLayer `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgImage'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// Sets the number of columns used in thumbnail sprite image.  The number of rows are automatically calculated and a VTT file is generated with the coordinate mappings for each thumbnail in the sprite. Note: this value should be a positive integer and a proper value is recommended so that the output image resolution will not go beyond JPEG maximum pixel resolution limit 65535x65535.
	SpriteColumn *int `pulumi:"spriteColumn"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// JpgImageInput is an input type that accepts JpgImageArgs and JpgImageOutput values.
// You can construct a concrete instance of `JpgImageInput` via:
//
//	JpgImageArgs{...}
type JpgImageInput interface {
	pulumi.Input

	ToJpgImageOutput() JpgImageOutput
	ToJpgImageOutputWithContext(context.Context) JpgImageOutput
}

// Describes the properties for producing a series of JPEG images from the input video.
type JpgImageArgs struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval pulumi.StringPtrInput `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// A collection of output JPEG image layers to be produced by the encoder.
	Layers JpgLayerArrayInput `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgImage'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range pulumi.StringPtrInput `pulumi:"range"`
	// Sets the number of columns used in thumbnail sprite image.  The number of rows are automatically calculated and a VTT file is generated with the coordinate mappings for each thumbnail in the sprite. Note: this value should be a positive integer and a proper value is recommended so that the output image resolution will not go beyond JPEG maximum pixel resolution limit 65535x65535.
	SpriteColumn pulumi.IntPtrInput `pulumi:"spriteColumn"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start pulumi.StringInput `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step pulumi.StringPtrInput `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode pulumi.StringPtrInput `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode pulumi.StringPtrInput `pulumi:"syncMode"`
}

func (JpgImageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JpgImage)(nil)).Elem()
}

func (i JpgImageArgs) ToJpgImageOutput() JpgImageOutput {
	return i.ToJpgImageOutputWithContext(context.Background())
}

func (i JpgImageArgs) ToJpgImageOutputWithContext(ctx context.Context) JpgImageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JpgImageOutput)
}

// Describes the properties for producing a series of JPEG images from the input video.
type JpgImageOutput struct{ *pulumi.OutputState }

func (JpgImageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JpgImage)(nil)).Elem()
}

func (o JpgImageOutput) ToJpgImageOutput() JpgImageOutput {
	return o
}

func (o JpgImageOutput) ToJpgImageOutputWithContext(ctx context.Context) JpgImageOutput {
	return o
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o JpgImageOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImage) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o JpgImageOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImage) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// A collection of output JPEG image layers to be produced by the encoder.
func (o JpgImageOutput) Layers() JpgLayerArrayOutput {
	return o.ApplyT(func(v JpgImage) []JpgLayer { return v.Layers }).(JpgLayerArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JpgImage'.
func (o JpgImageOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JpgImage) string { return v.OdataType }).(pulumi.StringOutput)
}

// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
func (o JpgImageOutput) Range() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImage) *string { return v.Range }).(pulumi.StringPtrOutput)
}

// Sets the number of columns used in thumbnail sprite image.  The number of rows are automatically calculated and a VTT file is generated with the coordinate mappings for each thumbnail in the sprite. Note: this value should be a positive integer and a proper value is recommended so that the output image resolution will not go beyond JPEG maximum pixel resolution limit 65535x65535.
func (o JpgImageOutput) SpriteColumn() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JpgImage) *int { return v.SpriteColumn }).(pulumi.IntPtrOutput)
}

// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
func (o JpgImageOutput) Start() pulumi.StringOutput {
	return o.ApplyT(func(v JpgImage) string { return v.Start }).(pulumi.StringOutput)
}

// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
func (o JpgImageOutput) Step() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImage) *string { return v.Step }).(pulumi.StringPtrOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o JpgImageOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImage) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o JpgImageOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImage) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// Describes the properties for producing a series of JPEG images from the input video.
type JpgImageResponse struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// A collection of output JPEG image layers to be produced by the encoder.
	Layers []JpgLayerResponse `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgImage'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// Sets the number of columns used in thumbnail sprite image.  The number of rows are automatically calculated and a VTT file is generated with the coordinate mappings for each thumbnail in the sprite. Note: this value should be a positive integer and a proper value is recommended so that the output image resolution will not go beyond JPEG maximum pixel resolution limit 65535x65535.
	SpriteColumn *int `pulumi:"spriteColumn"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes the properties for producing a series of JPEG images from the input video.
type JpgImageResponseOutput struct{ *pulumi.OutputState }

func (JpgImageResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JpgImageResponse)(nil)).Elem()
}

func (o JpgImageResponseOutput) ToJpgImageResponseOutput() JpgImageResponseOutput {
	return o
}

func (o JpgImageResponseOutput) ToJpgImageResponseOutputWithContext(ctx context.Context) JpgImageResponseOutput {
	return o
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o JpgImageResponseOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImageResponse) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o JpgImageResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImageResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// A collection of output JPEG image layers to be produced by the encoder.
func (o JpgImageResponseOutput) Layers() JpgLayerResponseArrayOutput {
	return o.ApplyT(func(v JpgImageResponse) []JpgLayerResponse { return v.Layers }).(JpgLayerResponseArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JpgImage'.
func (o JpgImageResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JpgImageResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
func (o JpgImageResponseOutput) Range() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImageResponse) *string { return v.Range }).(pulumi.StringPtrOutput)
}

// Sets the number of columns used in thumbnail sprite image.  The number of rows are automatically calculated and a VTT file is generated with the coordinate mappings for each thumbnail in the sprite. Note: this value should be a positive integer and a proper value is recommended so that the output image resolution will not go beyond JPEG maximum pixel resolution limit 65535x65535.
func (o JpgImageResponseOutput) SpriteColumn() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JpgImageResponse) *int { return v.SpriteColumn }).(pulumi.IntPtrOutput)
}

// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
func (o JpgImageResponseOutput) Start() pulumi.StringOutput {
	return o.ApplyT(func(v JpgImageResponse) string { return v.Start }).(pulumi.StringOutput)
}

// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
func (o JpgImageResponseOutput) Step() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImageResponse) *string { return v.Step }).(pulumi.StringPtrOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o JpgImageResponseOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImageResponse) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o JpgImageResponseOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgImageResponse) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// Describes the settings to produce a JPEG image from the input video.
type JpgLayer struct {
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// The compression quality of the JPEG output. Range is from 0-100 and the default is 70.
	Quality *int `pulumi:"quality"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// JpgLayerInput is an input type that accepts JpgLayerArgs and JpgLayerOutput values.
// You can construct a concrete instance of `JpgLayerInput` via:
//
//	JpgLayerArgs{...}
type JpgLayerInput interface {
	pulumi.Input

	ToJpgLayerOutput() JpgLayerOutput
	ToJpgLayerOutputWithContext(context.Context) JpgLayerOutput
}

// Describes the settings to produce a JPEG image from the input video.
type JpgLayerArgs struct {
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height pulumi.StringPtrInput `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The compression quality of the JPEG output. Range is from 0-100 and the default is 70.
	Quality pulumi.IntPtrInput `pulumi:"quality"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width pulumi.StringPtrInput `pulumi:"width"`
}

func (JpgLayerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JpgLayer)(nil)).Elem()
}

func (i JpgLayerArgs) ToJpgLayerOutput() JpgLayerOutput {
	return i.ToJpgLayerOutputWithContext(context.Background())
}

func (i JpgLayerArgs) ToJpgLayerOutputWithContext(ctx context.Context) JpgLayerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JpgLayerOutput)
}

// JpgLayerArrayInput is an input type that accepts JpgLayerArray and JpgLayerArrayOutput values.
// You can construct a concrete instance of `JpgLayerArrayInput` via:
//
//	JpgLayerArray{ JpgLayerArgs{...} }
type JpgLayerArrayInput interface {
	pulumi.Input

	ToJpgLayerArrayOutput() JpgLayerArrayOutput
	ToJpgLayerArrayOutputWithContext(context.Context) JpgLayerArrayOutput
}

type JpgLayerArray []JpgLayerInput

func (JpgLayerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JpgLayer)(nil)).Elem()
}

func (i JpgLayerArray) ToJpgLayerArrayOutput() JpgLayerArrayOutput {
	return i.ToJpgLayerArrayOutputWithContext(context.Background())
}

func (i JpgLayerArray) ToJpgLayerArrayOutputWithContext(ctx context.Context) JpgLayerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JpgLayerArrayOutput)
}

// Describes the settings to produce a JPEG image from the input video.
type JpgLayerOutput struct{ *pulumi.OutputState }

func (JpgLayerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JpgLayer)(nil)).Elem()
}

func (o JpgLayerOutput) ToJpgLayerOutput() JpgLayerOutput {
	return o
}

func (o JpgLayerOutput) ToJpgLayerOutputWithContext(ctx context.Context) JpgLayerOutput {
	return o
}

// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
func (o JpgLayerOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgLayer) *string { return v.Height }).(pulumi.StringPtrOutput)
}

// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
func (o JpgLayerOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgLayer) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The compression quality of the JPEG output. Range is from 0-100 and the default is 70.
func (o JpgLayerOutput) Quality() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JpgLayer) *int { return v.Quality }).(pulumi.IntPtrOutput)
}

// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
func (o JpgLayerOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgLayer) *string { return v.Width }).(pulumi.StringPtrOutput)
}

type JpgLayerArrayOutput struct{ *pulumi.OutputState }

func (JpgLayerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JpgLayer)(nil)).Elem()
}

func (o JpgLayerArrayOutput) ToJpgLayerArrayOutput() JpgLayerArrayOutput {
	return o
}

func (o JpgLayerArrayOutput) ToJpgLayerArrayOutputWithContext(ctx context.Context) JpgLayerArrayOutput {
	return o
}

func (o JpgLayerArrayOutput) Index(i pulumi.IntInput) JpgLayerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JpgLayer {
		return vs[0].([]JpgLayer)[vs[1].(int)]
	}).(JpgLayerOutput)
}

// Describes the settings to produce a JPEG image from the input video.
type JpgLayerResponse struct {
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// The compression quality of the JPEG output. Range is from 0-100 and the default is 70.
	Quality *int `pulumi:"quality"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// Describes the settings to produce a JPEG image from the input video.
type JpgLayerResponseOutput struct{ *pulumi.OutputState }

func (JpgLayerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JpgLayerResponse)(nil)).Elem()
}

func (o JpgLayerResponseOutput) ToJpgLayerResponseOutput() JpgLayerResponseOutput {
	return o
}

func (o JpgLayerResponseOutput) ToJpgLayerResponseOutputWithContext(ctx context.Context) JpgLayerResponseOutput {
	return o
}

// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
func (o JpgLayerResponseOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgLayerResponse) *string { return v.Height }).(pulumi.StringPtrOutput)
}

// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
func (o JpgLayerResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgLayerResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The compression quality of the JPEG output. Range is from 0-100 and the default is 70.
func (o JpgLayerResponseOutput) Quality() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JpgLayerResponse) *int { return v.Quality }).(pulumi.IntPtrOutput)
}

// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
func (o JpgLayerResponseOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JpgLayerResponse) *string { return v.Width }).(pulumi.StringPtrOutput)
}

type JpgLayerResponseArrayOutput struct{ *pulumi.OutputState }

func (JpgLayerResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JpgLayerResponse)(nil)).Elem()
}

func (o JpgLayerResponseArrayOutput) ToJpgLayerResponseArrayOutput() JpgLayerResponseArrayOutput {
	return o
}

func (o JpgLayerResponseArrayOutput) ToJpgLayerResponseArrayOutputWithContext(ctx context.Context) JpgLayerResponseArrayOutput {
	return o
}

func (o JpgLayerResponseArrayOutput) Index(i pulumi.IntInput) JpgLayerResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JpgLayerResponse {
		return vs[0].([]JpgLayerResponse)[vs[1].(int)]
	}).(JpgLayerResponseOutput)
}

type KeyDelivery struct {
	// The access control properties for Key Delivery.
	AccessControl *AccessControl `pulumi:"accessControl"`
}

// KeyDeliveryInput is an input type that accepts KeyDeliveryArgs and KeyDeliveryOutput values.
// You can construct a concrete instance of `KeyDeliveryInput` via:
//
//	KeyDeliveryArgs{...}
type KeyDeliveryInput interface {
	pulumi.Input

	ToKeyDeliveryOutput() KeyDeliveryOutput
	ToKeyDeliveryOutputWithContext(context.Context) KeyDeliveryOutput
}

type KeyDeliveryArgs struct {
	// The access control properties for Key Delivery.
	AccessControl AccessControlPtrInput `pulumi:"accessControl"`
}

func (KeyDeliveryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyDelivery)(nil)).Elem()
}

func (i KeyDeliveryArgs) ToKeyDeliveryOutput() KeyDeliveryOutput {
	return i.ToKeyDeliveryOutputWithContext(context.Background())
}

func (i KeyDeliveryArgs) ToKeyDeliveryOutputWithContext(ctx context.Context) KeyDeliveryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyDeliveryOutput)
}

func (i KeyDeliveryArgs) ToKeyDeliveryPtrOutput() KeyDeliveryPtrOutput {
	return i.ToKeyDeliveryPtrOutputWithContext(context.Background())
}

func (i KeyDeliveryArgs) ToKeyDeliveryPtrOutputWithContext(ctx context.Context) KeyDeliveryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyDeliveryOutput).ToKeyDeliveryPtrOutputWithContext(ctx)
}

// KeyDeliveryPtrInput is an input type that accepts KeyDeliveryArgs, KeyDeliveryPtr and KeyDeliveryPtrOutput values.
// You can construct a concrete instance of `KeyDeliveryPtrInput` via:
//
//	        KeyDeliveryArgs{...}
//
//	or:
//
//	        nil
type KeyDeliveryPtrInput interface {
	pulumi.Input

	ToKeyDeliveryPtrOutput() KeyDeliveryPtrOutput
	ToKeyDeliveryPtrOutputWithContext(context.Context) KeyDeliveryPtrOutput
}

type keyDeliveryPtrType KeyDeliveryArgs

func KeyDeliveryPtr(v *KeyDeliveryArgs) KeyDeliveryPtrInput {
	return (*keyDeliveryPtrType)(v)
}

func (*keyDeliveryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyDelivery)(nil)).Elem()
}

func (i *keyDeliveryPtrType) ToKeyDeliveryPtrOutput() KeyDeliveryPtrOutput {
	return i.ToKeyDeliveryPtrOutputWithContext(context.Background())
}

func (i *keyDeliveryPtrType) ToKeyDeliveryPtrOutputWithContext(ctx context.Context) KeyDeliveryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyDeliveryPtrOutput)
}

type KeyDeliveryOutput struct{ *pulumi.OutputState }

func (KeyDeliveryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyDelivery)(nil)).Elem()
}

func (o KeyDeliveryOutput) ToKeyDeliveryOutput() KeyDeliveryOutput {
	return o
}

func (o KeyDeliveryOutput) ToKeyDeliveryOutputWithContext(ctx context.Context) KeyDeliveryOutput {
	return o
}

func (o KeyDeliveryOutput) ToKeyDeliveryPtrOutput() KeyDeliveryPtrOutput {
	return o.ToKeyDeliveryPtrOutputWithContext(context.Background())
}

func (o KeyDeliveryOutput) ToKeyDeliveryPtrOutputWithContext(ctx context.Context) KeyDeliveryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KeyDelivery) *KeyDelivery {
		return &v
	}).(KeyDeliveryPtrOutput)
}

// The access control properties for Key Delivery.
func (o KeyDeliveryOutput) AccessControl() AccessControlPtrOutput {
	return o.ApplyT(func(v KeyDelivery) *AccessControl { return v.AccessControl }).(AccessControlPtrOutput)
}

type KeyDeliveryPtrOutput struct{ *pulumi.OutputState }

func (KeyDeliveryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyDelivery)(nil)).Elem()
}

func (o KeyDeliveryPtrOutput) ToKeyDeliveryPtrOutput() KeyDeliveryPtrOutput {
	return o
}

func (o KeyDeliveryPtrOutput) ToKeyDeliveryPtrOutputWithContext(ctx context.Context) KeyDeliveryPtrOutput {
	return o
}

func (o KeyDeliveryPtrOutput) Elem() KeyDeliveryOutput {
	return o.ApplyT(func(v *KeyDelivery) KeyDelivery {
		if v != nil {
			return *v
		}
		var ret KeyDelivery
		return ret
	}).(KeyDeliveryOutput)
}

// The access control properties for Key Delivery.
func (o KeyDeliveryPtrOutput) AccessControl() AccessControlPtrOutput {
	return o.ApplyT(func(v *KeyDelivery) *AccessControl {
		if v == nil {
			return nil
		}
		return v.AccessControl
	}).(AccessControlPtrOutput)
}

type KeyDeliveryResponse struct {
	// The access control properties for Key Delivery.
	AccessControl *AccessControlResponse `pulumi:"accessControl"`
}

type KeyDeliveryResponseOutput struct{ *pulumi.OutputState }

func (KeyDeliveryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyDeliveryResponse)(nil)).Elem()
}

func (o KeyDeliveryResponseOutput) ToKeyDeliveryResponseOutput() KeyDeliveryResponseOutput {
	return o
}

func (o KeyDeliveryResponseOutput) ToKeyDeliveryResponseOutputWithContext(ctx context.Context) KeyDeliveryResponseOutput {
	return o
}

// The access control properties for Key Delivery.
func (o KeyDeliveryResponseOutput) AccessControl() AccessControlResponsePtrOutput {
	return o.ApplyT(func(v KeyDeliveryResponse) *AccessControlResponse { return v.AccessControl }).(AccessControlResponsePtrOutput)
}

type KeyDeliveryResponsePtrOutput struct{ *pulumi.OutputState }

func (KeyDeliveryResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyDeliveryResponse)(nil)).Elem()
}

func (o KeyDeliveryResponsePtrOutput) ToKeyDeliveryResponsePtrOutput() KeyDeliveryResponsePtrOutput {
	return o
}

func (o KeyDeliveryResponsePtrOutput) ToKeyDeliveryResponsePtrOutputWithContext(ctx context.Context) KeyDeliveryResponsePtrOutput {
	return o
}

func (o KeyDeliveryResponsePtrOutput) Elem() KeyDeliveryResponseOutput {
	return o.ApplyT(func(v *KeyDeliveryResponse) KeyDeliveryResponse {
		if v != nil {
			return *v
		}
		var ret KeyDeliveryResponse
		return ret
	}).(KeyDeliveryResponseOutput)
}

// The access control properties for Key Delivery.
func (o KeyDeliveryResponsePtrOutput) AccessControl() AccessControlResponsePtrOutput {
	return o.ApplyT(func(v *KeyDeliveryResponse) *AccessControlResponse {
		if v == nil {
			return nil
		}
		return v.AccessControl
	}).(AccessControlResponsePtrOutput)
}

type KeyVaultProperties struct {
	// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
	KeyIdentifier *string `pulumi:"keyIdentifier"`
}

// KeyVaultPropertiesInput is an input type that accepts KeyVaultPropertiesArgs and KeyVaultPropertiesOutput values.
// You can construct a concrete instance of `KeyVaultPropertiesInput` via:
//
//	KeyVaultPropertiesArgs{...}
type KeyVaultPropertiesInput interface {
	pulumi.Input

	ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput
	ToKeyVaultPropertiesOutputWithContext(context.Context) KeyVaultPropertiesOutput
}

type KeyVaultPropertiesArgs struct {
	// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
	KeyIdentifier pulumi.StringPtrInput `pulumi:"keyIdentifier"`
}

func (KeyVaultPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultProperties)(nil)).Elem()
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput {
	return i.ToKeyVaultPropertiesOutputWithContext(context.Background())
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesOutputWithContext(ctx context.Context) KeyVaultPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesOutput)
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return i.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesOutput).ToKeyVaultPropertiesPtrOutputWithContext(ctx)
}

// KeyVaultPropertiesPtrInput is an input type that accepts KeyVaultPropertiesArgs, KeyVaultPropertiesPtr and KeyVaultPropertiesPtrOutput values.
// You can construct a concrete instance of `KeyVaultPropertiesPtrInput` via:
//
//	        KeyVaultPropertiesArgs{...}
//
//	or:
//
//	        nil
type KeyVaultPropertiesPtrInput interface {
	pulumi.Input

	ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput
	ToKeyVaultPropertiesPtrOutputWithContext(context.Context) KeyVaultPropertiesPtrOutput
}

type keyVaultPropertiesPtrType KeyVaultPropertiesArgs

func KeyVaultPropertiesPtr(v *KeyVaultPropertiesArgs) KeyVaultPropertiesPtrInput {
	return (*keyVaultPropertiesPtrType)(v)
}

func (*keyVaultPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultProperties)(nil)).Elem()
}

func (i *keyVaultPropertiesPtrType) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return i.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (i *keyVaultPropertiesPtrType) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesPtrOutput)
}

type KeyVaultPropertiesOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultProperties)(nil)).Elem()
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput {
	return o
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesOutputWithContext(ctx context.Context) KeyVaultPropertiesOutput {
	return o
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return o.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KeyVaultProperties) *KeyVaultProperties {
		return &v
	}).(KeyVaultPropertiesPtrOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyVaultProperties) *string { return v.KeyIdentifier }).(pulumi.StringPtrOutput)
}

type KeyVaultPropertiesPtrOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultProperties)(nil)).Elem()
}

func (o KeyVaultPropertiesPtrOutput) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return o
}

func (o KeyVaultPropertiesPtrOutput) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return o
}

func (o KeyVaultPropertiesPtrOutput) Elem() KeyVaultPropertiesOutput {
	return o.ApplyT(func(v *KeyVaultProperties) KeyVaultProperties {
		if v != nil {
			return *v
		}
		var ret KeyVaultProperties
		return ret
	}).(KeyVaultPropertiesOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesPtrOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultProperties) *string {
		if v == nil {
			return nil
		}
		return v.KeyIdentifier
	}).(pulumi.StringPtrOutput)
}

type KeyVaultPropertiesResponse struct {
	// The current key used to encrypt the Media Services account, including the key version.
	CurrentKeyIdentifier string `pulumi:"currentKeyIdentifier"`
	// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
	KeyIdentifier *string `pulumi:"keyIdentifier"`
}

type KeyVaultPropertiesResponseOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultPropertiesResponse)(nil)).Elem()
}

func (o KeyVaultPropertiesResponseOutput) ToKeyVaultPropertiesResponseOutput() KeyVaultPropertiesResponseOutput {
	return o
}

func (o KeyVaultPropertiesResponseOutput) ToKeyVaultPropertiesResponseOutputWithContext(ctx context.Context) KeyVaultPropertiesResponseOutput {
	return o
}

// The current key used to encrypt the Media Services account, including the key version.
func (o KeyVaultPropertiesResponseOutput) CurrentKeyIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v KeyVaultPropertiesResponse) string { return v.CurrentKeyIdentifier }).(pulumi.StringOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesResponseOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyVaultPropertiesResponse) *string { return v.KeyIdentifier }).(pulumi.StringPtrOutput)
}

type KeyVaultPropertiesResponsePtrOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultPropertiesResponse)(nil)).Elem()
}

func (o KeyVaultPropertiesResponsePtrOutput) ToKeyVaultPropertiesResponsePtrOutput() KeyVaultPropertiesResponsePtrOutput {
	return o
}

func (o KeyVaultPropertiesResponsePtrOutput) ToKeyVaultPropertiesResponsePtrOutputWithContext(ctx context.Context) KeyVaultPropertiesResponsePtrOutput {
	return o
}

func (o KeyVaultPropertiesResponsePtrOutput) Elem() KeyVaultPropertiesResponseOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) KeyVaultPropertiesResponse {
		if v != nil {
			return *v
		}
		var ret KeyVaultPropertiesResponse
		return ret
	}).(KeyVaultPropertiesResponseOutput)
}

// The current key used to encrypt the Media Services account, including the key version.
func (o KeyVaultPropertiesResponsePtrOutput) CurrentKeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return &v.CurrentKeyIdentifier
	}).(pulumi.StringPtrOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesResponsePtrOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return v.KeyIdentifier
	}).(pulumi.StringPtrOutput)
}

// Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncoding struct {
	// Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
	EncodingType *string `pulumi:"encodingType"`
	// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
	PresetName *string `pulumi:"presetName"`
	// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
	StretchMode *string `pulumi:"stretchMode"`
}

// LiveEventEncodingInput is an input type that accepts LiveEventEncodingArgs and LiveEventEncodingOutput values.
// You can construct a concrete instance of `LiveEventEncodingInput` via:
//
//	LiveEventEncodingArgs{...}
type LiveEventEncodingInput interface {
	pulumi.Input

	ToLiveEventEncodingOutput() LiveEventEncodingOutput
	ToLiveEventEncodingOutputWithContext(context.Context) LiveEventEncodingOutput
}

// Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncodingArgs struct {
	// Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
	EncodingType pulumi.StringPtrInput `pulumi:"encodingType"`
	// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
	KeyFrameInterval pulumi.StringPtrInput `pulumi:"keyFrameInterval"`
	// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
	PresetName pulumi.StringPtrInput `pulumi:"presetName"`
	// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
	StretchMode pulumi.StringPtrInput `pulumi:"stretchMode"`
}

func (LiveEventEncodingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEncoding)(nil)).Elem()
}

func (i LiveEventEncodingArgs) ToLiveEventEncodingOutput() LiveEventEncodingOutput {
	return i.ToLiveEventEncodingOutputWithContext(context.Background())
}

func (i LiveEventEncodingArgs) ToLiveEventEncodingOutputWithContext(ctx context.Context) LiveEventEncodingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventEncodingOutput)
}

func (i LiveEventEncodingArgs) ToLiveEventEncodingPtrOutput() LiveEventEncodingPtrOutput {
	return i.ToLiveEventEncodingPtrOutputWithContext(context.Background())
}

func (i LiveEventEncodingArgs) ToLiveEventEncodingPtrOutputWithContext(ctx context.Context) LiveEventEncodingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventEncodingOutput).ToLiveEventEncodingPtrOutputWithContext(ctx)
}

// LiveEventEncodingPtrInput is an input type that accepts LiveEventEncodingArgs, LiveEventEncodingPtr and LiveEventEncodingPtrOutput values.
// You can construct a concrete instance of `LiveEventEncodingPtrInput` via:
//
//	        LiveEventEncodingArgs{...}
//
//	or:
//
//	        nil
type LiveEventEncodingPtrInput interface {
	pulumi.Input

	ToLiveEventEncodingPtrOutput() LiveEventEncodingPtrOutput
	ToLiveEventEncodingPtrOutputWithContext(context.Context) LiveEventEncodingPtrOutput
}

type liveEventEncodingPtrType LiveEventEncodingArgs

func LiveEventEncodingPtr(v *LiveEventEncodingArgs) LiveEventEncodingPtrInput {
	return (*liveEventEncodingPtrType)(v)
}

func (*liveEventEncodingPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventEncoding)(nil)).Elem()
}

func (i *liveEventEncodingPtrType) ToLiveEventEncodingPtrOutput() LiveEventEncodingPtrOutput {
	return i.ToLiveEventEncodingPtrOutputWithContext(context.Background())
}

func (i *liveEventEncodingPtrType) ToLiveEventEncodingPtrOutputWithContext(ctx context.Context) LiveEventEncodingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventEncodingPtrOutput)
}

// Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncodingOutput struct{ *pulumi.OutputState }

func (LiveEventEncodingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEncoding)(nil)).Elem()
}

func (o LiveEventEncodingOutput) ToLiveEventEncodingOutput() LiveEventEncodingOutput {
	return o
}

func (o LiveEventEncodingOutput) ToLiveEventEncodingOutputWithContext(ctx context.Context) LiveEventEncodingOutput {
	return o
}

func (o LiveEventEncodingOutput) ToLiveEventEncodingPtrOutput() LiveEventEncodingPtrOutput {
	return o.ToLiveEventEncodingPtrOutputWithContext(context.Background())
}

func (o LiveEventEncodingOutput) ToLiveEventEncodingPtrOutputWithContext(ctx context.Context) LiveEventEncodingPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LiveEventEncoding) *LiveEventEncoding {
		return &v
	}).(LiveEventEncodingPtrOutput)
}

// Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
func (o LiveEventEncodingOutput) EncodingType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncoding) *string { return v.EncodingType }).(pulumi.StringPtrOutput)
}

// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
func (o LiveEventEncodingOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncoding) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
func (o LiveEventEncodingOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncoding) *string { return v.PresetName }).(pulumi.StringPtrOutput)
}

// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
func (o LiveEventEncodingOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncoding) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

type LiveEventEncodingPtrOutput struct{ *pulumi.OutputState }

func (LiveEventEncodingPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventEncoding)(nil)).Elem()
}

func (o LiveEventEncodingPtrOutput) ToLiveEventEncodingPtrOutput() LiveEventEncodingPtrOutput {
	return o
}

func (o LiveEventEncodingPtrOutput) ToLiveEventEncodingPtrOutputWithContext(ctx context.Context) LiveEventEncodingPtrOutput {
	return o
}

func (o LiveEventEncodingPtrOutput) Elem() LiveEventEncodingOutput {
	return o.ApplyT(func(v *LiveEventEncoding) LiveEventEncoding {
		if v != nil {
			return *v
		}
		var ret LiveEventEncoding
		return ret
	}).(LiveEventEncodingOutput)
}

// Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
func (o LiveEventEncodingPtrOutput) EncodingType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncoding) *string {
		if v == nil {
			return nil
		}
		return v.EncodingType
	}).(pulumi.StringPtrOutput)
}

// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
func (o LiveEventEncodingPtrOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncoding) *string {
		if v == nil {
			return nil
		}
		return v.KeyFrameInterval
	}).(pulumi.StringPtrOutput)
}

// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
func (o LiveEventEncodingPtrOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncoding) *string {
		if v == nil {
			return nil
		}
		return v.PresetName
	}).(pulumi.StringPtrOutput)
}

// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
func (o LiveEventEncodingPtrOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncoding) *string {
		if v == nil {
			return nil
		}
		return v.StretchMode
	}).(pulumi.StringPtrOutput)
}

// Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncodingResponse struct {
	// Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
	EncodingType *string `pulumi:"encodingType"`
	// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
	PresetName *string `pulumi:"presetName"`
	// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
	StretchMode *string `pulumi:"stretchMode"`
}

// Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncodingResponseOutput struct{ *pulumi.OutputState }

func (LiveEventEncodingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEncodingResponse)(nil)).Elem()
}

func (o LiveEventEncodingResponseOutput) ToLiveEventEncodingResponseOutput() LiveEventEncodingResponseOutput {
	return o
}

func (o LiveEventEncodingResponseOutput) ToLiveEventEncodingResponseOutputWithContext(ctx context.Context) LiveEventEncodingResponseOutput {
	return o
}

// Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
func (o LiveEventEncodingResponseOutput) EncodingType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncodingResponse) *string { return v.EncodingType }).(pulumi.StringPtrOutput)
}

// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
func (o LiveEventEncodingResponseOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncodingResponse) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
func (o LiveEventEncodingResponseOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncodingResponse) *string { return v.PresetName }).(pulumi.StringPtrOutput)
}

// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
func (o LiveEventEncodingResponseOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncodingResponse) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

type LiveEventEncodingResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventEncodingResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventEncodingResponse)(nil)).Elem()
}

func (o LiveEventEncodingResponsePtrOutput) ToLiveEventEncodingResponsePtrOutput() LiveEventEncodingResponsePtrOutput {
	return o
}

func (o LiveEventEncodingResponsePtrOutput) ToLiveEventEncodingResponsePtrOutputWithContext(ctx context.Context) LiveEventEncodingResponsePtrOutput {
	return o
}

func (o LiveEventEncodingResponsePtrOutput) Elem() LiveEventEncodingResponseOutput {
	return o.ApplyT(func(v *LiveEventEncodingResponse) LiveEventEncodingResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventEncodingResponse
		return ret
	}).(LiveEventEncodingResponseOutput)
}

// Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
func (o LiveEventEncodingResponsePtrOutput) EncodingType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncodingResponse) *string {
		if v == nil {
			return nil
		}
		return v.EncodingType
	}).(pulumi.StringPtrOutput)
}

// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
func (o LiveEventEncodingResponsePtrOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncodingResponse) *string {
		if v == nil {
			return nil
		}
		return v.KeyFrameInterval
	}).(pulumi.StringPtrOutput)
}

// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
func (o LiveEventEncodingResponsePtrOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncodingResponse) *string {
		if v == nil {
			return nil
		}
		return v.PresetName
	}).(pulumi.StringPtrOutput)
}

// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
func (o LiveEventEncodingResponsePtrOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncodingResponse) *string {
		if v == nil {
			return nil
		}
		return v.StretchMode
	}).(pulumi.StringPtrOutput)
}

// The live event endpoint.
type LiveEventEndpoint struct {
	// The endpoint protocol.
	Protocol *string `pulumi:"protocol"`
	// The endpoint URL.
	Url *string `pulumi:"url"`
}

// LiveEventEndpointInput is an input type that accepts LiveEventEndpointArgs and LiveEventEndpointOutput values.
// You can construct a concrete instance of `LiveEventEndpointInput` via:
//
//	LiveEventEndpointArgs{...}
type LiveEventEndpointInput interface {
	pulumi.Input

	ToLiveEventEndpointOutput() LiveEventEndpointOutput
	ToLiveEventEndpointOutputWithContext(context.Context) LiveEventEndpointOutput
}

// The live event endpoint.
type LiveEventEndpointArgs struct {
	// The endpoint protocol.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// The endpoint URL.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (LiveEventEndpointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEndpoint)(nil)).Elem()
}

func (i LiveEventEndpointArgs) ToLiveEventEndpointOutput() LiveEventEndpointOutput {
	return i.ToLiveEventEndpointOutputWithContext(context.Background())
}

func (i LiveEventEndpointArgs) ToLiveEventEndpointOutputWithContext(ctx context.Context) LiveEventEndpointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventEndpointOutput)
}

// LiveEventEndpointArrayInput is an input type that accepts LiveEventEndpointArray and LiveEventEndpointArrayOutput values.
// You can construct a concrete instance of `LiveEventEndpointArrayInput` via:
//
//	LiveEventEndpointArray{ LiveEventEndpointArgs{...} }
type LiveEventEndpointArrayInput interface {
	pulumi.Input

	ToLiveEventEndpointArrayOutput() LiveEventEndpointArrayOutput
	ToLiveEventEndpointArrayOutputWithContext(context.Context) LiveEventEndpointArrayOutput
}

type LiveEventEndpointArray []LiveEventEndpointInput

func (LiveEventEndpointArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventEndpoint)(nil)).Elem()
}

func (i LiveEventEndpointArray) ToLiveEventEndpointArrayOutput() LiveEventEndpointArrayOutput {
	return i.ToLiveEventEndpointArrayOutputWithContext(context.Background())
}

func (i LiveEventEndpointArray) ToLiveEventEndpointArrayOutputWithContext(ctx context.Context) LiveEventEndpointArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventEndpointArrayOutput)
}

// The live event endpoint.
type LiveEventEndpointOutput struct{ *pulumi.OutputState }

func (LiveEventEndpointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEndpoint)(nil)).Elem()
}

func (o LiveEventEndpointOutput) ToLiveEventEndpointOutput() LiveEventEndpointOutput {
	return o
}

func (o LiveEventEndpointOutput) ToLiveEventEndpointOutputWithContext(ctx context.Context) LiveEventEndpointOutput {
	return o
}

// The endpoint protocol.
func (o LiveEventEndpointOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEndpoint) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// The endpoint URL.
func (o LiveEventEndpointOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEndpoint) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type LiveEventEndpointArrayOutput struct{ *pulumi.OutputState }

func (LiveEventEndpointArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventEndpoint)(nil)).Elem()
}

func (o LiveEventEndpointArrayOutput) ToLiveEventEndpointArrayOutput() LiveEventEndpointArrayOutput {
	return o
}

func (o LiveEventEndpointArrayOutput) ToLiveEventEndpointArrayOutputWithContext(ctx context.Context) LiveEventEndpointArrayOutput {
	return o
}

func (o LiveEventEndpointArrayOutput) Index(i pulumi.IntInput) LiveEventEndpointOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventEndpoint {
		return vs[0].([]LiveEventEndpoint)[vs[1].(int)]
	}).(LiveEventEndpointOutput)
}

// The live event endpoint.
type LiveEventEndpointResponse struct {
	// The endpoint protocol.
	Protocol *string `pulumi:"protocol"`
	// The endpoint URL.
	Url *string `pulumi:"url"`
}

// The live event endpoint.
type LiveEventEndpointResponseOutput struct{ *pulumi.OutputState }

func (LiveEventEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEndpointResponse)(nil)).Elem()
}

func (o LiveEventEndpointResponseOutput) ToLiveEventEndpointResponseOutput() LiveEventEndpointResponseOutput {
	return o
}

func (o LiveEventEndpointResponseOutput) ToLiveEventEndpointResponseOutputWithContext(ctx context.Context) LiveEventEndpointResponseOutput {
	return o
}

// The endpoint protocol.
func (o LiveEventEndpointResponseOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEndpointResponse) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// The endpoint URL.
func (o LiveEventEndpointResponseOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEndpointResponse) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type LiveEventEndpointResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventEndpointResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventEndpointResponse)(nil)).Elem()
}

func (o LiveEventEndpointResponseArrayOutput) ToLiveEventEndpointResponseArrayOutput() LiveEventEndpointResponseArrayOutput {
	return o
}

func (o LiveEventEndpointResponseArrayOutput) ToLiveEventEndpointResponseArrayOutputWithContext(ctx context.Context) LiveEventEndpointResponseArrayOutput {
	return o
}

func (o LiveEventEndpointResponseArrayOutput) Index(i pulumi.IntInput) LiveEventEndpointResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventEndpointResponse {
		return vs[0].([]LiveEventEndpointResponse)[vs[1].(int)]
	}).(LiveEventEndpointResponseOutput)
}

// The live event ingest interruption data.
type LiveEventIngestInterruptionResponse struct {
	// UTC time of interruption start, encoder disconnected.
	Begin *string `pulumi:"begin"`
	// Duration of interruption in ISO 8601 time. For example, use PT1H30M to indicate 1 hour and 30 minutes.
	Duration *string `pulumi:"duration"`
	// UTC time of interruption end, encoder re-connected.
	End *string `pulumi:"end"`
	// Interruption reason.
	Reason *string `pulumi:"reason"`
}

// The live event ingest interruption data.
type LiveEventIngestInterruptionResponseOutput struct{ *pulumi.OutputState }

func (LiveEventIngestInterruptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventIngestInterruptionResponse)(nil)).Elem()
}

func (o LiveEventIngestInterruptionResponseOutput) ToLiveEventIngestInterruptionResponseOutput() LiveEventIngestInterruptionResponseOutput {
	return o
}

func (o LiveEventIngestInterruptionResponseOutput) ToLiveEventIngestInterruptionResponseOutputWithContext(ctx context.Context) LiveEventIngestInterruptionResponseOutput {
	return o
}

// UTC time of interruption start, encoder disconnected.
func (o LiveEventIngestInterruptionResponseOutput) Begin() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventIngestInterruptionResponse) *string { return v.Begin }).(pulumi.StringPtrOutput)
}

// Duration of interruption in ISO 8601 time. For example, use PT1H30M to indicate 1 hour and 30 minutes.
func (o LiveEventIngestInterruptionResponseOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventIngestInterruptionResponse) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// UTC time of interruption end, encoder re-connected.
func (o LiveEventIngestInterruptionResponseOutput) End() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventIngestInterruptionResponse) *string { return v.End }).(pulumi.StringPtrOutput)
}

// Interruption reason.
func (o LiveEventIngestInterruptionResponseOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventIngestInterruptionResponse) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

type LiveEventIngestInterruptionResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventIngestInterruptionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventIngestInterruptionResponse)(nil)).Elem()
}

func (o LiveEventIngestInterruptionResponseArrayOutput) ToLiveEventIngestInterruptionResponseArrayOutput() LiveEventIngestInterruptionResponseArrayOutput {
	return o
}

func (o LiveEventIngestInterruptionResponseArrayOutput) ToLiveEventIngestInterruptionResponseArrayOutputWithContext(ctx context.Context) LiveEventIngestInterruptionResponseArrayOutput {
	return o
}

func (o LiveEventIngestInterruptionResponseArrayOutput) Index(i pulumi.IntInput) LiveEventIngestInterruptionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventIngestInterruptionResponse {
		return vs[0].([]LiveEventIngestInterruptionResponse)[vs[1].(int)]
	}).(LiveEventIngestInterruptionResponseOutput)
}

// The live event ingestion telemetry data.
type LiveEventIngestionResponse struct {
	// Ingestion begin time in UTC.
	Begin *string `pulumi:"begin"`
	// Ingestion end time in UTC. Empty if it's not stopped yet.
	End *string `pulumi:"end"`
	// Reason why ingestion stops. Empty if it's not stopped yet. E.g) Service Stopped. No Ingestion.
	EndReason *string `pulumi:"endReason"`
	// IngestInterruption entry list.
	IngestInterruptions []LiveEventIngestInterruptionResponse `pulumi:"ingestInterruptions"`
	// Ingestion stream name.
	StreamName *string `pulumi:"streamName"`
}

// The live event ingestion telemetry data.
type LiveEventIngestionResponseOutput struct{ *pulumi.OutputState }

func (LiveEventIngestionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventIngestionResponse)(nil)).Elem()
}

func (o LiveEventIngestionResponseOutput) ToLiveEventIngestionResponseOutput() LiveEventIngestionResponseOutput {
	return o
}

func (o LiveEventIngestionResponseOutput) ToLiveEventIngestionResponseOutputWithContext(ctx context.Context) LiveEventIngestionResponseOutput {
	return o
}

// Ingestion begin time in UTC.
func (o LiveEventIngestionResponseOutput) Begin() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventIngestionResponse) *string { return v.Begin }).(pulumi.StringPtrOutput)
}

// Ingestion end time in UTC. Empty if it's not stopped yet.
func (o LiveEventIngestionResponseOutput) End() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventIngestionResponse) *string { return v.End }).(pulumi.StringPtrOutput)
}

// Reason why ingestion stops. Empty if it's not stopped yet. E.g) Service Stopped. No Ingestion.
func (o LiveEventIngestionResponseOutput) EndReason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventIngestionResponse) *string { return v.EndReason }).(pulumi.StringPtrOutput)
}

// IngestInterruption entry list.
func (o LiveEventIngestionResponseOutput) IngestInterruptions() LiveEventIngestInterruptionResponseArrayOutput {
	return o.ApplyT(func(v LiveEventIngestionResponse) []LiveEventIngestInterruptionResponse { return v.IngestInterruptions }).(LiveEventIngestInterruptionResponseArrayOutput)
}

// Ingestion stream name.
func (o LiveEventIngestionResponseOutput) StreamName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventIngestionResponse) *string { return v.StreamName }).(pulumi.StringPtrOutput)
}

type LiveEventIngestionResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventIngestionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventIngestionResponse)(nil)).Elem()
}

func (o LiveEventIngestionResponsePtrOutput) ToLiveEventIngestionResponsePtrOutput() LiveEventIngestionResponsePtrOutput {
	return o
}

func (o LiveEventIngestionResponsePtrOutput) ToLiveEventIngestionResponsePtrOutputWithContext(ctx context.Context) LiveEventIngestionResponsePtrOutput {
	return o
}

func (o LiveEventIngestionResponsePtrOutput) Elem() LiveEventIngestionResponseOutput {
	return o.ApplyT(func(v *LiveEventIngestionResponse) LiveEventIngestionResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventIngestionResponse
		return ret
	}).(LiveEventIngestionResponseOutput)
}

// Ingestion begin time in UTC.
func (o LiveEventIngestionResponsePtrOutput) Begin() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventIngestionResponse) *string {
		if v == nil {
			return nil
		}
		return v.Begin
	}).(pulumi.StringPtrOutput)
}

// Ingestion end time in UTC. Empty if it's not stopped yet.
func (o LiveEventIngestionResponsePtrOutput) End() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventIngestionResponse) *string {
		if v == nil {
			return nil
		}
		return v.End
	}).(pulumi.StringPtrOutput)
}

// Reason why ingestion stops. Empty if it's not stopped yet. E.g) Service Stopped. No Ingestion.
func (o LiveEventIngestionResponsePtrOutput) EndReason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventIngestionResponse) *string {
		if v == nil {
			return nil
		}
		return v.EndReason
	}).(pulumi.StringPtrOutput)
}

// IngestInterruption entry list.
func (o LiveEventIngestionResponsePtrOutput) IngestInterruptions() LiveEventIngestInterruptionResponseArrayOutput {
	return o.ApplyT(func(v *LiveEventIngestionResponse) []LiveEventIngestInterruptionResponse {
		if v == nil {
			return nil
		}
		return v.IngestInterruptions
	}).(LiveEventIngestInterruptionResponseArrayOutput)
}

// Ingestion stream name.
func (o LiveEventIngestionResponsePtrOutput) StreamName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventIngestionResponse) *string {
		if v == nil {
			return nil
		}
		return v.StreamName
	}).(pulumi.StringPtrOutput)
}

// The live event input.
type LiveEventInputType struct {
	// Access control for live event input.
	AccessControl *LiveEventInputAccessControl `pulumi:"accessControl"`
	// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.
	AccessToken *string `pulumi:"accessToken"`
	// The input endpoints for the live event.
	Endpoints []LiveEventEndpoint `pulumi:"endpoints"`
	// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
	KeyFrameIntervalDuration *string `pulumi:"keyFrameIntervalDuration"`
	// The input protocol for the live event. This is specified at creation time and cannot be updated.
	StreamingProtocol string `pulumi:"streamingProtocol"`
	// The metadata endpoints for the live event.
	TimedMetadataEndpoints []LiveEventTimedMetadataEndpoint `pulumi:"timedMetadataEndpoints"`
}

// LiveEventInputTypeInput is an input type that accepts LiveEventInputTypeArgs and LiveEventInputTypeOutput values.
// You can construct a concrete instance of `LiveEventInputTypeInput` via:
//
//	LiveEventInputTypeArgs{...}
type LiveEventInputTypeInput interface {
	pulumi.Input

	ToLiveEventInputTypeOutput() LiveEventInputTypeOutput
	ToLiveEventInputTypeOutputWithContext(context.Context) LiveEventInputTypeOutput
}

// The live event input.
type LiveEventInputTypeArgs struct {
	// Access control for live event input.
	AccessControl LiveEventInputAccessControlPtrInput `pulumi:"accessControl"`
	// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.
	AccessToken pulumi.StringPtrInput `pulumi:"accessToken"`
	// The input endpoints for the live event.
	Endpoints LiveEventEndpointArrayInput `pulumi:"endpoints"`
	// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
	KeyFrameIntervalDuration pulumi.StringPtrInput `pulumi:"keyFrameIntervalDuration"`
	// The input protocol for the live event. This is specified at creation time and cannot be updated.
	StreamingProtocol pulumi.StringInput `pulumi:"streamingProtocol"`
	// The metadata endpoints for the live event.
	TimedMetadataEndpoints LiveEventTimedMetadataEndpointArrayInput `pulumi:"timedMetadataEndpoints"`
}

func (LiveEventInputTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputType)(nil)).Elem()
}

func (i LiveEventInputTypeArgs) ToLiveEventInputTypeOutput() LiveEventInputTypeOutput {
	return i.ToLiveEventInputTypeOutputWithContext(context.Background())
}

func (i LiveEventInputTypeArgs) ToLiveEventInputTypeOutputWithContext(ctx context.Context) LiveEventInputTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputTypeOutput)
}

// The live event input.
type LiveEventInputTypeOutput struct{ *pulumi.OutputState }

func (LiveEventInputTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputType)(nil)).Elem()
}

func (o LiveEventInputTypeOutput) ToLiveEventInputTypeOutput() LiveEventInputTypeOutput {
	return o
}

func (o LiveEventInputTypeOutput) ToLiveEventInputTypeOutputWithContext(ctx context.Context) LiveEventInputTypeOutput {
	return o
}

// Access control for live event input.
func (o LiveEventInputTypeOutput) AccessControl() LiveEventInputAccessControlPtrOutput {
	return o.ApplyT(func(v LiveEventInputType) *LiveEventInputAccessControl { return v.AccessControl }).(LiveEventInputAccessControlPtrOutput)
}

// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.
func (o LiveEventInputTypeOutput) AccessToken() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputType) *string { return v.AccessToken }).(pulumi.StringPtrOutput)
}

// The input endpoints for the live event.
func (o LiveEventInputTypeOutput) Endpoints() LiveEventEndpointArrayOutput {
	return o.ApplyT(func(v LiveEventInputType) []LiveEventEndpoint { return v.Endpoints }).(LiveEventEndpointArrayOutput)
}

// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
func (o LiveEventInputTypeOutput) KeyFrameIntervalDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputType) *string { return v.KeyFrameIntervalDuration }).(pulumi.StringPtrOutput)
}

// The input protocol for the live event. This is specified at creation time and cannot be updated.
func (o LiveEventInputTypeOutput) StreamingProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v LiveEventInputType) string { return v.StreamingProtocol }).(pulumi.StringOutput)
}

// The metadata endpoints for the live event.
func (o LiveEventInputTypeOutput) TimedMetadataEndpoints() LiveEventTimedMetadataEndpointArrayOutput {
	return o.ApplyT(func(v LiveEventInputType) []LiveEventTimedMetadataEndpoint { return v.TimedMetadataEndpoints }).(LiveEventTimedMetadataEndpointArrayOutput)
}

// The IP access control for live event input.
type LiveEventInputAccessControl struct {
	// The IP access control properties.
	Ip *IPAccessControl `pulumi:"ip"`
}

// LiveEventInputAccessControlInput is an input type that accepts LiveEventInputAccessControlArgs and LiveEventInputAccessControlOutput values.
// You can construct a concrete instance of `LiveEventInputAccessControlInput` via:
//
//	LiveEventInputAccessControlArgs{...}
type LiveEventInputAccessControlInput interface {
	pulumi.Input

	ToLiveEventInputAccessControlOutput() LiveEventInputAccessControlOutput
	ToLiveEventInputAccessControlOutputWithContext(context.Context) LiveEventInputAccessControlOutput
}

// The IP access control for live event input.
type LiveEventInputAccessControlArgs struct {
	// The IP access control properties.
	Ip IPAccessControlPtrInput `pulumi:"ip"`
}

func (LiveEventInputAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputAccessControl)(nil)).Elem()
}

func (i LiveEventInputAccessControlArgs) ToLiveEventInputAccessControlOutput() LiveEventInputAccessControlOutput {
	return i.ToLiveEventInputAccessControlOutputWithContext(context.Background())
}

func (i LiveEventInputAccessControlArgs) ToLiveEventInputAccessControlOutputWithContext(ctx context.Context) LiveEventInputAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputAccessControlOutput)
}

func (i LiveEventInputAccessControlArgs) ToLiveEventInputAccessControlPtrOutput() LiveEventInputAccessControlPtrOutput {
	return i.ToLiveEventInputAccessControlPtrOutputWithContext(context.Background())
}

func (i LiveEventInputAccessControlArgs) ToLiveEventInputAccessControlPtrOutputWithContext(ctx context.Context) LiveEventInputAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputAccessControlOutput).ToLiveEventInputAccessControlPtrOutputWithContext(ctx)
}

// LiveEventInputAccessControlPtrInput is an input type that accepts LiveEventInputAccessControlArgs, LiveEventInputAccessControlPtr and LiveEventInputAccessControlPtrOutput values.
// You can construct a concrete instance of `LiveEventInputAccessControlPtrInput` via:
//
//	        LiveEventInputAccessControlArgs{...}
//
//	or:
//
//	        nil
type LiveEventInputAccessControlPtrInput interface {
	pulumi.Input

	ToLiveEventInputAccessControlPtrOutput() LiveEventInputAccessControlPtrOutput
	ToLiveEventInputAccessControlPtrOutputWithContext(context.Context) LiveEventInputAccessControlPtrOutput
}

type liveEventInputAccessControlPtrType LiveEventInputAccessControlArgs

func LiveEventInputAccessControlPtr(v *LiveEventInputAccessControlArgs) LiveEventInputAccessControlPtrInput {
	return (*liveEventInputAccessControlPtrType)(v)
}

func (*liveEventInputAccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventInputAccessControl)(nil)).Elem()
}

func (i *liveEventInputAccessControlPtrType) ToLiveEventInputAccessControlPtrOutput() LiveEventInputAccessControlPtrOutput {
	return i.ToLiveEventInputAccessControlPtrOutputWithContext(context.Background())
}

func (i *liveEventInputAccessControlPtrType) ToLiveEventInputAccessControlPtrOutputWithContext(ctx context.Context) LiveEventInputAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputAccessControlPtrOutput)
}

// The IP access control for live event input.
type LiveEventInputAccessControlOutput struct{ *pulumi.OutputState }

func (LiveEventInputAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputAccessControl)(nil)).Elem()
}

func (o LiveEventInputAccessControlOutput) ToLiveEventInputAccessControlOutput() LiveEventInputAccessControlOutput {
	return o
}

func (o LiveEventInputAccessControlOutput) ToLiveEventInputAccessControlOutputWithContext(ctx context.Context) LiveEventInputAccessControlOutput {
	return o
}

func (o LiveEventInputAccessControlOutput) ToLiveEventInputAccessControlPtrOutput() LiveEventInputAccessControlPtrOutput {
	return o.ToLiveEventInputAccessControlPtrOutputWithContext(context.Background())
}

func (o LiveEventInputAccessControlOutput) ToLiveEventInputAccessControlPtrOutputWithContext(ctx context.Context) LiveEventInputAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LiveEventInputAccessControl) *LiveEventInputAccessControl {
		return &v
	}).(LiveEventInputAccessControlPtrOutput)
}

// The IP access control properties.
func (o LiveEventInputAccessControlOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v LiveEventInputAccessControl) *IPAccessControl { return v.Ip }).(IPAccessControlPtrOutput)
}

type LiveEventInputAccessControlPtrOutput struct{ *pulumi.OutputState }

func (LiveEventInputAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventInputAccessControl)(nil)).Elem()
}

func (o LiveEventInputAccessControlPtrOutput) ToLiveEventInputAccessControlPtrOutput() LiveEventInputAccessControlPtrOutput {
	return o
}

func (o LiveEventInputAccessControlPtrOutput) ToLiveEventInputAccessControlPtrOutputWithContext(ctx context.Context) LiveEventInputAccessControlPtrOutput {
	return o
}

func (o LiveEventInputAccessControlPtrOutput) Elem() LiveEventInputAccessControlOutput {
	return o.ApplyT(func(v *LiveEventInputAccessControl) LiveEventInputAccessControl {
		if v != nil {
			return *v
		}
		var ret LiveEventInputAccessControl
		return ret
	}).(LiveEventInputAccessControlOutput)
}

// The IP access control properties.
func (o LiveEventInputAccessControlPtrOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v *LiveEventInputAccessControl) *IPAccessControl {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlPtrOutput)
}

// The IP access control for live event input.
type LiveEventInputAccessControlResponse struct {
	// The IP access control properties.
	Ip *IPAccessControlResponse `pulumi:"ip"`
}

// The IP access control for live event input.
type LiveEventInputAccessControlResponseOutput struct{ *pulumi.OutputState }

func (LiveEventInputAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputAccessControlResponse)(nil)).Elem()
}

func (o LiveEventInputAccessControlResponseOutput) ToLiveEventInputAccessControlResponseOutput() LiveEventInputAccessControlResponseOutput {
	return o
}

func (o LiveEventInputAccessControlResponseOutput) ToLiveEventInputAccessControlResponseOutputWithContext(ctx context.Context) LiveEventInputAccessControlResponseOutput {
	return o
}

// The IP access control properties.
func (o LiveEventInputAccessControlResponseOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v LiveEventInputAccessControlResponse) *IPAccessControlResponse { return v.Ip }).(IPAccessControlResponsePtrOutput)
}

type LiveEventInputAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventInputAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventInputAccessControlResponse)(nil)).Elem()
}

func (o LiveEventInputAccessControlResponsePtrOutput) ToLiveEventInputAccessControlResponsePtrOutput() LiveEventInputAccessControlResponsePtrOutput {
	return o
}

func (o LiveEventInputAccessControlResponsePtrOutput) ToLiveEventInputAccessControlResponsePtrOutputWithContext(ctx context.Context) LiveEventInputAccessControlResponsePtrOutput {
	return o
}

func (o LiveEventInputAccessControlResponsePtrOutput) Elem() LiveEventInputAccessControlResponseOutput {
	return o.ApplyT(func(v *LiveEventInputAccessControlResponse) LiveEventInputAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventInputAccessControlResponse
		return ret
	}).(LiveEventInputAccessControlResponseOutput)
}

// The IP access control properties.
func (o LiveEventInputAccessControlResponsePtrOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *LiveEventInputAccessControlResponse) *IPAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlResponsePtrOutput)
}

// The live event input.
type LiveEventInputResponse struct {
	// Access control for live event input.
	AccessControl *LiveEventInputAccessControlResponse `pulumi:"accessControl"`
	// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.
	AccessToken *string `pulumi:"accessToken"`
	// The input endpoints for the live event.
	Endpoints []LiveEventEndpointResponse `pulumi:"endpoints"`
	// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
	KeyFrameIntervalDuration *string `pulumi:"keyFrameIntervalDuration"`
	// The input protocol for the live event. This is specified at creation time and cannot be updated.
	StreamingProtocol string `pulumi:"streamingProtocol"`
	// The metadata endpoints for the live event.
	TimedMetadataEndpoints []LiveEventTimedMetadataEndpointResponse `pulumi:"timedMetadataEndpoints"`
}

// The live event input.
type LiveEventInputResponseOutput struct{ *pulumi.OutputState }

func (LiveEventInputResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputResponse)(nil)).Elem()
}

func (o LiveEventInputResponseOutput) ToLiveEventInputResponseOutput() LiveEventInputResponseOutput {
	return o
}

func (o LiveEventInputResponseOutput) ToLiveEventInputResponseOutputWithContext(ctx context.Context) LiveEventInputResponseOutput {
	return o
}

// Access control for live event input.
func (o LiveEventInputResponseOutput) AccessControl() LiveEventInputAccessControlResponsePtrOutput {
	return o.ApplyT(func(v LiveEventInputResponse) *LiveEventInputAccessControlResponse { return v.AccessControl }).(LiveEventInputAccessControlResponsePtrOutput)
}

// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.
func (o LiveEventInputResponseOutput) AccessToken() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputResponse) *string { return v.AccessToken }).(pulumi.StringPtrOutput)
}

// The input endpoints for the live event.
func (o LiveEventInputResponseOutput) Endpoints() LiveEventEndpointResponseArrayOutput {
	return o.ApplyT(func(v LiveEventInputResponse) []LiveEventEndpointResponse { return v.Endpoints }).(LiveEventEndpointResponseArrayOutput)
}

// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
func (o LiveEventInputResponseOutput) KeyFrameIntervalDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputResponse) *string { return v.KeyFrameIntervalDuration }).(pulumi.StringPtrOutput)
}

// The input protocol for the live event. This is specified at creation time and cannot be updated.
func (o LiveEventInputResponseOutput) StreamingProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v LiveEventInputResponse) string { return v.StreamingProtocol }).(pulumi.StringOutput)
}

// The metadata endpoints for the live event.
func (o LiveEventInputResponseOutput) TimedMetadataEndpoints() LiveEventTimedMetadataEndpointResponseArrayOutput {
	return o.ApplyT(func(v LiveEventInputResponse) []LiveEventTimedMetadataEndpointResponse {
		return v.TimedMetadataEndpoints
	}).(LiveEventTimedMetadataEndpointResponseArrayOutput)
}

// A track selection condition. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventInputTrackSelection struct {
	// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
	Operation *string `pulumi:"operation"`
	// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
	Property *string `pulumi:"property"`
	// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
	Value *string `pulumi:"value"`
}

// LiveEventInputTrackSelectionInput is an input type that accepts LiveEventInputTrackSelectionArgs and LiveEventInputTrackSelectionOutput values.
// You can construct a concrete instance of `LiveEventInputTrackSelectionInput` via:
//
//	LiveEventInputTrackSelectionArgs{...}
type LiveEventInputTrackSelectionInput interface {
	pulumi.Input

	ToLiveEventInputTrackSelectionOutput() LiveEventInputTrackSelectionOutput
	ToLiveEventInputTrackSelectionOutputWithContext(context.Context) LiveEventInputTrackSelectionOutput
}

// A track selection condition. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventInputTrackSelectionArgs struct {
	// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
	Operation pulumi.StringPtrInput `pulumi:"operation"`
	// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
	Property pulumi.StringPtrInput `pulumi:"property"`
	// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (LiveEventInputTrackSelectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputTrackSelection)(nil)).Elem()
}

func (i LiveEventInputTrackSelectionArgs) ToLiveEventInputTrackSelectionOutput() LiveEventInputTrackSelectionOutput {
	return i.ToLiveEventInputTrackSelectionOutputWithContext(context.Background())
}

func (i LiveEventInputTrackSelectionArgs) ToLiveEventInputTrackSelectionOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputTrackSelectionOutput)
}

// LiveEventInputTrackSelectionArrayInput is an input type that accepts LiveEventInputTrackSelectionArray and LiveEventInputTrackSelectionArrayOutput values.
// You can construct a concrete instance of `LiveEventInputTrackSelectionArrayInput` via:
//
//	LiveEventInputTrackSelectionArray{ LiveEventInputTrackSelectionArgs{...} }
type LiveEventInputTrackSelectionArrayInput interface {
	pulumi.Input

	ToLiveEventInputTrackSelectionArrayOutput() LiveEventInputTrackSelectionArrayOutput
	ToLiveEventInputTrackSelectionArrayOutputWithContext(context.Context) LiveEventInputTrackSelectionArrayOutput
}

type LiveEventInputTrackSelectionArray []LiveEventInputTrackSelectionInput

func (LiveEventInputTrackSelectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventInputTrackSelection)(nil)).Elem()
}

func (i LiveEventInputTrackSelectionArray) ToLiveEventInputTrackSelectionArrayOutput() LiveEventInputTrackSelectionArrayOutput {
	return i.ToLiveEventInputTrackSelectionArrayOutputWithContext(context.Background())
}

func (i LiveEventInputTrackSelectionArray) ToLiveEventInputTrackSelectionArrayOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputTrackSelectionArrayOutput)
}

// A track selection condition. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventInputTrackSelectionOutput struct{ *pulumi.OutputState }

func (LiveEventInputTrackSelectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputTrackSelection)(nil)).Elem()
}

func (o LiveEventInputTrackSelectionOutput) ToLiveEventInputTrackSelectionOutput() LiveEventInputTrackSelectionOutput {
	return o
}

func (o LiveEventInputTrackSelectionOutput) ToLiveEventInputTrackSelectionOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionOutput {
	return o
}

// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionOutput) Operation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelection) *string { return v.Operation }).(pulumi.StringPtrOutput)
}

// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionOutput) Property() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelection) *string { return v.Property }).(pulumi.StringPtrOutput)
}

// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelection) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type LiveEventInputTrackSelectionArrayOutput struct{ *pulumi.OutputState }

func (LiveEventInputTrackSelectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventInputTrackSelection)(nil)).Elem()
}

func (o LiveEventInputTrackSelectionArrayOutput) ToLiveEventInputTrackSelectionArrayOutput() LiveEventInputTrackSelectionArrayOutput {
	return o
}

func (o LiveEventInputTrackSelectionArrayOutput) ToLiveEventInputTrackSelectionArrayOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionArrayOutput {
	return o
}

func (o LiveEventInputTrackSelectionArrayOutput) Index(i pulumi.IntInput) LiveEventInputTrackSelectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventInputTrackSelection {
		return vs[0].([]LiveEventInputTrackSelection)[vs[1].(int)]
	}).(LiveEventInputTrackSelectionOutput)
}

// A track selection condition. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventInputTrackSelectionResponse struct {
	// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
	Operation *string `pulumi:"operation"`
	// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
	Property *string `pulumi:"property"`
	// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
	Value *string `pulumi:"value"`
}

// A track selection condition. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventInputTrackSelectionResponseOutput struct{ *pulumi.OutputState }

func (LiveEventInputTrackSelectionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputTrackSelectionResponse)(nil)).Elem()
}

func (o LiveEventInputTrackSelectionResponseOutput) ToLiveEventInputTrackSelectionResponseOutput() LiveEventInputTrackSelectionResponseOutput {
	return o
}

func (o LiveEventInputTrackSelectionResponseOutput) ToLiveEventInputTrackSelectionResponseOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionResponseOutput {
	return o
}

// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionResponseOutput) Operation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelectionResponse) *string { return v.Operation }).(pulumi.StringPtrOutput)
}

// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionResponseOutput) Property() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelectionResponse) *string { return v.Property }).(pulumi.StringPtrOutput)
}

// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionResponseOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelectionResponse) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type LiveEventInputTrackSelectionResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventInputTrackSelectionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventInputTrackSelectionResponse)(nil)).Elem()
}

func (o LiveEventInputTrackSelectionResponseArrayOutput) ToLiveEventInputTrackSelectionResponseArrayOutput() LiveEventInputTrackSelectionResponseArrayOutput {
	return o
}

func (o LiveEventInputTrackSelectionResponseArrayOutput) ToLiveEventInputTrackSelectionResponseArrayOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionResponseArrayOutput {
	return o
}

func (o LiveEventInputTrackSelectionResponseArrayOutput) Index(i pulumi.IntInput) LiveEventInputTrackSelectionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventInputTrackSelectionResponse {
		return vs[0].([]LiveEventInputTrackSelectionResponse)[vs[1].(int)]
	}).(LiveEventInputTrackSelectionResponseOutput)
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrack struct {
	// The output track name. This property is reserved for future use, any value set on this property will be ignored.
	TrackName string `pulumi:"trackName"`
}

// LiveEventOutputTranscriptionTrackInput is an input type that accepts LiveEventOutputTranscriptionTrackArgs and LiveEventOutputTranscriptionTrackOutput values.
// You can construct a concrete instance of `LiveEventOutputTranscriptionTrackInput` via:
//
//	LiveEventOutputTranscriptionTrackArgs{...}
type LiveEventOutputTranscriptionTrackInput interface {
	pulumi.Input

	ToLiveEventOutputTranscriptionTrackOutput() LiveEventOutputTranscriptionTrackOutput
	ToLiveEventOutputTranscriptionTrackOutputWithContext(context.Context) LiveEventOutputTranscriptionTrackOutput
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrackArgs struct {
	// The output track name. This property is reserved for future use, any value set on this property will be ignored.
	TrackName pulumi.StringInput `pulumi:"trackName"`
}

func (LiveEventOutputTranscriptionTrackArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventOutputTranscriptionTrack)(nil)).Elem()
}

func (i LiveEventOutputTranscriptionTrackArgs) ToLiveEventOutputTranscriptionTrackOutput() LiveEventOutputTranscriptionTrackOutput {
	return i.ToLiveEventOutputTranscriptionTrackOutputWithContext(context.Background())
}

func (i LiveEventOutputTranscriptionTrackArgs) ToLiveEventOutputTranscriptionTrackOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventOutputTranscriptionTrackOutput)
}

func (i LiveEventOutputTranscriptionTrackArgs) ToLiveEventOutputTranscriptionTrackPtrOutput() LiveEventOutputTranscriptionTrackPtrOutput {
	return i.ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(context.Background())
}

func (i LiveEventOutputTranscriptionTrackArgs) ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventOutputTranscriptionTrackOutput).ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(ctx)
}

// LiveEventOutputTranscriptionTrackPtrInput is an input type that accepts LiveEventOutputTranscriptionTrackArgs, LiveEventOutputTranscriptionTrackPtr and LiveEventOutputTranscriptionTrackPtrOutput values.
// You can construct a concrete instance of `LiveEventOutputTranscriptionTrackPtrInput` via:
//
//	        LiveEventOutputTranscriptionTrackArgs{...}
//
//	or:
//
//	        nil
type LiveEventOutputTranscriptionTrackPtrInput interface {
	pulumi.Input

	ToLiveEventOutputTranscriptionTrackPtrOutput() LiveEventOutputTranscriptionTrackPtrOutput
	ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(context.Context) LiveEventOutputTranscriptionTrackPtrOutput
}

type liveEventOutputTranscriptionTrackPtrType LiveEventOutputTranscriptionTrackArgs

func LiveEventOutputTranscriptionTrackPtr(v *LiveEventOutputTranscriptionTrackArgs) LiveEventOutputTranscriptionTrackPtrInput {
	return (*liveEventOutputTranscriptionTrackPtrType)(v)
}

func (*liveEventOutputTranscriptionTrackPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventOutputTranscriptionTrack)(nil)).Elem()
}

func (i *liveEventOutputTranscriptionTrackPtrType) ToLiveEventOutputTranscriptionTrackPtrOutput() LiveEventOutputTranscriptionTrackPtrOutput {
	return i.ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(context.Background())
}

func (i *liveEventOutputTranscriptionTrackPtrType) ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventOutputTranscriptionTrackPtrOutput)
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrackOutput struct{ *pulumi.OutputState }

func (LiveEventOutputTranscriptionTrackOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventOutputTranscriptionTrack)(nil)).Elem()
}

func (o LiveEventOutputTranscriptionTrackOutput) ToLiveEventOutputTranscriptionTrackOutput() LiveEventOutputTranscriptionTrackOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackOutput) ToLiveEventOutputTranscriptionTrackOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackOutput) ToLiveEventOutputTranscriptionTrackPtrOutput() LiveEventOutputTranscriptionTrackPtrOutput {
	return o.ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(context.Background())
}

func (o LiveEventOutputTranscriptionTrackOutput) ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LiveEventOutputTranscriptionTrack) *LiveEventOutputTranscriptionTrack {
		return &v
	}).(LiveEventOutputTranscriptionTrackPtrOutput)
}

// The output track name. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventOutputTranscriptionTrackOutput) TrackName() pulumi.StringOutput {
	return o.ApplyT(func(v LiveEventOutputTranscriptionTrack) string { return v.TrackName }).(pulumi.StringOutput)
}

type LiveEventOutputTranscriptionTrackPtrOutput struct{ *pulumi.OutputState }

func (LiveEventOutputTranscriptionTrackPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventOutputTranscriptionTrack)(nil)).Elem()
}

func (o LiveEventOutputTranscriptionTrackPtrOutput) ToLiveEventOutputTranscriptionTrackPtrOutput() LiveEventOutputTranscriptionTrackPtrOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackPtrOutput) ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackPtrOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackPtrOutput) Elem() LiveEventOutputTranscriptionTrackOutput {
	return o.ApplyT(func(v *LiveEventOutputTranscriptionTrack) LiveEventOutputTranscriptionTrack {
		if v != nil {
			return *v
		}
		var ret LiveEventOutputTranscriptionTrack
		return ret
	}).(LiveEventOutputTranscriptionTrackOutput)
}

// The output track name. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventOutputTranscriptionTrackPtrOutput) TrackName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventOutputTranscriptionTrack) *string {
		if v == nil {
			return nil
		}
		return &v.TrackName
	}).(pulumi.StringPtrOutput)
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrackResponse struct {
	// The output track name. This property is reserved for future use, any value set on this property will be ignored.
	TrackName string `pulumi:"trackName"`
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrackResponseOutput struct{ *pulumi.OutputState }

func (LiveEventOutputTranscriptionTrackResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventOutputTranscriptionTrackResponse)(nil)).Elem()
}

func (o LiveEventOutputTranscriptionTrackResponseOutput) ToLiveEventOutputTranscriptionTrackResponseOutput() LiveEventOutputTranscriptionTrackResponseOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackResponseOutput) ToLiveEventOutputTranscriptionTrackResponseOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackResponseOutput {
	return o
}

// The output track name. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventOutputTranscriptionTrackResponseOutput) TrackName() pulumi.StringOutput {
	return o.ApplyT(func(v LiveEventOutputTranscriptionTrackResponse) string { return v.TrackName }).(pulumi.StringOutput)
}

type LiveEventOutputTranscriptionTrackResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventOutputTranscriptionTrackResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventOutputTranscriptionTrackResponse)(nil)).Elem()
}

func (o LiveEventOutputTranscriptionTrackResponsePtrOutput) ToLiveEventOutputTranscriptionTrackResponsePtrOutput() LiveEventOutputTranscriptionTrackResponsePtrOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackResponsePtrOutput) ToLiveEventOutputTranscriptionTrackResponsePtrOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackResponsePtrOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackResponsePtrOutput) Elem() LiveEventOutputTranscriptionTrackResponseOutput {
	return o.ApplyT(func(v *LiveEventOutputTranscriptionTrackResponse) LiveEventOutputTranscriptionTrackResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventOutputTranscriptionTrackResponse
		return ret
	}).(LiveEventOutputTranscriptionTrackResponseOutput)
}

// The output track name. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventOutputTranscriptionTrackResponsePtrOutput) TrackName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventOutputTranscriptionTrackResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TrackName
	}).(pulumi.StringPtrOutput)
}

// Live event preview settings.
type LiveEventPreview struct {
	// The access control for live event preview.
	AccessControl *LiveEventPreviewAccessControl `pulumi:"accessControl"`
	// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
	AlternativeMediaId *string `pulumi:"alternativeMediaId"`
	// The endpoints for preview. Do not share the preview URL with the live event audience.
	Endpoints []LiveEventEndpoint `pulumi:"endpoints"`
	// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
	PreviewLocator *string `pulumi:"previewLocator"`
	// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
	StreamingPolicyName *string `pulumi:"streamingPolicyName"`
}

// LiveEventPreviewInput is an input type that accepts LiveEventPreviewArgs and LiveEventPreviewOutput values.
// You can construct a concrete instance of `LiveEventPreviewInput` via:
//
//	LiveEventPreviewArgs{...}
type LiveEventPreviewInput interface {
	pulumi.Input

	ToLiveEventPreviewOutput() LiveEventPreviewOutput
	ToLiveEventPreviewOutputWithContext(context.Context) LiveEventPreviewOutput
}

// Live event preview settings.
type LiveEventPreviewArgs struct {
	// The access control for live event preview.
	AccessControl LiveEventPreviewAccessControlPtrInput `pulumi:"accessControl"`
	// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
	AlternativeMediaId pulumi.StringPtrInput `pulumi:"alternativeMediaId"`
	// The endpoints for preview. Do not share the preview URL with the live event audience.
	Endpoints LiveEventEndpointArrayInput `pulumi:"endpoints"`
	// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
	PreviewLocator pulumi.StringPtrInput `pulumi:"previewLocator"`
	// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
	StreamingPolicyName pulumi.StringPtrInput `pulumi:"streamingPolicyName"`
}

func (LiveEventPreviewArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreview)(nil)).Elem()
}

func (i LiveEventPreviewArgs) ToLiveEventPreviewOutput() LiveEventPreviewOutput {
	return i.ToLiveEventPreviewOutputWithContext(context.Background())
}

func (i LiveEventPreviewArgs) ToLiveEventPreviewOutputWithContext(ctx context.Context) LiveEventPreviewOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewOutput)
}

func (i LiveEventPreviewArgs) ToLiveEventPreviewPtrOutput() LiveEventPreviewPtrOutput {
	return i.ToLiveEventPreviewPtrOutputWithContext(context.Background())
}

func (i LiveEventPreviewArgs) ToLiveEventPreviewPtrOutputWithContext(ctx context.Context) LiveEventPreviewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewOutput).ToLiveEventPreviewPtrOutputWithContext(ctx)
}

// LiveEventPreviewPtrInput is an input type that accepts LiveEventPreviewArgs, LiveEventPreviewPtr and LiveEventPreviewPtrOutput values.
// You can construct a concrete instance of `LiveEventPreviewPtrInput` via:
//
//	        LiveEventPreviewArgs{...}
//
//	or:
//
//	        nil
type LiveEventPreviewPtrInput interface {
	pulumi.Input

	ToLiveEventPreviewPtrOutput() LiveEventPreviewPtrOutput
	ToLiveEventPreviewPtrOutputWithContext(context.Context) LiveEventPreviewPtrOutput
}

type liveEventPreviewPtrType LiveEventPreviewArgs

func LiveEventPreviewPtr(v *LiveEventPreviewArgs) LiveEventPreviewPtrInput {
	return (*liveEventPreviewPtrType)(v)
}

func (*liveEventPreviewPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreview)(nil)).Elem()
}

func (i *liveEventPreviewPtrType) ToLiveEventPreviewPtrOutput() LiveEventPreviewPtrOutput {
	return i.ToLiveEventPreviewPtrOutputWithContext(context.Background())
}

func (i *liveEventPreviewPtrType) ToLiveEventPreviewPtrOutputWithContext(ctx context.Context) LiveEventPreviewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewPtrOutput)
}

// Live event preview settings.
type LiveEventPreviewOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreview)(nil)).Elem()
}

func (o LiveEventPreviewOutput) ToLiveEventPreviewOutput() LiveEventPreviewOutput {
	return o
}

func (o LiveEventPreviewOutput) ToLiveEventPreviewOutputWithContext(ctx context.Context) LiveEventPreviewOutput {
	return o
}

func (o LiveEventPreviewOutput) ToLiveEventPreviewPtrOutput() LiveEventPreviewPtrOutput {
	return o.ToLiveEventPreviewPtrOutputWithContext(context.Background())
}

func (o LiveEventPreviewOutput) ToLiveEventPreviewPtrOutputWithContext(ctx context.Context) LiveEventPreviewPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LiveEventPreview) *LiveEventPreview {
		return &v
	}).(LiveEventPreviewPtrOutput)
}

// The access control for live event preview.
func (o LiveEventPreviewOutput) AccessControl() LiveEventPreviewAccessControlPtrOutput {
	return o.ApplyT(func(v LiveEventPreview) *LiveEventPreviewAccessControl { return v.AccessControl }).(LiveEventPreviewAccessControlPtrOutput)
}

// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
func (o LiveEventPreviewOutput) AlternativeMediaId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreview) *string { return v.AlternativeMediaId }).(pulumi.StringPtrOutput)
}

// The endpoints for preview. Do not share the preview URL with the live event audience.
func (o LiveEventPreviewOutput) Endpoints() LiveEventEndpointArrayOutput {
	return o.ApplyT(func(v LiveEventPreview) []LiveEventEndpoint { return v.Endpoints }).(LiveEventEndpointArrayOutput)
}

// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
func (o LiveEventPreviewOutput) PreviewLocator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreview) *string { return v.PreviewLocator }).(pulumi.StringPtrOutput)
}

// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
func (o LiveEventPreviewOutput) StreamingPolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreview) *string { return v.StreamingPolicyName }).(pulumi.StringPtrOutput)
}

type LiveEventPreviewPtrOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreview)(nil)).Elem()
}

func (o LiveEventPreviewPtrOutput) ToLiveEventPreviewPtrOutput() LiveEventPreviewPtrOutput {
	return o
}

func (o LiveEventPreviewPtrOutput) ToLiveEventPreviewPtrOutputWithContext(ctx context.Context) LiveEventPreviewPtrOutput {
	return o
}

func (o LiveEventPreviewPtrOutput) Elem() LiveEventPreviewOutput {
	return o.ApplyT(func(v *LiveEventPreview) LiveEventPreview {
		if v != nil {
			return *v
		}
		var ret LiveEventPreview
		return ret
	}).(LiveEventPreviewOutput)
}

// The access control for live event preview.
func (o LiveEventPreviewPtrOutput) AccessControl() LiveEventPreviewAccessControlPtrOutput {
	return o.ApplyT(func(v *LiveEventPreview) *LiveEventPreviewAccessControl {
		if v == nil {
			return nil
		}
		return v.AccessControl
	}).(LiveEventPreviewAccessControlPtrOutput)
}

// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
func (o LiveEventPreviewPtrOutput) AlternativeMediaId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreview) *string {
		if v == nil {
			return nil
		}
		return v.AlternativeMediaId
	}).(pulumi.StringPtrOutput)
}

// The endpoints for preview. Do not share the preview URL with the live event audience.
func (o LiveEventPreviewPtrOutput) Endpoints() LiveEventEndpointArrayOutput {
	return o.ApplyT(func(v *LiveEventPreview) []LiveEventEndpoint {
		if v == nil {
			return nil
		}
		return v.Endpoints
	}).(LiveEventEndpointArrayOutput)
}

// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
func (o LiveEventPreviewPtrOutput) PreviewLocator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreview) *string {
		if v == nil {
			return nil
		}
		return v.PreviewLocator
	}).(pulumi.StringPtrOutput)
}

// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
func (o LiveEventPreviewPtrOutput) StreamingPolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreview) *string {
		if v == nil {
			return nil
		}
		return v.StreamingPolicyName
	}).(pulumi.StringPtrOutput)
}

// The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControl struct {
	// The IP access control properties.
	Ip *IPAccessControl `pulumi:"ip"`
}

// LiveEventPreviewAccessControlInput is an input type that accepts LiveEventPreviewAccessControlArgs and LiveEventPreviewAccessControlOutput values.
// You can construct a concrete instance of `LiveEventPreviewAccessControlInput` via:
//
//	LiveEventPreviewAccessControlArgs{...}
type LiveEventPreviewAccessControlInput interface {
	pulumi.Input

	ToLiveEventPreviewAccessControlOutput() LiveEventPreviewAccessControlOutput
	ToLiveEventPreviewAccessControlOutputWithContext(context.Context) LiveEventPreviewAccessControlOutput
}

// The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControlArgs struct {
	// The IP access control properties.
	Ip IPAccessControlPtrInput `pulumi:"ip"`
}

func (LiveEventPreviewAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreviewAccessControl)(nil)).Elem()
}

func (i LiveEventPreviewAccessControlArgs) ToLiveEventPreviewAccessControlOutput() LiveEventPreviewAccessControlOutput {
	return i.ToLiveEventPreviewAccessControlOutputWithContext(context.Background())
}

func (i LiveEventPreviewAccessControlArgs) ToLiveEventPreviewAccessControlOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewAccessControlOutput)
}

func (i LiveEventPreviewAccessControlArgs) ToLiveEventPreviewAccessControlPtrOutput() LiveEventPreviewAccessControlPtrOutput {
	return i.ToLiveEventPreviewAccessControlPtrOutputWithContext(context.Background())
}

func (i LiveEventPreviewAccessControlArgs) ToLiveEventPreviewAccessControlPtrOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewAccessControlOutput).ToLiveEventPreviewAccessControlPtrOutputWithContext(ctx)
}

// LiveEventPreviewAccessControlPtrInput is an input type that accepts LiveEventPreviewAccessControlArgs, LiveEventPreviewAccessControlPtr and LiveEventPreviewAccessControlPtrOutput values.
// You can construct a concrete instance of `LiveEventPreviewAccessControlPtrInput` via:
//
//	        LiveEventPreviewAccessControlArgs{...}
//
//	or:
//
//	        nil
type LiveEventPreviewAccessControlPtrInput interface {
	pulumi.Input

	ToLiveEventPreviewAccessControlPtrOutput() LiveEventPreviewAccessControlPtrOutput
	ToLiveEventPreviewAccessControlPtrOutputWithContext(context.Context) LiveEventPreviewAccessControlPtrOutput
}

type liveEventPreviewAccessControlPtrType LiveEventPreviewAccessControlArgs

func LiveEventPreviewAccessControlPtr(v *LiveEventPreviewAccessControlArgs) LiveEventPreviewAccessControlPtrInput {
	return (*liveEventPreviewAccessControlPtrType)(v)
}

func (*liveEventPreviewAccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreviewAccessControl)(nil)).Elem()
}

func (i *liveEventPreviewAccessControlPtrType) ToLiveEventPreviewAccessControlPtrOutput() LiveEventPreviewAccessControlPtrOutput {
	return i.ToLiveEventPreviewAccessControlPtrOutputWithContext(context.Background())
}

func (i *liveEventPreviewAccessControlPtrType) ToLiveEventPreviewAccessControlPtrOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewAccessControlPtrOutput)
}

// The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControlOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreviewAccessControl)(nil)).Elem()
}

func (o LiveEventPreviewAccessControlOutput) ToLiveEventPreviewAccessControlOutput() LiveEventPreviewAccessControlOutput {
	return o
}

func (o LiveEventPreviewAccessControlOutput) ToLiveEventPreviewAccessControlOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlOutput {
	return o
}

func (o LiveEventPreviewAccessControlOutput) ToLiveEventPreviewAccessControlPtrOutput() LiveEventPreviewAccessControlPtrOutput {
	return o.ToLiveEventPreviewAccessControlPtrOutputWithContext(context.Background())
}

func (o LiveEventPreviewAccessControlOutput) ToLiveEventPreviewAccessControlPtrOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LiveEventPreviewAccessControl) *LiveEventPreviewAccessControl {
		return &v
	}).(LiveEventPreviewAccessControlPtrOutput)
}

// The IP access control properties.
func (o LiveEventPreviewAccessControlOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v LiveEventPreviewAccessControl) *IPAccessControl { return v.Ip }).(IPAccessControlPtrOutput)
}

type LiveEventPreviewAccessControlPtrOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreviewAccessControl)(nil)).Elem()
}

func (o LiveEventPreviewAccessControlPtrOutput) ToLiveEventPreviewAccessControlPtrOutput() LiveEventPreviewAccessControlPtrOutput {
	return o
}

func (o LiveEventPreviewAccessControlPtrOutput) ToLiveEventPreviewAccessControlPtrOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlPtrOutput {
	return o
}

func (o LiveEventPreviewAccessControlPtrOutput) Elem() LiveEventPreviewAccessControlOutput {
	return o.ApplyT(func(v *LiveEventPreviewAccessControl) LiveEventPreviewAccessControl {
		if v != nil {
			return *v
		}
		var ret LiveEventPreviewAccessControl
		return ret
	}).(LiveEventPreviewAccessControlOutput)
}

// The IP access control properties.
func (o LiveEventPreviewAccessControlPtrOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewAccessControl) *IPAccessControl {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlPtrOutput)
}

// The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControlResponse struct {
	// The IP access control properties.
	Ip *IPAccessControlResponse `pulumi:"ip"`
}

// The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControlResponseOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreviewAccessControlResponse)(nil)).Elem()
}

func (o LiveEventPreviewAccessControlResponseOutput) ToLiveEventPreviewAccessControlResponseOutput() LiveEventPreviewAccessControlResponseOutput {
	return o
}

func (o LiveEventPreviewAccessControlResponseOutput) ToLiveEventPreviewAccessControlResponseOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlResponseOutput {
	return o
}

// The IP access control properties.
func (o LiveEventPreviewAccessControlResponseOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v LiveEventPreviewAccessControlResponse) *IPAccessControlResponse { return v.Ip }).(IPAccessControlResponsePtrOutput)
}

type LiveEventPreviewAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreviewAccessControlResponse)(nil)).Elem()
}

func (o LiveEventPreviewAccessControlResponsePtrOutput) ToLiveEventPreviewAccessControlResponsePtrOutput() LiveEventPreviewAccessControlResponsePtrOutput {
	return o
}

func (o LiveEventPreviewAccessControlResponsePtrOutput) ToLiveEventPreviewAccessControlResponsePtrOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlResponsePtrOutput {
	return o
}

func (o LiveEventPreviewAccessControlResponsePtrOutput) Elem() LiveEventPreviewAccessControlResponseOutput {
	return o.ApplyT(func(v *LiveEventPreviewAccessControlResponse) LiveEventPreviewAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventPreviewAccessControlResponse
		return ret
	}).(LiveEventPreviewAccessControlResponseOutput)
}

// The IP access control properties.
func (o LiveEventPreviewAccessControlResponsePtrOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewAccessControlResponse) *IPAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlResponsePtrOutput)
}

// Live event preview settings.
type LiveEventPreviewResponse struct {
	// The access control for live event preview.
	AccessControl *LiveEventPreviewAccessControlResponse `pulumi:"accessControl"`
	// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
	AlternativeMediaId *string `pulumi:"alternativeMediaId"`
	// The endpoints for preview. Do not share the preview URL with the live event audience.
	Endpoints []LiveEventEndpointResponse `pulumi:"endpoints"`
	// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
	PreviewLocator *string `pulumi:"previewLocator"`
	// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
	StreamingPolicyName *string `pulumi:"streamingPolicyName"`
}

// Live event preview settings.
type LiveEventPreviewResponseOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreviewResponse)(nil)).Elem()
}

func (o LiveEventPreviewResponseOutput) ToLiveEventPreviewResponseOutput() LiveEventPreviewResponseOutput {
	return o
}

func (o LiveEventPreviewResponseOutput) ToLiveEventPreviewResponseOutputWithContext(ctx context.Context) LiveEventPreviewResponseOutput {
	return o
}

// The access control for live event preview.
func (o LiveEventPreviewResponseOutput) AccessControl() LiveEventPreviewAccessControlResponsePtrOutput {
	return o.ApplyT(func(v LiveEventPreviewResponse) *LiveEventPreviewAccessControlResponse { return v.AccessControl }).(LiveEventPreviewAccessControlResponsePtrOutput)
}

// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
func (o LiveEventPreviewResponseOutput) AlternativeMediaId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreviewResponse) *string { return v.AlternativeMediaId }).(pulumi.StringPtrOutput)
}

// The endpoints for preview. Do not share the preview URL with the live event audience.
func (o LiveEventPreviewResponseOutput) Endpoints() LiveEventEndpointResponseArrayOutput {
	return o.ApplyT(func(v LiveEventPreviewResponse) []LiveEventEndpointResponse { return v.Endpoints }).(LiveEventEndpointResponseArrayOutput)
}

// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
func (o LiveEventPreviewResponseOutput) PreviewLocator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreviewResponse) *string { return v.PreviewLocator }).(pulumi.StringPtrOutput)
}

// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
func (o LiveEventPreviewResponseOutput) StreamingPolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreviewResponse) *string { return v.StreamingPolicyName }).(pulumi.StringPtrOutput)
}

type LiveEventPreviewResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreviewResponse)(nil)).Elem()
}

func (o LiveEventPreviewResponsePtrOutput) ToLiveEventPreviewResponsePtrOutput() LiveEventPreviewResponsePtrOutput {
	return o
}

func (o LiveEventPreviewResponsePtrOutput) ToLiveEventPreviewResponsePtrOutputWithContext(ctx context.Context) LiveEventPreviewResponsePtrOutput {
	return o
}

func (o LiveEventPreviewResponsePtrOutput) Elem() LiveEventPreviewResponseOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) LiveEventPreviewResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventPreviewResponse
		return ret
	}).(LiveEventPreviewResponseOutput)
}

// The access control for live event preview.
func (o LiveEventPreviewResponsePtrOutput) AccessControl() LiveEventPreviewAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) *LiveEventPreviewAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.AccessControl
	}).(LiveEventPreviewAccessControlResponsePtrOutput)
}

// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
func (o LiveEventPreviewResponsePtrOutput) AlternativeMediaId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) *string {
		if v == nil {
			return nil
		}
		return v.AlternativeMediaId
	}).(pulumi.StringPtrOutput)
}

// The endpoints for preview. Do not share the preview URL with the live event audience.
func (o LiveEventPreviewResponsePtrOutput) Endpoints() LiveEventEndpointResponseArrayOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) []LiveEventEndpointResponse {
		if v == nil {
			return nil
		}
		return v.Endpoints
	}).(LiveEventEndpointResponseArrayOutput)
}

// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
func (o LiveEventPreviewResponsePtrOutput) PreviewLocator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) *string {
		if v == nil {
			return nil
		}
		return v.PreviewLocator
	}).(pulumi.StringPtrOutput)
}

// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
func (o LiveEventPreviewResponsePtrOutput) StreamingPolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) *string {
		if v == nil {
			return nil
		}
		return v.StreamingPolicyName
	}).(pulumi.StringPtrOutput)
}

// The live event status.
type LiveEventStatusResponse struct {
	// List of strings justifying the health status.
	HealthDescriptions []string `pulumi:"healthDescriptions"`
	// Health status of last 20 seconds.
	HealthStatus *string `pulumi:"healthStatus"`
	// Live event ingestion entry.
	Ingestion *LiveEventIngestionResponse `pulumi:"ingestion"`
	// Last updated UTC time of this status.
	LastUpdatedTime *string `pulumi:"lastUpdatedTime"`
	// Current state of the live event. See https://go.microsoft.com/fwlink/?linkid=2139012 for more information.
	State *string `pulumi:"state"`
	// Track entry list.
	TrackStatus []LiveEventTrackStatusResponse `pulumi:"trackStatus"`
}

// The live event status.
type LiveEventStatusResponseOutput struct{ *pulumi.OutputState }

func (LiveEventStatusResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventStatusResponse)(nil)).Elem()
}

func (o LiveEventStatusResponseOutput) ToLiveEventStatusResponseOutput() LiveEventStatusResponseOutput {
	return o
}

func (o LiveEventStatusResponseOutput) ToLiveEventStatusResponseOutputWithContext(ctx context.Context) LiveEventStatusResponseOutput {
	return o
}

// List of strings justifying the health status.
func (o LiveEventStatusResponseOutput) HealthDescriptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LiveEventStatusResponse) []string { return v.HealthDescriptions }).(pulumi.StringArrayOutput)
}

// Health status of last 20 seconds.
func (o LiveEventStatusResponseOutput) HealthStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStatusResponse) *string { return v.HealthStatus }).(pulumi.StringPtrOutput)
}

// Live event ingestion entry.
func (o LiveEventStatusResponseOutput) Ingestion() LiveEventIngestionResponsePtrOutput {
	return o.ApplyT(func(v LiveEventStatusResponse) *LiveEventIngestionResponse { return v.Ingestion }).(LiveEventIngestionResponsePtrOutput)
}

// Last updated UTC time of this status.
func (o LiveEventStatusResponseOutput) LastUpdatedTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStatusResponse) *string { return v.LastUpdatedTime }).(pulumi.StringPtrOutput)
}

// Current state of the live event. See https://go.microsoft.com/fwlink/?linkid=2139012 for more information.
func (o LiveEventStatusResponseOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStatusResponse) *string { return v.State }).(pulumi.StringPtrOutput)
}

// Track entry list.
func (o LiveEventStatusResponseOutput) TrackStatus() LiveEventTrackStatusResponseArrayOutput {
	return o.ApplyT(func(v LiveEventStatusResponse) []LiveEventTrackStatusResponse { return v.TrackStatus }).(LiveEventTrackStatusResponseArrayOutput)
}

type LiveEventStatusResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventStatusResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventStatusResponse)(nil)).Elem()
}

func (o LiveEventStatusResponseArrayOutput) ToLiveEventStatusResponseArrayOutput() LiveEventStatusResponseArrayOutput {
	return o
}

func (o LiveEventStatusResponseArrayOutput) ToLiveEventStatusResponseArrayOutputWithContext(ctx context.Context) LiveEventStatusResponseArrayOutput {
	return o
}

func (o LiveEventStatusResponseArrayOutput) Index(i pulumi.IntInput) LiveEventStatusResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventStatusResponse {
		return vs[0].([]LiveEventStatusResponse)[vs[1].(int)]
	}).(LiveEventStatusResponseOutput)
}

// The live event stream event data.
type LiveEventStreamEventDataResponse struct {
	// Bitrate of the track.
	Bitrate *float64 `pulumi:"bitrate"`
	// Current fragment timestamp in timescale.
	CurrentFragmentTimestamp *string `pulumi:"currentFragmentTimestamp"`
	// Length of the discontinuity gap in timescale.
	DiscontinuityGap *float64 `pulumi:"discontinuityGap"`
	// Fragment duration.
	Duration *string `pulumi:"duration"`
	// Reason the fragment was dropped.
	FragmentDropReason *string `pulumi:"fragmentDropReason"`
	// Duration of first fragment used to make a comparison, in timescale.
	FragmentOneDuration *string `pulumi:"fragmentOneDuration"`
	// Timestamp of first fragment used to make a comparison, in timescale.
	FragmentOneTimestamp *string `pulumi:"fragmentOneTimestamp"`
	// Duration of second fragment used to make a comparison, in timescale.
	FragmentTwoDuration *string `pulumi:"fragmentTwoDuration"`
	// Timestamp of second fragment used to make a comparison, in timescale.
	FragmentTwoTimestamp *string `pulumi:"fragmentTwoTimestamp"`
	// The larger timestamp of the two fragments compared.
	MaxTime *string `pulumi:"maxTime"`
	// The media type of the larger timestamp of two fragments compared.
	MaxTimeMediaType *string `pulumi:"maxTimeMediaType"`
	// Fragment timestamp in timescale.
	MediaTimestamp *string `pulumi:"mediaTimestamp"`
	// Type of the track.
	MediaType *string `pulumi:"mediaType"`
	// The smaller timestamp of the two fragments compared.
	MinTime *string `pulumi:"minTime"`
	// The media type of the smaller timestamp of two fragments compared.
	MinTimeMediaType *string `pulumi:"minTimeMediaType"`
	// Previous fragment duration in timescale.
	PreviousFragmentDuration *string `pulumi:"previousFragmentDuration"`
	// Previous fragment timestamp in timescale.
	PreviousFragmentTimestamp *string `pulumi:"previousFragmentTimestamp"`
	// Truncated IP of the encoder.
	RemoteIp *string `pulumi:"remoteIp"`
	// Port of the encoder.
	RemotePort *string `pulumi:"remotePort"`
	// Width x Height for video, null otherwise.
	Resolution *string `pulumi:"resolution"`
	// Result code.
	ResultCode *string `pulumi:"resultCode"`
	// Result message.
	ResultMessage *string `pulumi:"resultMessage"`
	// Stream ID in the format "trackName_bitrate"
	StreamId *string `pulumi:"streamId"`
	// Identifier of the stream or connection. Encoder or customer is responsible to add this ID in the ingest URL.
	StreamName *string `pulumi:"streamName"`
	// Timescale in which timestamps are expressed.
	Timescale *string `pulumi:"timescale"`
	// Timescale of the fragment with the larger timestamp.
	TimescaleOfMaxTime *string `pulumi:"timescaleOfMaxTime"`
	// Timescale of the fragment with the smaller timestamp.
	TimescaleOfMinTime *string `pulumi:"timescaleOfMinTime"`
	// Track index.
	TrackId *int `pulumi:"trackId"`
	// Name of the track.
	TrackName *string `pulumi:"trackName"`
}

// The live event stream event data.
type LiveEventStreamEventDataResponseOutput struct{ *pulumi.OutputState }

func (LiveEventStreamEventDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventStreamEventDataResponse)(nil)).Elem()
}

func (o LiveEventStreamEventDataResponseOutput) ToLiveEventStreamEventDataResponseOutput() LiveEventStreamEventDataResponseOutput {
	return o
}

func (o LiveEventStreamEventDataResponseOutput) ToLiveEventStreamEventDataResponseOutputWithContext(ctx context.Context) LiveEventStreamEventDataResponseOutput {
	return o
}

// Bitrate of the track.
func (o LiveEventStreamEventDataResponseOutput) Bitrate() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *float64 { return v.Bitrate }).(pulumi.Float64PtrOutput)
}

// Current fragment timestamp in timescale.
func (o LiveEventStreamEventDataResponseOutput) CurrentFragmentTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.CurrentFragmentTimestamp }).(pulumi.StringPtrOutput)
}

// Length of the discontinuity gap in timescale.
func (o LiveEventStreamEventDataResponseOutput) DiscontinuityGap() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *float64 { return v.DiscontinuityGap }).(pulumi.Float64PtrOutput)
}

// Fragment duration.
func (o LiveEventStreamEventDataResponseOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// Reason the fragment was dropped.
func (o LiveEventStreamEventDataResponseOutput) FragmentDropReason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.FragmentDropReason }).(pulumi.StringPtrOutput)
}

// Duration of first fragment used to make a comparison, in timescale.
func (o LiveEventStreamEventDataResponseOutput) FragmentOneDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.FragmentOneDuration }).(pulumi.StringPtrOutput)
}

// Timestamp of first fragment used to make a comparison, in timescale.
func (o LiveEventStreamEventDataResponseOutput) FragmentOneTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.FragmentOneTimestamp }).(pulumi.StringPtrOutput)
}

// Duration of second fragment used to make a comparison, in timescale.
func (o LiveEventStreamEventDataResponseOutput) FragmentTwoDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.FragmentTwoDuration }).(pulumi.StringPtrOutput)
}

// Timestamp of second fragment used to make a comparison, in timescale.
func (o LiveEventStreamEventDataResponseOutput) FragmentTwoTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.FragmentTwoTimestamp }).(pulumi.StringPtrOutput)
}

// The larger timestamp of the two fragments compared.
func (o LiveEventStreamEventDataResponseOutput) MaxTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.MaxTime }).(pulumi.StringPtrOutput)
}

// The media type of the larger timestamp of two fragments compared.
func (o LiveEventStreamEventDataResponseOutput) MaxTimeMediaType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.MaxTimeMediaType }).(pulumi.StringPtrOutput)
}

// Fragment timestamp in timescale.
func (o LiveEventStreamEventDataResponseOutput) MediaTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.MediaTimestamp }).(pulumi.StringPtrOutput)
}

// Type of the track.
func (o LiveEventStreamEventDataResponseOutput) MediaType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.MediaType }).(pulumi.StringPtrOutput)
}

// The smaller timestamp of the two fragments compared.
func (o LiveEventStreamEventDataResponseOutput) MinTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.MinTime }).(pulumi.StringPtrOutput)
}

// The media type of the smaller timestamp of two fragments compared.
func (o LiveEventStreamEventDataResponseOutput) MinTimeMediaType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.MinTimeMediaType }).(pulumi.StringPtrOutput)
}

// Previous fragment duration in timescale.
func (o LiveEventStreamEventDataResponseOutput) PreviousFragmentDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.PreviousFragmentDuration }).(pulumi.StringPtrOutput)
}

// Previous fragment timestamp in timescale.
func (o LiveEventStreamEventDataResponseOutput) PreviousFragmentTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.PreviousFragmentTimestamp }).(pulumi.StringPtrOutput)
}

// Truncated IP of the encoder.
func (o LiveEventStreamEventDataResponseOutput) RemoteIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.RemoteIp }).(pulumi.StringPtrOutput)
}

// Port of the encoder.
func (o LiveEventStreamEventDataResponseOutput) RemotePort() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.RemotePort }).(pulumi.StringPtrOutput)
}

// Width x Height for video, null otherwise.
func (o LiveEventStreamEventDataResponseOutput) Resolution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.Resolution }).(pulumi.StringPtrOutput)
}

// Result code.
func (o LiveEventStreamEventDataResponseOutput) ResultCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.ResultCode }).(pulumi.StringPtrOutput)
}

// Result message.
func (o LiveEventStreamEventDataResponseOutput) ResultMessage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.ResultMessage }).(pulumi.StringPtrOutput)
}

// Stream ID in the format "trackName_bitrate"
func (o LiveEventStreamEventDataResponseOutput) StreamId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.StreamId }).(pulumi.StringPtrOutput)
}

// Identifier of the stream or connection. Encoder or customer is responsible to add this ID in the ingest URL.
func (o LiveEventStreamEventDataResponseOutput) StreamName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.StreamName }).(pulumi.StringPtrOutput)
}

// Timescale in which timestamps are expressed.
func (o LiveEventStreamEventDataResponseOutput) Timescale() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.Timescale }).(pulumi.StringPtrOutput)
}

// Timescale of the fragment with the larger timestamp.
func (o LiveEventStreamEventDataResponseOutput) TimescaleOfMaxTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.TimescaleOfMaxTime }).(pulumi.StringPtrOutput)
}

// Timescale of the fragment with the smaller timestamp.
func (o LiveEventStreamEventDataResponseOutput) TimescaleOfMinTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.TimescaleOfMinTime }).(pulumi.StringPtrOutput)
}

// Track index.
func (o LiveEventStreamEventDataResponseOutput) TrackId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *int { return v.TrackId }).(pulumi.IntPtrOutput)
}

// Name of the track.
func (o LiveEventStreamEventDataResponseOutput) TrackName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventDataResponse) *string { return v.TrackName }).(pulumi.StringPtrOutput)
}

type LiveEventStreamEventDataResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventStreamEventDataResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventStreamEventDataResponse)(nil)).Elem()
}

func (o LiveEventStreamEventDataResponsePtrOutput) ToLiveEventStreamEventDataResponsePtrOutput() LiveEventStreamEventDataResponsePtrOutput {
	return o
}

func (o LiveEventStreamEventDataResponsePtrOutput) ToLiveEventStreamEventDataResponsePtrOutputWithContext(ctx context.Context) LiveEventStreamEventDataResponsePtrOutput {
	return o
}

func (o LiveEventStreamEventDataResponsePtrOutput) Elem() LiveEventStreamEventDataResponseOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) LiveEventStreamEventDataResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventStreamEventDataResponse
		return ret
	}).(LiveEventStreamEventDataResponseOutput)
}

// Bitrate of the track.
func (o LiveEventStreamEventDataResponsePtrOutput) Bitrate() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.Bitrate
	}).(pulumi.Float64PtrOutput)
}

// Current fragment timestamp in timescale.
func (o LiveEventStreamEventDataResponsePtrOutput) CurrentFragmentTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.CurrentFragmentTimestamp
	}).(pulumi.StringPtrOutput)
}

// Length of the discontinuity gap in timescale.
func (o LiveEventStreamEventDataResponsePtrOutput) DiscontinuityGap() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.DiscontinuityGap
	}).(pulumi.Float64PtrOutput)
}

// Fragment duration.
func (o LiveEventStreamEventDataResponsePtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// Reason the fragment was dropped.
func (o LiveEventStreamEventDataResponsePtrOutput) FragmentDropReason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.FragmentDropReason
	}).(pulumi.StringPtrOutput)
}

// Duration of first fragment used to make a comparison, in timescale.
func (o LiveEventStreamEventDataResponsePtrOutput) FragmentOneDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.FragmentOneDuration
	}).(pulumi.StringPtrOutput)
}

// Timestamp of first fragment used to make a comparison, in timescale.
func (o LiveEventStreamEventDataResponsePtrOutput) FragmentOneTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.FragmentOneTimestamp
	}).(pulumi.StringPtrOutput)
}

// Duration of second fragment used to make a comparison, in timescale.
func (o LiveEventStreamEventDataResponsePtrOutput) FragmentTwoDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.FragmentTwoDuration
	}).(pulumi.StringPtrOutput)
}

// Timestamp of second fragment used to make a comparison, in timescale.
func (o LiveEventStreamEventDataResponsePtrOutput) FragmentTwoTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.FragmentTwoTimestamp
	}).(pulumi.StringPtrOutput)
}

// The larger timestamp of the two fragments compared.
func (o LiveEventStreamEventDataResponsePtrOutput) MaxTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.MaxTime
	}).(pulumi.StringPtrOutput)
}

// The media type of the larger timestamp of two fragments compared.
func (o LiveEventStreamEventDataResponsePtrOutput) MaxTimeMediaType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.MaxTimeMediaType
	}).(pulumi.StringPtrOutput)
}

// Fragment timestamp in timescale.
func (o LiveEventStreamEventDataResponsePtrOutput) MediaTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.MediaTimestamp
	}).(pulumi.StringPtrOutput)
}

// Type of the track.
func (o LiveEventStreamEventDataResponsePtrOutput) MediaType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.MediaType
	}).(pulumi.StringPtrOutput)
}

// The smaller timestamp of the two fragments compared.
func (o LiveEventStreamEventDataResponsePtrOutput) MinTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.MinTime
	}).(pulumi.StringPtrOutput)
}

// The media type of the smaller timestamp of two fragments compared.
func (o LiveEventStreamEventDataResponsePtrOutput) MinTimeMediaType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.MinTimeMediaType
	}).(pulumi.StringPtrOutput)
}

// Previous fragment duration in timescale.
func (o LiveEventStreamEventDataResponsePtrOutput) PreviousFragmentDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.PreviousFragmentDuration
	}).(pulumi.StringPtrOutput)
}

// Previous fragment timestamp in timescale.
func (o LiveEventStreamEventDataResponsePtrOutput) PreviousFragmentTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.PreviousFragmentTimestamp
	}).(pulumi.StringPtrOutput)
}

// Truncated IP of the encoder.
func (o LiveEventStreamEventDataResponsePtrOutput) RemoteIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.RemoteIp
	}).(pulumi.StringPtrOutput)
}

// Port of the encoder.
func (o LiveEventStreamEventDataResponsePtrOutput) RemotePort() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.RemotePort
	}).(pulumi.StringPtrOutput)
}

// Width x Height for video, null otherwise.
func (o LiveEventStreamEventDataResponsePtrOutput) Resolution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.Resolution
	}).(pulumi.StringPtrOutput)
}

// Result code.
func (o LiveEventStreamEventDataResponsePtrOutput) ResultCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.ResultCode
	}).(pulumi.StringPtrOutput)
}

// Result message.
func (o LiveEventStreamEventDataResponsePtrOutput) ResultMessage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.ResultMessage
	}).(pulumi.StringPtrOutput)
}

// Stream ID in the format "trackName_bitrate"
func (o LiveEventStreamEventDataResponsePtrOutput) StreamId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.StreamId
	}).(pulumi.StringPtrOutput)
}

// Identifier of the stream or connection. Encoder or customer is responsible to add this ID in the ingest URL.
func (o LiveEventStreamEventDataResponsePtrOutput) StreamName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.StreamName
	}).(pulumi.StringPtrOutput)
}

// Timescale in which timestamps are expressed.
func (o LiveEventStreamEventDataResponsePtrOutput) Timescale() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.Timescale
	}).(pulumi.StringPtrOutput)
}

// Timescale of the fragment with the larger timestamp.
func (o LiveEventStreamEventDataResponsePtrOutput) TimescaleOfMaxTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.TimescaleOfMaxTime
	}).(pulumi.StringPtrOutput)
}

// Timescale of the fragment with the smaller timestamp.
func (o LiveEventStreamEventDataResponsePtrOutput) TimescaleOfMinTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.TimescaleOfMinTime
	}).(pulumi.StringPtrOutput)
}

// Track index.
func (o LiveEventStreamEventDataResponsePtrOutput) TrackId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *int {
		if v == nil {
			return nil
		}
		return v.TrackId
	}).(pulumi.IntPtrOutput)
}

// Name of the track.
func (o LiveEventStreamEventDataResponsePtrOutput) TrackName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventStreamEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.TrackName
	}).(pulumi.StringPtrOutput)
}

// The live event stream event.
type LiveEventStreamEventResponse struct {
	// Event data based on event type.
	Data *LiveEventStreamEventDataResponse `pulumi:"data"`
	// Event level.
	EventLevel *string `pulumi:"eventLevel"`
	// The time event raised.
	EventTime *string `pulumi:"eventTime"`
	// The type of the stream event. Format: StreamEvent/{eventType}
	EventType *string `pulumi:"eventType"`
}

// The live event stream event.
type LiveEventStreamEventResponseOutput struct{ *pulumi.OutputState }

func (LiveEventStreamEventResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventStreamEventResponse)(nil)).Elem()
}

func (o LiveEventStreamEventResponseOutput) ToLiveEventStreamEventResponseOutput() LiveEventStreamEventResponseOutput {
	return o
}

func (o LiveEventStreamEventResponseOutput) ToLiveEventStreamEventResponseOutputWithContext(ctx context.Context) LiveEventStreamEventResponseOutput {
	return o
}

// Event data based on event type.
func (o LiveEventStreamEventResponseOutput) Data() LiveEventStreamEventDataResponsePtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventResponse) *LiveEventStreamEventDataResponse { return v.Data }).(LiveEventStreamEventDataResponsePtrOutput)
}

// Event level.
func (o LiveEventStreamEventResponseOutput) EventLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventResponse) *string { return v.EventLevel }).(pulumi.StringPtrOutput)
}

// The time event raised.
func (o LiveEventStreamEventResponseOutput) EventTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventResponse) *string { return v.EventTime }).(pulumi.StringPtrOutput)
}

// The type of the stream event. Format: StreamEvent/{eventType}
func (o LiveEventStreamEventResponseOutput) EventType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventStreamEventResponse) *string { return v.EventType }).(pulumi.StringPtrOutput)
}

type LiveEventStreamEventResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventStreamEventResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventStreamEventResponse)(nil)).Elem()
}

func (o LiveEventStreamEventResponseArrayOutput) ToLiveEventStreamEventResponseArrayOutput() LiveEventStreamEventResponseArrayOutput {
	return o
}

func (o LiveEventStreamEventResponseArrayOutput) ToLiveEventStreamEventResponseArrayOutputWithContext(ctx context.Context) LiveEventStreamEventResponseArrayOutput {
	return o
}

func (o LiveEventStreamEventResponseArrayOutput) Index(i pulumi.IntInput) LiveEventStreamEventResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventStreamEventResponse {
		return vs[0].([]LiveEventStreamEventResponse)[vs[1].(int)]
	}).(LiveEventStreamEventResponseOutput)
}

// The live event metadata insertion endpoint.
type LiveEventTimedMetadataEndpoint struct {
	// The metadata endpoint URL.
	Url *string `pulumi:"url"`
}

// LiveEventTimedMetadataEndpointInput is an input type that accepts LiveEventTimedMetadataEndpointArgs and LiveEventTimedMetadataEndpointOutput values.
// You can construct a concrete instance of `LiveEventTimedMetadataEndpointInput` via:
//
//	LiveEventTimedMetadataEndpointArgs{...}
type LiveEventTimedMetadataEndpointInput interface {
	pulumi.Input

	ToLiveEventTimedMetadataEndpointOutput() LiveEventTimedMetadataEndpointOutput
	ToLiveEventTimedMetadataEndpointOutputWithContext(context.Context) LiveEventTimedMetadataEndpointOutput
}

// The live event metadata insertion endpoint.
type LiveEventTimedMetadataEndpointArgs struct {
	// The metadata endpoint URL.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (LiveEventTimedMetadataEndpointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTimedMetadataEndpoint)(nil)).Elem()
}

func (i LiveEventTimedMetadataEndpointArgs) ToLiveEventTimedMetadataEndpointOutput() LiveEventTimedMetadataEndpointOutput {
	return i.ToLiveEventTimedMetadataEndpointOutputWithContext(context.Background())
}

func (i LiveEventTimedMetadataEndpointArgs) ToLiveEventTimedMetadataEndpointOutputWithContext(ctx context.Context) LiveEventTimedMetadataEndpointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventTimedMetadataEndpointOutput)
}

// LiveEventTimedMetadataEndpointArrayInput is an input type that accepts LiveEventTimedMetadataEndpointArray and LiveEventTimedMetadataEndpointArrayOutput values.
// You can construct a concrete instance of `LiveEventTimedMetadataEndpointArrayInput` via:
//
//	LiveEventTimedMetadataEndpointArray{ LiveEventTimedMetadataEndpointArgs{...} }
type LiveEventTimedMetadataEndpointArrayInput interface {
	pulumi.Input

	ToLiveEventTimedMetadataEndpointArrayOutput() LiveEventTimedMetadataEndpointArrayOutput
	ToLiveEventTimedMetadataEndpointArrayOutputWithContext(context.Context) LiveEventTimedMetadataEndpointArrayOutput
}

type LiveEventTimedMetadataEndpointArray []LiveEventTimedMetadataEndpointInput

func (LiveEventTimedMetadataEndpointArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventTimedMetadataEndpoint)(nil)).Elem()
}

func (i LiveEventTimedMetadataEndpointArray) ToLiveEventTimedMetadataEndpointArrayOutput() LiveEventTimedMetadataEndpointArrayOutput {
	return i.ToLiveEventTimedMetadataEndpointArrayOutputWithContext(context.Background())
}

func (i LiveEventTimedMetadataEndpointArray) ToLiveEventTimedMetadataEndpointArrayOutputWithContext(ctx context.Context) LiveEventTimedMetadataEndpointArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventTimedMetadataEndpointArrayOutput)
}

// The live event metadata insertion endpoint.
type LiveEventTimedMetadataEndpointOutput struct{ *pulumi.OutputState }

func (LiveEventTimedMetadataEndpointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTimedMetadataEndpoint)(nil)).Elem()
}

func (o LiveEventTimedMetadataEndpointOutput) ToLiveEventTimedMetadataEndpointOutput() LiveEventTimedMetadataEndpointOutput {
	return o
}

func (o LiveEventTimedMetadataEndpointOutput) ToLiveEventTimedMetadataEndpointOutputWithContext(ctx context.Context) LiveEventTimedMetadataEndpointOutput {
	return o
}

// The metadata endpoint URL.
func (o LiveEventTimedMetadataEndpointOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTimedMetadataEndpoint) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type LiveEventTimedMetadataEndpointArrayOutput struct{ *pulumi.OutputState }

func (LiveEventTimedMetadataEndpointArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventTimedMetadataEndpoint)(nil)).Elem()
}

func (o LiveEventTimedMetadataEndpointArrayOutput) ToLiveEventTimedMetadataEndpointArrayOutput() LiveEventTimedMetadataEndpointArrayOutput {
	return o
}

func (o LiveEventTimedMetadataEndpointArrayOutput) ToLiveEventTimedMetadataEndpointArrayOutputWithContext(ctx context.Context) LiveEventTimedMetadataEndpointArrayOutput {
	return o
}

func (o LiveEventTimedMetadataEndpointArrayOutput) Index(i pulumi.IntInput) LiveEventTimedMetadataEndpointOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventTimedMetadataEndpoint {
		return vs[0].([]LiveEventTimedMetadataEndpoint)[vs[1].(int)]
	}).(LiveEventTimedMetadataEndpointOutput)
}

// The live event metadata insertion endpoint.
type LiveEventTimedMetadataEndpointResponse struct {
	// The metadata endpoint URL.
	Url *string `pulumi:"url"`
}

// The live event metadata insertion endpoint.
type LiveEventTimedMetadataEndpointResponseOutput struct{ *pulumi.OutputState }

func (LiveEventTimedMetadataEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTimedMetadataEndpointResponse)(nil)).Elem()
}

func (o LiveEventTimedMetadataEndpointResponseOutput) ToLiveEventTimedMetadataEndpointResponseOutput() LiveEventTimedMetadataEndpointResponseOutput {
	return o
}

func (o LiveEventTimedMetadataEndpointResponseOutput) ToLiveEventTimedMetadataEndpointResponseOutputWithContext(ctx context.Context) LiveEventTimedMetadataEndpointResponseOutput {
	return o
}

// The metadata endpoint URL.
func (o LiveEventTimedMetadataEndpointResponseOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTimedMetadataEndpointResponse) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type LiveEventTimedMetadataEndpointResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventTimedMetadataEndpointResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventTimedMetadataEndpointResponse)(nil)).Elem()
}

func (o LiveEventTimedMetadataEndpointResponseArrayOutput) ToLiveEventTimedMetadataEndpointResponseArrayOutput() LiveEventTimedMetadataEndpointResponseArrayOutput {
	return o
}

func (o LiveEventTimedMetadataEndpointResponseArrayOutput) ToLiveEventTimedMetadataEndpointResponseArrayOutputWithContext(ctx context.Context) LiveEventTimedMetadataEndpointResponseArrayOutput {
	return o
}

func (o LiveEventTimedMetadataEndpointResponseArrayOutput) Index(i pulumi.IntInput) LiveEventTimedMetadataEndpointResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventTimedMetadataEndpointResponse {
		return vs[0].([]LiveEventTimedMetadataEndpointResponse)[vs[1].(int)]
	}).(LiveEventTimedMetadataEndpointResponseOutput)
}

// The live event track ingest heart beat event data.
type LiveEventTrackEventDataResponse struct {
	// Bitrate of the track.
	Bitrate *float64 `pulumi:"bitrate"`
	// Number of discontinuities detected in the last 20 seconds.
	DiscontinuityCount *float64 `pulumi:"discontinuityCount"`
	// Indicates whether ingest is healthy.
	Healthy *bool `pulumi:"healthy"`
	// Calculated bitrate based on data chunks coming from encoder.
	IncomingBitrate *float64 `pulumi:"incomingBitrate"`
	// Indicates the speed of delay, in seconds-per-minute, of the incoming audio or video data during the last minute. The value is greater than zero if data is arriving to the live event slower than expected in the last minute; zero if data arrived with no delay; and "n/a" if no audio or video data was received. For example, if you have a contribution encoder sending in live content, and it is slowing down due to processing issues, or network latency, it may be only able to deliver a total of 58 seconds of audio or video in a one-minute period. This would be reported as two seconds-per-minute of drift. If the encoder is able to catch up and send all 60 seconds or more of data every minute, you will see this value reported as 0. If there was a disconnection or discontinuity from the encoder, this value may still display as 0, as it does not account for breaks in the data - only data that is delayed in timestamps.
	IngestDriftValue *string `pulumi:"ingestDriftValue"`
	// The last timestamp in UTC that a fragment arrived at the ingest endpoint.
	LastFragmentArrivalTime *string `pulumi:"lastFragmentArrivalTime"`
	// Latest timestamp received for a track in last 20 seconds.
	LastTimestamp *string `pulumi:"lastTimestamp"`
	// Number of data chunks with timestamps in the past that were received in last 20 seconds.
	NonincreasingCount *float64 `pulumi:"nonincreasingCount"`
	// Number of data chunks that had overlapped timestamps in last 20 seconds.
	OverlapCount *float64 `pulumi:"overlapCount"`
	// State of the live event.
	State *string `pulumi:"state"`
	// Timescale in which timestamps are expressed.
	Timescale *string `pulumi:"timescale"`
	// Name of the track.
	TrackName *string `pulumi:"trackName"`
	// Type of the track.
	TrackType *string `pulumi:"trackType"`
	// The language code (in BCP-47 format) of the transcription language. For example, "de-de" indicates German (Germany). The value is empty for the video track heartbeats, or when live transcription is turned off.
	TranscriptionLanguage *string `pulumi:"transcriptionLanguage"`
	// This value is "On" for audio track heartbeats if live transcription is turned on, otherwise you will see an empty string. This state is only applicable to track type of "audio" for Live transcription. All other tracks will have an empty value.
	TranscriptionState *string `pulumi:"transcriptionState"`
	// If expected and actual bitrates differ by more than allowed limit in last 20 seconds.
	UnexpectedBitrate *bool `pulumi:"unexpectedBitrate"`
}

// The live event track ingest heart beat event data.
type LiveEventTrackEventDataResponseOutput struct{ *pulumi.OutputState }

func (LiveEventTrackEventDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTrackEventDataResponse)(nil)).Elem()
}

func (o LiveEventTrackEventDataResponseOutput) ToLiveEventTrackEventDataResponseOutput() LiveEventTrackEventDataResponseOutput {
	return o
}

func (o LiveEventTrackEventDataResponseOutput) ToLiveEventTrackEventDataResponseOutputWithContext(ctx context.Context) LiveEventTrackEventDataResponseOutput {
	return o
}

// Bitrate of the track.
func (o LiveEventTrackEventDataResponseOutput) Bitrate() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *float64 { return v.Bitrate }).(pulumi.Float64PtrOutput)
}

// Number of discontinuities detected in the last 20 seconds.
func (o LiveEventTrackEventDataResponseOutput) DiscontinuityCount() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *float64 { return v.DiscontinuityCount }).(pulumi.Float64PtrOutput)
}

// Indicates whether ingest is healthy.
func (o LiveEventTrackEventDataResponseOutput) Healthy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *bool { return v.Healthy }).(pulumi.BoolPtrOutput)
}

// Calculated bitrate based on data chunks coming from encoder.
func (o LiveEventTrackEventDataResponseOutput) IncomingBitrate() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *float64 { return v.IncomingBitrate }).(pulumi.Float64PtrOutput)
}

// Indicates the speed of delay, in seconds-per-minute, of the incoming audio or video data during the last minute. The value is greater than zero if data is arriving to the live event slower than expected in the last minute; zero if data arrived with no delay; and "n/a" if no audio or video data was received. For example, if you have a contribution encoder sending in live content, and it is slowing down due to processing issues, or network latency, it may be only able to deliver a total of 58 seconds of audio or video in a one-minute period. This would be reported as two seconds-per-minute of drift. If the encoder is able to catch up and send all 60 seconds or more of data every minute, you will see this value reported as 0. If there was a disconnection or discontinuity from the encoder, this value may still display as 0, as it does not account for breaks in the data - only data that is delayed in timestamps.
func (o LiveEventTrackEventDataResponseOutput) IngestDriftValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *string { return v.IngestDriftValue }).(pulumi.StringPtrOutput)
}

// The last timestamp in UTC that a fragment arrived at the ingest endpoint.
func (o LiveEventTrackEventDataResponseOutput) LastFragmentArrivalTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *string { return v.LastFragmentArrivalTime }).(pulumi.StringPtrOutput)
}

// Latest timestamp received for a track in last 20 seconds.
func (o LiveEventTrackEventDataResponseOutput) LastTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *string { return v.LastTimestamp }).(pulumi.StringPtrOutput)
}

// Number of data chunks with timestamps in the past that were received in last 20 seconds.
func (o LiveEventTrackEventDataResponseOutput) NonincreasingCount() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *float64 { return v.NonincreasingCount }).(pulumi.Float64PtrOutput)
}

// Number of data chunks that had overlapped timestamps in last 20 seconds.
func (o LiveEventTrackEventDataResponseOutput) OverlapCount() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *float64 { return v.OverlapCount }).(pulumi.Float64PtrOutput)
}

// State of the live event.
func (o LiveEventTrackEventDataResponseOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *string { return v.State }).(pulumi.StringPtrOutput)
}

// Timescale in which timestamps are expressed.
func (o LiveEventTrackEventDataResponseOutput) Timescale() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *string { return v.Timescale }).(pulumi.StringPtrOutput)
}

// Name of the track.
func (o LiveEventTrackEventDataResponseOutput) TrackName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *string { return v.TrackName }).(pulumi.StringPtrOutput)
}

// Type of the track.
func (o LiveEventTrackEventDataResponseOutput) TrackType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *string { return v.TrackType }).(pulumi.StringPtrOutput)
}

// The language code (in BCP-47 format) of the transcription language. For example, "de-de" indicates German (Germany). The value is empty for the video track heartbeats, or when live transcription is turned off.
func (o LiveEventTrackEventDataResponseOutput) TranscriptionLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *string { return v.TranscriptionLanguage }).(pulumi.StringPtrOutput)
}

// This value is "On" for audio track heartbeats if live transcription is turned on, otherwise you will see an empty string. This state is only applicable to track type of "audio" for Live transcription. All other tracks will have an empty value.
func (o LiveEventTrackEventDataResponseOutput) TranscriptionState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *string { return v.TranscriptionState }).(pulumi.StringPtrOutput)
}

// If expected and actual bitrates differ by more than allowed limit in last 20 seconds.
func (o LiveEventTrackEventDataResponseOutput) UnexpectedBitrate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventDataResponse) *bool { return v.UnexpectedBitrate }).(pulumi.BoolPtrOutput)
}

type LiveEventTrackEventDataResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventTrackEventDataResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventTrackEventDataResponse)(nil)).Elem()
}

func (o LiveEventTrackEventDataResponsePtrOutput) ToLiveEventTrackEventDataResponsePtrOutput() LiveEventTrackEventDataResponsePtrOutput {
	return o
}

func (o LiveEventTrackEventDataResponsePtrOutput) ToLiveEventTrackEventDataResponsePtrOutputWithContext(ctx context.Context) LiveEventTrackEventDataResponsePtrOutput {
	return o
}

func (o LiveEventTrackEventDataResponsePtrOutput) Elem() LiveEventTrackEventDataResponseOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) LiveEventTrackEventDataResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventTrackEventDataResponse
		return ret
	}).(LiveEventTrackEventDataResponseOutput)
}

// Bitrate of the track.
func (o LiveEventTrackEventDataResponsePtrOutput) Bitrate() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.Bitrate
	}).(pulumi.Float64PtrOutput)
}

// Number of discontinuities detected in the last 20 seconds.
func (o LiveEventTrackEventDataResponsePtrOutput) DiscontinuityCount() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.DiscontinuityCount
	}).(pulumi.Float64PtrOutput)
}

// Indicates whether ingest is healthy.
func (o LiveEventTrackEventDataResponsePtrOutput) Healthy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *bool {
		if v == nil {
			return nil
		}
		return v.Healthy
	}).(pulumi.BoolPtrOutput)
}

// Calculated bitrate based on data chunks coming from encoder.
func (o LiveEventTrackEventDataResponsePtrOutput) IncomingBitrate() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.IncomingBitrate
	}).(pulumi.Float64PtrOutput)
}

// Indicates the speed of delay, in seconds-per-minute, of the incoming audio or video data during the last minute. The value is greater than zero if data is arriving to the live event slower than expected in the last minute; zero if data arrived with no delay; and "n/a" if no audio or video data was received. For example, if you have a contribution encoder sending in live content, and it is slowing down due to processing issues, or network latency, it may be only able to deliver a total of 58 seconds of audio or video in a one-minute period. This would be reported as two seconds-per-minute of drift. If the encoder is able to catch up and send all 60 seconds or more of data every minute, you will see this value reported as 0. If there was a disconnection or discontinuity from the encoder, this value may still display as 0, as it does not account for breaks in the data - only data that is delayed in timestamps.
func (o LiveEventTrackEventDataResponsePtrOutput) IngestDriftValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.IngestDriftValue
	}).(pulumi.StringPtrOutput)
}

// The last timestamp in UTC that a fragment arrived at the ingest endpoint.
func (o LiveEventTrackEventDataResponsePtrOutput) LastFragmentArrivalTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.LastFragmentArrivalTime
	}).(pulumi.StringPtrOutput)
}

// Latest timestamp received for a track in last 20 seconds.
func (o LiveEventTrackEventDataResponsePtrOutput) LastTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.LastTimestamp
	}).(pulumi.StringPtrOutput)
}

// Number of data chunks with timestamps in the past that were received in last 20 seconds.
func (o LiveEventTrackEventDataResponsePtrOutput) NonincreasingCount() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.NonincreasingCount
	}).(pulumi.Float64PtrOutput)
}

// Number of data chunks that had overlapped timestamps in last 20 seconds.
func (o LiveEventTrackEventDataResponsePtrOutput) OverlapCount() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.OverlapCount
	}).(pulumi.Float64PtrOutput)
}

// State of the live event.
func (o LiveEventTrackEventDataResponsePtrOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.State
	}).(pulumi.StringPtrOutput)
}

// Timescale in which timestamps are expressed.
func (o LiveEventTrackEventDataResponsePtrOutput) Timescale() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.Timescale
	}).(pulumi.StringPtrOutput)
}

// Name of the track.
func (o LiveEventTrackEventDataResponsePtrOutput) TrackName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.TrackName
	}).(pulumi.StringPtrOutput)
}

// Type of the track.
func (o LiveEventTrackEventDataResponsePtrOutput) TrackType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.TrackType
	}).(pulumi.StringPtrOutput)
}

// The language code (in BCP-47 format) of the transcription language. For example, "de-de" indicates German (Germany). The value is empty for the video track heartbeats, or when live transcription is turned off.
func (o LiveEventTrackEventDataResponsePtrOutput) TranscriptionLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.TranscriptionLanguage
	}).(pulumi.StringPtrOutput)
}

// This value is "On" for audio track heartbeats if live transcription is turned on, otherwise you will see an empty string. This state is only applicable to track type of "audio" for Live transcription. All other tracks will have an empty value.
func (o LiveEventTrackEventDataResponsePtrOutput) TranscriptionState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.TranscriptionState
	}).(pulumi.StringPtrOutput)
}

// If expected and actual bitrates differ by more than allowed limit in last 20 seconds.
func (o LiveEventTrackEventDataResponsePtrOutput) UnexpectedBitrate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LiveEventTrackEventDataResponse) *bool {
		if v == nil {
			return nil
		}
		return v.UnexpectedBitrate
	}).(pulumi.BoolPtrOutput)
}

// The live event track event.
type LiveEventTrackEventResponse struct {
	// Event data.
	Data *LiveEventTrackEventDataResponse `pulumi:"data"`
	// The time event raised.
	EventTime *string `pulumi:"eventTime"`
	// The type of the track event.
	EventType *string `pulumi:"eventType"`
}

// The live event track event.
type LiveEventTrackEventResponseOutput struct{ *pulumi.OutputState }

func (LiveEventTrackEventResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTrackEventResponse)(nil)).Elem()
}

func (o LiveEventTrackEventResponseOutput) ToLiveEventTrackEventResponseOutput() LiveEventTrackEventResponseOutput {
	return o
}

func (o LiveEventTrackEventResponseOutput) ToLiveEventTrackEventResponseOutputWithContext(ctx context.Context) LiveEventTrackEventResponseOutput {
	return o
}

// Event data.
func (o LiveEventTrackEventResponseOutput) Data() LiveEventTrackEventDataResponsePtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventResponse) *LiveEventTrackEventDataResponse { return v.Data }).(LiveEventTrackEventDataResponsePtrOutput)
}

// The time event raised.
func (o LiveEventTrackEventResponseOutput) EventTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventResponse) *string { return v.EventTime }).(pulumi.StringPtrOutput)
}

// The type of the track event.
func (o LiveEventTrackEventResponseOutput) EventType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackEventResponse) *string { return v.EventType }).(pulumi.StringPtrOutput)
}

type LiveEventTrackEventResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventTrackEventResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventTrackEventResponse)(nil)).Elem()
}

func (o LiveEventTrackEventResponseArrayOutput) ToLiveEventTrackEventResponseArrayOutput() LiveEventTrackEventResponseArrayOutput {
	return o
}

func (o LiveEventTrackEventResponseArrayOutput) ToLiveEventTrackEventResponseArrayOutputWithContext(ctx context.Context) LiveEventTrackEventResponseArrayOutput {
	return o
}

func (o LiveEventTrackEventResponseArrayOutput) Index(i pulumi.IntInput) LiveEventTrackEventResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventTrackEventResponse {
		return vs[0].([]LiveEventTrackEventResponse)[vs[1].(int)]
	}).(LiveEventTrackEventResponseOutput)
}

// The live event track status.
type LiveEventTrackStatusResponse struct {
	// Expected bitrate for this track.
	ExpectedBitrate *float64 `pulumi:"expectedBitrate"`
	// Average incoming bitrate for last 20 seconds when live event is running.
	IncomingBitrate *float64 `pulumi:"incomingBitrate"`
	// Current ingest drift value in seconds for last 1 minute.
	IngestDrift *string `pulumi:"ingestDrift"`
	// Total number of timed metadata request received.
	RequestReceived *float64 `pulumi:"requestReceived"`
	// Total number of successful timed metadata request received.
	RequestSucceeded *float64 `pulumi:"requestSucceeded"`
	// Track Id.
	TrackId *string `pulumi:"trackId"`
}

// The live event track status.
type LiveEventTrackStatusResponseOutput struct{ *pulumi.OutputState }

func (LiveEventTrackStatusResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTrackStatusResponse)(nil)).Elem()
}

func (o LiveEventTrackStatusResponseOutput) ToLiveEventTrackStatusResponseOutput() LiveEventTrackStatusResponseOutput {
	return o
}

func (o LiveEventTrackStatusResponseOutput) ToLiveEventTrackStatusResponseOutputWithContext(ctx context.Context) LiveEventTrackStatusResponseOutput {
	return o
}

// Expected bitrate for this track.
func (o LiveEventTrackStatusResponseOutput) ExpectedBitrate() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LiveEventTrackStatusResponse) *float64 { return v.ExpectedBitrate }).(pulumi.Float64PtrOutput)
}

// Average incoming bitrate for last 20 seconds when live event is running.
func (o LiveEventTrackStatusResponseOutput) IncomingBitrate() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LiveEventTrackStatusResponse) *float64 { return v.IncomingBitrate }).(pulumi.Float64PtrOutput)
}

// Current ingest drift value in seconds for last 1 minute.
func (o LiveEventTrackStatusResponseOutput) IngestDrift() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackStatusResponse) *string { return v.IngestDrift }).(pulumi.StringPtrOutput)
}

// Total number of timed metadata request received.
func (o LiveEventTrackStatusResponseOutput) RequestReceived() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LiveEventTrackStatusResponse) *float64 { return v.RequestReceived }).(pulumi.Float64PtrOutput)
}

// Total number of successful timed metadata request received.
func (o LiveEventTrackStatusResponseOutput) RequestSucceeded() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LiveEventTrackStatusResponse) *float64 { return v.RequestSucceeded }).(pulumi.Float64PtrOutput)
}

// Track Id.
func (o LiveEventTrackStatusResponseOutput) TrackId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTrackStatusResponse) *string { return v.TrackId }).(pulumi.StringPtrOutput)
}

type LiveEventTrackStatusResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventTrackStatusResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventTrackStatusResponse)(nil)).Elem()
}

func (o LiveEventTrackStatusResponseArrayOutput) ToLiveEventTrackStatusResponseArrayOutput() LiveEventTrackStatusResponseArrayOutput {
	return o
}

func (o LiveEventTrackStatusResponseArrayOutput) ToLiveEventTrackStatusResponseArrayOutputWithContext(ctx context.Context) LiveEventTrackStatusResponseArrayOutput {
	return o
}

func (o LiveEventTrackStatusResponseArrayOutput) Index(i pulumi.IntInput) LiveEventTrackStatusResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventTrackStatusResponse {
		return vs[0].([]LiveEventTrackStatusResponse)[vs[1].(int)]
	}).(LiveEventTrackStatusResponseOutput)
}

// Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventTranscription struct {
	// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied. This property is reserved for future use, any value set on this property will be ignored.
	InputTrackSelection []LiveEventInputTrackSelection `pulumi:"inputTrackSelection"`
	// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in BCP-47 format (e.g: 'en-US'). See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list of supported languages.
	Language *string `pulumi:"language"`
	// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
	OutputTranscriptionTrack *LiveEventOutputTranscriptionTrack `pulumi:"outputTranscriptionTrack"`
}

// LiveEventTranscriptionInput is an input type that accepts LiveEventTranscriptionArgs and LiveEventTranscriptionOutput values.
// You can construct a concrete instance of `LiveEventTranscriptionInput` via:
//
//	LiveEventTranscriptionArgs{...}
type LiveEventTranscriptionInput interface {
	pulumi.Input

	ToLiveEventTranscriptionOutput() LiveEventTranscriptionOutput
	ToLiveEventTranscriptionOutputWithContext(context.Context) LiveEventTranscriptionOutput
}

// Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventTranscriptionArgs struct {
	// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied. This property is reserved for future use, any value set on this property will be ignored.
	InputTrackSelection LiveEventInputTrackSelectionArrayInput `pulumi:"inputTrackSelection"`
	// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in BCP-47 format (e.g: 'en-US'). See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list of supported languages.
	Language pulumi.StringPtrInput `pulumi:"language"`
	// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
	OutputTranscriptionTrack LiveEventOutputTranscriptionTrackPtrInput `pulumi:"outputTranscriptionTrack"`
}

func (LiveEventTranscriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTranscription)(nil)).Elem()
}

func (i LiveEventTranscriptionArgs) ToLiveEventTranscriptionOutput() LiveEventTranscriptionOutput {
	return i.ToLiveEventTranscriptionOutputWithContext(context.Background())
}

func (i LiveEventTranscriptionArgs) ToLiveEventTranscriptionOutputWithContext(ctx context.Context) LiveEventTranscriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventTranscriptionOutput)
}

// LiveEventTranscriptionArrayInput is an input type that accepts LiveEventTranscriptionArray and LiveEventTranscriptionArrayOutput values.
// You can construct a concrete instance of `LiveEventTranscriptionArrayInput` via:
//
//	LiveEventTranscriptionArray{ LiveEventTranscriptionArgs{...} }
type LiveEventTranscriptionArrayInput interface {
	pulumi.Input

	ToLiveEventTranscriptionArrayOutput() LiveEventTranscriptionArrayOutput
	ToLiveEventTranscriptionArrayOutputWithContext(context.Context) LiveEventTranscriptionArrayOutput
}

type LiveEventTranscriptionArray []LiveEventTranscriptionInput

func (LiveEventTranscriptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventTranscription)(nil)).Elem()
}

func (i LiveEventTranscriptionArray) ToLiveEventTranscriptionArrayOutput() LiveEventTranscriptionArrayOutput {
	return i.ToLiveEventTranscriptionArrayOutputWithContext(context.Background())
}

func (i LiveEventTranscriptionArray) ToLiveEventTranscriptionArrayOutputWithContext(ctx context.Context) LiveEventTranscriptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventTranscriptionArrayOutput)
}

// Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventTranscriptionOutput struct{ *pulumi.OutputState }

func (LiveEventTranscriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTranscription)(nil)).Elem()
}

func (o LiveEventTranscriptionOutput) ToLiveEventTranscriptionOutput() LiveEventTranscriptionOutput {
	return o
}

func (o LiveEventTranscriptionOutput) ToLiveEventTranscriptionOutputWithContext(ctx context.Context) LiveEventTranscriptionOutput {
	return o
}

// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventTranscriptionOutput) InputTrackSelection() LiveEventInputTrackSelectionArrayOutput {
	return o.ApplyT(func(v LiveEventTranscription) []LiveEventInputTrackSelection { return v.InputTrackSelection }).(LiveEventInputTrackSelectionArrayOutput)
}

// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in BCP-47 format (e.g: 'en-US'). See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list of supported languages.
func (o LiveEventTranscriptionOutput) Language() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTranscription) *string { return v.Language }).(pulumi.StringPtrOutput)
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventTranscriptionOutput) OutputTranscriptionTrack() LiveEventOutputTranscriptionTrackPtrOutput {
	return o.ApplyT(func(v LiveEventTranscription) *LiveEventOutputTranscriptionTrack { return v.OutputTranscriptionTrack }).(LiveEventOutputTranscriptionTrackPtrOutput)
}

type LiveEventTranscriptionArrayOutput struct{ *pulumi.OutputState }

func (LiveEventTranscriptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventTranscription)(nil)).Elem()
}

func (o LiveEventTranscriptionArrayOutput) ToLiveEventTranscriptionArrayOutput() LiveEventTranscriptionArrayOutput {
	return o
}

func (o LiveEventTranscriptionArrayOutput) ToLiveEventTranscriptionArrayOutputWithContext(ctx context.Context) LiveEventTranscriptionArrayOutput {
	return o
}

func (o LiveEventTranscriptionArrayOutput) Index(i pulumi.IntInput) LiveEventTranscriptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventTranscription {
		return vs[0].([]LiveEventTranscription)[vs[1].(int)]
	}).(LiveEventTranscriptionOutput)
}

// Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventTranscriptionResponse struct {
	// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied. This property is reserved for future use, any value set on this property will be ignored.
	InputTrackSelection []LiveEventInputTrackSelectionResponse `pulumi:"inputTrackSelection"`
	// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in BCP-47 format (e.g: 'en-US'). See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list of supported languages.
	Language *string `pulumi:"language"`
	// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
	OutputTranscriptionTrack *LiveEventOutputTranscriptionTrackResponse `pulumi:"outputTranscriptionTrack"`
}

// Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventTranscriptionResponseOutput struct{ *pulumi.OutputState }

func (LiveEventTranscriptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTranscriptionResponse)(nil)).Elem()
}

func (o LiveEventTranscriptionResponseOutput) ToLiveEventTranscriptionResponseOutput() LiveEventTranscriptionResponseOutput {
	return o
}

func (o LiveEventTranscriptionResponseOutput) ToLiveEventTranscriptionResponseOutputWithContext(ctx context.Context) LiveEventTranscriptionResponseOutput {
	return o
}

// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventTranscriptionResponseOutput) InputTrackSelection() LiveEventInputTrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v LiveEventTranscriptionResponse) []LiveEventInputTrackSelectionResponse {
		return v.InputTrackSelection
	}).(LiveEventInputTrackSelectionResponseArrayOutput)
}

// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in BCP-47 format (e.g: 'en-US'). See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list of supported languages.
func (o LiveEventTranscriptionResponseOutput) Language() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTranscriptionResponse) *string { return v.Language }).(pulumi.StringPtrOutput)
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventTranscriptionResponseOutput) OutputTranscriptionTrack() LiveEventOutputTranscriptionTrackResponsePtrOutput {
	return o.ApplyT(func(v LiveEventTranscriptionResponse) *LiveEventOutputTranscriptionTrackResponse {
		return v.OutputTranscriptionTrack
	}).(LiveEventOutputTranscriptionTrackResponsePtrOutput)
}

type LiveEventTranscriptionResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventTranscriptionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventTranscriptionResponse)(nil)).Elem()
}

func (o LiveEventTranscriptionResponseArrayOutput) ToLiveEventTranscriptionResponseArrayOutput() LiveEventTranscriptionResponseArrayOutput {
	return o
}

func (o LiveEventTranscriptionResponseArrayOutput) ToLiveEventTranscriptionResponseArrayOutputWithContext(ctx context.Context) LiveEventTranscriptionResponseArrayOutput {
	return o
}

func (o LiveEventTranscriptionResponseArrayOutput) Index(i pulumi.IntInput) LiveEventTranscriptionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventTranscriptionResponse {
		return vs[0].([]LiveEventTranscriptionResponse)[vs[1].(int)]
	}).(LiveEventTranscriptionResponseOutput)
}

// Asset sink.
type MediaGraphAssetSink struct {
	// Asset name.
	AssetName string `pulumi:"assetName"`
	// Sink inputs.
	Inputs []string `pulumi:"inputs"`
	// Sink name.
	Name string `pulumi:"name"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphAssetSink'.
	OdataType string `pulumi:"odataType"`
}

// MediaGraphAssetSinkInput is an input type that accepts MediaGraphAssetSinkArgs and MediaGraphAssetSinkOutput values.
// You can construct a concrete instance of `MediaGraphAssetSinkInput` via:
//
//	MediaGraphAssetSinkArgs{...}
type MediaGraphAssetSinkInput interface {
	pulumi.Input

	ToMediaGraphAssetSinkOutput() MediaGraphAssetSinkOutput
	ToMediaGraphAssetSinkOutputWithContext(context.Context) MediaGraphAssetSinkOutput
}

// Asset sink.
type MediaGraphAssetSinkArgs struct {
	// Asset name.
	AssetName pulumi.StringInput `pulumi:"assetName"`
	// Sink inputs.
	Inputs pulumi.StringArrayInput `pulumi:"inputs"`
	// Sink name.
	Name pulumi.StringInput `pulumi:"name"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphAssetSink'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (MediaGraphAssetSinkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphAssetSink)(nil)).Elem()
}

func (i MediaGraphAssetSinkArgs) ToMediaGraphAssetSinkOutput() MediaGraphAssetSinkOutput {
	return i.ToMediaGraphAssetSinkOutputWithContext(context.Background())
}

func (i MediaGraphAssetSinkArgs) ToMediaGraphAssetSinkOutputWithContext(ctx context.Context) MediaGraphAssetSinkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphAssetSinkOutput)
}

// MediaGraphAssetSinkArrayInput is an input type that accepts MediaGraphAssetSinkArray and MediaGraphAssetSinkArrayOutput values.
// You can construct a concrete instance of `MediaGraphAssetSinkArrayInput` via:
//
//	MediaGraphAssetSinkArray{ MediaGraphAssetSinkArgs{...} }
type MediaGraphAssetSinkArrayInput interface {
	pulumi.Input

	ToMediaGraphAssetSinkArrayOutput() MediaGraphAssetSinkArrayOutput
	ToMediaGraphAssetSinkArrayOutputWithContext(context.Context) MediaGraphAssetSinkArrayOutput
}

type MediaGraphAssetSinkArray []MediaGraphAssetSinkInput

func (MediaGraphAssetSinkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MediaGraphAssetSink)(nil)).Elem()
}

func (i MediaGraphAssetSinkArray) ToMediaGraphAssetSinkArrayOutput() MediaGraphAssetSinkArrayOutput {
	return i.ToMediaGraphAssetSinkArrayOutputWithContext(context.Background())
}

func (i MediaGraphAssetSinkArray) ToMediaGraphAssetSinkArrayOutputWithContext(ctx context.Context) MediaGraphAssetSinkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphAssetSinkArrayOutput)
}

// Asset sink.
type MediaGraphAssetSinkOutput struct{ *pulumi.OutputState }

func (MediaGraphAssetSinkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphAssetSink)(nil)).Elem()
}

func (o MediaGraphAssetSinkOutput) ToMediaGraphAssetSinkOutput() MediaGraphAssetSinkOutput {
	return o
}

func (o MediaGraphAssetSinkOutput) ToMediaGraphAssetSinkOutputWithContext(ctx context.Context) MediaGraphAssetSinkOutput {
	return o
}

// Asset name.
func (o MediaGraphAssetSinkOutput) AssetName() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphAssetSink) string { return v.AssetName }).(pulumi.StringOutput)
}

// Sink inputs.
func (o MediaGraphAssetSinkOutput) Inputs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v MediaGraphAssetSink) []string { return v.Inputs }).(pulumi.StringArrayOutput)
}

// Sink name.
func (o MediaGraphAssetSinkOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphAssetSink) string { return v.Name }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphAssetSink'.
func (o MediaGraphAssetSinkOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphAssetSink) string { return v.OdataType }).(pulumi.StringOutput)
}

type MediaGraphAssetSinkArrayOutput struct{ *pulumi.OutputState }

func (MediaGraphAssetSinkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MediaGraphAssetSink)(nil)).Elem()
}

func (o MediaGraphAssetSinkArrayOutput) ToMediaGraphAssetSinkArrayOutput() MediaGraphAssetSinkArrayOutput {
	return o
}

func (o MediaGraphAssetSinkArrayOutput) ToMediaGraphAssetSinkArrayOutputWithContext(ctx context.Context) MediaGraphAssetSinkArrayOutput {
	return o
}

func (o MediaGraphAssetSinkArrayOutput) Index(i pulumi.IntInput) MediaGraphAssetSinkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MediaGraphAssetSink {
		return vs[0].([]MediaGraphAssetSink)[vs[1].(int)]
	}).(MediaGraphAssetSinkOutput)
}

// Asset sink.
type MediaGraphAssetSinkResponse struct {
	// Asset name.
	AssetName string `pulumi:"assetName"`
	// Sink inputs.
	Inputs []string `pulumi:"inputs"`
	// Sink name.
	Name string `pulumi:"name"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphAssetSink'.
	OdataType string `pulumi:"odataType"`
}

// Asset sink.
type MediaGraphAssetSinkResponseOutput struct{ *pulumi.OutputState }

func (MediaGraphAssetSinkResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphAssetSinkResponse)(nil)).Elem()
}

func (o MediaGraphAssetSinkResponseOutput) ToMediaGraphAssetSinkResponseOutput() MediaGraphAssetSinkResponseOutput {
	return o
}

func (o MediaGraphAssetSinkResponseOutput) ToMediaGraphAssetSinkResponseOutputWithContext(ctx context.Context) MediaGraphAssetSinkResponseOutput {
	return o
}

// Asset name.
func (o MediaGraphAssetSinkResponseOutput) AssetName() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphAssetSinkResponse) string { return v.AssetName }).(pulumi.StringOutput)
}

// Sink inputs.
func (o MediaGraphAssetSinkResponseOutput) Inputs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v MediaGraphAssetSinkResponse) []string { return v.Inputs }).(pulumi.StringArrayOutput)
}

// Sink name.
func (o MediaGraphAssetSinkResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphAssetSinkResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphAssetSink'.
func (o MediaGraphAssetSinkResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphAssetSinkResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

type MediaGraphAssetSinkResponseArrayOutput struct{ *pulumi.OutputState }

func (MediaGraphAssetSinkResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MediaGraphAssetSinkResponse)(nil)).Elem()
}

func (o MediaGraphAssetSinkResponseArrayOutput) ToMediaGraphAssetSinkResponseArrayOutput() MediaGraphAssetSinkResponseArrayOutput {
	return o
}

func (o MediaGraphAssetSinkResponseArrayOutput) ToMediaGraphAssetSinkResponseArrayOutputWithContext(ctx context.Context) MediaGraphAssetSinkResponseArrayOutput {
	return o
}

func (o MediaGraphAssetSinkResponseArrayOutput) Index(i pulumi.IntInput) MediaGraphAssetSinkResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MediaGraphAssetSinkResponse {
		return vs[0].([]MediaGraphAssetSinkResponse)[vs[1].(int)]
	}).(MediaGraphAssetSinkResponseOutput)
}

// An endpoint to connect to with no encryption in transit.
type MediaGraphClearEndpoint struct {
	// Polymorphic credentials to present to the endpoint.
	Credentials *MediaGraphUsernamePasswordCredentials `pulumi:"credentials"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphClearEndpoint'.
	OdataType string `pulumi:"odataType"`
	// Url for the endpoint.
	Url string `pulumi:"url"`
}

// MediaGraphClearEndpointInput is an input type that accepts MediaGraphClearEndpointArgs and MediaGraphClearEndpointOutput values.
// You can construct a concrete instance of `MediaGraphClearEndpointInput` via:
//
//	MediaGraphClearEndpointArgs{...}
type MediaGraphClearEndpointInput interface {
	pulumi.Input

	ToMediaGraphClearEndpointOutput() MediaGraphClearEndpointOutput
	ToMediaGraphClearEndpointOutputWithContext(context.Context) MediaGraphClearEndpointOutput
}

// An endpoint to connect to with no encryption in transit.
type MediaGraphClearEndpointArgs struct {
	// Polymorphic credentials to present to the endpoint.
	Credentials MediaGraphUsernamePasswordCredentialsPtrInput `pulumi:"credentials"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphClearEndpoint'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Url for the endpoint.
	Url pulumi.StringInput `pulumi:"url"`
}

func (MediaGraphClearEndpointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphClearEndpoint)(nil)).Elem()
}

func (i MediaGraphClearEndpointArgs) ToMediaGraphClearEndpointOutput() MediaGraphClearEndpointOutput {
	return i.ToMediaGraphClearEndpointOutputWithContext(context.Background())
}

func (i MediaGraphClearEndpointArgs) ToMediaGraphClearEndpointOutputWithContext(ctx context.Context) MediaGraphClearEndpointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphClearEndpointOutput)
}

// An endpoint to connect to with no encryption in transit.
type MediaGraphClearEndpointOutput struct{ *pulumi.OutputState }

func (MediaGraphClearEndpointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphClearEndpoint)(nil)).Elem()
}

func (o MediaGraphClearEndpointOutput) ToMediaGraphClearEndpointOutput() MediaGraphClearEndpointOutput {
	return o
}

func (o MediaGraphClearEndpointOutput) ToMediaGraphClearEndpointOutputWithContext(ctx context.Context) MediaGraphClearEndpointOutput {
	return o
}

// Polymorphic credentials to present to the endpoint.
func (o MediaGraphClearEndpointOutput) Credentials() MediaGraphUsernamePasswordCredentialsPtrOutput {
	return o.ApplyT(func(v MediaGraphClearEndpoint) *MediaGraphUsernamePasswordCredentials { return v.Credentials }).(MediaGraphUsernamePasswordCredentialsPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphClearEndpoint'.
func (o MediaGraphClearEndpointOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphClearEndpoint) string { return v.OdataType }).(pulumi.StringOutput)
}

// Url for the endpoint.
func (o MediaGraphClearEndpointOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphClearEndpoint) string { return v.Url }).(pulumi.StringOutput)
}

// An endpoint to connect to with no encryption in transit.
type MediaGraphClearEndpointResponse struct {
	// Polymorphic credentials to present to the endpoint.
	Credentials *MediaGraphUsernamePasswordCredentialsResponse `pulumi:"credentials"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphClearEndpoint'.
	OdataType string `pulumi:"odataType"`
	// Url for the endpoint.
	Url string `pulumi:"url"`
}

// An endpoint to connect to with no encryption in transit.
type MediaGraphClearEndpointResponseOutput struct{ *pulumi.OutputState }

func (MediaGraphClearEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphClearEndpointResponse)(nil)).Elem()
}

func (o MediaGraphClearEndpointResponseOutput) ToMediaGraphClearEndpointResponseOutput() MediaGraphClearEndpointResponseOutput {
	return o
}

func (o MediaGraphClearEndpointResponseOutput) ToMediaGraphClearEndpointResponseOutputWithContext(ctx context.Context) MediaGraphClearEndpointResponseOutput {
	return o
}

// Polymorphic credentials to present to the endpoint.
func (o MediaGraphClearEndpointResponseOutput) Credentials() MediaGraphUsernamePasswordCredentialsResponsePtrOutput {
	return o.ApplyT(func(v MediaGraphClearEndpointResponse) *MediaGraphUsernamePasswordCredentialsResponse {
		return v.Credentials
	}).(MediaGraphUsernamePasswordCredentialsResponsePtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphClearEndpoint'.
func (o MediaGraphClearEndpointResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphClearEndpointResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Url for the endpoint.
func (o MediaGraphClearEndpointResponseOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphClearEndpointResponse) string { return v.Url }).(pulumi.StringOutput)
}

// A list of PEM formatted certificates.
type MediaGraphPemCertificateList struct {
	// PEM formatted public certificates, one per entry.
	Certificates []string `pulumi:"certificates"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphPemCertificateList'.
	OdataType string `pulumi:"odataType"`
}

// MediaGraphPemCertificateListInput is an input type that accepts MediaGraphPemCertificateListArgs and MediaGraphPemCertificateListOutput values.
// You can construct a concrete instance of `MediaGraphPemCertificateListInput` via:
//
//	MediaGraphPemCertificateListArgs{...}
type MediaGraphPemCertificateListInput interface {
	pulumi.Input

	ToMediaGraphPemCertificateListOutput() MediaGraphPemCertificateListOutput
	ToMediaGraphPemCertificateListOutputWithContext(context.Context) MediaGraphPemCertificateListOutput
}

// A list of PEM formatted certificates.
type MediaGraphPemCertificateListArgs struct {
	// PEM formatted public certificates, one per entry.
	Certificates pulumi.StringArrayInput `pulumi:"certificates"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphPemCertificateList'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (MediaGraphPemCertificateListArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphPemCertificateList)(nil)).Elem()
}

func (i MediaGraphPemCertificateListArgs) ToMediaGraphPemCertificateListOutput() MediaGraphPemCertificateListOutput {
	return i.ToMediaGraphPemCertificateListOutputWithContext(context.Background())
}

func (i MediaGraphPemCertificateListArgs) ToMediaGraphPemCertificateListOutputWithContext(ctx context.Context) MediaGraphPemCertificateListOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphPemCertificateListOutput)
}

func (i MediaGraphPemCertificateListArgs) ToMediaGraphPemCertificateListPtrOutput() MediaGraphPemCertificateListPtrOutput {
	return i.ToMediaGraphPemCertificateListPtrOutputWithContext(context.Background())
}

func (i MediaGraphPemCertificateListArgs) ToMediaGraphPemCertificateListPtrOutputWithContext(ctx context.Context) MediaGraphPemCertificateListPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphPemCertificateListOutput).ToMediaGraphPemCertificateListPtrOutputWithContext(ctx)
}

// MediaGraphPemCertificateListPtrInput is an input type that accepts MediaGraphPemCertificateListArgs, MediaGraphPemCertificateListPtr and MediaGraphPemCertificateListPtrOutput values.
// You can construct a concrete instance of `MediaGraphPemCertificateListPtrInput` via:
//
//	        MediaGraphPemCertificateListArgs{...}
//
//	or:
//
//	        nil
type MediaGraphPemCertificateListPtrInput interface {
	pulumi.Input

	ToMediaGraphPemCertificateListPtrOutput() MediaGraphPemCertificateListPtrOutput
	ToMediaGraphPemCertificateListPtrOutputWithContext(context.Context) MediaGraphPemCertificateListPtrOutput
}

type mediaGraphPemCertificateListPtrType MediaGraphPemCertificateListArgs

func MediaGraphPemCertificateListPtr(v *MediaGraphPemCertificateListArgs) MediaGraphPemCertificateListPtrInput {
	return (*mediaGraphPemCertificateListPtrType)(v)
}

func (*mediaGraphPemCertificateListPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaGraphPemCertificateList)(nil)).Elem()
}

func (i *mediaGraphPemCertificateListPtrType) ToMediaGraphPemCertificateListPtrOutput() MediaGraphPemCertificateListPtrOutput {
	return i.ToMediaGraphPemCertificateListPtrOutputWithContext(context.Background())
}

func (i *mediaGraphPemCertificateListPtrType) ToMediaGraphPemCertificateListPtrOutputWithContext(ctx context.Context) MediaGraphPemCertificateListPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphPemCertificateListPtrOutput)
}

// A list of PEM formatted certificates.
type MediaGraphPemCertificateListOutput struct{ *pulumi.OutputState }

func (MediaGraphPemCertificateListOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphPemCertificateList)(nil)).Elem()
}

func (o MediaGraphPemCertificateListOutput) ToMediaGraphPemCertificateListOutput() MediaGraphPemCertificateListOutput {
	return o
}

func (o MediaGraphPemCertificateListOutput) ToMediaGraphPemCertificateListOutputWithContext(ctx context.Context) MediaGraphPemCertificateListOutput {
	return o
}

func (o MediaGraphPemCertificateListOutput) ToMediaGraphPemCertificateListPtrOutput() MediaGraphPemCertificateListPtrOutput {
	return o.ToMediaGraphPemCertificateListPtrOutputWithContext(context.Background())
}

func (o MediaGraphPemCertificateListOutput) ToMediaGraphPemCertificateListPtrOutputWithContext(ctx context.Context) MediaGraphPemCertificateListPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MediaGraphPemCertificateList) *MediaGraphPemCertificateList {
		return &v
	}).(MediaGraphPemCertificateListPtrOutput)
}

// PEM formatted public certificates, one per entry.
func (o MediaGraphPemCertificateListOutput) Certificates() pulumi.StringArrayOutput {
	return o.ApplyT(func(v MediaGraphPemCertificateList) []string { return v.Certificates }).(pulumi.StringArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphPemCertificateList'.
func (o MediaGraphPemCertificateListOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphPemCertificateList) string { return v.OdataType }).(pulumi.StringOutput)
}

type MediaGraphPemCertificateListPtrOutput struct{ *pulumi.OutputState }

func (MediaGraphPemCertificateListPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaGraphPemCertificateList)(nil)).Elem()
}

func (o MediaGraphPemCertificateListPtrOutput) ToMediaGraphPemCertificateListPtrOutput() MediaGraphPemCertificateListPtrOutput {
	return o
}

func (o MediaGraphPemCertificateListPtrOutput) ToMediaGraphPemCertificateListPtrOutputWithContext(ctx context.Context) MediaGraphPemCertificateListPtrOutput {
	return o
}

func (o MediaGraphPemCertificateListPtrOutput) Elem() MediaGraphPemCertificateListOutput {
	return o.ApplyT(func(v *MediaGraphPemCertificateList) MediaGraphPemCertificateList {
		if v != nil {
			return *v
		}
		var ret MediaGraphPemCertificateList
		return ret
	}).(MediaGraphPemCertificateListOutput)
}

// PEM formatted public certificates, one per entry.
func (o MediaGraphPemCertificateListPtrOutput) Certificates() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *MediaGraphPemCertificateList) []string {
		if v == nil {
			return nil
		}
		return v.Certificates
	}).(pulumi.StringArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphPemCertificateList'.
func (o MediaGraphPemCertificateListPtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaGraphPemCertificateList) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// A list of PEM formatted certificates.
type MediaGraphPemCertificateListResponse struct {
	// PEM formatted public certificates, one per entry.
	Certificates []string `pulumi:"certificates"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphPemCertificateList'.
	OdataType string `pulumi:"odataType"`
}

// A list of PEM formatted certificates.
type MediaGraphPemCertificateListResponseOutput struct{ *pulumi.OutputState }

func (MediaGraphPemCertificateListResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphPemCertificateListResponse)(nil)).Elem()
}

func (o MediaGraphPemCertificateListResponseOutput) ToMediaGraphPemCertificateListResponseOutput() MediaGraphPemCertificateListResponseOutput {
	return o
}

func (o MediaGraphPemCertificateListResponseOutput) ToMediaGraphPemCertificateListResponseOutputWithContext(ctx context.Context) MediaGraphPemCertificateListResponseOutput {
	return o
}

// PEM formatted public certificates, one per entry.
func (o MediaGraphPemCertificateListResponseOutput) Certificates() pulumi.StringArrayOutput {
	return o.ApplyT(func(v MediaGraphPemCertificateListResponse) []string { return v.Certificates }).(pulumi.StringArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphPemCertificateList'.
func (o MediaGraphPemCertificateListResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphPemCertificateListResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

type MediaGraphPemCertificateListResponsePtrOutput struct{ *pulumi.OutputState }

func (MediaGraphPemCertificateListResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaGraphPemCertificateListResponse)(nil)).Elem()
}

func (o MediaGraphPemCertificateListResponsePtrOutput) ToMediaGraphPemCertificateListResponsePtrOutput() MediaGraphPemCertificateListResponsePtrOutput {
	return o
}

func (o MediaGraphPemCertificateListResponsePtrOutput) ToMediaGraphPemCertificateListResponsePtrOutputWithContext(ctx context.Context) MediaGraphPemCertificateListResponsePtrOutput {
	return o
}

func (o MediaGraphPemCertificateListResponsePtrOutput) Elem() MediaGraphPemCertificateListResponseOutput {
	return o.ApplyT(func(v *MediaGraphPemCertificateListResponse) MediaGraphPemCertificateListResponse {
		if v != nil {
			return *v
		}
		var ret MediaGraphPemCertificateListResponse
		return ret
	}).(MediaGraphPemCertificateListResponseOutput)
}

// PEM formatted public certificates, one per entry.
func (o MediaGraphPemCertificateListResponsePtrOutput) Certificates() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *MediaGraphPemCertificateListResponse) []string {
		if v == nil {
			return nil
		}
		return v.Certificates
	}).(pulumi.StringArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphPemCertificateList'.
func (o MediaGraphPemCertificateListResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaGraphPemCertificateListResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// RTSP source.
type MediaGraphRtspSource struct {
	// RTSP endpoint of the stream being connected to.
	Endpoint interface{} `pulumi:"endpoint"`
	// Source name.
	Name string `pulumi:"name"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphRtspSource'.
	OdataType string `pulumi:"odataType"`
	// Underlying RTSP transport. This can be used to enable or disable HTTP tunneling.
	Transport string `pulumi:"transport"`
}

// MediaGraphRtspSourceInput is an input type that accepts MediaGraphRtspSourceArgs and MediaGraphRtspSourceOutput values.
// You can construct a concrete instance of `MediaGraphRtspSourceInput` via:
//
//	MediaGraphRtspSourceArgs{...}
type MediaGraphRtspSourceInput interface {
	pulumi.Input

	ToMediaGraphRtspSourceOutput() MediaGraphRtspSourceOutput
	ToMediaGraphRtspSourceOutputWithContext(context.Context) MediaGraphRtspSourceOutput
}

// RTSP source.
type MediaGraphRtspSourceArgs struct {
	// RTSP endpoint of the stream being connected to.
	Endpoint pulumi.Input `pulumi:"endpoint"`
	// Source name.
	Name pulumi.StringInput `pulumi:"name"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphRtspSource'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Underlying RTSP transport. This can be used to enable or disable HTTP tunneling.
	Transport pulumi.StringInput `pulumi:"transport"`
}

func (MediaGraphRtspSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphRtspSource)(nil)).Elem()
}

func (i MediaGraphRtspSourceArgs) ToMediaGraphRtspSourceOutput() MediaGraphRtspSourceOutput {
	return i.ToMediaGraphRtspSourceOutputWithContext(context.Background())
}

func (i MediaGraphRtspSourceArgs) ToMediaGraphRtspSourceOutputWithContext(ctx context.Context) MediaGraphRtspSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphRtspSourceOutput)
}

// MediaGraphRtspSourceArrayInput is an input type that accepts MediaGraphRtspSourceArray and MediaGraphRtspSourceArrayOutput values.
// You can construct a concrete instance of `MediaGraphRtspSourceArrayInput` via:
//
//	MediaGraphRtspSourceArray{ MediaGraphRtspSourceArgs{...} }
type MediaGraphRtspSourceArrayInput interface {
	pulumi.Input

	ToMediaGraphRtspSourceArrayOutput() MediaGraphRtspSourceArrayOutput
	ToMediaGraphRtspSourceArrayOutputWithContext(context.Context) MediaGraphRtspSourceArrayOutput
}

type MediaGraphRtspSourceArray []MediaGraphRtspSourceInput

func (MediaGraphRtspSourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MediaGraphRtspSource)(nil)).Elem()
}

func (i MediaGraphRtspSourceArray) ToMediaGraphRtspSourceArrayOutput() MediaGraphRtspSourceArrayOutput {
	return i.ToMediaGraphRtspSourceArrayOutputWithContext(context.Background())
}

func (i MediaGraphRtspSourceArray) ToMediaGraphRtspSourceArrayOutputWithContext(ctx context.Context) MediaGraphRtspSourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphRtspSourceArrayOutput)
}

// RTSP source.
type MediaGraphRtspSourceOutput struct{ *pulumi.OutputState }

func (MediaGraphRtspSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphRtspSource)(nil)).Elem()
}

func (o MediaGraphRtspSourceOutput) ToMediaGraphRtspSourceOutput() MediaGraphRtspSourceOutput {
	return o
}

func (o MediaGraphRtspSourceOutput) ToMediaGraphRtspSourceOutputWithContext(ctx context.Context) MediaGraphRtspSourceOutput {
	return o
}

// RTSP endpoint of the stream being connected to.
func (o MediaGraphRtspSourceOutput) Endpoint() pulumi.AnyOutput {
	return o.ApplyT(func(v MediaGraphRtspSource) interface{} { return v.Endpoint }).(pulumi.AnyOutput)
}

// Source name.
func (o MediaGraphRtspSourceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphRtspSource) string { return v.Name }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphRtspSource'.
func (o MediaGraphRtspSourceOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphRtspSource) string { return v.OdataType }).(pulumi.StringOutput)
}

// Underlying RTSP transport. This can be used to enable or disable HTTP tunneling.
func (o MediaGraphRtspSourceOutput) Transport() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphRtspSource) string { return v.Transport }).(pulumi.StringOutput)
}

type MediaGraphRtspSourceArrayOutput struct{ *pulumi.OutputState }

func (MediaGraphRtspSourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MediaGraphRtspSource)(nil)).Elem()
}

func (o MediaGraphRtspSourceArrayOutput) ToMediaGraphRtspSourceArrayOutput() MediaGraphRtspSourceArrayOutput {
	return o
}

func (o MediaGraphRtspSourceArrayOutput) ToMediaGraphRtspSourceArrayOutputWithContext(ctx context.Context) MediaGraphRtspSourceArrayOutput {
	return o
}

func (o MediaGraphRtspSourceArrayOutput) Index(i pulumi.IntInput) MediaGraphRtspSourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MediaGraphRtspSource {
		return vs[0].([]MediaGraphRtspSource)[vs[1].(int)]
	}).(MediaGraphRtspSourceOutput)
}

// RTSP source.
type MediaGraphRtspSourceResponse struct {
	// RTSP endpoint of the stream being connected to.
	Endpoint interface{} `pulumi:"endpoint"`
	// Source name.
	Name string `pulumi:"name"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphRtspSource'.
	OdataType string `pulumi:"odataType"`
	// Underlying RTSP transport. This can be used to enable or disable HTTP tunneling.
	Transport string `pulumi:"transport"`
}

// RTSP source.
type MediaGraphRtspSourceResponseOutput struct{ *pulumi.OutputState }

func (MediaGraphRtspSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphRtspSourceResponse)(nil)).Elem()
}

func (o MediaGraphRtspSourceResponseOutput) ToMediaGraphRtspSourceResponseOutput() MediaGraphRtspSourceResponseOutput {
	return o
}

func (o MediaGraphRtspSourceResponseOutput) ToMediaGraphRtspSourceResponseOutputWithContext(ctx context.Context) MediaGraphRtspSourceResponseOutput {
	return o
}

// RTSP endpoint of the stream being connected to.
func (o MediaGraphRtspSourceResponseOutput) Endpoint() pulumi.AnyOutput {
	return o.ApplyT(func(v MediaGraphRtspSourceResponse) interface{} { return v.Endpoint }).(pulumi.AnyOutput)
}

// Source name.
func (o MediaGraphRtspSourceResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphRtspSourceResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphRtspSource'.
func (o MediaGraphRtspSourceResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphRtspSourceResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Underlying RTSP transport. This can be used to enable or disable HTTP tunneling.
func (o MediaGraphRtspSourceResponseOutput) Transport() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphRtspSourceResponse) string { return v.Transport }).(pulumi.StringOutput)
}

type MediaGraphRtspSourceResponseArrayOutput struct{ *pulumi.OutputState }

func (MediaGraphRtspSourceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MediaGraphRtspSourceResponse)(nil)).Elem()
}

func (o MediaGraphRtspSourceResponseArrayOutput) ToMediaGraphRtspSourceResponseArrayOutput() MediaGraphRtspSourceResponseArrayOutput {
	return o
}

func (o MediaGraphRtspSourceResponseArrayOutput) ToMediaGraphRtspSourceResponseArrayOutputWithContext(ctx context.Context) MediaGraphRtspSourceResponseArrayOutput {
	return o
}

func (o MediaGraphRtspSourceResponseArrayOutput) Index(i pulumi.IntInput) MediaGraphRtspSourceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MediaGraphRtspSourceResponse {
		return vs[0].([]MediaGraphRtspSourceResponse)[vs[1].(int)]
	}).(MediaGraphRtspSourceResponseOutput)
}

// An endpoint which must be connected over TLS/SSL.
type MediaGraphTlsEndpoint struct {
	// Polymorphic credentials to present to the endpoint.
	Credentials *MediaGraphUsernamePasswordCredentials `pulumi:"credentials"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphTlsEndpoint'.
	OdataType string `pulumi:"odataType"`
	// What certificates should be trusted when authenticating a TLS connection. Null designates that Azure Media's source of trust should be used.
	TrustedCertificates *MediaGraphPemCertificateList `pulumi:"trustedCertificates"`
	// Url for the endpoint.
	Url string `pulumi:"url"`
	// Validation options to use when authenticating a TLS connection. By default, strict validation is used.
	ValidationOptions *MediaGraphTlsValidationOptions `pulumi:"validationOptions"`
}

// MediaGraphTlsEndpointInput is an input type that accepts MediaGraphTlsEndpointArgs and MediaGraphTlsEndpointOutput values.
// You can construct a concrete instance of `MediaGraphTlsEndpointInput` via:
//
//	MediaGraphTlsEndpointArgs{...}
type MediaGraphTlsEndpointInput interface {
	pulumi.Input

	ToMediaGraphTlsEndpointOutput() MediaGraphTlsEndpointOutput
	ToMediaGraphTlsEndpointOutputWithContext(context.Context) MediaGraphTlsEndpointOutput
}

// An endpoint which must be connected over TLS/SSL.
type MediaGraphTlsEndpointArgs struct {
	// Polymorphic credentials to present to the endpoint.
	Credentials MediaGraphUsernamePasswordCredentialsPtrInput `pulumi:"credentials"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphTlsEndpoint'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// What certificates should be trusted when authenticating a TLS connection. Null designates that Azure Media's source of trust should be used.
	TrustedCertificates MediaGraphPemCertificateListPtrInput `pulumi:"trustedCertificates"`
	// Url for the endpoint.
	Url pulumi.StringInput `pulumi:"url"`
	// Validation options to use when authenticating a TLS connection. By default, strict validation is used.
	ValidationOptions MediaGraphTlsValidationOptionsPtrInput `pulumi:"validationOptions"`
}

func (MediaGraphTlsEndpointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphTlsEndpoint)(nil)).Elem()
}

func (i MediaGraphTlsEndpointArgs) ToMediaGraphTlsEndpointOutput() MediaGraphTlsEndpointOutput {
	return i.ToMediaGraphTlsEndpointOutputWithContext(context.Background())
}

func (i MediaGraphTlsEndpointArgs) ToMediaGraphTlsEndpointOutputWithContext(ctx context.Context) MediaGraphTlsEndpointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphTlsEndpointOutput)
}

// An endpoint which must be connected over TLS/SSL.
type MediaGraphTlsEndpointOutput struct{ *pulumi.OutputState }

func (MediaGraphTlsEndpointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphTlsEndpoint)(nil)).Elem()
}

func (o MediaGraphTlsEndpointOutput) ToMediaGraphTlsEndpointOutput() MediaGraphTlsEndpointOutput {
	return o
}

func (o MediaGraphTlsEndpointOutput) ToMediaGraphTlsEndpointOutputWithContext(ctx context.Context) MediaGraphTlsEndpointOutput {
	return o
}

// Polymorphic credentials to present to the endpoint.
func (o MediaGraphTlsEndpointOutput) Credentials() MediaGraphUsernamePasswordCredentialsPtrOutput {
	return o.ApplyT(func(v MediaGraphTlsEndpoint) *MediaGraphUsernamePasswordCredentials { return v.Credentials }).(MediaGraphUsernamePasswordCredentialsPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphTlsEndpoint'.
func (o MediaGraphTlsEndpointOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphTlsEndpoint) string { return v.OdataType }).(pulumi.StringOutput)
}

// What certificates should be trusted when authenticating a TLS connection. Null designates that Azure Media's source of trust should be used.
func (o MediaGraphTlsEndpointOutput) TrustedCertificates() MediaGraphPemCertificateListPtrOutput {
	return o.ApplyT(func(v MediaGraphTlsEndpoint) *MediaGraphPemCertificateList { return v.TrustedCertificates }).(MediaGraphPemCertificateListPtrOutput)
}

// Url for the endpoint.
func (o MediaGraphTlsEndpointOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphTlsEndpoint) string { return v.Url }).(pulumi.StringOutput)
}

// Validation options to use when authenticating a TLS connection. By default, strict validation is used.
func (o MediaGraphTlsEndpointOutput) ValidationOptions() MediaGraphTlsValidationOptionsPtrOutput {
	return o.ApplyT(func(v MediaGraphTlsEndpoint) *MediaGraphTlsValidationOptions { return v.ValidationOptions }).(MediaGraphTlsValidationOptionsPtrOutput)
}

// An endpoint which must be connected over TLS/SSL.
type MediaGraphTlsEndpointResponse struct {
	// Polymorphic credentials to present to the endpoint.
	Credentials *MediaGraphUsernamePasswordCredentialsResponse `pulumi:"credentials"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphTlsEndpoint'.
	OdataType string `pulumi:"odataType"`
	// What certificates should be trusted when authenticating a TLS connection. Null designates that Azure Media's source of trust should be used.
	TrustedCertificates *MediaGraphPemCertificateListResponse `pulumi:"trustedCertificates"`
	// Url for the endpoint.
	Url string `pulumi:"url"`
	// Validation options to use when authenticating a TLS connection. By default, strict validation is used.
	ValidationOptions *MediaGraphTlsValidationOptionsResponse `pulumi:"validationOptions"`
}

// An endpoint which must be connected over TLS/SSL.
type MediaGraphTlsEndpointResponseOutput struct{ *pulumi.OutputState }

func (MediaGraphTlsEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphTlsEndpointResponse)(nil)).Elem()
}

func (o MediaGraphTlsEndpointResponseOutput) ToMediaGraphTlsEndpointResponseOutput() MediaGraphTlsEndpointResponseOutput {
	return o
}

func (o MediaGraphTlsEndpointResponseOutput) ToMediaGraphTlsEndpointResponseOutputWithContext(ctx context.Context) MediaGraphTlsEndpointResponseOutput {
	return o
}

// Polymorphic credentials to present to the endpoint.
func (o MediaGraphTlsEndpointResponseOutput) Credentials() MediaGraphUsernamePasswordCredentialsResponsePtrOutput {
	return o.ApplyT(func(v MediaGraphTlsEndpointResponse) *MediaGraphUsernamePasswordCredentialsResponse {
		return v.Credentials
	}).(MediaGraphUsernamePasswordCredentialsResponsePtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphTlsEndpoint'.
func (o MediaGraphTlsEndpointResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphTlsEndpointResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// What certificates should be trusted when authenticating a TLS connection. Null designates that Azure Media's source of trust should be used.
func (o MediaGraphTlsEndpointResponseOutput) TrustedCertificates() MediaGraphPemCertificateListResponsePtrOutput {
	return o.ApplyT(func(v MediaGraphTlsEndpointResponse) *MediaGraphPemCertificateListResponse {
		return v.TrustedCertificates
	}).(MediaGraphPemCertificateListResponsePtrOutput)
}

// Url for the endpoint.
func (o MediaGraphTlsEndpointResponseOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphTlsEndpointResponse) string { return v.Url }).(pulumi.StringOutput)
}

// Validation options to use when authenticating a TLS connection. By default, strict validation is used.
func (o MediaGraphTlsEndpointResponseOutput) ValidationOptions() MediaGraphTlsValidationOptionsResponsePtrOutput {
	return o.ApplyT(func(v MediaGraphTlsEndpointResponse) *MediaGraphTlsValidationOptionsResponse {
		return v.ValidationOptions
	}).(MediaGraphTlsValidationOptionsResponsePtrOutput)
}

// Options for controlling the authentication of TLS endpoints.
type MediaGraphTlsValidationOptions struct {
	// Ignore the host name (common name) during validation.
	IgnoreHostname bool `pulumi:"ignoreHostname"`
	// Ignore the integrity of the certificate chain at the current time.
	IgnoreSignature bool `pulumi:"ignoreSignature"`
}

// MediaGraphTlsValidationOptionsInput is an input type that accepts MediaGraphTlsValidationOptionsArgs and MediaGraphTlsValidationOptionsOutput values.
// You can construct a concrete instance of `MediaGraphTlsValidationOptionsInput` via:
//
//	MediaGraphTlsValidationOptionsArgs{...}
type MediaGraphTlsValidationOptionsInput interface {
	pulumi.Input

	ToMediaGraphTlsValidationOptionsOutput() MediaGraphTlsValidationOptionsOutput
	ToMediaGraphTlsValidationOptionsOutputWithContext(context.Context) MediaGraphTlsValidationOptionsOutput
}

// Options for controlling the authentication of TLS endpoints.
type MediaGraphTlsValidationOptionsArgs struct {
	// Ignore the host name (common name) during validation.
	IgnoreHostname pulumi.BoolInput `pulumi:"ignoreHostname"`
	// Ignore the integrity of the certificate chain at the current time.
	IgnoreSignature pulumi.BoolInput `pulumi:"ignoreSignature"`
}

func (MediaGraphTlsValidationOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphTlsValidationOptions)(nil)).Elem()
}

func (i MediaGraphTlsValidationOptionsArgs) ToMediaGraphTlsValidationOptionsOutput() MediaGraphTlsValidationOptionsOutput {
	return i.ToMediaGraphTlsValidationOptionsOutputWithContext(context.Background())
}

func (i MediaGraphTlsValidationOptionsArgs) ToMediaGraphTlsValidationOptionsOutputWithContext(ctx context.Context) MediaGraphTlsValidationOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphTlsValidationOptionsOutput)
}

func (i MediaGraphTlsValidationOptionsArgs) ToMediaGraphTlsValidationOptionsPtrOutput() MediaGraphTlsValidationOptionsPtrOutput {
	return i.ToMediaGraphTlsValidationOptionsPtrOutputWithContext(context.Background())
}

func (i MediaGraphTlsValidationOptionsArgs) ToMediaGraphTlsValidationOptionsPtrOutputWithContext(ctx context.Context) MediaGraphTlsValidationOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphTlsValidationOptionsOutput).ToMediaGraphTlsValidationOptionsPtrOutputWithContext(ctx)
}

// MediaGraphTlsValidationOptionsPtrInput is an input type that accepts MediaGraphTlsValidationOptionsArgs, MediaGraphTlsValidationOptionsPtr and MediaGraphTlsValidationOptionsPtrOutput values.
// You can construct a concrete instance of `MediaGraphTlsValidationOptionsPtrInput` via:
//
//	        MediaGraphTlsValidationOptionsArgs{...}
//
//	or:
//
//	        nil
type MediaGraphTlsValidationOptionsPtrInput interface {
	pulumi.Input

	ToMediaGraphTlsValidationOptionsPtrOutput() MediaGraphTlsValidationOptionsPtrOutput
	ToMediaGraphTlsValidationOptionsPtrOutputWithContext(context.Context) MediaGraphTlsValidationOptionsPtrOutput
}

type mediaGraphTlsValidationOptionsPtrType MediaGraphTlsValidationOptionsArgs

func MediaGraphTlsValidationOptionsPtr(v *MediaGraphTlsValidationOptionsArgs) MediaGraphTlsValidationOptionsPtrInput {
	return (*mediaGraphTlsValidationOptionsPtrType)(v)
}

func (*mediaGraphTlsValidationOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaGraphTlsValidationOptions)(nil)).Elem()
}

func (i *mediaGraphTlsValidationOptionsPtrType) ToMediaGraphTlsValidationOptionsPtrOutput() MediaGraphTlsValidationOptionsPtrOutput {
	return i.ToMediaGraphTlsValidationOptionsPtrOutputWithContext(context.Background())
}

func (i *mediaGraphTlsValidationOptionsPtrType) ToMediaGraphTlsValidationOptionsPtrOutputWithContext(ctx context.Context) MediaGraphTlsValidationOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphTlsValidationOptionsPtrOutput)
}

// Options for controlling the authentication of TLS endpoints.
type MediaGraphTlsValidationOptionsOutput struct{ *pulumi.OutputState }

func (MediaGraphTlsValidationOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphTlsValidationOptions)(nil)).Elem()
}

func (o MediaGraphTlsValidationOptionsOutput) ToMediaGraphTlsValidationOptionsOutput() MediaGraphTlsValidationOptionsOutput {
	return o
}

func (o MediaGraphTlsValidationOptionsOutput) ToMediaGraphTlsValidationOptionsOutputWithContext(ctx context.Context) MediaGraphTlsValidationOptionsOutput {
	return o
}

func (o MediaGraphTlsValidationOptionsOutput) ToMediaGraphTlsValidationOptionsPtrOutput() MediaGraphTlsValidationOptionsPtrOutput {
	return o.ToMediaGraphTlsValidationOptionsPtrOutputWithContext(context.Background())
}

func (o MediaGraphTlsValidationOptionsOutput) ToMediaGraphTlsValidationOptionsPtrOutputWithContext(ctx context.Context) MediaGraphTlsValidationOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MediaGraphTlsValidationOptions) *MediaGraphTlsValidationOptions {
		return &v
	}).(MediaGraphTlsValidationOptionsPtrOutput)
}

// Ignore the host name (common name) during validation.
func (o MediaGraphTlsValidationOptionsOutput) IgnoreHostname() pulumi.BoolOutput {
	return o.ApplyT(func(v MediaGraphTlsValidationOptions) bool { return v.IgnoreHostname }).(pulumi.BoolOutput)
}

// Ignore the integrity of the certificate chain at the current time.
func (o MediaGraphTlsValidationOptionsOutput) IgnoreSignature() pulumi.BoolOutput {
	return o.ApplyT(func(v MediaGraphTlsValidationOptions) bool { return v.IgnoreSignature }).(pulumi.BoolOutput)
}

type MediaGraphTlsValidationOptionsPtrOutput struct{ *pulumi.OutputState }

func (MediaGraphTlsValidationOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaGraphTlsValidationOptions)(nil)).Elem()
}

func (o MediaGraphTlsValidationOptionsPtrOutput) ToMediaGraphTlsValidationOptionsPtrOutput() MediaGraphTlsValidationOptionsPtrOutput {
	return o
}

func (o MediaGraphTlsValidationOptionsPtrOutput) ToMediaGraphTlsValidationOptionsPtrOutputWithContext(ctx context.Context) MediaGraphTlsValidationOptionsPtrOutput {
	return o
}

func (o MediaGraphTlsValidationOptionsPtrOutput) Elem() MediaGraphTlsValidationOptionsOutput {
	return o.ApplyT(func(v *MediaGraphTlsValidationOptions) MediaGraphTlsValidationOptions {
		if v != nil {
			return *v
		}
		var ret MediaGraphTlsValidationOptions
		return ret
	}).(MediaGraphTlsValidationOptionsOutput)
}

// Ignore the host name (common name) during validation.
func (o MediaGraphTlsValidationOptionsPtrOutput) IgnoreHostname() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *MediaGraphTlsValidationOptions) *bool {
		if v == nil {
			return nil
		}
		return &v.IgnoreHostname
	}).(pulumi.BoolPtrOutput)
}

// Ignore the integrity of the certificate chain at the current time.
func (o MediaGraphTlsValidationOptionsPtrOutput) IgnoreSignature() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *MediaGraphTlsValidationOptions) *bool {
		if v == nil {
			return nil
		}
		return &v.IgnoreSignature
	}).(pulumi.BoolPtrOutput)
}

// Options for controlling the authentication of TLS endpoints.
type MediaGraphTlsValidationOptionsResponse struct {
	// Ignore the host name (common name) during validation.
	IgnoreHostname bool `pulumi:"ignoreHostname"`
	// Ignore the integrity of the certificate chain at the current time.
	IgnoreSignature bool `pulumi:"ignoreSignature"`
}

// Options for controlling the authentication of TLS endpoints.
type MediaGraphTlsValidationOptionsResponseOutput struct{ *pulumi.OutputState }

func (MediaGraphTlsValidationOptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphTlsValidationOptionsResponse)(nil)).Elem()
}

func (o MediaGraphTlsValidationOptionsResponseOutput) ToMediaGraphTlsValidationOptionsResponseOutput() MediaGraphTlsValidationOptionsResponseOutput {
	return o
}

func (o MediaGraphTlsValidationOptionsResponseOutput) ToMediaGraphTlsValidationOptionsResponseOutputWithContext(ctx context.Context) MediaGraphTlsValidationOptionsResponseOutput {
	return o
}

// Ignore the host name (common name) during validation.
func (o MediaGraphTlsValidationOptionsResponseOutput) IgnoreHostname() pulumi.BoolOutput {
	return o.ApplyT(func(v MediaGraphTlsValidationOptionsResponse) bool { return v.IgnoreHostname }).(pulumi.BoolOutput)
}

// Ignore the integrity of the certificate chain at the current time.
func (o MediaGraphTlsValidationOptionsResponseOutput) IgnoreSignature() pulumi.BoolOutput {
	return o.ApplyT(func(v MediaGraphTlsValidationOptionsResponse) bool { return v.IgnoreSignature }).(pulumi.BoolOutput)
}

type MediaGraphTlsValidationOptionsResponsePtrOutput struct{ *pulumi.OutputState }

func (MediaGraphTlsValidationOptionsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaGraphTlsValidationOptionsResponse)(nil)).Elem()
}

func (o MediaGraphTlsValidationOptionsResponsePtrOutput) ToMediaGraphTlsValidationOptionsResponsePtrOutput() MediaGraphTlsValidationOptionsResponsePtrOutput {
	return o
}

func (o MediaGraphTlsValidationOptionsResponsePtrOutput) ToMediaGraphTlsValidationOptionsResponsePtrOutputWithContext(ctx context.Context) MediaGraphTlsValidationOptionsResponsePtrOutput {
	return o
}

func (o MediaGraphTlsValidationOptionsResponsePtrOutput) Elem() MediaGraphTlsValidationOptionsResponseOutput {
	return o.ApplyT(func(v *MediaGraphTlsValidationOptionsResponse) MediaGraphTlsValidationOptionsResponse {
		if v != nil {
			return *v
		}
		var ret MediaGraphTlsValidationOptionsResponse
		return ret
	}).(MediaGraphTlsValidationOptionsResponseOutput)
}

// Ignore the host name (common name) during validation.
func (o MediaGraphTlsValidationOptionsResponsePtrOutput) IgnoreHostname() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *MediaGraphTlsValidationOptionsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.IgnoreHostname
	}).(pulumi.BoolPtrOutput)
}

// Ignore the integrity of the certificate chain at the current time.
func (o MediaGraphTlsValidationOptionsResponsePtrOutput) IgnoreSignature() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *MediaGraphTlsValidationOptionsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.IgnoreSignature
	}).(pulumi.BoolPtrOutput)
}

// Username/password credential pair.
type MediaGraphUsernamePasswordCredentials struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphUsernamePasswordCredentials'.
	OdataType string `pulumi:"odataType"`
	// Password for a username/password pair.
	Password string `pulumi:"password"`
	// Username for a username/password pair.
	Username string `pulumi:"username"`
}

// MediaGraphUsernamePasswordCredentialsInput is an input type that accepts MediaGraphUsernamePasswordCredentialsArgs and MediaGraphUsernamePasswordCredentialsOutput values.
// You can construct a concrete instance of `MediaGraphUsernamePasswordCredentialsInput` via:
//
//	MediaGraphUsernamePasswordCredentialsArgs{...}
type MediaGraphUsernamePasswordCredentialsInput interface {
	pulumi.Input

	ToMediaGraphUsernamePasswordCredentialsOutput() MediaGraphUsernamePasswordCredentialsOutput
	ToMediaGraphUsernamePasswordCredentialsOutputWithContext(context.Context) MediaGraphUsernamePasswordCredentialsOutput
}

// Username/password credential pair.
type MediaGraphUsernamePasswordCredentialsArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphUsernamePasswordCredentials'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Password for a username/password pair.
	Password pulumi.StringInput `pulumi:"password"`
	// Username for a username/password pair.
	Username pulumi.StringInput `pulumi:"username"`
}

func (MediaGraphUsernamePasswordCredentialsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphUsernamePasswordCredentials)(nil)).Elem()
}

func (i MediaGraphUsernamePasswordCredentialsArgs) ToMediaGraphUsernamePasswordCredentialsOutput() MediaGraphUsernamePasswordCredentialsOutput {
	return i.ToMediaGraphUsernamePasswordCredentialsOutputWithContext(context.Background())
}

func (i MediaGraphUsernamePasswordCredentialsArgs) ToMediaGraphUsernamePasswordCredentialsOutputWithContext(ctx context.Context) MediaGraphUsernamePasswordCredentialsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphUsernamePasswordCredentialsOutput)
}

func (i MediaGraphUsernamePasswordCredentialsArgs) ToMediaGraphUsernamePasswordCredentialsPtrOutput() MediaGraphUsernamePasswordCredentialsPtrOutput {
	return i.ToMediaGraphUsernamePasswordCredentialsPtrOutputWithContext(context.Background())
}

func (i MediaGraphUsernamePasswordCredentialsArgs) ToMediaGraphUsernamePasswordCredentialsPtrOutputWithContext(ctx context.Context) MediaGraphUsernamePasswordCredentialsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphUsernamePasswordCredentialsOutput).ToMediaGraphUsernamePasswordCredentialsPtrOutputWithContext(ctx)
}

// MediaGraphUsernamePasswordCredentialsPtrInput is an input type that accepts MediaGraphUsernamePasswordCredentialsArgs, MediaGraphUsernamePasswordCredentialsPtr and MediaGraphUsernamePasswordCredentialsPtrOutput values.
// You can construct a concrete instance of `MediaGraphUsernamePasswordCredentialsPtrInput` via:
//
//	        MediaGraphUsernamePasswordCredentialsArgs{...}
//
//	or:
//
//	        nil
type MediaGraphUsernamePasswordCredentialsPtrInput interface {
	pulumi.Input

	ToMediaGraphUsernamePasswordCredentialsPtrOutput() MediaGraphUsernamePasswordCredentialsPtrOutput
	ToMediaGraphUsernamePasswordCredentialsPtrOutputWithContext(context.Context) MediaGraphUsernamePasswordCredentialsPtrOutput
}

type mediaGraphUsernamePasswordCredentialsPtrType MediaGraphUsernamePasswordCredentialsArgs

func MediaGraphUsernamePasswordCredentialsPtr(v *MediaGraphUsernamePasswordCredentialsArgs) MediaGraphUsernamePasswordCredentialsPtrInput {
	return (*mediaGraphUsernamePasswordCredentialsPtrType)(v)
}

func (*mediaGraphUsernamePasswordCredentialsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaGraphUsernamePasswordCredentials)(nil)).Elem()
}

func (i *mediaGraphUsernamePasswordCredentialsPtrType) ToMediaGraphUsernamePasswordCredentialsPtrOutput() MediaGraphUsernamePasswordCredentialsPtrOutput {
	return i.ToMediaGraphUsernamePasswordCredentialsPtrOutputWithContext(context.Background())
}

func (i *mediaGraphUsernamePasswordCredentialsPtrType) ToMediaGraphUsernamePasswordCredentialsPtrOutputWithContext(ctx context.Context) MediaGraphUsernamePasswordCredentialsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaGraphUsernamePasswordCredentialsPtrOutput)
}

// Username/password credential pair.
type MediaGraphUsernamePasswordCredentialsOutput struct{ *pulumi.OutputState }

func (MediaGraphUsernamePasswordCredentialsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphUsernamePasswordCredentials)(nil)).Elem()
}

func (o MediaGraphUsernamePasswordCredentialsOutput) ToMediaGraphUsernamePasswordCredentialsOutput() MediaGraphUsernamePasswordCredentialsOutput {
	return o
}

func (o MediaGraphUsernamePasswordCredentialsOutput) ToMediaGraphUsernamePasswordCredentialsOutputWithContext(ctx context.Context) MediaGraphUsernamePasswordCredentialsOutput {
	return o
}

func (o MediaGraphUsernamePasswordCredentialsOutput) ToMediaGraphUsernamePasswordCredentialsPtrOutput() MediaGraphUsernamePasswordCredentialsPtrOutput {
	return o.ToMediaGraphUsernamePasswordCredentialsPtrOutputWithContext(context.Background())
}

func (o MediaGraphUsernamePasswordCredentialsOutput) ToMediaGraphUsernamePasswordCredentialsPtrOutputWithContext(ctx context.Context) MediaGraphUsernamePasswordCredentialsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MediaGraphUsernamePasswordCredentials) *MediaGraphUsernamePasswordCredentials {
		return &v
	}).(MediaGraphUsernamePasswordCredentialsPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphUsernamePasswordCredentials'.
func (o MediaGraphUsernamePasswordCredentialsOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphUsernamePasswordCredentials) string { return v.OdataType }).(pulumi.StringOutput)
}

// Password for a username/password pair.
func (o MediaGraphUsernamePasswordCredentialsOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphUsernamePasswordCredentials) string { return v.Password }).(pulumi.StringOutput)
}

// Username for a username/password pair.
func (o MediaGraphUsernamePasswordCredentialsOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphUsernamePasswordCredentials) string { return v.Username }).(pulumi.StringOutput)
}

type MediaGraphUsernamePasswordCredentialsPtrOutput struct{ *pulumi.OutputState }

func (MediaGraphUsernamePasswordCredentialsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaGraphUsernamePasswordCredentials)(nil)).Elem()
}

func (o MediaGraphUsernamePasswordCredentialsPtrOutput) ToMediaGraphUsernamePasswordCredentialsPtrOutput() MediaGraphUsernamePasswordCredentialsPtrOutput {
	return o
}

func (o MediaGraphUsernamePasswordCredentialsPtrOutput) ToMediaGraphUsernamePasswordCredentialsPtrOutputWithContext(ctx context.Context) MediaGraphUsernamePasswordCredentialsPtrOutput {
	return o
}

func (o MediaGraphUsernamePasswordCredentialsPtrOutput) Elem() MediaGraphUsernamePasswordCredentialsOutput {
	return o.ApplyT(func(v *MediaGraphUsernamePasswordCredentials) MediaGraphUsernamePasswordCredentials {
		if v != nil {
			return *v
		}
		var ret MediaGraphUsernamePasswordCredentials
		return ret
	}).(MediaGraphUsernamePasswordCredentialsOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphUsernamePasswordCredentials'.
func (o MediaGraphUsernamePasswordCredentialsPtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaGraphUsernamePasswordCredentials) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// Password for a username/password pair.
func (o MediaGraphUsernamePasswordCredentialsPtrOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaGraphUsernamePasswordCredentials) *string {
		if v == nil {
			return nil
		}
		return &v.Password
	}).(pulumi.StringPtrOutput)
}

// Username for a username/password pair.
func (o MediaGraphUsernamePasswordCredentialsPtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaGraphUsernamePasswordCredentials) *string {
		if v == nil {
			return nil
		}
		return &v.Username
	}).(pulumi.StringPtrOutput)
}

// Username/password credential pair.
type MediaGraphUsernamePasswordCredentialsResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MediaGraphUsernamePasswordCredentials'.
	OdataType string `pulumi:"odataType"`
	// Password for a username/password pair.
	Password string `pulumi:"password"`
	// Username for a username/password pair.
	Username string `pulumi:"username"`
}

// Username/password credential pair.
type MediaGraphUsernamePasswordCredentialsResponseOutput struct{ *pulumi.OutputState }

func (MediaGraphUsernamePasswordCredentialsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaGraphUsernamePasswordCredentialsResponse)(nil)).Elem()
}

func (o MediaGraphUsernamePasswordCredentialsResponseOutput) ToMediaGraphUsernamePasswordCredentialsResponseOutput() MediaGraphUsernamePasswordCredentialsResponseOutput {
	return o
}

func (o MediaGraphUsernamePasswordCredentialsResponseOutput) ToMediaGraphUsernamePasswordCredentialsResponseOutputWithContext(ctx context.Context) MediaGraphUsernamePasswordCredentialsResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphUsernamePasswordCredentials'.
func (o MediaGraphUsernamePasswordCredentialsResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphUsernamePasswordCredentialsResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Password for a username/password pair.
func (o MediaGraphUsernamePasswordCredentialsResponseOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphUsernamePasswordCredentialsResponse) string { return v.Password }).(pulumi.StringOutput)
}

// Username for a username/password pair.
func (o MediaGraphUsernamePasswordCredentialsResponseOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v MediaGraphUsernamePasswordCredentialsResponse) string { return v.Username }).(pulumi.StringOutput)
}

type MediaGraphUsernamePasswordCredentialsResponsePtrOutput struct{ *pulumi.OutputState }

func (MediaGraphUsernamePasswordCredentialsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaGraphUsernamePasswordCredentialsResponse)(nil)).Elem()
}

func (o MediaGraphUsernamePasswordCredentialsResponsePtrOutput) ToMediaGraphUsernamePasswordCredentialsResponsePtrOutput() MediaGraphUsernamePasswordCredentialsResponsePtrOutput {
	return o
}

func (o MediaGraphUsernamePasswordCredentialsResponsePtrOutput) ToMediaGraphUsernamePasswordCredentialsResponsePtrOutputWithContext(ctx context.Context) MediaGraphUsernamePasswordCredentialsResponsePtrOutput {
	return o
}

func (o MediaGraphUsernamePasswordCredentialsResponsePtrOutput) Elem() MediaGraphUsernamePasswordCredentialsResponseOutput {
	return o.ApplyT(func(v *MediaGraphUsernamePasswordCredentialsResponse) MediaGraphUsernamePasswordCredentialsResponse {
		if v != nil {
			return *v
		}
		var ret MediaGraphUsernamePasswordCredentialsResponse
		return ret
	}).(MediaGraphUsernamePasswordCredentialsResponseOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MediaGraphUsernamePasswordCredentials'.
func (o MediaGraphUsernamePasswordCredentialsResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaGraphUsernamePasswordCredentialsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// Password for a username/password pair.
func (o MediaGraphUsernamePasswordCredentialsResponsePtrOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaGraphUsernamePasswordCredentialsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Password
	}).(pulumi.StringPtrOutput)
}

// Username for a username/password pair.
func (o MediaGraphUsernamePasswordCredentialsResponsePtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaGraphUsernamePasswordCredentialsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Username
	}).(pulumi.StringPtrOutput)
}

type MediaServiceIdentity struct {
	// The identity type.
	Type string `pulumi:"type"`
	// The user assigned managed identities.
	UserAssignedIdentities []string `pulumi:"userAssignedIdentities"`
}

// MediaServiceIdentityInput is an input type that accepts MediaServiceIdentityArgs and MediaServiceIdentityOutput values.
// You can construct a concrete instance of `MediaServiceIdentityInput` via:
//
//	MediaServiceIdentityArgs{...}
type MediaServiceIdentityInput interface {
	pulumi.Input

	ToMediaServiceIdentityOutput() MediaServiceIdentityOutput
	ToMediaServiceIdentityOutputWithContext(context.Context) MediaServiceIdentityOutput
}

type MediaServiceIdentityArgs struct {
	// The identity type.
	Type pulumi.StringInput `pulumi:"type"`
	// The user assigned managed identities.
	UserAssignedIdentities pulumi.StringArrayInput `pulumi:"userAssignedIdentities"`
}

func (MediaServiceIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaServiceIdentity)(nil)).Elem()
}

func (i MediaServiceIdentityArgs) ToMediaServiceIdentityOutput() MediaServiceIdentityOutput {
	return i.ToMediaServiceIdentityOutputWithContext(context.Background())
}

func (i MediaServiceIdentityArgs) ToMediaServiceIdentityOutputWithContext(ctx context.Context) MediaServiceIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaServiceIdentityOutput)
}

func (i MediaServiceIdentityArgs) ToMediaServiceIdentityPtrOutput() MediaServiceIdentityPtrOutput {
	return i.ToMediaServiceIdentityPtrOutputWithContext(context.Background())
}

func (i MediaServiceIdentityArgs) ToMediaServiceIdentityPtrOutputWithContext(ctx context.Context) MediaServiceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaServiceIdentityOutput).ToMediaServiceIdentityPtrOutputWithContext(ctx)
}

// MediaServiceIdentityPtrInput is an input type that accepts MediaServiceIdentityArgs, MediaServiceIdentityPtr and MediaServiceIdentityPtrOutput values.
// You can construct a concrete instance of `MediaServiceIdentityPtrInput` via:
//
//	        MediaServiceIdentityArgs{...}
//
//	or:
//
//	        nil
type MediaServiceIdentityPtrInput interface {
	pulumi.Input

	ToMediaServiceIdentityPtrOutput() MediaServiceIdentityPtrOutput
	ToMediaServiceIdentityPtrOutputWithContext(context.Context) MediaServiceIdentityPtrOutput
}

type mediaServiceIdentityPtrType MediaServiceIdentityArgs

func MediaServiceIdentityPtr(v *MediaServiceIdentityArgs) MediaServiceIdentityPtrInput {
	return (*mediaServiceIdentityPtrType)(v)
}

func (*mediaServiceIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaServiceIdentity)(nil)).Elem()
}

func (i *mediaServiceIdentityPtrType) ToMediaServiceIdentityPtrOutput() MediaServiceIdentityPtrOutput {
	return i.ToMediaServiceIdentityPtrOutputWithContext(context.Background())
}

func (i *mediaServiceIdentityPtrType) ToMediaServiceIdentityPtrOutputWithContext(ctx context.Context) MediaServiceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaServiceIdentityPtrOutput)
}

type MediaServiceIdentityOutput struct{ *pulumi.OutputState }

func (MediaServiceIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaServiceIdentity)(nil)).Elem()
}

func (o MediaServiceIdentityOutput) ToMediaServiceIdentityOutput() MediaServiceIdentityOutput {
	return o
}

func (o MediaServiceIdentityOutput) ToMediaServiceIdentityOutputWithContext(ctx context.Context) MediaServiceIdentityOutput {
	return o
}

func (o MediaServiceIdentityOutput) ToMediaServiceIdentityPtrOutput() MediaServiceIdentityPtrOutput {
	return o.ToMediaServiceIdentityPtrOutputWithContext(context.Background())
}

func (o MediaServiceIdentityOutput) ToMediaServiceIdentityPtrOutputWithContext(ctx context.Context) MediaServiceIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MediaServiceIdentity) *MediaServiceIdentity {
		return &v
	}).(MediaServiceIdentityPtrOutput)
}

// The identity type.
func (o MediaServiceIdentityOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MediaServiceIdentity) string { return v.Type }).(pulumi.StringOutput)
}

// The user assigned managed identities.
func (o MediaServiceIdentityOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v MediaServiceIdentity) []string { return v.UserAssignedIdentities }).(pulumi.StringArrayOutput)
}

type MediaServiceIdentityPtrOutput struct{ *pulumi.OutputState }

func (MediaServiceIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaServiceIdentity)(nil)).Elem()
}

func (o MediaServiceIdentityPtrOutput) ToMediaServiceIdentityPtrOutput() MediaServiceIdentityPtrOutput {
	return o
}

func (o MediaServiceIdentityPtrOutput) ToMediaServiceIdentityPtrOutputWithContext(ctx context.Context) MediaServiceIdentityPtrOutput {
	return o
}

func (o MediaServiceIdentityPtrOutput) Elem() MediaServiceIdentityOutput {
	return o.ApplyT(func(v *MediaServiceIdentity) MediaServiceIdentity {
		if v != nil {
			return *v
		}
		var ret MediaServiceIdentity
		return ret
	}).(MediaServiceIdentityOutput)
}

// The identity type.
func (o MediaServiceIdentityPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaServiceIdentity) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The user assigned managed identities.
func (o MediaServiceIdentityPtrOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *MediaServiceIdentity) []string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.StringArrayOutput)
}

type MediaServiceIdentityResponse struct {
	// The Principal ID of the identity.
	PrincipalId string `pulumi:"principalId"`
	// The Tenant ID of the identity.
	TenantId string `pulumi:"tenantId"`
	// The identity type.
	Type string `pulumi:"type"`
	// The user assigned managed identities.
	UserAssignedIdentities map[string]UserAssignedManagedIdentityResponse `pulumi:"userAssignedIdentities"`
}

type MediaServiceIdentityResponseOutput struct{ *pulumi.OutputState }

func (MediaServiceIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaServiceIdentityResponse)(nil)).Elem()
}

func (o MediaServiceIdentityResponseOutput) ToMediaServiceIdentityResponseOutput() MediaServiceIdentityResponseOutput {
	return o
}

func (o MediaServiceIdentityResponseOutput) ToMediaServiceIdentityResponseOutputWithContext(ctx context.Context) MediaServiceIdentityResponseOutput {
	return o
}

// The Principal ID of the identity.
func (o MediaServiceIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v MediaServiceIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

// The Tenant ID of the identity.
func (o MediaServiceIdentityResponseOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v MediaServiceIdentityResponse) string { return v.TenantId }).(pulumi.StringOutput)
}

// The identity type.
func (o MediaServiceIdentityResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MediaServiceIdentityResponse) string { return v.Type }).(pulumi.StringOutput)
}

// The user assigned managed identities.
func (o MediaServiceIdentityResponseOutput) UserAssignedIdentities() UserAssignedManagedIdentityResponseMapOutput {
	return o.ApplyT(func(v MediaServiceIdentityResponse) map[string]UserAssignedManagedIdentityResponse {
		return v.UserAssignedIdentities
	}).(UserAssignedManagedIdentityResponseMapOutput)
}

type MediaServiceIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (MediaServiceIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaServiceIdentityResponse)(nil)).Elem()
}

func (o MediaServiceIdentityResponsePtrOutput) ToMediaServiceIdentityResponsePtrOutput() MediaServiceIdentityResponsePtrOutput {
	return o
}

func (o MediaServiceIdentityResponsePtrOutput) ToMediaServiceIdentityResponsePtrOutputWithContext(ctx context.Context) MediaServiceIdentityResponsePtrOutput {
	return o
}

func (o MediaServiceIdentityResponsePtrOutput) Elem() MediaServiceIdentityResponseOutput {
	return o.ApplyT(func(v *MediaServiceIdentityResponse) MediaServiceIdentityResponse {
		if v != nil {
			return *v
		}
		var ret MediaServiceIdentityResponse
		return ret
	}).(MediaServiceIdentityResponseOutput)
}

// The Principal ID of the identity.
func (o MediaServiceIdentityResponsePtrOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PrincipalId
	}).(pulumi.StringPtrOutput)
}

// The Tenant ID of the identity.
func (o MediaServiceIdentityResponsePtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TenantId
	}).(pulumi.StringPtrOutput)
}

// The identity type.
func (o MediaServiceIdentityResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The user assigned managed identities.
func (o MediaServiceIdentityResponsePtrOutput) UserAssignedIdentities() UserAssignedManagedIdentityResponseMapOutput {
	return o.ApplyT(func(v *MediaServiceIdentityResponse) map[string]UserAssignedManagedIdentityResponse {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(UserAssignedManagedIdentityResponseMapOutput)
}

// Describes the properties for an output ISO MP4 file.
type Mp4Format struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Mp4Format'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFile `pulumi:"outputFiles"`
}

// Mp4FormatInput is an input type that accepts Mp4FormatArgs and Mp4FormatOutput values.
// You can construct a concrete instance of `Mp4FormatInput` via:
//
//	Mp4FormatArgs{...}
type Mp4FormatInput interface {
	pulumi.Input

	ToMp4FormatOutput() Mp4FormatOutput
	ToMp4FormatOutputWithContext(context.Context) Mp4FormatOutput
}

// Describes the properties for an output ISO MP4 file.
type Mp4FormatArgs struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern pulumi.StringInput `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Mp4Format'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles OutputFileArrayInput `pulumi:"outputFiles"`
}

func (Mp4FormatArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Mp4Format)(nil)).Elem()
}

func (i Mp4FormatArgs) ToMp4FormatOutput() Mp4FormatOutput {
	return i.ToMp4FormatOutputWithContext(context.Background())
}

func (i Mp4FormatArgs) ToMp4FormatOutputWithContext(ctx context.Context) Mp4FormatOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Mp4FormatOutput)
}

// Describes the properties for an output ISO MP4 file.
type Mp4FormatOutput struct{ *pulumi.OutputState }

func (Mp4FormatOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Mp4Format)(nil)).Elem()
}

func (o Mp4FormatOutput) ToMp4FormatOutput() Mp4FormatOutput {
	return o
}

func (o Mp4FormatOutput) ToMp4FormatOutputWithContext(ctx context.Context) Mp4FormatOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o Mp4FormatOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v Mp4Format) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.Mp4Format'.
func (o Mp4FormatOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v Mp4Format) string { return v.OdataType }).(pulumi.StringOutput)
}

// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
func (o Mp4FormatOutput) OutputFiles() OutputFileArrayOutput {
	return o.ApplyT(func(v Mp4Format) []OutputFile { return v.OutputFiles }).(OutputFileArrayOutput)
}

// Describes the properties for an output ISO MP4 file.
type Mp4FormatResponse struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Mp4Format'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFileResponse `pulumi:"outputFiles"`
}

// Describes the properties for an output ISO MP4 file.
type Mp4FormatResponseOutput struct{ *pulumi.OutputState }

func (Mp4FormatResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Mp4FormatResponse)(nil)).Elem()
}

func (o Mp4FormatResponseOutput) ToMp4FormatResponseOutput() Mp4FormatResponseOutput {
	return o
}

func (o Mp4FormatResponseOutput) ToMp4FormatResponseOutputWithContext(ctx context.Context) Mp4FormatResponseOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o Mp4FormatResponseOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v Mp4FormatResponse) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.Mp4Format'.
func (o Mp4FormatResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v Mp4FormatResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
func (o Mp4FormatResponseOutput) OutputFiles() OutputFileResponseArrayOutput {
	return o.ApplyT(func(v Mp4FormatResponse) []OutputFileResponse { return v.OutputFiles }).(OutputFileResponseArrayOutput)
}

// Describes the properties for producing a collection of GOP aligned multi-bitrate files. The default behavior is to produce one output file for each video layer which is muxed together with all the audios. The exact output files produced can be controlled by specifying the outputFiles collection.
type MultiBitrateFormat struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MultiBitrateFormat'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFile `pulumi:"outputFiles"`
}

// MultiBitrateFormatInput is an input type that accepts MultiBitrateFormatArgs and MultiBitrateFormatOutput values.
// You can construct a concrete instance of `MultiBitrateFormatInput` via:
//
//	MultiBitrateFormatArgs{...}
type MultiBitrateFormatInput interface {
	pulumi.Input

	ToMultiBitrateFormatOutput() MultiBitrateFormatOutput
	ToMultiBitrateFormatOutputWithContext(context.Context) MultiBitrateFormatOutput
}

// Describes the properties for producing a collection of GOP aligned multi-bitrate files. The default behavior is to produce one output file for each video layer which is muxed together with all the audios. The exact output files produced can be controlled by specifying the outputFiles collection.
type MultiBitrateFormatArgs struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern pulumi.StringInput `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MultiBitrateFormat'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles OutputFileArrayInput `pulumi:"outputFiles"`
}

func (MultiBitrateFormatArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MultiBitrateFormat)(nil)).Elem()
}

func (i MultiBitrateFormatArgs) ToMultiBitrateFormatOutput() MultiBitrateFormatOutput {
	return i.ToMultiBitrateFormatOutputWithContext(context.Background())
}

func (i MultiBitrateFormatArgs) ToMultiBitrateFormatOutputWithContext(ctx context.Context) MultiBitrateFormatOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MultiBitrateFormatOutput)
}

// Describes the properties for producing a collection of GOP aligned multi-bitrate files. The default behavior is to produce one output file for each video layer which is muxed together with all the audios. The exact output files produced can be controlled by specifying the outputFiles collection.
type MultiBitrateFormatOutput struct{ *pulumi.OutputState }

func (MultiBitrateFormatOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MultiBitrateFormat)(nil)).Elem()
}

func (o MultiBitrateFormatOutput) ToMultiBitrateFormatOutput() MultiBitrateFormatOutput {
	return o
}

func (o MultiBitrateFormatOutput) ToMultiBitrateFormatOutputWithContext(ctx context.Context) MultiBitrateFormatOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o MultiBitrateFormatOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v MultiBitrateFormat) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MultiBitrateFormat'.
func (o MultiBitrateFormatOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MultiBitrateFormat) string { return v.OdataType }).(pulumi.StringOutput)
}

// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
func (o MultiBitrateFormatOutput) OutputFiles() OutputFileArrayOutput {
	return o.ApplyT(func(v MultiBitrateFormat) []OutputFile { return v.OutputFiles }).(OutputFileArrayOutput)
}

// Describes the properties for producing a collection of GOP aligned multi-bitrate files. The default behavior is to produce one output file for each video layer which is muxed together with all the audios. The exact output files produced can be controlled by specifying the outputFiles collection.
type MultiBitrateFormatResponse struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MultiBitrateFormat'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFileResponse `pulumi:"outputFiles"`
}

// Describes the properties for producing a collection of GOP aligned multi-bitrate files. The default behavior is to produce one output file for each video layer which is muxed together with all the audios. The exact output files produced can be controlled by specifying the outputFiles collection.
type MultiBitrateFormatResponseOutput struct{ *pulumi.OutputState }

func (MultiBitrateFormatResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MultiBitrateFormatResponse)(nil)).Elem()
}

func (o MultiBitrateFormatResponseOutput) ToMultiBitrateFormatResponseOutput() MultiBitrateFormatResponseOutput {
	return o
}

func (o MultiBitrateFormatResponseOutput) ToMultiBitrateFormatResponseOutputWithContext(ctx context.Context) MultiBitrateFormatResponseOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o MultiBitrateFormatResponseOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v MultiBitrateFormatResponse) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.MultiBitrateFormat'.
func (o MultiBitrateFormatResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v MultiBitrateFormatResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
func (o MultiBitrateFormatResponseOutput) OutputFiles() OutputFileResponseArrayOutput {
	return o.ApplyT(func(v MultiBitrateFormatResponse) []OutputFileResponse { return v.OutputFiles }).(OutputFileResponseArrayOutput)
}

// Class for NoEncryption scheme
type NoEncryption struct {
	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `pulumi:"enabledProtocols"`
}

// NoEncryptionInput is an input type that accepts NoEncryptionArgs and NoEncryptionOutput values.
// You can construct a concrete instance of `NoEncryptionInput` via:
//
//	NoEncryptionArgs{...}
type NoEncryptionInput interface {
	pulumi.Input

	ToNoEncryptionOutput() NoEncryptionOutput
	ToNoEncryptionOutputWithContext(context.Context) NoEncryptionOutput
}

// Class for NoEncryption scheme
type NoEncryptionArgs struct {
	// Representing supported protocols
	EnabledProtocols EnabledProtocolsPtrInput `pulumi:"enabledProtocols"`
}

func (NoEncryptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NoEncryption)(nil)).Elem()
}

func (i NoEncryptionArgs) ToNoEncryptionOutput() NoEncryptionOutput {
	return i.ToNoEncryptionOutputWithContext(context.Background())
}

func (i NoEncryptionArgs) ToNoEncryptionOutputWithContext(ctx context.Context) NoEncryptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoEncryptionOutput)
}

func (i NoEncryptionArgs) ToNoEncryptionPtrOutput() NoEncryptionPtrOutput {
	return i.ToNoEncryptionPtrOutputWithContext(context.Background())
}

func (i NoEncryptionArgs) ToNoEncryptionPtrOutputWithContext(ctx context.Context) NoEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoEncryptionOutput).ToNoEncryptionPtrOutputWithContext(ctx)
}

// NoEncryptionPtrInput is an input type that accepts NoEncryptionArgs, NoEncryptionPtr and NoEncryptionPtrOutput values.
// You can construct a concrete instance of `NoEncryptionPtrInput` via:
//
//	        NoEncryptionArgs{...}
//
//	or:
//
//	        nil
type NoEncryptionPtrInput interface {
	pulumi.Input

	ToNoEncryptionPtrOutput() NoEncryptionPtrOutput
	ToNoEncryptionPtrOutputWithContext(context.Context) NoEncryptionPtrOutput
}

type noEncryptionPtrType NoEncryptionArgs

func NoEncryptionPtr(v *NoEncryptionArgs) NoEncryptionPtrInput {
	return (*noEncryptionPtrType)(v)
}

func (*noEncryptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NoEncryption)(nil)).Elem()
}

func (i *noEncryptionPtrType) ToNoEncryptionPtrOutput() NoEncryptionPtrOutput {
	return i.ToNoEncryptionPtrOutputWithContext(context.Background())
}

func (i *noEncryptionPtrType) ToNoEncryptionPtrOutputWithContext(ctx context.Context) NoEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoEncryptionPtrOutput)
}

// Class for NoEncryption scheme
type NoEncryptionOutput struct{ *pulumi.OutputState }

func (NoEncryptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NoEncryption)(nil)).Elem()
}

func (o NoEncryptionOutput) ToNoEncryptionOutput() NoEncryptionOutput {
	return o
}

func (o NoEncryptionOutput) ToNoEncryptionOutputWithContext(ctx context.Context) NoEncryptionOutput {
	return o
}

func (o NoEncryptionOutput) ToNoEncryptionPtrOutput() NoEncryptionPtrOutput {
	return o.ToNoEncryptionPtrOutputWithContext(context.Background())
}

func (o NoEncryptionOutput) ToNoEncryptionPtrOutputWithContext(ctx context.Context) NoEncryptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NoEncryption) *NoEncryption {
		return &v
	}).(NoEncryptionPtrOutput)
}

// Representing supported protocols
func (o NoEncryptionOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v NoEncryption) *EnabledProtocols { return v.EnabledProtocols }).(EnabledProtocolsPtrOutput)
}

type NoEncryptionPtrOutput struct{ *pulumi.OutputState }

func (NoEncryptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NoEncryption)(nil)).Elem()
}

func (o NoEncryptionPtrOutput) ToNoEncryptionPtrOutput() NoEncryptionPtrOutput {
	return o
}

func (o NoEncryptionPtrOutput) ToNoEncryptionPtrOutputWithContext(ctx context.Context) NoEncryptionPtrOutput {
	return o
}

func (o NoEncryptionPtrOutput) Elem() NoEncryptionOutput {
	return o.ApplyT(func(v *NoEncryption) NoEncryption {
		if v != nil {
			return *v
		}
		var ret NoEncryption
		return ret
	}).(NoEncryptionOutput)
}

// Representing supported protocols
func (o NoEncryptionPtrOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v *NoEncryption) *EnabledProtocols {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsPtrOutput)
}

// Class for NoEncryption scheme
type NoEncryptionResponse struct {
	// Representing supported protocols
	EnabledProtocols *EnabledProtocolsResponse `pulumi:"enabledProtocols"`
}

// Class for NoEncryption scheme
type NoEncryptionResponseOutput struct{ *pulumi.OutputState }

func (NoEncryptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NoEncryptionResponse)(nil)).Elem()
}

func (o NoEncryptionResponseOutput) ToNoEncryptionResponseOutput() NoEncryptionResponseOutput {
	return o
}

func (o NoEncryptionResponseOutput) ToNoEncryptionResponseOutputWithContext(ctx context.Context) NoEncryptionResponseOutput {
	return o
}

// Representing supported protocols
func (o NoEncryptionResponseOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v NoEncryptionResponse) *EnabledProtocolsResponse { return v.EnabledProtocols }).(EnabledProtocolsResponsePtrOutput)
}

type NoEncryptionResponsePtrOutput struct{ *pulumi.OutputState }

func (NoEncryptionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NoEncryptionResponse)(nil)).Elem()
}

func (o NoEncryptionResponsePtrOutput) ToNoEncryptionResponsePtrOutput() NoEncryptionResponsePtrOutput {
	return o
}

func (o NoEncryptionResponsePtrOutput) ToNoEncryptionResponsePtrOutputWithContext(ctx context.Context) NoEncryptionResponsePtrOutput {
	return o
}

func (o NoEncryptionResponsePtrOutput) Elem() NoEncryptionResponseOutput {
	return o.ApplyT(func(v *NoEncryptionResponse) NoEncryptionResponse {
		if v != nil {
			return *v
		}
		var ret NoEncryptionResponse
		return ret
	}).(NoEncryptionResponseOutput)
}

// Representing supported protocols
func (o NoEncryptionResponsePtrOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v *NoEncryptionResponse) *EnabledProtocolsResponse {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsResponsePtrOutput)
}

// Represents an output file produced.
type OutputFile struct {
	// The list of labels that describe how the encoder should multiplex video and audio into an output file. For example, if the encoder is producing two video layers with labels v1 and v2, and one audio layer with label a1, then an array like '[v1, a1]' tells the encoder to produce an output file with the video track represented by v1 and the audio track represented by a1.
	Labels []string `pulumi:"labels"`
}

// OutputFileInput is an input type that accepts OutputFileArgs and OutputFileOutput values.
// You can construct a concrete instance of `OutputFileInput` via:
//
//	OutputFileArgs{...}
type OutputFileInput interface {
	pulumi.Input

	ToOutputFileOutput() OutputFileOutput
	ToOutputFileOutputWithContext(context.Context) OutputFileOutput
}

// Represents an output file produced.
type OutputFileArgs struct {
	// The list of labels that describe how the encoder should multiplex video and audio into an output file. For example, if the encoder is producing two video layers with labels v1 and v2, and one audio layer with label a1, then an array like '[v1, a1]' tells the encoder to produce an output file with the video track represented by v1 and the audio track represented by a1.
	Labels pulumi.StringArrayInput `pulumi:"labels"`
}

func (OutputFileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OutputFile)(nil)).Elem()
}

func (i OutputFileArgs) ToOutputFileOutput() OutputFileOutput {
	return i.ToOutputFileOutputWithContext(context.Background())
}

func (i OutputFileArgs) ToOutputFileOutputWithContext(ctx context.Context) OutputFileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OutputFileOutput)
}

// OutputFileArrayInput is an input type that accepts OutputFileArray and OutputFileArrayOutput values.
// You can construct a concrete instance of `OutputFileArrayInput` via:
//
//	OutputFileArray{ OutputFileArgs{...} }
type OutputFileArrayInput interface {
	pulumi.Input

	ToOutputFileArrayOutput() OutputFileArrayOutput
	ToOutputFileArrayOutputWithContext(context.Context) OutputFileArrayOutput
}

type OutputFileArray []OutputFileInput

func (OutputFileArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OutputFile)(nil)).Elem()
}

func (i OutputFileArray) ToOutputFileArrayOutput() OutputFileArrayOutput {
	return i.ToOutputFileArrayOutputWithContext(context.Background())
}

func (i OutputFileArray) ToOutputFileArrayOutputWithContext(ctx context.Context) OutputFileArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OutputFileArrayOutput)
}

// Represents an output file produced.
type OutputFileOutput struct{ *pulumi.OutputState }

func (OutputFileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OutputFile)(nil)).Elem()
}

func (o OutputFileOutput) ToOutputFileOutput() OutputFileOutput {
	return o
}

func (o OutputFileOutput) ToOutputFileOutputWithContext(ctx context.Context) OutputFileOutput {
	return o
}

// The list of labels that describe how the encoder should multiplex video and audio into an output file. For example, if the encoder is producing two video layers with labels v1 and v2, and one audio layer with label a1, then an array like '[v1, a1]' tells the encoder to produce an output file with the video track represented by v1 and the audio track represented by a1.
func (o OutputFileOutput) Labels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v OutputFile) []string { return v.Labels }).(pulumi.StringArrayOutput)
}

type OutputFileArrayOutput struct{ *pulumi.OutputState }

func (OutputFileArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OutputFile)(nil)).Elem()
}

func (o OutputFileArrayOutput) ToOutputFileArrayOutput() OutputFileArrayOutput {
	return o
}

func (o OutputFileArrayOutput) ToOutputFileArrayOutputWithContext(ctx context.Context) OutputFileArrayOutput {
	return o
}

func (o OutputFileArrayOutput) Index(i pulumi.IntInput) OutputFileOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OutputFile {
		return vs[0].([]OutputFile)[vs[1].(int)]
	}).(OutputFileOutput)
}

// Represents an output file produced.
type OutputFileResponse struct {
	// The list of labels that describe how the encoder should multiplex video and audio into an output file. For example, if the encoder is producing two video layers with labels v1 and v2, and one audio layer with label a1, then an array like '[v1, a1]' tells the encoder to produce an output file with the video track represented by v1 and the audio track represented by a1.
	Labels []string `pulumi:"labels"`
}

// Represents an output file produced.
type OutputFileResponseOutput struct{ *pulumi.OutputState }

func (OutputFileResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OutputFileResponse)(nil)).Elem()
}

func (o OutputFileResponseOutput) ToOutputFileResponseOutput() OutputFileResponseOutput {
	return o
}

func (o OutputFileResponseOutput) ToOutputFileResponseOutputWithContext(ctx context.Context) OutputFileResponseOutput {
	return o
}

// The list of labels that describe how the encoder should multiplex video and audio into an output file. For example, if the encoder is producing two video layers with labels v1 and v2, and one audio layer with label a1, then an array like '[v1, a1]' tells the encoder to produce an output file with the video track represented by v1 and the audio track represented by a1.
func (o OutputFileResponseOutput) Labels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v OutputFileResponse) []string { return v.Labels }).(pulumi.StringArrayOutput)
}

type OutputFileResponseArrayOutput struct{ *pulumi.OutputState }

func (OutputFileResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OutputFileResponse)(nil)).Elem()
}

func (o OutputFileResponseArrayOutput) ToOutputFileResponseArrayOutput() OutputFileResponseArrayOutput {
	return o
}

func (o OutputFileResponseArrayOutput) ToOutputFileResponseArrayOutputWithContext(ctx context.Context) OutputFileResponseArrayOutput {
	return o
}

func (o OutputFileResponseArrayOutput) Index(i pulumi.IntInput) OutputFileResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OutputFileResponse {
		return vs[0].([]OutputFileResponse)[vs[1].(int)]
	}).(OutputFileResponseOutput)
}

// Describes the settings for producing PNG thumbnails.
type PngFormat struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngFormat'.
	OdataType string `pulumi:"odataType"`
}

// PngFormatInput is an input type that accepts PngFormatArgs and PngFormatOutput values.
// You can construct a concrete instance of `PngFormatInput` via:
//
//	PngFormatArgs{...}
type PngFormatInput interface {
	pulumi.Input

	ToPngFormatOutput() PngFormatOutput
	ToPngFormatOutputWithContext(context.Context) PngFormatOutput
}

// Describes the settings for producing PNG thumbnails.
type PngFormatArgs struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern pulumi.StringInput `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngFormat'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (PngFormatArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PngFormat)(nil)).Elem()
}

func (i PngFormatArgs) ToPngFormatOutput() PngFormatOutput {
	return i.ToPngFormatOutputWithContext(context.Background())
}

func (i PngFormatArgs) ToPngFormatOutputWithContext(ctx context.Context) PngFormatOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PngFormatOutput)
}

// Describes the settings for producing PNG thumbnails.
type PngFormatOutput struct{ *pulumi.OutputState }

func (PngFormatOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PngFormat)(nil)).Elem()
}

func (o PngFormatOutput) ToPngFormatOutput() PngFormatOutput {
	return o
}

func (o PngFormatOutput) ToPngFormatOutputWithContext(ctx context.Context) PngFormatOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o PngFormatOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v PngFormat) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.PngFormat'.
func (o PngFormatOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v PngFormat) string { return v.OdataType }).(pulumi.StringOutput)
}

// Describes the settings for producing PNG thumbnails.
type PngFormatResponse struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngFormat'.
	OdataType string `pulumi:"odataType"`
}

// Describes the settings for producing PNG thumbnails.
type PngFormatResponseOutput struct{ *pulumi.OutputState }

func (PngFormatResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PngFormatResponse)(nil)).Elem()
}

func (o PngFormatResponseOutput) ToPngFormatResponseOutput() PngFormatResponseOutput {
	return o
}

func (o PngFormatResponseOutput) ToPngFormatResponseOutputWithContext(ctx context.Context) PngFormatResponseOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o PngFormatResponseOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v PngFormatResponse) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.PngFormat'.
func (o PngFormatResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v PngFormatResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Describes the properties for producing a series of PNG images from the input video.
type PngImage struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// A collection of output PNG image layers to be produced by the encoder.
	Layers []PngLayer `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngImage'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// PngImageInput is an input type that accepts PngImageArgs and PngImageOutput values.
// You can construct a concrete instance of `PngImageInput` via:
//
//	PngImageArgs{...}
type PngImageInput interface {
	pulumi.Input

	ToPngImageOutput() PngImageOutput
	ToPngImageOutputWithContext(context.Context) PngImageOutput
}

// Describes the properties for producing a series of PNG images from the input video.
type PngImageArgs struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval pulumi.StringPtrInput `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// A collection of output PNG image layers to be produced by the encoder.
	Layers PngLayerArrayInput `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngImage'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range pulumi.StringPtrInput `pulumi:"range"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start pulumi.StringInput `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step pulumi.StringPtrInput `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode pulumi.StringPtrInput `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode pulumi.StringPtrInput `pulumi:"syncMode"`
}

func (PngImageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PngImage)(nil)).Elem()
}

func (i PngImageArgs) ToPngImageOutput() PngImageOutput {
	return i.ToPngImageOutputWithContext(context.Background())
}

func (i PngImageArgs) ToPngImageOutputWithContext(ctx context.Context) PngImageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PngImageOutput)
}

// Describes the properties for producing a series of PNG images from the input video.
type PngImageOutput struct{ *pulumi.OutputState }

func (PngImageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PngImage)(nil)).Elem()
}

func (o PngImageOutput) ToPngImageOutput() PngImageOutput {
	return o
}

func (o PngImageOutput) ToPngImageOutputWithContext(ctx context.Context) PngImageOutput {
	return o
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o PngImageOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImage) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o PngImageOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImage) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// A collection of output PNG image layers to be produced by the encoder.
func (o PngImageOutput) Layers() PngLayerArrayOutput {
	return o.ApplyT(func(v PngImage) []PngLayer { return v.Layers }).(PngLayerArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.PngImage'.
func (o PngImageOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v PngImage) string { return v.OdataType }).(pulumi.StringOutput)
}

// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
func (o PngImageOutput) Range() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImage) *string { return v.Range }).(pulumi.StringPtrOutput)
}

// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
func (o PngImageOutput) Start() pulumi.StringOutput {
	return o.ApplyT(func(v PngImage) string { return v.Start }).(pulumi.StringOutput)
}

// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
func (o PngImageOutput) Step() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImage) *string { return v.Step }).(pulumi.StringPtrOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o PngImageOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImage) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o PngImageOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImage) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// Describes the properties for producing a series of PNG images from the input video.
type PngImageResponse struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// A collection of output PNG image layers to be produced by the encoder.
	Layers []PngLayerResponse `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngImage'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes the properties for producing a series of PNG images from the input video.
type PngImageResponseOutput struct{ *pulumi.OutputState }

func (PngImageResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PngImageResponse)(nil)).Elem()
}

func (o PngImageResponseOutput) ToPngImageResponseOutput() PngImageResponseOutput {
	return o
}

func (o PngImageResponseOutput) ToPngImageResponseOutputWithContext(ctx context.Context) PngImageResponseOutput {
	return o
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o PngImageResponseOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImageResponse) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o PngImageResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImageResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// A collection of output PNG image layers to be produced by the encoder.
func (o PngImageResponseOutput) Layers() PngLayerResponseArrayOutput {
	return o.ApplyT(func(v PngImageResponse) []PngLayerResponse { return v.Layers }).(PngLayerResponseArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.PngImage'.
func (o PngImageResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v PngImageResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
func (o PngImageResponseOutput) Range() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImageResponse) *string { return v.Range }).(pulumi.StringPtrOutput)
}

// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
func (o PngImageResponseOutput) Start() pulumi.StringOutput {
	return o.ApplyT(func(v PngImageResponse) string { return v.Start }).(pulumi.StringOutput)
}

// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
func (o PngImageResponseOutput) Step() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImageResponse) *string { return v.Step }).(pulumi.StringPtrOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o PngImageResponseOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImageResponse) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o PngImageResponseOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngImageResponse) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// Describes the settings to produce a PNG image from the input video.
type PngLayer struct {
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// PngLayerInput is an input type that accepts PngLayerArgs and PngLayerOutput values.
// You can construct a concrete instance of `PngLayerInput` via:
//
//	PngLayerArgs{...}
type PngLayerInput interface {
	pulumi.Input

	ToPngLayerOutput() PngLayerOutput
	ToPngLayerOutputWithContext(context.Context) PngLayerOutput
}

// Describes the settings to produce a PNG image from the input video.
type PngLayerArgs struct {
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height pulumi.StringPtrInput `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width pulumi.StringPtrInput `pulumi:"width"`
}

func (PngLayerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PngLayer)(nil)).Elem()
}

func (i PngLayerArgs) ToPngLayerOutput() PngLayerOutput {
	return i.ToPngLayerOutputWithContext(context.Background())
}

func (i PngLayerArgs) ToPngLayerOutputWithContext(ctx context.Context) PngLayerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PngLayerOutput)
}

// PngLayerArrayInput is an input type that accepts PngLayerArray and PngLayerArrayOutput values.
// You can construct a concrete instance of `PngLayerArrayInput` via:
//
//	PngLayerArray{ PngLayerArgs{...} }
type PngLayerArrayInput interface {
	pulumi.Input

	ToPngLayerArrayOutput() PngLayerArrayOutput
	ToPngLayerArrayOutputWithContext(context.Context) PngLayerArrayOutput
}

type PngLayerArray []PngLayerInput

func (PngLayerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PngLayer)(nil)).Elem()
}

func (i PngLayerArray) ToPngLayerArrayOutput() PngLayerArrayOutput {
	return i.ToPngLayerArrayOutputWithContext(context.Background())
}

func (i PngLayerArray) ToPngLayerArrayOutputWithContext(ctx context.Context) PngLayerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PngLayerArrayOutput)
}

// Describes the settings to produce a PNG image from the input video.
type PngLayerOutput struct{ *pulumi.OutputState }

func (PngLayerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PngLayer)(nil)).Elem()
}

func (o PngLayerOutput) ToPngLayerOutput() PngLayerOutput {
	return o
}

func (o PngLayerOutput) ToPngLayerOutputWithContext(ctx context.Context) PngLayerOutput {
	return o
}

// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
func (o PngLayerOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngLayer) *string { return v.Height }).(pulumi.StringPtrOutput)
}

// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
func (o PngLayerOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngLayer) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
func (o PngLayerOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngLayer) *string { return v.Width }).(pulumi.StringPtrOutput)
}

type PngLayerArrayOutput struct{ *pulumi.OutputState }

func (PngLayerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PngLayer)(nil)).Elem()
}

func (o PngLayerArrayOutput) ToPngLayerArrayOutput() PngLayerArrayOutput {
	return o
}

func (o PngLayerArrayOutput) ToPngLayerArrayOutputWithContext(ctx context.Context) PngLayerArrayOutput {
	return o
}

func (o PngLayerArrayOutput) Index(i pulumi.IntInput) PngLayerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PngLayer {
		return vs[0].([]PngLayer)[vs[1].(int)]
	}).(PngLayerOutput)
}

// Describes the settings to produce a PNG image from the input video.
type PngLayerResponse struct {
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// Describes the settings to produce a PNG image from the input video.
type PngLayerResponseOutput struct{ *pulumi.OutputState }

func (PngLayerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PngLayerResponse)(nil)).Elem()
}

func (o PngLayerResponseOutput) ToPngLayerResponseOutput() PngLayerResponseOutput {
	return o
}

func (o PngLayerResponseOutput) ToPngLayerResponseOutputWithContext(ctx context.Context) PngLayerResponseOutput {
	return o
}

// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
func (o PngLayerResponseOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngLayerResponse) *string { return v.Height }).(pulumi.StringPtrOutput)
}

// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
func (o PngLayerResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngLayerResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
func (o PngLayerResponseOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PngLayerResponse) *string { return v.Width }).(pulumi.StringPtrOutput)
}

type PngLayerResponseArrayOutput struct{ *pulumi.OutputState }

func (PngLayerResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PngLayerResponse)(nil)).Elem()
}

func (o PngLayerResponseArrayOutput) ToPngLayerResponseArrayOutput() PngLayerResponseArrayOutput {
	return o
}

func (o PngLayerResponseArrayOutput) ToPngLayerResponseArrayOutputWithContext(ctx context.Context) PngLayerResponseArrayOutput {
	return o
}

func (o PngLayerResponseArrayOutput) Index(i pulumi.IntInput) PngLayerResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PngLayerResponse {
		return vs[0].([]PngLayerResponse)[vs[1].(int)]
	}).(PngLayerResponseOutput)
}

// The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRange struct {
	// The absolute end time boundary.
	EndTimestamp *float64 `pulumi:"endTimestamp"`
	// The indicator of forcing existing of end time stamp.
	ForceEndTimestamp *bool `pulumi:"forceEndTimestamp"`
	// The relative to end right edge.
	LiveBackoffDuration *float64 `pulumi:"liveBackoffDuration"`
	// The relative to end sliding window.
	PresentationWindowDuration *float64 `pulumi:"presentationWindowDuration"`
	// The absolute start time boundary.
	StartTimestamp *float64 `pulumi:"startTimestamp"`
	// The time scale of time stamps.
	Timescale *float64 `pulumi:"timescale"`
}

// PresentationTimeRangeInput is an input type that accepts PresentationTimeRangeArgs and PresentationTimeRangeOutput values.
// You can construct a concrete instance of `PresentationTimeRangeInput` via:
//
//	PresentationTimeRangeArgs{...}
type PresentationTimeRangeInput interface {
	pulumi.Input

	ToPresentationTimeRangeOutput() PresentationTimeRangeOutput
	ToPresentationTimeRangeOutputWithContext(context.Context) PresentationTimeRangeOutput
}

// The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRangeArgs struct {
	// The absolute end time boundary.
	EndTimestamp pulumi.Float64PtrInput `pulumi:"endTimestamp"`
	// The indicator of forcing existing of end time stamp.
	ForceEndTimestamp pulumi.BoolPtrInput `pulumi:"forceEndTimestamp"`
	// The relative to end right edge.
	LiveBackoffDuration pulumi.Float64PtrInput `pulumi:"liveBackoffDuration"`
	// The relative to end sliding window.
	PresentationWindowDuration pulumi.Float64PtrInput `pulumi:"presentationWindowDuration"`
	// The absolute start time boundary.
	StartTimestamp pulumi.Float64PtrInput `pulumi:"startTimestamp"`
	// The time scale of time stamps.
	Timescale pulumi.Float64PtrInput `pulumi:"timescale"`
}

func (PresentationTimeRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PresentationTimeRange)(nil)).Elem()
}

func (i PresentationTimeRangeArgs) ToPresentationTimeRangeOutput() PresentationTimeRangeOutput {
	return i.ToPresentationTimeRangeOutputWithContext(context.Background())
}

func (i PresentationTimeRangeArgs) ToPresentationTimeRangeOutputWithContext(ctx context.Context) PresentationTimeRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PresentationTimeRangeOutput)
}

func (i PresentationTimeRangeArgs) ToPresentationTimeRangePtrOutput() PresentationTimeRangePtrOutput {
	return i.ToPresentationTimeRangePtrOutputWithContext(context.Background())
}

func (i PresentationTimeRangeArgs) ToPresentationTimeRangePtrOutputWithContext(ctx context.Context) PresentationTimeRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PresentationTimeRangeOutput).ToPresentationTimeRangePtrOutputWithContext(ctx)
}

// PresentationTimeRangePtrInput is an input type that accepts PresentationTimeRangeArgs, PresentationTimeRangePtr and PresentationTimeRangePtrOutput values.
// You can construct a concrete instance of `PresentationTimeRangePtrInput` via:
//
//	        PresentationTimeRangeArgs{...}
//
//	or:
//
//	        nil
type PresentationTimeRangePtrInput interface {
	pulumi.Input

	ToPresentationTimeRangePtrOutput() PresentationTimeRangePtrOutput
	ToPresentationTimeRangePtrOutputWithContext(context.Context) PresentationTimeRangePtrOutput
}

type presentationTimeRangePtrType PresentationTimeRangeArgs

func PresentationTimeRangePtr(v *PresentationTimeRangeArgs) PresentationTimeRangePtrInput {
	return (*presentationTimeRangePtrType)(v)
}

func (*presentationTimeRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PresentationTimeRange)(nil)).Elem()
}

func (i *presentationTimeRangePtrType) ToPresentationTimeRangePtrOutput() PresentationTimeRangePtrOutput {
	return i.ToPresentationTimeRangePtrOutputWithContext(context.Background())
}

func (i *presentationTimeRangePtrType) ToPresentationTimeRangePtrOutputWithContext(ctx context.Context) PresentationTimeRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PresentationTimeRangePtrOutput)
}

// The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRangeOutput struct{ *pulumi.OutputState }

func (PresentationTimeRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PresentationTimeRange)(nil)).Elem()
}

func (o PresentationTimeRangeOutput) ToPresentationTimeRangeOutput() PresentationTimeRangeOutput {
	return o
}

func (o PresentationTimeRangeOutput) ToPresentationTimeRangeOutputWithContext(ctx context.Context) PresentationTimeRangeOutput {
	return o
}

func (o PresentationTimeRangeOutput) ToPresentationTimeRangePtrOutput() PresentationTimeRangePtrOutput {
	return o.ToPresentationTimeRangePtrOutputWithContext(context.Background())
}

func (o PresentationTimeRangeOutput) ToPresentationTimeRangePtrOutputWithContext(ctx context.Context) PresentationTimeRangePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PresentationTimeRange) *PresentationTimeRange {
		return &v
	}).(PresentationTimeRangePtrOutput)
}

// The absolute end time boundary.
func (o PresentationTimeRangeOutput) EndTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *float64 { return v.EndTimestamp }).(pulumi.Float64PtrOutput)
}

// The indicator of forcing existing of end time stamp.
func (o PresentationTimeRangeOutput) ForceEndTimestamp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *bool { return v.ForceEndTimestamp }).(pulumi.BoolPtrOutput)
}

// The relative to end right edge.
func (o PresentationTimeRangeOutput) LiveBackoffDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *float64 { return v.LiveBackoffDuration }).(pulumi.Float64PtrOutput)
}

// The relative to end sliding window.
func (o PresentationTimeRangeOutput) PresentationWindowDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *float64 { return v.PresentationWindowDuration }).(pulumi.Float64PtrOutput)
}

// The absolute start time boundary.
func (o PresentationTimeRangeOutput) StartTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *float64 { return v.StartTimestamp }).(pulumi.Float64PtrOutput)
}

// The time scale of time stamps.
func (o PresentationTimeRangeOutput) Timescale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *float64 { return v.Timescale }).(pulumi.Float64PtrOutput)
}

type PresentationTimeRangePtrOutput struct{ *pulumi.OutputState }

func (PresentationTimeRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PresentationTimeRange)(nil)).Elem()
}

func (o PresentationTimeRangePtrOutput) ToPresentationTimeRangePtrOutput() PresentationTimeRangePtrOutput {
	return o
}

func (o PresentationTimeRangePtrOutput) ToPresentationTimeRangePtrOutputWithContext(ctx context.Context) PresentationTimeRangePtrOutput {
	return o
}

func (o PresentationTimeRangePtrOutput) Elem() PresentationTimeRangeOutput {
	return o.ApplyT(func(v *PresentationTimeRange) PresentationTimeRange {
		if v != nil {
			return *v
		}
		var ret PresentationTimeRange
		return ret
	}).(PresentationTimeRangeOutput)
}

// The absolute end time boundary.
func (o PresentationTimeRangePtrOutput) EndTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *float64 {
		if v == nil {
			return nil
		}
		return v.EndTimestamp
	}).(pulumi.Float64PtrOutput)
}

// The indicator of forcing existing of end time stamp.
func (o PresentationTimeRangePtrOutput) ForceEndTimestamp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *bool {
		if v == nil {
			return nil
		}
		return v.ForceEndTimestamp
	}).(pulumi.BoolPtrOutput)
}

// The relative to end right edge.
func (o PresentationTimeRangePtrOutput) LiveBackoffDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *float64 {
		if v == nil {
			return nil
		}
		return v.LiveBackoffDuration
	}).(pulumi.Float64PtrOutput)
}

// The relative to end sliding window.
func (o PresentationTimeRangePtrOutput) PresentationWindowDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *float64 {
		if v == nil {
			return nil
		}
		return v.PresentationWindowDuration
	}).(pulumi.Float64PtrOutput)
}

// The absolute start time boundary.
func (o PresentationTimeRangePtrOutput) StartTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *float64 {
		if v == nil {
			return nil
		}
		return v.StartTimestamp
	}).(pulumi.Float64PtrOutput)
}

// The time scale of time stamps.
func (o PresentationTimeRangePtrOutput) Timescale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *float64 {
		if v == nil {
			return nil
		}
		return v.Timescale
	}).(pulumi.Float64PtrOutput)
}

// The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRangeResponse struct {
	// The absolute end time boundary.
	EndTimestamp *float64 `pulumi:"endTimestamp"`
	// The indicator of forcing existing of end time stamp.
	ForceEndTimestamp *bool `pulumi:"forceEndTimestamp"`
	// The relative to end right edge.
	LiveBackoffDuration *float64 `pulumi:"liveBackoffDuration"`
	// The relative to end sliding window.
	PresentationWindowDuration *float64 `pulumi:"presentationWindowDuration"`
	// The absolute start time boundary.
	StartTimestamp *float64 `pulumi:"startTimestamp"`
	// The time scale of time stamps.
	Timescale *float64 `pulumi:"timescale"`
}

// The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRangeResponseOutput struct{ *pulumi.OutputState }

func (PresentationTimeRangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PresentationTimeRangeResponse)(nil)).Elem()
}

func (o PresentationTimeRangeResponseOutput) ToPresentationTimeRangeResponseOutput() PresentationTimeRangeResponseOutput {
	return o
}

func (o PresentationTimeRangeResponseOutput) ToPresentationTimeRangeResponseOutputWithContext(ctx context.Context) PresentationTimeRangeResponseOutput {
	return o
}

// The absolute end time boundary.
func (o PresentationTimeRangeResponseOutput) EndTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *float64 { return v.EndTimestamp }).(pulumi.Float64PtrOutput)
}

// The indicator of forcing existing of end time stamp.
func (o PresentationTimeRangeResponseOutput) ForceEndTimestamp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *bool { return v.ForceEndTimestamp }).(pulumi.BoolPtrOutput)
}

// The relative to end right edge.
func (o PresentationTimeRangeResponseOutput) LiveBackoffDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *float64 { return v.LiveBackoffDuration }).(pulumi.Float64PtrOutput)
}

// The relative to end sliding window.
func (o PresentationTimeRangeResponseOutput) PresentationWindowDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *float64 { return v.PresentationWindowDuration }).(pulumi.Float64PtrOutput)
}

// The absolute start time boundary.
func (o PresentationTimeRangeResponseOutput) StartTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *float64 { return v.StartTimestamp }).(pulumi.Float64PtrOutput)
}

// The time scale of time stamps.
func (o PresentationTimeRangeResponseOutput) Timescale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *float64 { return v.Timescale }).(pulumi.Float64PtrOutput)
}

type PresentationTimeRangeResponsePtrOutput struct{ *pulumi.OutputState }

func (PresentationTimeRangeResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PresentationTimeRangeResponse)(nil)).Elem()
}

func (o PresentationTimeRangeResponsePtrOutput) ToPresentationTimeRangeResponsePtrOutput() PresentationTimeRangeResponsePtrOutput {
	return o
}

func (o PresentationTimeRangeResponsePtrOutput) ToPresentationTimeRangeResponsePtrOutputWithContext(ctx context.Context) PresentationTimeRangeResponsePtrOutput {
	return o
}

func (o PresentationTimeRangeResponsePtrOutput) Elem() PresentationTimeRangeResponseOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) PresentationTimeRangeResponse {
		if v != nil {
			return *v
		}
		var ret PresentationTimeRangeResponse
		return ret
	}).(PresentationTimeRangeResponseOutput)
}

// The absolute end time boundary.
func (o PresentationTimeRangeResponsePtrOutput) EndTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.EndTimestamp
	}).(pulumi.Float64PtrOutput)
}

// The indicator of forcing existing of end time stamp.
func (o PresentationTimeRangeResponsePtrOutput) ForceEndTimestamp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *bool {
		if v == nil {
			return nil
		}
		return v.ForceEndTimestamp
	}).(pulumi.BoolPtrOutput)
}

// The relative to end right edge.
func (o PresentationTimeRangeResponsePtrOutput) LiveBackoffDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.LiveBackoffDuration
	}).(pulumi.Float64PtrOutput)
}

// The relative to end sliding window.
func (o PresentationTimeRangeResponsePtrOutput) PresentationWindowDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.PresentationWindowDuration
	}).(pulumi.Float64PtrOutput)
}

// The absolute start time boundary.
func (o PresentationTimeRangeResponsePtrOutput) StartTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.StartTimestamp
	}).(pulumi.Float64PtrOutput)
}

// The time scale of time stamps.
func (o PresentationTimeRangeResponsePtrOutput) Timescale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.Timescale
	}).(pulumi.Float64PtrOutput)
}

// An object of optional configuration settings for encoder.
type PresetConfigurations struct {
	// Allows you to configure the encoder settings to control the balance between speed and quality. Example: set Complexity as Speed for faster encoding but less compression efficiency.
	Complexity *string `pulumi:"complexity"`
	// Sets the interleave mode of the output to control how audio and video are stored in the container format. Example: set InterleavedOutput as NonInterleavedOutput to produce audio-only and video-only outputs in separate MP4 files.
	InterleaveOutput *string `pulumi:"interleaveOutput"`
	// The key frame interval in seconds. Example: set KeyFrameIntervalInSeconds as 2 to reduce the playback buffering for some players.
	KeyFrameIntervalInSeconds *float64 `pulumi:"keyFrameIntervalInSeconds"`
	// The maximum bitrate in bits per second (threshold for the top video layer). Example: set MaxBitrateBps as 6000000 to avoid producing very high bitrate outputs for contents with high complexity.
	MaxBitrateBps *int `pulumi:"maxBitrateBps"`
	// The maximum height of output video layers. Example: set MaxHeight as 720 to produce output layers up to 720P even if the input is 4K.
	MaxHeight *int `pulumi:"maxHeight"`
	// The maximum number of output video layers. Example: set MaxLayers as 4 to make sure at most 4 output layers are produced to control the overall cost of the encoding job.
	MaxLayers *int `pulumi:"maxLayers"`
	// The minimum bitrate in bits per second (threshold for the bottom video layer). Example: set MinBitrateBps as 200000 to have a bottom layer that covers users with low network bandwidth.
	MinBitrateBps *int `pulumi:"minBitrateBps"`
	// The minimum height of output video layers. Example: set MinHeight as 360 to avoid output layers of smaller resolutions like 180P.
	MinHeight *int `pulumi:"minHeight"`
}

// PresetConfigurationsInput is an input type that accepts PresetConfigurationsArgs and PresetConfigurationsOutput values.
// You can construct a concrete instance of `PresetConfigurationsInput` via:
//
//	PresetConfigurationsArgs{...}
type PresetConfigurationsInput interface {
	pulumi.Input

	ToPresetConfigurationsOutput() PresetConfigurationsOutput
	ToPresetConfigurationsOutputWithContext(context.Context) PresetConfigurationsOutput
}

// An object of optional configuration settings for encoder.
type PresetConfigurationsArgs struct {
	// Allows you to configure the encoder settings to control the balance between speed and quality. Example: set Complexity as Speed for faster encoding but less compression efficiency.
	Complexity pulumi.StringPtrInput `pulumi:"complexity"`
	// Sets the interleave mode of the output to control how audio and video are stored in the container format. Example: set InterleavedOutput as NonInterleavedOutput to produce audio-only and video-only outputs in separate MP4 files.
	InterleaveOutput pulumi.StringPtrInput `pulumi:"interleaveOutput"`
	// The key frame interval in seconds. Example: set KeyFrameIntervalInSeconds as 2 to reduce the playback buffering for some players.
	KeyFrameIntervalInSeconds pulumi.Float64PtrInput `pulumi:"keyFrameIntervalInSeconds"`
	// The maximum bitrate in bits per second (threshold for the top video layer). Example: set MaxBitrateBps as 6000000 to avoid producing very high bitrate outputs for contents with high complexity.
	MaxBitrateBps pulumi.IntPtrInput `pulumi:"maxBitrateBps"`
	// The maximum height of output video layers. Example: set MaxHeight as 720 to produce output layers up to 720P even if the input is 4K.
	MaxHeight pulumi.IntPtrInput `pulumi:"maxHeight"`
	// The maximum number of output video layers. Example: set MaxLayers as 4 to make sure at most 4 output layers are produced to control the overall cost of the encoding job.
	MaxLayers pulumi.IntPtrInput `pulumi:"maxLayers"`
	// The minimum bitrate in bits per second (threshold for the bottom video layer). Example: set MinBitrateBps as 200000 to have a bottom layer that covers users with low network bandwidth.
	MinBitrateBps pulumi.IntPtrInput `pulumi:"minBitrateBps"`
	// The minimum height of output video layers. Example: set MinHeight as 360 to avoid output layers of smaller resolutions like 180P.
	MinHeight pulumi.IntPtrInput `pulumi:"minHeight"`
}

func (PresetConfigurationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PresetConfigurations)(nil)).Elem()
}

func (i PresetConfigurationsArgs) ToPresetConfigurationsOutput() PresetConfigurationsOutput {
	return i.ToPresetConfigurationsOutputWithContext(context.Background())
}

func (i PresetConfigurationsArgs) ToPresetConfigurationsOutputWithContext(ctx context.Context) PresetConfigurationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PresetConfigurationsOutput)
}

func (i PresetConfigurationsArgs) ToPresetConfigurationsPtrOutput() PresetConfigurationsPtrOutput {
	return i.ToPresetConfigurationsPtrOutputWithContext(context.Background())
}

func (i PresetConfigurationsArgs) ToPresetConfigurationsPtrOutputWithContext(ctx context.Context) PresetConfigurationsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PresetConfigurationsOutput).ToPresetConfigurationsPtrOutputWithContext(ctx)
}

// PresetConfigurationsPtrInput is an input type that accepts PresetConfigurationsArgs, PresetConfigurationsPtr and PresetConfigurationsPtrOutput values.
// You can construct a concrete instance of `PresetConfigurationsPtrInput` via:
//
//	        PresetConfigurationsArgs{...}
//
//	or:
//
//	        nil
type PresetConfigurationsPtrInput interface {
	pulumi.Input

	ToPresetConfigurationsPtrOutput() PresetConfigurationsPtrOutput
	ToPresetConfigurationsPtrOutputWithContext(context.Context) PresetConfigurationsPtrOutput
}

type presetConfigurationsPtrType PresetConfigurationsArgs

func PresetConfigurationsPtr(v *PresetConfigurationsArgs) PresetConfigurationsPtrInput {
	return (*presetConfigurationsPtrType)(v)
}

func (*presetConfigurationsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PresetConfigurations)(nil)).Elem()
}

func (i *presetConfigurationsPtrType) ToPresetConfigurationsPtrOutput() PresetConfigurationsPtrOutput {
	return i.ToPresetConfigurationsPtrOutputWithContext(context.Background())
}

func (i *presetConfigurationsPtrType) ToPresetConfigurationsPtrOutputWithContext(ctx context.Context) PresetConfigurationsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PresetConfigurationsPtrOutput)
}

// An object of optional configuration settings for encoder.
type PresetConfigurationsOutput struct{ *pulumi.OutputState }

func (PresetConfigurationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PresetConfigurations)(nil)).Elem()
}

func (o PresetConfigurationsOutput) ToPresetConfigurationsOutput() PresetConfigurationsOutput {
	return o
}

func (o PresetConfigurationsOutput) ToPresetConfigurationsOutputWithContext(ctx context.Context) PresetConfigurationsOutput {
	return o
}

func (o PresetConfigurationsOutput) ToPresetConfigurationsPtrOutput() PresetConfigurationsPtrOutput {
	return o.ToPresetConfigurationsPtrOutputWithContext(context.Background())
}

func (o PresetConfigurationsOutput) ToPresetConfigurationsPtrOutputWithContext(ctx context.Context) PresetConfigurationsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PresetConfigurations) *PresetConfigurations {
		return &v
	}).(PresetConfigurationsPtrOutput)
}

// Allows you to configure the encoder settings to control the balance between speed and quality. Example: set Complexity as Speed for faster encoding but less compression efficiency.
func (o PresetConfigurationsOutput) Complexity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PresetConfigurations) *string { return v.Complexity }).(pulumi.StringPtrOutput)
}

// Sets the interleave mode of the output to control how audio and video are stored in the container format. Example: set InterleavedOutput as NonInterleavedOutput to produce audio-only and video-only outputs in separate MP4 files.
func (o PresetConfigurationsOutput) InterleaveOutput() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PresetConfigurations) *string { return v.InterleaveOutput }).(pulumi.StringPtrOutput)
}

// The key frame interval in seconds. Example: set KeyFrameIntervalInSeconds as 2 to reduce the playback buffering for some players.
func (o PresetConfigurationsOutput) KeyFrameIntervalInSeconds() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresetConfigurations) *float64 { return v.KeyFrameIntervalInSeconds }).(pulumi.Float64PtrOutput)
}

// The maximum bitrate in bits per second (threshold for the top video layer). Example: set MaxBitrateBps as 6000000 to avoid producing very high bitrate outputs for contents with high complexity.
func (o PresetConfigurationsOutput) MaxBitrateBps() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PresetConfigurations) *int { return v.MaxBitrateBps }).(pulumi.IntPtrOutput)
}

// The maximum height of output video layers. Example: set MaxHeight as 720 to produce output layers up to 720P even if the input is 4K.
func (o PresetConfigurationsOutput) MaxHeight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PresetConfigurations) *int { return v.MaxHeight }).(pulumi.IntPtrOutput)
}

// The maximum number of output video layers. Example: set MaxLayers as 4 to make sure at most 4 output layers are produced to control the overall cost of the encoding job.
func (o PresetConfigurationsOutput) MaxLayers() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PresetConfigurations) *int { return v.MaxLayers }).(pulumi.IntPtrOutput)
}

// The minimum bitrate in bits per second (threshold for the bottom video layer). Example: set MinBitrateBps as 200000 to have a bottom layer that covers users with low network bandwidth.
func (o PresetConfigurationsOutput) MinBitrateBps() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PresetConfigurations) *int { return v.MinBitrateBps }).(pulumi.IntPtrOutput)
}

// The minimum height of output video layers. Example: set MinHeight as 360 to avoid output layers of smaller resolutions like 180P.
func (o PresetConfigurationsOutput) MinHeight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PresetConfigurations) *int { return v.MinHeight }).(pulumi.IntPtrOutput)
}

type PresetConfigurationsPtrOutput struct{ *pulumi.OutputState }

func (PresetConfigurationsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PresetConfigurations)(nil)).Elem()
}

func (o PresetConfigurationsPtrOutput) ToPresetConfigurationsPtrOutput() PresetConfigurationsPtrOutput {
	return o
}

func (o PresetConfigurationsPtrOutput) ToPresetConfigurationsPtrOutputWithContext(ctx context.Context) PresetConfigurationsPtrOutput {
	return o
}

func (o PresetConfigurationsPtrOutput) Elem() PresetConfigurationsOutput {
	return o.ApplyT(func(v *PresetConfigurations) PresetConfigurations {
		if v != nil {
			return *v
		}
		var ret PresetConfigurations
		return ret
	}).(PresetConfigurationsOutput)
}

// Allows you to configure the encoder settings to control the balance between speed and quality. Example: set Complexity as Speed for faster encoding but less compression efficiency.
func (o PresetConfigurationsPtrOutput) Complexity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PresetConfigurations) *string {
		if v == nil {
			return nil
		}
		return v.Complexity
	}).(pulumi.StringPtrOutput)
}

// Sets the interleave mode of the output to control how audio and video are stored in the container format. Example: set InterleavedOutput as NonInterleavedOutput to produce audio-only and video-only outputs in separate MP4 files.
func (o PresetConfigurationsPtrOutput) InterleaveOutput() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PresetConfigurations) *string {
		if v == nil {
			return nil
		}
		return v.InterleaveOutput
	}).(pulumi.StringPtrOutput)
}

// The key frame interval in seconds. Example: set KeyFrameIntervalInSeconds as 2 to reduce the playback buffering for some players.
func (o PresetConfigurationsPtrOutput) KeyFrameIntervalInSeconds() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresetConfigurations) *float64 {
		if v == nil {
			return nil
		}
		return v.KeyFrameIntervalInSeconds
	}).(pulumi.Float64PtrOutput)
}

// The maximum bitrate in bits per second (threshold for the top video layer). Example: set MaxBitrateBps as 6000000 to avoid producing very high bitrate outputs for contents with high complexity.
func (o PresetConfigurationsPtrOutput) MaxBitrateBps() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PresetConfigurations) *int {
		if v == nil {
			return nil
		}
		return v.MaxBitrateBps
	}).(pulumi.IntPtrOutput)
}

// The maximum height of output video layers. Example: set MaxHeight as 720 to produce output layers up to 720P even if the input is 4K.
func (o PresetConfigurationsPtrOutput) MaxHeight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PresetConfigurations) *int {
		if v == nil {
			return nil
		}
		return v.MaxHeight
	}).(pulumi.IntPtrOutput)
}

// The maximum number of output video layers. Example: set MaxLayers as 4 to make sure at most 4 output layers are produced to control the overall cost of the encoding job.
func (o PresetConfigurationsPtrOutput) MaxLayers() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PresetConfigurations) *int {
		if v == nil {
			return nil
		}
		return v.MaxLayers
	}).(pulumi.IntPtrOutput)
}

// The minimum bitrate in bits per second (threshold for the bottom video layer). Example: set MinBitrateBps as 200000 to have a bottom layer that covers users with low network bandwidth.
func (o PresetConfigurationsPtrOutput) MinBitrateBps() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PresetConfigurations) *int {
		if v == nil {
			return nil
		}
		return v.MinBitrateBps
	}).(pulumi.IntPtrOutput)
}

// The minimum height of output video layers. Example: set MinHeight as 360 to avoid output layers of smaller resolutions like 180P.
func (o PresetConfigurationsPtrOutput) MinHeight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PresetConfigurations) *int {
		if v == nil {
			return nil
		}
		return v.MinHeight
	}).(pulumi.IntPtrOutput)
}

// An object of optional configuration settings for encoder.
type PresetConfigurationsResponse struct {
	// Allows you to configure the encoder settings to control the balance between speed and quality. Example: set Complexity as Speed for faster encoding but less compression efficiency.
	Complexity *string `pulumi:"complexity"`
	// Sets the interleave mode of the output to control how audio and video are stored in the container format. Example: set InterleavedOutput as NonInterleavedOutput to produce audio-only and video-only outputs in separate MP4 files.
	InterleaveOutput *string `pulumi:"interleaveOutput"`
	// The key frame interval in seconds. Example: set KeyFrameIntervalInSeconds as 2 to reduce the playback buffering for some players.
	KeyFrameIntervalInSeconds *float64 `pulumi:"keyFrameIntervalInSeconds"`
	// The maximum bitrate in bits per second (threshold for the top video layer). Example: set MaxBitrateBps as 6000000 to avoid producing very high bitrate outputs for contents with high complexity.
	MaxBitrateBps *int `pulumi:"maxBitrateBps"`
	// The maximum height of output video layers. Example: set MaxHeight as 720 to produce output layers up to 720P even if the input is 4K.
	MaxHeight *int `pulumi:"maxHeight"`
	// The maximum number of output video layers. Example: set MaxLayers as 4 to make sure at most 4 output layers are produced to control the overall cost of the encoding job.
	MaxLayers *int `pulumi:"maxLayers"`
	// The minimum bitrate in bits per second (threshold for the bottom video layer). Example: set MinBitrateBps as 200000 to have a bottom layer that covers users with low network bandwidth.
	MinBitrateBps *int `pulumi:"minBitrateBps"`
	// The minimum height of output video layers. Example: set MinHeight as 360 to avoid output layers of smaller resolutions like 180P.
	MinHeight *int `pulumi:"minHeight"`
}

// An object of optional configuration settings for encoder.
type PresetConfigurationsResponseOutput struct{ *pulumi.OutputState }

func (PresetConfigurationsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PresetConfigurationsResponse)(nil)).Elem()
}

func (o PresetConfigurationsResponseOutput) ToPresetConfigurationsResponseOutput() PresetConfigurationsResponseOutput {
	return o
}

func (o PresetConfigurationsResponseOutput) ToPresetConfigurationsResponseOutputWithContext(ctx context.Context) PresetConfigurationsResponseOutput {
	return o
}

// Allows you to configure the encoder settings to control the balance between speed and quality. Example: set Complexity as Speed for faster encoding but less compression efficiency.
func (o PresetConfigurationsResponseOutput) Complexity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PresetConfigurationsResponse) *string { return v.Complexity }).(pulumi.StringPtrOutput)
}

// Sets the interleave mode of the output to control how audio and video are stored in the container format. Example: set InterleavedOutput as NonInterleavedOutput to produce audio-only and video-only outputs in separate MP4 files.
func (o PresetConfigurationsResponseOutput) InterleaveOutput() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PresetConfigurationsResponse) *string { return v.InterleaveOutput }).(pulumi.StringPtrOutput)
}

// The key frame interval in seconds. Example: set KeyFrameIntervalInSeconds as 2 to reduce the playback buffering for some players.
func (o PresetConfigurationsResponseOutput) KeyFrameIntervalInSeconds() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresetConfigurationsResponse) *float64 { return v.KeyFrameIntervalInSeconds }).(pulumi.Float64PtrOutput)
}

// The maximum bitrate in bits per second (threshold for the top video layer). Example: set MaxBitrateBps as 6000000 to avoid producing very high bitrate outputs for contents with high complexity.
func (o PresetConfigurationsResponseOutput) MaxBitrateBps() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PresetConfigurationsResponse) *int { return v.MaxBitrateBps }).(pulumi.IntPtrOutput)
}

// The maximum height of output video layers. Example: set MaxHeight as 720 to produce output layers up to 720P even if the input is 4K.
func (o PresetConfigurationsResponseOutput) MaxHeight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PresetConfigurationsResponse) *int { return v.MaxHeight }).(pulumi.IntPtrOutput)
}

// The maximum number of output video layers. Example: set MaxLayers as 4 to make sure at most 4 output layers are produced to control the overall cost of the encoding job.
func (o PresetConfigurationsResponseOutput) MaxLayers() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PresetConfigurationsResponse) *int { return v.MaxLayers }).(pulumi.IntPtrOutput)
}

// The minimum bitrate in bits per second (threshold for the bottom video layer). Example: set MinBitrateBps as 200000 to have a bottom layer that covers users with low network bandwidth.
func (o PresetConfigurationsResponseOutput) MinBitrateBps() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PresetConfigurationsResponse) *int { return v.MinBitrateBps }).(pulumi.IntPtrOutput)
}

// The minimum height of output video layers. Example: set MinHeight as 360 to avoid output layers of smaller resolutions like 180P.
func (o PresetConfigurationsResponseOutput) MinHeight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PresetConfigurationsResponse) *int { return v.MinHeight }).(pulumi.IntPtrOutput)
}

type PresetConfigurationsResponsePtrOutput struct{ *pulumi.OutputState }

func (PresetConfigurationsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PresetConfigurationsResponse)(nil)).Elem()
}

func (o PresetConfigurationsResponsePtrOutput) ToPresetConfigurationsResponsePtrOutput() PresetConfigurationsResponsePtrOutput {
	return o
}

func (o PresetConfigurationsResponsePtrOutput) ToPresetConfigurationsResponsePtrOutputWithContext(ctx context.Context) PresetConfigurationsResponsePtrOutput {
	return o
}

func (o PresetConfigurationsResponsePtrOutput) Elem() PresetConfigurationsResponseOutput {
	return o.ApplyT(func(v *PresetConfigurationsResponse) PresetConfigurationsResponse {
		if v != nil {
			return *v
		}
		var ret PresetConfigurationsResponse
		return ret
	}).(PresetConfigurationsResponseOutput)
}

// Allows you to configure the encoder settings to control the balance between speed and quality. Example: set Complexity as Speed for faster encoding but less compression efficiency.
func (o PresetConfigurationsResponsePtrOutput) Complexity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PresetConfigurationsResponse) *string {
		if v == nil {
			return nil
		}
		return v.Complexity
	}).(pulumi.StringPtrOutput)
}

// Sets the interleave mode of the output to control how audio and video are stored in the container format. Example: set InterleavedOutput as NonInterleavedOutput to produce audio-only and video-only outputs in separate MP4 files.
func (o PresetConfigurationsResponsePtrOutput) InterleaveOutput() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PresetConfigurationsResponse) *string {
		if v == nil {
			return nil
		}
		return v.InterleaveOutput
	}).(pulumi.StringPtrOutput)
}

// The key frame interval in seconds. Example: set KeyFrameIntervalInSeconds as 2 to reduce the playback buffering for some players.
func (o PresetConfigurationsResponsePtrOutput) KeyFrameIntervalInSeconds() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresetConfigurationsResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.KeyFrameIntervalInSeconds
	}).(pulumi.Float64PtrOutput)
}

// The maximum bitrate in bits per second (threshold for the top video layer). Example: set MaxBitrateBps as 6000000 to avoid producing very high bitrate outputs for contents with high complexity.
func (o PresetConfigurationsResponsePtrOutput) MaxBitrateBps() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PresetConfigurationsResponse) *int {
		if v == nil {
			return nil
		}
		return v.MaxBitrateBps
	}).(pulumi.IntPtrOutput)
}

// The maximum height of output video layers. Example: set MaxHeight as 720 to produce output layers up to 720P even if the input is 4K.
func (o PresetConfigurationsResponsePtrOutput) MaxHeight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PresetConfigurationsResponse) *int {
		if v == nil {
			return nil
		}
		return v.MaxHeight
	}).(pulumi.IntPtrOutput)
}

// The maximum number of output video layers. Example: set MaxLayers as 4 to make sure at most 4 output layers are produced to control the overall cost of the encoding job.
func (o PresetConfigurationsResponsePtrOutput) MaxLayers() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PresetConfigurationsResponse) *int {
		if v == nil {
			return nil
		}
		return v.MaxLayers
	}).(pulumi.IntPtrOutput)
}

// The minimum bitrate in bits per second (threshold for the bottom video layer). Example: set MinBitrateBps as 200000 to have a bottom layer that covers users with low network bandwidth.
func (o PresetConfigurationsResponsePtrOutput) MinBitrateBps() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PresetConfigurationsResponse) *int {
		if v == nil {
			return nil
		}
		return v.MinBitrateBps
	}).(pulumi.IntPtrOutput)
}

// The minimum height of output video layers. Example: set MinHeight as 360 to avoid output layers of smaller resolutions like 180P.
func (o PresetConfigurationsResponsePtrOutput) MinHeight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PresetConfigurationsResponse) *int {
		if v == nil {
			return nil
		}
		return v.MinHeight
	}).(pulumi.IntPtrOutput)
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnectionResponse struct {
	// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id string `pulumi:"id"`
	// The name of the resource
	Name string `pulumi:"name"`
	// The resource of private end point.
	PrivateEndpoint *PrivateEndpointResponse `pulumi:"privateEndpoint"`
	// A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState PrivateLinkServiceConnectionStateResponse `pulumi:"privateLinkServiceConnectionState"`
	// The provisioning state of the private endpoint connection resource.
	ProvisioningState string `pulumi:"provisioningState"`
	// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type string `pulumi:"type"`
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnectionResponseOutput struct{ *pulumi.OutputState }

func (PrivateEndpointConnectionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateEndpointConnectionResponse)(nil)).Elem()
}

func (o PrivateEndpointConnectionResponseOutput) ToPrivateEndpointConnectionResponseOutput() PrivateEndpointConnectionResponseOutput {
	return o
}

func (o PrivateEndpointConnectionResponseOutput) ToPrivateEndpointConnectionResponseOutputWithContext(ctx context.Context) PrivateEndpointConnectionResponseOutput {
	return o
}

// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
func (o PrivateEndpointConnectionResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Id }).(pulumi.StringOutput)
}

// The name of the resource
func (o PrivateEndpointConnectionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The resource of private end point.
func (o PrivateEndpointConnectionResponseOutput) PrivateEndpoint() PrivateEndpointResponsePtrOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) *PrivateEndpointResponse { return v.PrivateEndpoint }).(PrivateEndpointResponsePtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
func (o PrivateEndpointConnectionResponseOutput) PrivateLinkServiceConnectionState() PrivateLinkServiceConnectionStateResponseOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) PrivateLinkServiceConnectionStateResponse {
		return v.PrivateLinkServiceConnectionState
	}).(PrivateLinkServiceConnectionStateResponseOutput)
}

// The provisioning state of the private endpoint connection resource.
func (o PrivateEndpointConnectionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
func (o PrivateEndpointConnectionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Type }).(pulumi.StringOutput)
}

type PrivateEndpointConnectionResponseArrayOutput struct{ *pulumi.OutputState }

func (PrivateEndpointConnectionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PrivateEndpointConnectionResponse)(nil)).Elem()
}

func (o PrivateEndpointConnectionResponseArrayOutput) ToPrivateEndpointConnectionResponseArrayOutput() PrivateEndpointConnectionResponseArrayOutput {
	return o
}

func (o PrivateEndpointConnectionResponseArrayOutput) ToPrivateEndpointConnectionResponseArrayOutputWithContext(ctx context.Context) PrivateEndpointConnectionResponseArrayOutput {
	return o
}

func (o PrivateEndpointConnectionResponseArrayOutput) Index(i pulumi.IntInput) PrivateEndpointConnectionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PrivateEndpointConnectionResponse {
		return vs[0].([]PrivateEndpointConnectionResponse)[vs[1].(int)]
	}).(PrivateEndpointConnectionResponseOutput)
}

// The Private Endpoint resource.
type PrivateEndpointResponse struct {
	// The ARM identifier for Private Endpoint
	Id string `pulumi:"id"`
}

// The Private Endpoint resource.
type PrivateEndpointResponseOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateEndpointResponse)(nil)).Elem()
}

func (o PrivateEndpointResponseOutput) ToPrivateEndpointResponseOutput() PrivateEndpointResponseOutput {
	return o
}

func (o PrivateEndpointResponseOutput) ToPrivateEndpointResponseOutputWithContext(ctx context.Context) PrivateEndpointResponseOutput {
	return o
}

// The ARM identifier for Private Endpoint
func (o PrivateEndpointResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointResponse) string { return v.Id }).(pulumi.StringOutput)
}

type PrivateEndpointResponsePtrOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateEndpointResponse)(nil)).Elem()
}

func (o PrivateEndpointResponsePtrOutput) ToPrivateEndpointResponsePtrOutput() PrivateEndpointResponsePtrOutput {
	return o
}

func (o PrivateEndpointResponsePtrOutput) ToPrivateEndpointResponsePtrOutputWithContext(ctx context.Context) PrivateEndpointResponsePtrOutput {
	return o
}

func (o PrivateEndpointResponsePtrOutput) Elem() PrivateEndpointResponseOutput {
	return o.ApplyT(func(v *PrivateEndpointResponse) PrivateEndpointResponse {
		if v != nil {
			return *v
		}
		var ret PrivateEndpointResponse
		return ret
	}).(PrivateEndpointResponseOutput)
}

// The ARM identifier for Private Endpoint
func (o PrivateEndpointResponsePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateEndpointResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Id
	}).(pulumi.StringPtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionState struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description *string `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *string `pulumi:"status"`
}

// PrivateLinkServiceConnectionStateInput is an input type that accepts PrivateLinkServiceConnectionStateArgs and PrivateLinkServiceConnectionStateOutput values.
// You can construct a concrete instance of `PrivateLinkServiceConnectionStateInput` via:
//
//	PrivateLinkServiceConnectionStateArgs{...}
type PrivateLinkServiceConnectionStateInput interface {
	pulumi.Input

	ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput
	ToPrivateLinkServiceConnectionStateOutputWithContext(context.Context) PrivateLinkServiceConnectionStateOutput
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateArgs struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired pulumi.StringPtrInput `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status pulumi.StringPtrInput `pulumi:"status"`
}

func (PrivateLinkServiceConnectionStateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput {
	return i.ToPrivateLinkServiceConnectionStateOutputWithContext(context.Background())
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateLinkServiceConnectionStateOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateOutput {
	return o
}

// A message indicating if changes on the service provider require any updates on the consumer.
func (o PrivateLinkServiceConnectionStateOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// The reason for approval/rejection of the connection.
func (o PrivateLinkServiceConnectionStateOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
func (o PrivateLinkServiceConnectionStateOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateResponse struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description *string `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *string `pulumi:"status"`
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateResponseOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionStateResponse)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStateResponseOutput) ToPrivateLinkServiceConnectionStateResponseOutput() PrivateLinkServiceConnectionStateResponseOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateResponseOutput) ToPrivateLinkServiceConnectionStateResponseOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateResponseOutput {
	return o
}

// A message indicating if changes on the service provider require any updates on the consumer.
func (o PrivateLinkServiceConnectionStateResponseOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// The reason for approval/rejection of the connection.
func (o PrivateLinkServiceConnectionStateResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
func (o PrivateLinkServiceConnectionStateResponseOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// Describes the properties of a rectangular window applied to the input media before processing it.
type Rectangle struct {
	// The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Height *string `pulumi:"height"`
	// The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Left *string `pulumi:"left"`
	// The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Top *string `pulumi:"top"`
	// The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Width *string `pulumi:"width"`
}

// RectangleInput is an input type that accepts RectangleArgs and RectangleOutput values.
// You can construct a concrete instance of `RectangleInput` via:
//
//	RectangleArgs{...}
type RectangleInput interface {
	pulumi.Input

	ToRectangleOutput() RectangleOutput
	ToRectangleOutputWithContext(context.Context) RectangleOutput
}

// Describes the properties of a rectangular window applied to the input media before processing it.
type RectangleArgs struct {
	// The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Height pulumi.StringPtrInput `pulumi:"height"`
	// The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Left pulumi.StringPtrInput `pulumi:"left"`
	// The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Top pulumi.StringPtrInput `pulumi:"top"`
	// The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Width pulumi.StringPtrInput `pulumi:"width"`
}

func (RectangleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Rectangle)(nil)).Elem()
}

func (i RectangleArgs) ToRectangleOutput() RectangleOutput {
	return i.ToRectangleOutputWithContext(context.Background())
}

func (i RectangleArgs) ToRectangleOutputWithContext(ctx context.Context) RectangleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RectangleOutput)
}

func (i RectangleArgs) ToRectanglePtrOutput() RectanglePtrOutput {
	return i.ToRectanglePtrOutputWithContext(context.Background())
}

func (i RectangleArgs) ToRectanglePtrOutputWithContext(ctx context.Context) RectanglePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RectangleOutput).ToRectanglePtrOutputWithContext(ctx)
}

// RectanglePtrInput is an input type that accepts RectangleArgs, RectanglePtr and RectanglePtrOutput values.
// You can construct a concrete instance of `RectanglePtrInput` via:
//
//	        RectangleArgs{...}
//
//	or:
//
//	        nil
type RectanglePtrInput interface {
	pulumi.Input

	ToRectanglePtrOutput() RectanglePtrOutput
	ToRectanglePtrOutputWithContext(context.Context) RectanglePtrOutput
}

type rectanglePtrType RectangleArgs

func RectanglePtr(v *RectangleArgs) RectanglePtrInput {
	return (*rectanglePtrType)(v)
}

func (*rectanglePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Rectangle)(nil)).Elem()
}

func (i *rectanglePtrType) ToRectanglePtrOutput() RectanglePtrOutput {
	return i.ToRectanglePtrOutputWithContext(context.Background())
}

func (i *rectanglePtrType) ToRectanglePtrOutputWithContext(ctx context.Context) RectanglePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RectanglePtrOutput)
}

// Describes the properties of a rectangular window applied to the input media before processing it.
type RectangleOutput struct{ *pulumi.OutputState }

func (RectangleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Rectangle)(nil)).Elem()
}

func (o RectangleOutput) ToRectangleOutput() RectangleOutput {
	return o
}

func (o RectangleOutput) ToRectangleOutputWithContext(ctx context.Context) RectangleOutput {
	return o
}

func (o RectangleOutput) ToRectanglePtrOutput() RectanglePtrOutput {
	return o.ToRectanglePtrOutputWithContext(context.Background())
}

func (o RectangleOutput) ToRectanglePtrOutputWithContext(ctx context.Context) RectanglePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Rectangle) *Rectangle {
		return &v
	}).(RectanglePtrOutput)
}

// The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Rectangle) *string { return v.Height }).(pulumi.StringPtrOutput)
}

// The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleOutput) Left() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Rectangle) *string { return v.Left }).(pulumi.StringPtrOutput)
}

// The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleOutput) Top() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Rectangle) *string { return v.Top }).(pulumi.StringPtrOutput)
}

// The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Rectangle) *string { return v.Width }).(pulumi.StringPtrOutput)
}

type RectanglePtrOutput struct{ *pulumi.OutputState }

func (RectanglePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Rectangle)(nil)).Elem()
}

func (o RectanglePtrOutput) ToRectanglePtrOutput() RectanglePtrOutput {
	return o
}

func (o RectanglePtrOutput) ToRectanglePtrOutputWithContext(ctx context.Context) RectanglePtrOutput {
	return o
}

func (o RectanglePtrOutput) Elem() RectangleOutput {
	return o.ApplyT(func(v *Rectangle) Rectangle {
		if v != nil {
			return *v
		}
		var ret Rectangle
		return ret
	}).(RectangleOutput)
}

// The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectanglePtrOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Rectangle) *string {
		if v == nil {
			return nil
		}
		return v.Height
	}).(pulumi.StringPtrOutput)
}

// The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectanglePtrOutput) Left() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Rectangle) *string {
		if v == nil {
			return nil
		}
		return v.Left
	}).(pulumi.StringPtrOutput)
}

// The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectanglePtrOutput) Top() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Rectangle) *string {
		if v == nil {
			return nil
		}
		return v.Top
	}).(pulumi.StringPtrOutput)
}

// The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectanglePtrOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Rectangle) *string {
		if v == nil {
			return nil
		}
		return v.Width
	}).(pulumi.StringPtrOutput)
}

// Describes the properties of a rectangular window applied to the input media before processing it.
type RectangleResponse struct {
	// The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Height *string `pulumi:"height"`
	// The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Left *string `pulumi:"left"`
	// The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Top *string `pulumi:"top"`
	// The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Width *string `pulumi:"width"`
}

// Describes the properties of a rectangular window applied to the input media before processing it.
type RectangleResponseOutput struct{ *pulumi.OutputState }

func (RectangleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RectangleResponse)(nil)).Elem()
}

func (o RectangleResponseOutput) ToRectangleResponseOutput() RectangleResponseOutput {
	return o
}

func (o RectangleResponseOutput) ToRectangleResponseOutputWithContext(ctx context.Context) RectangleResponseOutput {
	return o
}

// The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleResponseOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RectangleResponse) *string { return v.Height }).(pulumi.StringPtrOutput)
}

// The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleResponseOutput) Left() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RectangleResponse) *string { return v.Left }).(pulumi.StringPtrOutput)
}

// The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleResponseOutput) Top() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RectangleResponse) *string { return v.Top }).(pulumi.StringPtrOutput)
}

// The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleResponseOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RectangleResponse) *string { return v.Width }).(pulumi.StringPtrOutput)
}

type RectangleResponsePtrOutput struct{ *pulumi.OutputState }

func (RectangleResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RectangleResponse)(nil)).Elem()
}

func (o RectangleResponsePtrOutput) ToRectangleResponsePtrOutput() RectangleResponsePtrOutput {
	return o
}

func (o RectangleResponsePtrOutput) ToRectangleResponsePtrOutputWithContext(ctx context.Context) RectangleResponsePtrOutput {
	return o
}

func (o RectangleResponsePtrOutput) Elem() RectangleResponseOutput {
	return o.ApplyT(func(v *RectangleResponse) RectangleResponse {
		if v != nil {
			return *v
		}
		var ret RectangleResponse
		return ret
	}).(RectangleResponseOutput)
}

// The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleResponsePtrOutput) Height() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RectangleResponse) *string {
		if v == nil {
			return nil
		}
		return v.Height
	}).(pulumi.StringPtrOutput)
}

// The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleResponsePtrOutput) Left() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RectangleResponse) *string {
		if v == nil {
			return nil
		}
		return v.Left
	}).(pulumi.StringPtrOutput)
}

// The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleResponsePtrOutput) Top() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RectangleResponse) *string {
		if v == nil {
			return nil
		}
		return v.Top
	}).(pulumi.StringPtrOutput)
}

// The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
func (o RectangleResponsePtrOutput) Width() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RectangleResponse) *string {
		if v == nil {
			return nil
		}
		return v.Width
	}).(pulumi.StringPtrOutput)
}

type ResourceIdentity struct {
	// Indicates whether to use System Assigned Managed Identity. Mutual exclusive with User Assigned Managed Identity.
	UseSystemAssignedIdentity bool `pulumi:"useSystemAssignedIdentity"`
	// The user assigned managed identity's ARM ID to use when accessing a resource.
	UserAssignedIdentity *string `pulumi:"userAssignedIdentity"`
}

// ResourceIdentityInput is an input type that accepts ResourceIdentityArgs and ResourceIdentityOutput values.
// You can construct a concrete instance of `ResourceIdentityInput` via:
//
//	ResourceIdentityArgs{...}
type ResourceIdentityInput interface {
	pulumi.Input

	ToResourceIdentityOutput() ResourceIdentityOutput
	ToResourceIdentityOutputWithContext(context.Context) ResourceIdentityOutput
}

type ResourceIdentityArgs struct {
	// Indicates whether to use System Assigned Managed Identity. Mutual exclusive with User Assigned Managed Identity.
	UseSystemAssignedIdentity pulumi.BoolInput `pulumi:"useSystemAssignedIdentity"`
	// The user assigned managed identity's ARM ID to use when accessing a resource.
	UserAssignedIdentity pulumi.StringPtrInput `pulumi:"userAssignedIdentity"`
}

func (ResourceIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceIdentity)(nil)).Elem()
}

func (i ResourceIdentityArgs) ToResourceIdentityOutput() ResourceIdentityOutput {
	return i.ToResourceIdentityOutputWithContext(context.Background())
}

func (i ResourceIdentityArgs) ToResourceIdentityOutputWithContext(ctx context.Context) ResourceIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceIdentityOutput)
}

func (i ResourceIdentityArgs) ToResourceIdentityPtrOutput() ResourceIdentityPtrOutput {
	return i.ToResourceIdentityPtrOutputWithContext(context.Background())
}

func (i ResourceIdentityArgs) ToResourceIdentityPtrOutputWithContext(ctx context.Context) ResourceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceIdentityOutput).ToResourceIdentityPtrOutputWithContext(ctx)
}

// ResourceIdentityPtrInput is an input type that accepts ResourceIdentityArgs, ResourceIdentityPtr and ResourceIdentityPtrOutput values.
// You can construct a concrete instance of `ResourceIdentityPtrInput` via:
//
//	        ResourceIdentityArgs{...}
//
//	or:
//
//	        nil
type ResourceIdentityPtrInput interface {
	pulumi.Input

	ToResourceIdentityPtrOutput() ResourceIdentityPtrOutput
	ToResourceIdentityPtrOutputWithContext(context.Context) ResourceIdentityPtrOutput
}

type resourceIdentityPtrType ResourceIdentityArgs

func ResourceIdentityPtr(v *ResourceIdentityArgs) ResourceIdentityPtrInput {
	return (*resourceIdentityPtrType)(v)
}

func (*resourceIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceIdentity)(nil)).Elem()
}

func (i *resourceIdentityPtrType) ToResourceIdentityPtrOutput() ResourceIdentityPtrOutput {
	return i.ToResourceIdentityPtrOutputWithContext(context.Background())
}

func (i *resourceIdentityPtrType) ToResourceIdentityPtrOutputWithContext(ctx context.Context) ResourceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceIdentityPtrOutput)
}

type ResourceIdentityOutput struct{ *pulumi.OutputState }

func (ResourceIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceIdentity)(nil)).Elem()
}

func (o ResourceIdentityOutput) ToResourceIdentityOutput() ResourceIdentityOutput {
	return o
}

func (o ResourceIdentityOutput) ToResourceIdentityOutputWithContext(ctx context.Context) ResourceIdentityOutput {
	return o
}

func (o ResourceIdentityOutput) ToResourceIdentityPtrOutput() ResourceIdentityPtrOutput {
	return o.ToResourceIdentityPtrOutputWithContext(context.Background())
}

func (o ResourceIdentityOutput) ToResourceIdentityPtrOutputWithContext(ctx context.Context) ResourceIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceIdentity) *ResourceIdentity {
		return &v
	}).(ResourceIdentityPtrOutput)
}

// Indicates whether to use System Assigned Managed Identity. Mutual exclusive with User Assigned Managed Identity.
func (o ResourceIdentityOutput) UseSystemAssignedIdentity() pulumi.BoolOutput {
	return o.ApplyT(func(v ResourceIdentity) bool { return v.UseSystemAssignedIdentity }).(pulumi.BoolOutput)
}

// The user assigned managed identity's ARM ID to use when accessing a resource.
func (o ResourceIdentityOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceIdentity) *string { return v.UserAssignedIdentity }).(pulumi.StringPtrOutput)
}

type ResourceIdentityPtrOutput struct{ *pulumi.OutputState }

func (ResourceIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceIdentity)(nil)).Elem()
}

func (o ResourceIdentityPtrOutput) ToResourceIdentityPtrOutput() ResourceIdentityPtrOutput {
	return o
}

func (o ResourceIdentityPtrOutput) ToResourceIdentityPtrOutputWithContext(ctx context.Context) ResourceIdentityPtrOutput {
	return o
}

func (o ResourceIdentityPtrOutput) Elem() ResourceIdentityOutput {
	return o.ApplyT(func(v *ResourceIdentity) ResourceIdentity {
		if v != nil {
			return *v
		}
		var ret ResourceIdentity
		return ret
	}).(ResourceIdentityOutput)
}

// Indicates whether to use System Assigned Managed Identity. Mutual exclusive with User Assigned Managed Identity.
func (o ResourceIdentityPtrOutput) UseSystemAssignedIdentity() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ResourceIdentity) *bool {
		if v == nil {
			return nil
		}
		return &v.UseSystemAssignedIdentity
	}).(pulumi.BoolPtrOutput)
}

// The user assigned managed identity's ARM ID to use when accessing a resource.
func (o ResourceIdentityPtrOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceIdentity) *string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentity
	}).(pulumi.StringPtrOutput)
}

type ResourceIdentityResponse struct {
	// Indicates whether to use System Assigned Managed Identity. Mutual exclusive with User Assigned Managed Identity.
	UseSystemAssignedIdentity bool `pulumi:"useSystemAssignedIdentity"`
	// The user assigned managed identity's ARM ID to use when accessing a resource.
	UserAssignedIdentity *string `pulumi:"userAssignedIdentity"`
}

type ResourceIdentityResponseOutput struct{ *pulumi.OutputState }

func (ResourceIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceIdentityResponse)(nil)).Elem()
}

func (o ResourceIdentityResponseOutput) ToResourceIdentityResponseOutput() ResourceIdentityResponseOutput {
	return o
}

func (o ResourceIdentityResponseOutput) ToResourceIdentityResponseOutputWithContext(ctx context.Context) ResourceIdentityResponseOutput {
	return o
}

// Indicates whether to use System Assigned Managed Identity. Mutual exclusive with User Assigned Managed Identity.
func (o ResourceIdentityResponseOutput) UseSystemAssignedIdentity() pulumi.BoolOutput {
	return o.ApplyT(func(v ResourceIdentityResponse) bool { return v.UseSystemAssignedIdentity }).(pulumi.BoolOutput)
}

// The user assigned managed identity's ARM ID to use when accessing a resource.
func (o ResourceIdentityResponseOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceIdentityResponse) *string { return v.UserAssignedIdentity }).(pulumi.StringPtrOutput)
}

type ResourceIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (ResourceIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceIdentityResponse)(nil)).Elem()
}

func (o ResourceIdentityResponsePtrOutput) ToResourceIdentityResponsePtrOutput() ResourceIdentityResponsePtrOutput {
	return o
}

func (o ResourceIdentityResponsePtrOutput) ToResourceIdentityResponsePtrOutputWithContext(ctx context.Context) ResourceIdentityResponsePtrOutput {
	return o
}

func (o ResourceIdentityResponsePtrOutput) Elem() ResourceIdentityResponseOutput {
	return o.ApplyT(func(v *ResourceIdentityResponse) ResourceIdentityResponse {
		if v != nil {
			return *v
		}
		var ret ResourceIdentityResponse
		return ret
	}).(ResourceIdentityResponseOutput)
}

// Indicates whether to use System Assigned Managed Identity. Mutual exclusive with User Assigned Managed Identity.
func (o ResourceIdentityResponsePtrOutput) UseSystemAssignedIdentity() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ResourceIdentityResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.UseSystemAssignedIdentity
	}).(pulumi.BoolPtrOutput)
}

// The user assigned managed identity's ARM ID to use when accessing a resource.
func (o ResourceIdentityResponsePtrOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentity
	}).(pulumi.StringPtrOutput)
}

// Select audio tracks from the input by specifying an attribute and an attribute filter.
type SelectAudioTrackByAttribute struct {
	// The TrackAttribute to filter the tracks by.
	Attribute string `pulumi:"attribute"`
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter string `pulumi:"filter"`
	// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property.
	FilterValue *string `pulumi:"filterValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectAudioTrackByAttribute'.
	OdataType string `pulumi:"odataType"`
}

// SelectAudioTrackByAttributeInput is an input type that accepts SelectAudioTrackByAttributeArgs and SelectAudioTrackByAttributeOutput values.
// You can construct a concrete instance of `SelectAudioTrackByAttributeInput` via:
//
//	SelectAudioTrackByAttributeArgs{...}
type SelectAudioTrackByAttributeInput interface {
	pulumi.Input

	ToSelectAudioTrackByAttributeOutput() SelectAudioTrackByAttributeOutput
	ToSelectAudioTrackByAttributeOutputWithContext(context.Context) SelectAudioTrackByAttributeOutput
}

// Select audio tracks from the input by specifying an attribute and an attribute filter.
type SelectAudioTrackByAttributeArgs struct {
	// The TrackAttribute to filter the tracks by.
	Attribute pulumi.StringInput `pulumi:"attribute"`
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping pulumi.StringPtrInput `pulumi:"channelMapping"`
	// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter pulumi.StringInput `pulumi:"filter"`
	// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property.
	FilterValue pulumi.StringPtrInput `pulumi:"filterValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectAudioTrackByAttribute'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (SelectAudioTrackByAttributeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectAudioTrackByAttribute)(nil)).Elem()
}

func (i SelectAudioTrackByAttributeArgs) ToSelectAudioTrackByAttributeOutput() SelectAudioTrackByAttributeOutput {
	return i.ToSelectAudioTrackByAttributeOutputWithContext(context.Background())
}

func (i SelectAudioTrackByAttributeArgs) ToSelectAudioTrackByAttributeOutputWithContext(ctx context.Context) SelectAudioTrackByAttributeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SelectAudioTrackByAttributeOutput)
}

// Select audio tracks from the input by specifying an attribute and an attribute filter.
type SelectAudioTrackByAttributeOutput struct{ *pulumi.OutputState }

func (SelectAudioTrackByAttributeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectAudioTrackByAttribute)(nil)).Elem()
}

func (o SelectAudioTrackByAttributeOutput) ToSelectAudioTrackByAttributeOutput() SelectAudioTrackByAttributeOutput {
	return o
}

func (o SelectAudioTrackByAttributeOutput) ToSelectAudioTrackByAttributeOutputWithContext(ctx context.Context) SelectAudioTrackByAttributeOutput {
	return o
}

// The TrackAttribute to filter the tracks by.
func (o SelectAudioTrackByAttributeOutput) Attribute() pulumi.StringOutput {
	return o.ApplyT(func(v SelectAudioTrackByAttribute) string { return v.Attribute }).(pulumi.StringOutput)
}

// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
func (o SelectAudioTrackByAttributeOutput) ChannelMapping() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SelectAudioTrackByAttribute) *string { return v.ChannelMapping }).(pulumi.StringPtrOutput)
}

// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
func (o SelectAudioTrackByAttributeOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v SelectAudioTrackByAttribute) string { return v.Filter }).(pulumi.StringOutput)
}

// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property.
func (o SelectAudioTrackByAttributeOutput) FilterValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SelectAudioTrackByAttribute) *string { return v.FilterValue }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.SelectAudioTrackByAttribute'.
func (o SelectAudioTrackByAttributeOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v SelectAudioTrackByAttribute) string { return v.OdataType }).(pulumi.StringOutput)
}

// Select audio tracks from the input by specifying an attribute and an attribute filter.
type SelectAudioTrackByAttributeResponse struct {
	// The TrackAttribute to filter the tracks by.
	Attribute string `pulumi:"attribute"`
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter string `pulumi:"filter"`
	// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property.
	FilterValue *string `pulumi:"filterValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectAudioTrackByAttribute'.
	OdataType string `pulumi:"odataType"`
}

// Select audio tracks from the input by specifying an attribute and an attribute filter.
type SelectAudioTrackByAttributeResponseOutput struct{ *pulumi.OutputState }

func (SelectAudioTrackByAttributeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectAudioTrackByAttributeResponse)(nil)).Elem()
}

func (o SelectAudioTrackByAttributeResponseOutput) ToSelectAudioTrackByAttributeResponseOutput() SelectAudioTrackByAttributeResponseOutput {
	return o
}

func (o SelectAudioTrackByAttributeResponseOutput) ToSelectAudioTrackByAttributeResponseOutputWithContext(ctx context.Context) SelectAudioTrackByAttributeResponseOutput {
	return o
}

// The TrackAttribute to filter the tracks by.
func (o SelectAudioTrackByAttributeResponseOutput) Attribute() pulumi.StringOutput {
	return o.ApplyT(func(v SelectAudioTrackByAttributeResponse) string { return v.Attribute }).(pulumi.StringOutput)
}

// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
func (o SelectAudioTrackByAttributeResponseOutput) ChannelMapping() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SelectAudioTrackByAttributeResponse) *string { return v.ChannelMapping }).(pulumi.StringPtrOutput)
}

// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
func (o SelectAudioTrackByAttributeResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v SelectAudioTrackByAttributeResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property.
func (o SelectAudioTrackByAttributeResponseOutput) FilterValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SelectAudioTrackByAttributeResponse) *string { return v.FilterValue }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.SelectAudioTrackByAttribute'.
func (o SelectAudioTrackByAttributeResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v SelectAudioTrackByAttributeResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Select audio tracks from the input by specifying a track identifier.
type SelectAudioTrackById struct {
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectAudioTrackById'.
	OdataType string `pulumi:"odataType"`
	// Track identifier to select
	TrackId float64 `pulumi:"trackId"`
}

// SelectAudioTrackByIdInput is an input type that accepts SelectAudioTrackByIdArgs and SelectAudioTrackByIdOutput values.
// You can construct a concrete instance of `SelectAudioTrackByIdInput` via:
//
//	SelectAudioTrackByIdArgs{...}
type SelectAudioTrackByIdInput interface {
	pulumi.Input

	ToSelectAudioTrackByIdOutput() SelectAudioTrackByIdOutput
	ToSelectAudioTrackByIdOutputWithContext(context.Context) SelectAudioTrackByIdOutput
}

// Select audio tracks from the input by specifying a track identifier.
type SelectAudioTrackByIdArgs struct {
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping pulumi.StringPtrInput `pulumi:"channelMapping"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectAudioTrackById'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Track identifier to select
	TrackId pulumi.Float64Input `pulumi:"trackId"`
}

func (SelectAudioTrackByIdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectAudioTrackById)(nil)).Elem()
}

func (i SelectAudioTrackByIdArgs) ToSelectAudioTrackByIdOutput() SelectAudioTrackByIdOutput {
	return i.ToSelectAudioTrackByIdOutputWithContext(context.Background())
}

func (i SelectAudioTrackByIdArgs) ToSelectAudioTrackByIdOutputWithContext(ctx context.Context) SelectAudioTrackByIdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SelectAudioTrackByIdOutput)
}

// Select audio tracks from the input by specifying a track identifier.
type SelectAudioTrackByIdOutput struct{ *pulumi.OutputState }

func (SelectAudioTrackByIdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectAudioTrackById)(nil)).Elem()
}

func (o SelectAudioTrackByIdOutput) ToSelectAudioTrackByIdOutput() SelectAudioTrackByIdOutput {
	return o
}

func (o SelectAudioTrackByIdOutput) ToSelectAudioTrackByIdOutputWithContext(ctx context.Context) SelectAudioTrackByIdOutput {
	return o
}

// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
func (o SelectAudioTrackByIdOutput) ChannelMapping() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SelectAudioTrackById) *string { return v.ChannelMapping }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.SelectAudioTrackById'.
func (o SelectAudioTrackByIdOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v SelectAudioTrackById) string { return v.OdataType }).(pulumi.StringOutput)
}

// Track identifier to select
func (o SelectAudioTrackByIdOutput) TrackId() pulumi.Float64Output {
	return o.ApplyT(func(v SelectAudioTrackById) float64 { return v.TrackId }).(pulumi.Float64Output)
}

// Select audio tracks from the input by specifying a track identifier.
type SelectAudioTrackByIdResponse struct {
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectAudioTrackById'.
	OdataType string `pulumi:"odataType"`
	// Track identifier to select
	TrackId float64 `pulumi:"trackId"`
}

// Select audio tracks from the input by specifying a track identifier.
type SelectAudioTrackByIdResponseOutput struct{ *pulumi.OutputState }

func (SelectAudioTrackByIdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectAudioTrackByIdResponse)(nil)).Elem()
}

func (o SelectAudioTrackByIdResponseOutput) ToSelectAudioTrackByIdResponseOutput() SelectAudioTrackByIdResponseOutput {
	return o
}

func (o SelectAudioTrackByIdResponseOutput) ToSelectAudioTrackByIdResponseOutputWithContext(ctx context.Context) SelectAudioTrackByIdResponseOutput {
	return o
}

// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
func (o SelectAudioTrackByIdResponseOutput) ChannelMapping() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SelectAudioTrackByIdResponse) *string { return v.ChannelMapping }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.SelectAudioTrackById'.
func (o SelectAudioTrackByIdResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v SelectAudioTrackByIdResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Track identifier to select
func (o SelectAudioTrackByIdResponseOutput) TrackId() pulumi.Float64Output {
	return o.ApplyT(func(v SelectAudioTrackByIdResponse) float64 { return v.TrackId }).(pulumi.Float64Output)
}

// Select video tracks from the input by specifying an attribute and an attribute filter.
type SelectVideoTrackByAttribute struct {
	// The TrackAttribute to filter the tracks by.
	Attribute string `pulumi:"attribute"`
	// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter string `pulumi:"filter"`
	// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property. For TrackAttribute.Bitrate, this should be an integer value in bits per second (e.g: '1500000').  The TrackAttribute.Language is not supported for video tracks.
	FilterValue *string `pulumi:"filterValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectVideoTrackByAttribute'.
	OdataType string `pulumi:"odataType"`
}

// SelectVideoTrackByAttributeInput is an input type that accepts SelectVideoTrackByAttributeArgs and SelectVideoTrackByAttributeOutput values.
// You can construct a concrete instance of `SelectVideoTrackByAttributeInput` via:
//
//	SelectVideoTrackByAttributeArgs{...}
type SelectVideoTrackByAttributeInput interface {
	pulumi.Input

	ToSelectVideoTrackByAttributeOutput() SelectVideoTrackByAttributeOutput
	ToSelectVideoTrackByAttributeOutputWithContext(context.Context) SelectVideoTrackByAttributeOutput
}

// Select video tracks from the input by specifying an attribute and an attribute filter.
type SelectVideoTrackByAttributeArgs struct {
	// The TrackAttribute to filter the tracks by.
	Attribute pulumi.StringInput `pulumi:"attribute"`
	// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter pulumi.StringInput `pulumi:"filter"`
	// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property. For TrackAttribute.Bitrate, this should be an integer value in bits per second (e.g: '1500000').  The TrackAttribute.Language is not supported for video tracks.
	FilterValue pulumi.StringPtrInput `pulumi:"filterValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectVideoTrackByAttribute'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (SelectVideoTrackByAttributeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectVideoTrackByAttribute)(nil)).Elem()
}

func (i SelectVideoTrackByAttributeArgs) ToSelectVideoTrackByAttributeOutput() SelectVideoTrackByAttributeOutput {
	return i.ToSelectVideoTrackByAttributeOutputWithContext(context.Background())
}

func (i SelectVideoTrackByAttributeArgs) ToSelectVideoTrackByAttributeOutputWithContext(ctx context.Context) SelectVideoTrackByAttributeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SelectVideoTrackByAttributeOutput)
}

// Select video tracks from the input by specifying an attribute and an attribute filter.
type SelectVideoTrackByAttributeOutput struct{ *pulumi.OutputState }

func (SelectVideoTrackByAttributeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectVideoTrackByAttribute)(nil)).Elem()
}

func (o SelectVideoTrackByAttributeOutput) ToSelectVideoTrackByAttributeOutput() SelectVideoTrackByAttributeOutput {
	return o
}

func (o SelectVideoTrackByAttributeOutput) ToSelectVideoTrackByAttributeOutputWithContext(ctx context.Context) SelectVideoTrackByAttributeOutput {
	return o
}

// The TrackAttribute to filter the tracks by.
func (o SelectVideoTrackByAttributeOutput) Attribute() pulumi.StringOutput {
	return o.ApplyT(func(v SelectVideoTrackByAttribute) string { return v.Attribute }).(pulumi.StringOutput)
}

// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
func (o SelectVideoTrackByAttributeOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v SelectVideoTrackByAttribute) string { return v.Filter }).(pulumi.StringOutput)
}

// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property. For TrackAttribute.Bitrate, this should be an integer value in bits per second (e.g: '1500000').  The TrackAttribute.Language is not supported for video tracks.
func (o SelectVideoTrackByAttributeOutput) FilterValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SelectVideoTrackByAttribute) *string { return v.FilterValue }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.SelectVideoTrackByAttribute'.
func (o SelectVideoTrackByAttributeOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v SelectVideoTrackByAttribute) string { return v.OdataType }).(pulumi.StringOutput)
}

// Select video tracks from the input by specifying an attribute and an attribute filter.
type SelectVideoTrackByAttributeResponse struct {
	// The TrackAttribute to filter the tracks by.
	Attribute string `pulumi:"attribute"`
	// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter string `pulumi:"filter"`
	// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property. For TrackAttribute.Bitrate, this should be an integer value in bits per second (e.g: '1500000').  The TrackAttribute.Language is not supported for video tracks.
	FilterValue *string `pulumi:"filterValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectVideoTrackByAttribute'.
	OdataType string `pulumi:"odataType"`
}

// Select video tracks from the input by specifying an attribute and an attribute filter.
type SelectVideoTrackByAttributeResponseOutput struct{ *pulumi.OutputState }

func (SelectVideoTrackByAttributeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectVideoTrackByAttributeResponse)(nil)).Elem()
}

func (o SelectVideoTrackByAttributeResponseOutput) ToSelectVideoTrackByAttributeResponseOutput() SelectVideoTrackByAttributeResponseOutput {
	return o
}

func (o SelectVideoTrackByAttributeResponseOutput) ToSelectVideoTrackByAttributeResponseOutputWithContext(ctx context.Context) SelectVideoTrackByAttributeResponseOutput {
	return o
}

// The TrackAttribute to filter the tracks by.
func (o SelectVideoTrackByAttributeResponseOutput) Attribute() pulumi.StringOutput {
	return o.ApplyT(func(v SelectVideoTrackByAttributeResponse) string { return v.Attribute }).(pulumi.StringOutput)
}

// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
func (o SelectVideoTrackByAttributeResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v SelectVideoTrackByAttributeResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property. For TrackAttribute.Bitrate, this should be an integer value in bits per second (e.g: '1500000').  The TrackAttribute.Language is not supported for video tracks.
func (o SelectVideoTrackByAttributeResponseOutput) FilterValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SelectVideoTrackByAttributeResponse) *string { return v.FilterValue }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.SelectVideoTrackByAttribute'.
func (o SelectVideoTrackByAttributeResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v SelectVideoTrackByAttributeResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Select video tracks from the input by specifying a track identifier.
type SelectVideoTrackById struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectVideoTrackById'.
	OdataType string `pulumi:"odataType"`
	// Track identifier to select
	TrackId float64 `pulumi:"trackId"`
}

// SelectVideoTrackByIdInput is an input type that accepts SelectVideoTrackByIdArgs and SelectVideoTrackByIdOutput values.
// You can construct a concrete instance of `SelectVideoTrackByIdInput` via:
//
//	SelectVideoTrackByIdArgs{...}
type SelectVideoTrackByIdInput interface {
	pulumi.Input

	ToSelectVideoTrackByIdOutput() SelectVideoTrackByIdOutput
	ToSelectVideoTrackByIdOutputWithContext(context.Context) SelectVideoTrackByIdOutput
}

// Select video tracks from the input by specifying a track identifier.
type SelectVideoTrackByIdArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectVideoTrackById'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Track identifier to select
	TrackId pulumi.Float64Input `pulumi:"trackId"`
}

func (SelectVideoTrackByIdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectVideoTrackById)(nil)).Elem()
}

func (i SelectVideoTrackByIdArgs) ToSelectVideoTrackByIdOutput() SelectVideoTrackByIdOutput {
	return i.ToSelectVideoTrackByIdOutputWithContext(context.Background())
}

func (i SelectVideoTrackByIdArgs) ToSelectVideoTrackByIdOutputWithContext(ctx context.Context) SelectVideoTrackByIdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SelectVideoTrackByIdOutput)
}

// Select video tracks from the input by specifying a track identifier.
type SelectVideoTrackByIdOutput struct{ *pulumi.OutputState }

func (SelectVideoTrackByIdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectVideoTrackById)(nil)).Elem()
}

func (o SelectVideoTrackByIdOutput) ToSelectVideoTrackByIdOutput() SelectVideoTrackByIdOutput {
	return o
}

func (o SelectVideoTrackByIdOutput) ToSelectVideoTrackByIdOutputWithContext(ctx context.Context) SelectVideoTrackByIdOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.SelectVideoTrackById'.
func (o SelectVideoTrackByIdOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v SelectVideoTrackById) string { return v.OdataType }).(pulumi.StringOutput)
}

// Track identifier to select
func (o SelectVideoTrackByIdOutput) TrackId() pulumi.Float64Output {
	return o.ApplyT(func(v SelectVideoTrackById) float64 { return v.TrackId }).(pulumi.Float64Output)
}

// Select video tracks from the input by specifying a track identifier.
type SelectVideoTrackByIdResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectVideoTrackById'.
	OdataType string `pulumi:"odataType"`
	// Track identifier to select
	TrackId float64 `pulumi:"trackId"`
}

// Select video tracks from the input by specifying a track identifier.
type SelectVideoTrackByIdResponseOutput struct{ *pulumi.OutputState }

func (SelectVideoTrackByIdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SelectVideoTrackByIdResponse)(nil)).Elem()
}

func (o SelectVideoTrackByIdResponseOutput) ToSelectVideoTrackByIdResponseOutput() SelectVideoTrackByIdResponseOutput {
	return o
}

func (o SelectVideoTrackByIdResponseOutput) ToSelectVideoTrackByIdResponseOutputWithContext(ctx context.Context) SelectVideoTrackByIdResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.SelectVideoTrackById'.
func (o SelectVideoTrackByIdResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v SelectVideoTrackByIdResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Track identifier to select
func (o SelectVideoTrackByIdResponseOutput) TrackId() pulumi.Float64Output {
	return o.ApplyT(func(v SelectVideoTrackByIdResponse) float64 { return v.TrackId }).(pulumi.Float64Output)
}

// Describes all the settings to be used when encoding the input video with the Standard Encoder.
type StandardEncoderPreset struct {
	// The list of codecs to be used when encoding the input video.
	Codecs []interface{} `pulumi:"codecs"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// One or more filtering operations that are applied to the input media before encoding.
	Filters *Filters `pulumi:"filters"`
	// The list of outputs to be produced by the encoder.
	Formats []interface{} `pulumi:"formats"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.StandardEncoderPreset'.
	OdataType string `pulumi:"odataType"`
}

// StandardEncoderPresetInput is an input type that accepts StandardEncoderPresetArgs and StandardEncoderPresetOutput values.
// You can construct a concrete instance of `StandardEncoderPresetInput` via:
//
//	StandardEncoderPresetArgs{...}
type StandardEncoderPresetInput interface {
	pulumi.Input

	ToStandardEncoderPresetOutput() StandardEncoderPresetOutput
	ToStandardEncoderPresetOutputWithContext(context.Context) StandardEncoderPresetOutput
}

// Describes all the settings to be used when encoding the input video with the Standard Encoder.
type StandardEncoderPresetArgs struct {
	// The list of codecs to be used when encoding the input video.
	Codecs pulumi.ArrayInput `pulumi:"codecs"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions pulumi.StringMapInput `pulumi:"experimentalOptions"`
	// One or more filtering operations that are applied to the input media before encoding.
	Filters FiltersPtrInput `pulumi:"filters"`
	// The list of outputs to be produced by the encoder.
	Formats pulumi.ArrayInput `pulumi:"formats"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.StandardEncoderPreset'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (StandardEncoderPresetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StandardEncoderPreset)(nil)).Elem()
}

func (i StandardEncoderPresetArgs) ToStandardEncoderPresetOutput() StandardEncoderPresetOutput {
	return i.ToStandardEncoderPresetOutputWithContext(context.Background())
}

func (i StandardEncoderPresetArgs) ToStandardEncoderPresetOutputWithContext(ctx context.Context) StandardEncoderPresetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StandardEncoderPresetOutput)
}

func (i StandardEncoderPresetArgs) ToStandardEncoderPresetPtrOutput() StandardEncoderPresetPtrOutput {
	return i.ToStandardEncoderPresetPtrOutputWithContext(context.Background())
}

func (i StandardEncoderPresetArgs) ToStandardEncoderPresetPtrOutputWithContext(ctx context.Context) StandardEncoderPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StandardEncoderPresetOutput).ToStandardEncoderPresetPtrOutputWithContext(ctx)
}

// StandardEncoderPresetPtrInput is an input type that accepts StandardEncoderPresetArgs, StandardEncoderPresetPtr and StandardEncoderPresetPtrOutput values.
// You can construct a concrete instance of `StandardEncoderPresetPtrInput` via:
//
//	        StandardEncoderPresetArgs{...}
//
//	or:
//
//	        nil
type StandardEncoderPresetPtrInput interface {
	pulumi.Input

	ToStandardEncoderPresetPtrOutput() StandardEncoderPresetPtrOutput
	ToStandardEncoderPresetPtrOutputWithContext(context.Context) StandardEncoderPresetPtrOutput
}

type standardEncoderPresetPtrType StandardEncoderPresetArgs

func StandardEncoderPresetPtr(v *StandardEncoderPresetArgs) StandardEncoderPresetPtrInput {
	return (*standardEncoderPresetPtrType)(v)
}

func (*standardEncoderPresetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StandardEncoderPreset)(nil)).Elem()
}

func (i *standardEncoderPresetPtrType) ToStandardEncoderPresetPtrOutput() StandardEncoderPresetPtrOutput {
	return i.ToStandardEncoderPresetPtrOutputWithContext(context.Background())
}

func (i *standardEncoderPresetPtrType) ToStandardEncoderPresetPtrOutputWithContext(ctx context.Context) StandardEncoderPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StandardEncoderPresetPtrOutput)
}

// Describes all the settings to be used when encoding the input video with the Standard Encoder.
type StandardEncoderPresetOutput struct{ *pulumi.OutputState }

func (StandardEncoderPresetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StandardEncoderPreset)(nil)).Elem()
}

func (o StandardEncoderPresetOutput) ToStandardEncoderPresetOutput() StandardEncoderPresetOutput {
	return o
}

func (o StandardEncoderPresetOutput) ToStandardEncoderPresetOutputWithContext(ctx context.Context) StandardEncoderPresetOutput {
	return o
}

func (o StandardEncoderPresetOutput) ToStandardEncoderPresetPtrOutput() StandardEncoderPresetPtrOutput {
	return o.ToStandardEncoderPresetPtrOutputWithContext(context.Background())
}

func (o StandardEncoderPresetOutput) ToStandardEncoderPresetPtrOutputWithContext(ctx context.Context) StandardEncoderPresetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StandardEncoderPreset) *StandardEncoderPreset {
		return &v
	}).(StandardEncoderPresetPtrOutput)
}

// The list of codecs to be used when encoding the input video.
func (o StandardEncoderPresetOutput) Codecs() pulumi.ArrayOutput {
	return o.ApplyT(func(v StandardEncoderPreset) []interface{} { return v.Codecs }).(pulumi.ArrayOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o StandardEncoderPresetOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v StandardEncoderPreset) map[string]string { return v.ExperimentalOptions }).(pulumi.StringMapOutput)
}

// One or more filtering operations that are applied to the input media before encoding.
func (o StandardEncoderPresetOutput) Filters() FiltersPtrOutput {
	return o.ApplyT(func(v StandardEncoderPreset) *Filters { return v.Filters }).(FiltersPtrOutput)
}

// The list of outputs to be produced by the encoder.
func (o StandardEncoderPresetOutput) Formats() pulumi.ArrayOutput {
	return o.ApplyT(func(v StandardEncoderPreset) []interface{} { return v.Formats }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.StandardEncoderPreset'.
func (o StandardEncoderPresetOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v StandardEncoderPreset) string { return v.OdataType }).(pulumi.StringOutput)
}

type StandardEncoderPresetPtrOutput struct{ *pulumi.OutputState }

func (StandardEncoderPresetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StandardEncoderPreset)(nil)).Elem()
}

func (o StandardEncoderPresetPtrOutput) ToStandardEncoderPresetPtrOutput() StandardEncoderPresetPtrOutput {
	return o
}

func (o StandardEncoderPresetPtrOutput) ToStandardEncoderPresetPtrOutputWithContext(ctx context.Context) StandardEncoderPresetPtrOutput {
	return o
}

func (o StandardEncoderPresetPtrOutput) Elem() StandardEncoderPresetOutput {
	return o.ApplyT(func(v *StandardEncoderPreset) StandardEncoderPreset {
		if v != nil {
			return *v
		}
		var ret StandardEncoderPreset
		return ret
	}).(StandardEncoderPresetOutput)
}

// The list of codecs to be used when encoding the input video.
func (o StandardEncoderPresetPtrOutput) Codecs() pulumi.ArrayOutput {
	return o.ApplyT(func(v *StandardEncoderPreset) []interface{} {
		if v == nil {
			return nil
		}
		return v.Codecs
	}).(pulumi.ArrayOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o StandardEncoderPresetPtrOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *StandardEncoderPreset) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExperimentalOptions
	}).(pulumi.StringMapOutput)
}

// One or more filtering operations that are applied to the input media before encoding.
func (o StandardEncoderPresetPtrOutput) Filters() FiltersPtrOutput {
	return o.ApplyT(func(v *StandardEncoderPreset) *Filters {
		if v == nil {
			return nil
		}
		return v.Filters
	}).(FiltersPtrOutput)
}

// The list of outputs to be produced by the encoder.
func (o StandardEncoderPresetPtrOutput) Formats() pulumi.ArrayOutput {
	return o.ApplyT(func(v *StandardEncoderPreset) []interface{} {
		if v == nil {
			return nil
		}
		return v.Formats
	}).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.StandardEncoderPreset'.
func (o StandardEncoderPresetPtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StandardEncoderPreset) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// Describes all the settings to be used when encoding the input video with the Standard Encoder.
type StandardEncoderPresetResponse struct {
	// The list of codecs to be used when encoding the input video.
	Codecs []interface{} `pulumi:"codecs"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// One or more filtering operations that are applied to the input media before encoding.
	Filters *FiltersResponse `pulumi:"filters"`
	// The list of outputs to be produced by the encoder.
	Formats []interface{} `pulumi:"formats"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.StandardEncoderPreset'.
	OdataType string `pulumi:"odataType"`
}

// Describes all the settings to be used when encoding the input video with the Standard Encoder.
type StandardEncoderPresetResponseOutput struct{ *pulumi.OutputState }

func (StandardEncoderPresetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StandardEncoderPresetResponse)(nil)).Elem()
}

func (o StandardEncoderPresetResponseOutput) ToStandardEncoderPresetResponseOutput() StandardEncoderPresetResponseOutput {
	return o
}

func (o StandardEncoderPresetResponseOutput) ToStandardEncoderPresetResponseOutputWithContext(ctx context.Context) StandardEncoderPresetResponseOutput {
	return o
}

// The list of codecs to be used when encoding the input video.
func (o StandardEncoderPresetResponseOutput) Codecs() pulumi.ArrayOutput {
	return o.ApplyT(func(v StandardEncoderPresetResponse) []interface{} { return v.Codecs }).(pulumi.ArrayOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o StandardEncoderPresetResponseOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v StandardEncoderPresetResponse) map[string]string { return v.ExperimentalOptions }).(pulumi.StringMapOutput)
}

// One or more filtering operations that are applied to the input media before encoding.
func (o StandardEncoderPresetResponseOutput) Filters() FiltersResponsePtrOutput {
	return o.ApplyT(func(v StandardEncoderPresetResponse) *FiltersResponse { return v.Filters }).(FiltersResponsePtrOutput)
}

// The list of outputs to be produced by the encoder.
func (o StandardEncoderPresetResponseOutput) Formats() pulumi.ArrayOutput {
	return o.ApplyT(func(v StandardEncoderPresetResponse) []interface{} { return v.Formats }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.StandardEncoderPreset'.
func (o StandardEncoderPresetResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v StandardEncoderPresetResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

type StandardEncoderPresetResponsePtrOutput struct{ *pulumi.OutputState }

func (StandardEncoderPresetResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StandardEncoderPresetResponse)(nil)).Elem()
}

func (o StandardEncoderPresetResponsePtrOutput) ToStandardEncoderPresetResponsePtrOutput() StandardEncoderPresetResponsePtrOutput {
	return o
}

func (o StandardEncoderPresetResponsePtrOutput) ToStandardEncoderPresetResponsePtrOutputWithContext(ctx context.Context) StandardEncoderPresetResponsePtrOutput {
	return o
}

func (o StandardEncoderPresetResponsePtrOutput) Elem() StandardEncoderPresetResponseOutput {
	return o.ApplyT(func(v *StandardEncoderPresetResponse) StandardEncoderPresetResponse {
		if v != nil {
			return *v
		}
		var ret StandardEncoderPresetResponse
		return ret
	}).(StandardEncoderPresetResponseOutput)
}

// The list of codecs to be used when encoding the input video.
func (o StandardEncoderPresetResponsePtrOutput) Codecs() pulumi.ArrayOutput {
	return o.ApplyT(func(v *StandardEncoderPresetResponse) []interface{} {
		if v == nil {
			return nil
		}
		return v.Codecs
	}).(pulumi.ArrayOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o StandardEncoderPresetResponsePtrOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *StandardEncoderPresetResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExperimentalOptions
	}).(pulumi.StringMapOutput)
}

// One or more filtering operations that are applied to the input media before encoding.
func (o StandardEncoderPresetResponsePtrOutput) Filters() FiltersResponsePtrOutput {
	return o.ApplyT(func(v *StandardEncoderPresetResponse) *FiltersResponse {
		if v == nil {
			return nil
		}
		return v.Filters
	}).(FiltersResponsePtrOutput)
}

// The list of outputs to be produced by the encoder.
func (o StandardEncoderPresetResponsePtrOutput) Formats() pulumi.ArrayOutput {
	return o.ApplyT(func(v *StandardEncoderPresetResponse) []interface{} {
		if v == nil {
			return nil
		}
		return v.Formats
	}).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.StandardEncoderPreset'.
func (o StandardEncoderPresetResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StandardEncoderPresetResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// The storage account details.
type StorageAccount struct {
	// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
	Id *string `pulumi:"id"`
	// The storage account identity.
	Identity *ResourceIdentity `pulumi:"identity"`
	// The type of the storage account.
	Type string `pulumi:"type"`
}

// StorageAccountInput is an input type that accepts StorageAccountArgs and StorageAccountOutput values.
// You can construct a concrete instance of `StorageAccountInput` via:
//
//	StorageAccountArgs{...}
type StorageAccountInput interface {
	pulumi.Input

	ToStorageAccountOutput() StorageAccountOutput
	ToStorageAccountOutputWithContext(context.Context) StorageAccountOutput
}

// The storage account details.
type StorageAccountArgs struct {
	// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
	Id pulumi.StringPtrInput `pulumi:"id"`
	// The storage account identity.
	Identity ResourceIdentityPtrInput `pulumi:"identity"`
	// The type of the storage account.
	Type pulumi.StringInput `pulumi:"type"`
}

func (StorageAccountArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageAccount)(nil)).Elem()
}

func (i StorageAccountArgs) ToStorageAccountOutput() StorageAccountOutput {
	return i.ToStorageAccountOutputWithContext(context.Background())
}

func (i StorageAccountArgs) ToStorageAccountOutputWithContext(ctx context.Context) StorageAccountOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageAccountOutput)
}

// StorageAccountArrayInput is an input type that accepts StorageAccountArray and StorageAccountArrayOutput values.
// You can construct a concrete instance of `StorageAccountArrayInput` via:
//
//	StorageAccountArray{ StorageAccountArgs{...} }
type StorageAccountArrayInput interface {
	pulumi.Input

	ToStorageAccountArrayOutput() StorageAccountArrayOutput
	ToStorageAccountArrayOutputWithContext(context.Context) StorageAccountArrayOutput
}

type StorageAccountArray []StorageAccountInput

func (StorageAccountArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StorageAccount)(nil)).Elem()
}

func (i StorageAccountArray) ToStorageAccountArrayOutput() StorageAccountArrayOutput {
	return i.ToStorageAccountArrayOutputWithContext(context.Background())
}

func (i StorageAccountArray) ToStorageAccountArrayOutputWithContext(ctx context.Context) StorageAccountArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageAccountArrayOutput)
}

// The storage account details.
type StorageAccountOutput struct{ *pulumi.OutputState }

func (StorageAccountOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageAccount)(nil)).Elem()
}

func (o StorageAccountOutput) ToStorageAccountOutput() StorageAccountOutput {
	return o
}

func (o StorageAccountOutput) ToStorageAccountOutputWithContext(ctx context.Context) StorageAccountOutput {
	return o
}

// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
func (o StorageAccountOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StorageAccount) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// The storage account identity.
func (o StorageAccountOutput) Identity() ResourceIdentityPtrOutput {
	return o.ApplyT(func(v StorageAccount) *ResourceIdentity { return v.Identity }).(ResourceIdentityPtrOutput)
}

// The type of the storage account.
func (o StorageAccountOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v StorageAccount) string { return v.Type }).(pulumi.StringOutput)
}

type StorageAccountArrayOutput struct{ *pulumi.OutputState }

func (StorageAccountArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StorageAccount)(nil)).Elem()
}

func (o StorageAccountArrayOutput) ToStorageAccountArrayOutput() StorageAccountArrayOutput {
	return o
}

func (o StorageAccountArrayOutput) ToStorageAccountArrayOutputWithContext(ctx context.Context) StorageAccountArrayOutput {
	return o
}

func (o StorageAccountArrayOutput) Index(i pulumi.IntInput) StorageAccountOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StorageAccount {
		return vs[0].([]StorageAccount)[vs[1].(int)]
	}).(StorageAccountOutput)
}

// The storage account details.
type StorageAccountResponse struct {
	// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
	Id *string `pulumi:"id"`
	// The storage account identity.
	Identity *ResourceIdentityResponse `pulumi:"identity"`
	// The current status of the storage account mapping.
	Status string `pulumi:"status"`
	// The type of the storage account.
	Type string `pulumi:"type"`
}

// The storage account details.
type StorageAccountResponseOutput struct{ *pulumi.OutputState }

func (StorageAccountResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageAccountResponse)(nil)).Elem()
}

func (o StorageAccountResponseOutput) ToStorageAccountResponseOutput() StorageAccountResponseOutput {
	return o
}

func (o StorageAccountResponseOutput) ToStorageAccountResponseOutputWithContext(ctx context.Context) StorageAccountResponseOutput {
	return o
}

// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
func (o StorageAccountResponseOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StorageAccountResponse) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// The storage account identity.
func (o StorageAccountResponseOutput) Identity() ResourceIdentityResponsePtrOutput {
	return o.ApplyT(func(v StorageAccountResponse) *ResourceIdentityResponse { return v.Identity }).(ResourceIdentityResponsePtrOutput)
}

// The current status of the storage account mapping.
func (o StorageAccountResponseOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v StorageAccountResponse) string { return v.Status }).(pulumi.StringOutput)
}

// The type of the storage account.
func (o StorageAccountResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v StorageAccountResponse) string { return v.Type }).(pulumi.StringOutput)
}

type StorageAccountResponseArrayOutput struct{ *pulumi.OutputState }

func (StorageAccountResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StorageAccountResponse)(nil)).Elem()
}

func (o StorageAccountResponseArrayOutput) ToStorageAccountResponseArrayOutput() StorageAccountResponseArrayOutput {
	return o
}

func (o StorageAccountResponseArrayOutput) ToStorageAccountResponseArrayOutputWithContext(ctx context.Context) StorageAccountResponseArrayOutput {
	return o
}

func (o StorageAccountResponseArrayOutput) Index(i pulumi.IntInput) StorageAccountResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StorageAccountResponse {
		return vs[0].([]StorageAccountResponse)[vs[1].(int)]
	}).(StorageAccountResponseOutput)
}

// Streaming endpoint access control definition.
type StreamingEndpointAccessControl struct {
	// The access control of Akamai
	Akamai *AkamaiAccessControl `pulumi:"akamai"`
	// The IP access control of the streaming endpoint.
	Ip *IPAccessControl `pulumi:"ip"`
}

// StreamingEndpointAccessControlInput is an input type that accepts StreamingEndpointAccessControlArgs and StreamingEndpointAccessControlOutput values.
// You can construct a concrete instance of `StreamingEndpointAccessControlInput` via:
//
//	StreamingEndpointAccessControlArgs{...}
type StreamingEndpointAccessControlInput interface {
	pulumi.Input

	ToStreamingEndpointAccessControlOutput() StreamingEndpointAccessControlOutput
	ToStreamingEndpointAccessControlOutputWithContext(context.Context) StreamingEndpointAccessControlOutput
}

// Streaming endpoint access control definition.
type StreamingEndpointAccessControlArgs struct {
	// The access control of Akamai
	Akamai AkamaiAccessControlPtrInput `pulumi:"akamai"`
	// The IP access control of the streaming endpoint.
	Ip IPAccessControlPtrInput `pulumi:"ip"`
}

func (StreamingEndpointAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControl)(nil)).Elem()
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlOutput() StreamingEndpointAccessControlOutput {
	return i.ToStreamingEndpointAccessControlOutputWithContext(context.Background())
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlOutputWithContext(ctx context.Context) StreamingEndpointAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlOutput)
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return i.ToStreamingEndpointAccessControlPtrOutputWithContext(context.Background())
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlOutput).ToStreamingEndpointAccessControlPtrOutputWithContext(ctx)
}

// StreamingEndpointAccessControlPtrInput is an input type that accepts StreamingEndpointAccessControlArgs, StreamingEndpointAccessControlPtr and StreamingEndpointAccessControlPtrOutput values.
// You can construct a concrete instance of `StreamingEndpointAccessControlPtrInput` via:
//
//	        StreamingEndpointAccessControlArgs{...}
//
//	or:
//
//	        nil
type StreamingEndpointAccessControlPtrInput interface {
	pulumi.Input

	ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput
	ToStreamingEndpointAccessControlPtrOutputWithContext(context.Context) StreamingEndpointAccessControlPtrOutput
}

type streamingEndpointAccessControlPtrType StreamingEndpointAccessControlArgs

func StreamingEndpointAccessControlPtr(v *StreamingEndpointAccessControlArgs) StreamingEndpointAccessControlPtrInput {
	return (*streamingEndpointAccessControlPtrType)(v)
}

func (*streamingEndpointAccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingEndpointAccessControl)(nil)).Elem()
}

func (i *streamingEndpointAccessControlPtrType) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return i.ToStreamingEndpointAccessControlPtrOutputWithContext(context.Background())
}

func (i *streamingEndpointAccessControlPtrType) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlPtrOutput)
}

// Streaming endpoint access control definition.
type StreamingEndpointAccessControlOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControl)(nil)).Elem()
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlOutput() StreamingEndpointAccessControlOutput {
	return o
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlOutputWithContext(ctx context.Context) StreamingEndpointAccessControlOutput {
	return o
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return o.ToStreamingEndpointAccessControlPtrOutputWithContext(context.Background())
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StreamingEndpointAccessControl) *StreamingEndpointAccessControl {
		return &v
	}).(StreamingEndpointAccessControlPtrOutput)
}

// The access control of Akamai
func (o StreamingEndpointAccessControlOutput) Akamai() AkamaiAccessControlPtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControl) *AkamaiAccessControl { return v.Akamai }).(AkamaiAccessControlPtrOutput)
}

// The IP access control of the streaming endpoint.
func (o StreamingEndpointAccessControlOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControl) *IPAccessControl { return v.Ip }).(IPAccessControlPtrOutput)
}

type StreamingEndpointAccessControlPtrOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingEndpointAccessControl)(nil)).Elem()
}

func (o StreamingEndpointAccessControlPtrOutput) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return o
}

func (o StreamingEndpointAccessControlPtrOutput) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return o
}

func (o StreamingEndpointAccessControlPtrOutput) Elem() StreamingEndpointAccessControlOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControl) StreamingEndpointAccessControl {
		if v != nil {
			return *v
		}
		var ret StreamingEndpointAccessControl
		return ret
	}).(StreamingEndpointAccessControlOutput)
}

// The access control of Akamai
func (o StreamingEndpointAccessControlPtrOutput) Akamai() AkamaiAccessControlPtrOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControl) *AkamaiAccessControl {
		if v == nil {
			return nil
		}
		return v.Akamai
	}).(AkamaiAccessControlPtrOutput)
}

// The IP access control of the streaming endpoint.
func (o StreamingEndpointAccessControlPtrOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControl) *IPAccessControl {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlPtrOutput)
}

// Streaming endpoint access control definition.
type StreamingEndpointAccessControlResponse struct {
	// The access control of Akamai
	Akamai *AkamaiAccessControlResponse `pulumi:"akamai"`
	// The IP access control of the streaming endpoint.
	Ip *IPAccessControlResponse `pulumi:"ip"`
}

// Streaming endpoint access control definition.
type StreamingEndpointAccessControlResponseOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControlResponse)(nil)).Elem()
}

func (o StreamingEndpointAccessControlResponseOutput) ToStreamingEndpointAccessControlResponseOutput() StreamingEndpointAccessControlResponseOutput {
	return o
}

func (o StreamingEndpointAccessControlResponseOutput) ToStreamingEndpointAccessControlResponseOutputWithContext(ctx context.Context) StreamingEndpointAccessControlResponseOutput {
	return o
}

// The access control of Akamai
func (o StreamingEndpointAccessControlResponseOutput) Akamai() AkamaiAccessControlResponsePtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControlResponse) *AkamaiAccessControlResponse { return v.Akamai }).(AkamaiAccessControlResponsePtrOutput)
}

// The IP access control of the streaming endpoint.
func (o StreamingEndpointAccessControlResponseOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControlResponse) *IPAccessControlResponse { return v.Ip }).(IPAccessControlResponsePtrOutput)
}

type StreamingEndpointAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingEndpointAccessControlResponse)(nil)).Elem()
}

func (o StreamingEndpointAccessControlResponsePtrOutput) ToStreamingEndpointAccessControlResponsePtrOutput() StreamingEndpointAccessControlResponsePtrOutput {
	return o
}

func (o StreamingEndpointAccessControlResponsePtrOutput) ToStreamingEndpointAccessControlResponsePtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlResponsePtrOutput {
	return o
}

func (o StreamingEndpointAccessControlResponsePtrOutput) Elem() StreamingEndpointAccessControlResponseOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControlResponse) StreamingEndpointAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret StreamingEndpointAccessControlResponse
		return ret
	}).(StreamingEndpointAccessControlResponseOutput)
}

// The access control of Akamai
func (o StreamingEndpointAccessControlResponsePtrOutput) Akamai() AkamaiAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControlResponse) *AkamaiAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.Akamai
	}).(AkamaiAccessControlResponsePtrOutput)
}

// The IP access control of the streaming endpoint.
func (o StreamingEndpointAccessControlResponsePtrOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControlResponse) *IPAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlResponsePtrOutput)
}

// Class for content key in Streaming Locator
type StreamingLocatorContentKey struct {
	// ID of Content Key
	Id string `pulumi:"id"`
	// Label of Content Key as specified in the Streaming Policy
	LabelReferenceInStreamingPolicy *string `pulumi:"labelReferenceInStreamingPolicy"`
	// Value of Content Key
	Value *string `pulumi:"value"`
}

// StreamingLocatorContentKeyInput is an input type that accepts StreamingLocatorContentKeyArgs and StreamingLocatorContentKeyOutput values.
// You can construct a concrete instance of `StreamingLocatorContentKeyInput` via:
//
//	StreamingLocatorContentKeyArgs{...}
type StreamingLocatorContentKeyInput interface {
	pulumi.Input

	ToStreamingLocatorContentKeyOutput() StreamingLocatorContentKeyOutput
	ToStreamingLocatorContentKeyOutputWithContext(context.Context) StreamingLocatorContentKeyOutput
}

// Class for content key in Streaming Locator
type StreamingLocatorContentKeyArgs struct {
	// ID of Content Key
	Id pulumi.StringInput `pulumi:"id"`
	// Label of Content Key as specified in the Streaming Policy
	LabelReferenceInStreamingPolicy pulumi.StringPtrInput `pulumi:"labelReferenceInStreamingPolicy"`
	// Value of Content Key
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (StreamingLocatorContentKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingLocatorContentKey)(nil)).Elem()
}

func (i StreamingLocatorContentKeyArgs) ToStreamingLocatorContentKeyOutput() StreamingLocatorContentKeyOutput {
	return i.ToStreamingLocatorContentKeyOutputWithContext(context.Background())
}

func (i StreamingLocatorContentKeyArgs) ToStreamingLocatorContentKeyOutputWithContext(ctx context.Context) StreamingLocatorContentKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingLocatorContentKeyOutput)
}

// StreamingLocatorContentKeyArrayInput is an input type that accepts StreamingLocatorContentKeyArray and StreamingLocatorContentKeyArrayOutput values.
// You can construct a concrete instance of `StreamingLocatorContentKeyArrayInput` via:
//
//	StreamingLocatorContentKeyArray{ StreamingLocatorContentKeyArgs{...} }
type StreamingLocatorContentKeyArrayInput interface {
	pulumi.Input

	ToStreamingLocatorContentKeyArrayOutput() StreamingLocatorContentKeyArrayOutput
	ToStreamingLocatorContentKeyArrayOutputWithContext(context.Context) StreamingLocatorContentKeyArrayOutput
}

type StreamingLocatorContentKeyArray []StreamingLocatorContentKeyInput

func (StreamingLocatorContentKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingLocatorContentKey)(nil)).Elem()
}

func (i StreamingLocatorContentKeyArray) ToStreamingLocatorContentKeyArrayOutput() StreamingLocatorContentKeyArrayOutput {
	return i.ToStreamingLocatorContentKeyArrayOutputWithContext(context.Background())
}

func (i StreamingLocatorContentKeyArray) ToStreamingLocatorContentKeyArrayOutputWithContext(ctx context.Context) StreamingLocatorContentKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingLocatorContentKeyArrayOutput)
}

// Class for content key in Streaming Locator
type StreamingLocatorContentKeyOutput struct{ *pulumi.OutputState }

func (StreamingLocatorContentKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingLocatorContentKey)(nil)).Elem()
}

func (o StreamingLocatorContentKeyOutput) ToStreamingLocatorContentKeyOutput() StreamingLocatorContentKeyOutput {
	return o
}

func (o StreamingLocatorContentKeyOutput) ToStreamingLocatorContentKeyOutputWithContext(ctx context.Context) StreamingLocatorContentKeyOutput {
	return o
}

// ID of Content Key
func (o StreamingLocatorContentKeyOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingLocatorContentKey) string { return v.Id }).(pulumi.StringOutput)
}

// Label of Content Key as specified in the Streaming Policy
func (o StreamingLocatorContentKeyOutput) LabelReferenceInStreamingPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingLocatorContentKey) *string { return v.LabelReferenceInStreamingPolicy }).(pulumi.StringPtrOutput)
}

// Value of Content Key
func (o StreamingLocatorContentKeyOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingLocatorContentKey) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type StreamingLocatorContentKeyArrayOutput struct{ *pulumi.OutputState }

func (StreamingLocatorContentKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingLocatorContentKey)(nil)).Elem()
}

func (o StreamingLocatorContentKeyArrayOutput) ToStreamingLocatorContentKeyArrayOutput() StreamingLocatorContentKeyArrayOutput {
	return o
}

func (o StreamingLocatorContentKeyArrayOutput) ToStreamingLocatorContentKeyArrayOutputWithContext(ctx context.Context) StreamingLocatorContentKeyArrayOutput {
	return o
}

func (o StreamingLocatorContentKeyArrayOutput) Index(i pulumi.IntInput) StreamingLocatorContentKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingLocatorContentKey {
		return vs[0].([]StreamingLocatorContentKey)[vs[1].(int)]
	}).(StreamingLocatorContentKeyOutput)
}

// Class for content key in Streaming Locator
type StreamingLocatorContentKeyResponse struct {
	// ID of Content Key
	Id string `pulumi:"id"`
	// Label of Content Key as specified in the Streaming Policy
	LabelReferenceInStreamingPolicy *string `pulumi:"labelReferenceInStreamingPolicy"`
	// ContentKeyPolicy used by Content Key
	PolicyName string `pulumi:"policyName"`
	// Tracks which use this Content Key
	Tracks []TrackSelectionResponse `pulumi:"tracks"`
	// Encryption type of Content Key
	Type string `pulumi:"type"`
	// Value of Content Key
	Value *string `pulumi:"value"`
}

// Class for content key in Streaming Locator
type StreamingLocatorContentKeyResponseOutput struct{ *pulumi.OutputState }

func (StreamingLocatorContentKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingLocatorContentKeyResponse)(nil)).Elem()
}

func (o StreamingLocatorContentKeyResponseOutput) ToStreamingLocatorContentKeyResponseOutput() StreamingLocatorContentKeyResponseOutput {
	return o
}

func (o StreamingLocatorContentKeyResponseOutput) ToStreamingLocatorContentKeyResponseOutputWithContext(ctx context.Context) StreamingLocatorContentKeyResponseOutput {
	return o
}

// ID of Content Key
func (o StreamingLocatorContentKeyResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) string { return v.Id }).(pulumi.StringOutput)
}

// Label of Content Key as specified in the Streaming Policy
func (o StreamingLocatorContentKeyResponseOutput) LabelReferenceInStreamingPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) *string { return v.LabelReferenceInStreamingPolicy }).(pulumi.StringPtrOutput)
}

// ContentKeyPolicy used by Content Key
func (o StreamingLocatorContentKeyResponseOutput) PolicyName() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) string { return v.PolicyName }).(pulumi.StringOutput)
}

// Tracks which use this Content Key
func (o StreamingLocatorContentKeyResponseOutput) Tracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) []TrackSelectionResponse { return v.Tracks }).(TrackSelectionResponseArrayOutput)
}

// Encryption type of Content Key
func (o StreamingLocatorContentKeyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Value of Content Key
func (o StreamingLocatorContentKeyResponseOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type StreamingLocatorContentKeyResponseArrayOutput struct{ *pulumi.OutputState }

func (StreamingLocatorContentKeyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingLocatorContentKeyResponse)(nil)).Elem()
}

func (o StreamingLocatorContentKeyResponseArrayOutput) ToStreamingLocatorContentKeyResponseArrayOutput() StreamingLocatorContentKeyResponseArrayOutput {
	return o
}

func (o StreamingLocatorContentKeyResponseArrayOutput) ToStreamingLocatorContentKeyResponseArrayOutputWithContext(ctx context.Context) StreamingLocatorContentKeyResponseArrayOutput {
	return o
}

func (o StreamingLocatorContentKeyResponseArrayOutput) Index(i pulumi.IntInput) StreamingLocatorContentKeyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingLocatorContentKeyResponse {
		return vs[0].([]StreamingLocatorContentKeyResponse)[vs[1].(int)]
	}).(StreamingLocatorContentKeyResponseOutput)
}

// Class of paths for streaming
type StreamingPathResponse struct {
	// Encryption scheme
	EncryptionScheme string `pulumi:"encryptionScheme"`
	// Streaming paths for each protocol and encryptionScheme pair
	Paths []string `pulumi:"paths"`
	// Streaming protocol
	StreamingProtocol string `pulumi:"streamingProtocol"`
}

// Class of paths for streaming
type StreamingPathResponseOutput struct{ *pulumi.OutputState }

func (StreamingPathResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPathResponse)(nil)).Elem()
}

func (o StreamingPathResponseOutput) ToStreamingPathResponseOutput() StreamingPathResponseOutput {
	return o
}

func (o StreamingPathResponseOutput) ToStreamingPathResponseOutputWithContext(ctx context.Context) StreamingPathResponseOutput {
	return o
}

// Encryption scheme
func (o StreamingPathResponseOutput) EncryptionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingPathResponse) string { return v.EncryptionScheme }).(pulumi.StringOutput)
}

// Streaming paths for each protocol and encryptionScheme pair
func (o StreamingPathResponseOutput) Paths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v StreamingPathResponse) []string { return v.Paths }).(pulumi.StringArrayOutput)
}

// Streaming protocol
func (o StreamingPathResponseOutput) StreamingProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingPathResponse) string { return v.StreamingProtocol }).(pulumi.StringOutput)
}

type StreamingPathResponseArrayOutput struct{ *pulumi.OutputState }

func (StreamingPathResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingPathResponse)(nil)).Elem()
}

func (o StreamingPathResponseArrayOutput) ToStreamingPathResponseArrayOutput() StreamingPathResponseArrayOutput {
	return o
}

func (o StreamingPathResponseArrayOutput) ToStreamingPathResponseArrayOutputWithContext(ctx context.Context) StreamingPathResponseArrayOutput {
	return o
}

func (o StreamingPathResponseArrayOutput) Index(i pulumi.IntInput) StreamingPathResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingPathResponse {
		return vs[0].([]StreamingPathResponse)[vs[1].(int)]
	}).(StreamingPathResponseOutput)
}

// Class to specify properties of content key
type StreamingPolicyContentKey struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `pulumi:"label"`
	// Policy used by Content Key
	PolicyName *string `pulumi:"policyName"`
	// Tracks which use this content key
	Tracks []TrackSelection `pulumi:"tracks"`
}

// StreamingPolicyContentKeyInput is an input type that accepts StreamingPolicyContentKeyArgs and StreamingPolicyContentKeyOutput values.
// You can construct a concrete instance of `StreamingPolicyContentKeyInput` via:
//
//	StreamingPolicyContentKeyArgs{...}
type StreamingPolicyContentKeyInput interface {
	pulumi.Input

	ToStreamingPolicyContentKeyOutput() StreamingPolicyContentKeyOutput
	ToStreamingPolicyContentKeyOutputWithContext(context.Context) StreamingPolicyContentKeyOutput
}

// Class to specify properties of content key
type StreamingPolicyContentKeyArgs struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label pulumi.StringPtrInput `pulumi:"label"`
	// Policy used by Content Key
	PolicyName pulumi.StringPtrInput `pulumi:"policyName"`
	// Tracks which use this content key
	Tracks TrackSelectionArrayInput `pulumi:"tracks"`
}

func (StreamingPolicyContentKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKey)(nil)).Elem()
}

func (i StreamingPolicyContentKeyArgs) ToStreamingPolicyContentKeyOutput() StreamingPolicyContentKeyOutput {
	return i.ToStreamingPolicyContentKeyOutputWithContext(context.Background())
}

func (i StreamingPolicyContentKeyArgs) ToStreamingPolicyContentKeyOutputWithContext(ctx context.Context) StreamingPolicyContentKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyContentKeyOutput)
}

// StreamingPolicyContentKeyArrayInput is an input type that accepts StreamingPolicyContentKeyArray and StreamingPolicyContentKeyArrayOutput values.
// You can construct a concrete instance of `StreamingPolicyContentKeyArrayInput` via:
//
//	StreamingPolicyContentKeyArray{ StreamingPolicyContentKeyArgs{...} }
type StreamingPolicyContentKeyArrayInput interface {
	pulumi.Input

	ToStreamingPolicyContentKeyArrayOutput() StreamingPolicyContentKeyArrayOutput
	ToStreamingPolicyContentKeyArrayOutputWithContext(context.Context) StreamingPolicyContentKeyArrayOutput
}

type StreamingPolicyContentKeyArray []StreamingPolicyContentKeyInput

func (StreamingPolicyContentKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingPolicyContentKey)(nil)).Elem()
}

func (i StreamingPolicyContentKeyArray) ToStreamingPolicyContentKeyArrayOutput() StreamingPolicyContentKeyArrayOutput {
	return i.ToStreamingPolicyContentKeyArrayOutputWithContext(context.Background())
}

func (i StreamingPolicyContentKeyArray) ToStreamingPolicyContentKeyArrayOutputWithContext(ctx context.Context) StreamingPolicyContentKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyContentKeyArrayOutput)
}

// Class to specify properties of content key
type StreamingPolicyContentKeyOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKey)(nil)).Elem()
}

func (o StreamingPolicyContentKeyOutput) ToStreamingPolicyContentKeyOutput() StreamingPolicyContentKeyOutput {
	return o
}

func (o StreamingPolicyContentKeyOutput) ToStreamingPolicyContentKeyOutputWithContext(ctx context.Context) StreamingPolicyContentKeyOutput {
	return o
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o StreamingPolicyContentKeyOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKey) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// Policy used by Content Key
func (o StreamingPolicyContentKeyOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKey) *string { return v.PolicyName }).(pulumi.StringPtrOutput)
}

// Tracks which use this content key
func (o StreamingPolicyContentKeyOutput) Tracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v StreamingPolicyContentKey) []TrackSelection { return v.Tracks }).(TrackSelectionArrayOutput)
}

type StreamingPolicyContentKeyArrayOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingPolicyContentKey)(nil)).Elem()
}

func (o StreamingPolicyContentKeyArrayOutput) ToStreamingPolicyContentKeyArrayOutput() StreamingPolicyContentKeyArrayOutput {
	return o
}

func (o StreamingPolicyContentKeyArrayOutput) ToStreamingPolicyContentKeyArrayOutputWithContext(ctx context.Context) StreamingPolicyContentKeyArrayOutput {
	return o
}

func (o StreamingPolicyContentKeyArrayOutput) Index(i pulumi.IntInput) StreamingPolicyContentKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingPolicyContentKey {
		return vs[0].([]StreamingPolicyContentKey)[vs[1].(int)]
	}).(StreamingPolicyContentKeyOutput)
}

// Class to specify properties of content key
type StreamingPolicyContentKeyResponse struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `pulumi:"label"`
	// Policy used by Content Key
	PolicyName *string `pulumi:"policyName"`
	// Tracks which use this content key
	Tracks []TrackSelectionResponse `pulumi:"tracks"`
}

// Class to specify properties of content key
type StreamingPolicyContentKeyResponseOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKeyResponse)(nil)).Elem()
}

func (o StreamingPolicyContentKeyResponseOutput) ToStreamingPolicyContentKeyResponseOutput() StreamingPolicyContentKeyResponseOutput {
	return o
}

func (o StreamingPolicyContentKeyResponseOutput) ToStreamingPolicyContentKeyResponseOutputWithContext(ctx context.Context) StreamingPolicyContentKeyResponseOutput {
	return o
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o StreamingPolicyContentKeyResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeyResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// Policy used by Content Key
func (o StreamingPolicyContentKeyResponseOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeyResponse) *string { return v.PolicyName }).(pulumi.StringPtrOutput)
}

// Tracks which use this content key
func (o StreamingPolicyContentKeyResponseOutput) Tracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeyResponse) []TrackSelectionResponse { return v.Tracks }).(TrackSelectionResponseArrayOutput)
}

type StreamingPolicyContentKeyResponseArrayOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingPolicyContentKeyResponse)(nil)).Elem()
}

func (o StreamingPolicyContentKeyResponseArrayOutput) ToStreamingPolicyContentKeyResponseArrayOutput() StreamingPolicyContentKeyResponseArrayOutput {
	return o
}

func (o StreamingPolicyContentKeyResponseArrayOutput) ToStreamingPolicyContentKeyResponseArrayOutputWithContext(ctx context.Context) StreamingPolicyContentKeyResponseArrayOutput {
	return o
}

func (o StreamingPolicyContentKeyResponseArrayOutput) Index(i pulumi.IntInput) StreamingPolicyContentKeyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingPolicyContentKeyResponse {
		return vs[0].([]StreamingPolicyContentKeyResponse)[vs[1].(int)]
	}).(StreamingPolicyContentKeyResponseOutput)
}

// Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeys struct {
	// Default content key for an encryption scheme
	DefaultKey *DefaultKey `pulumi:"defaultKey"`
	// Representing tracks needs separate content key
	KeyToTrackMappings []StreamingPolicyContentKey `pulumi:"keyToTrackMappings"`
}

// StreamingPolicyContentKeysInput is an input type that accepts StreamingPolicyContentKeysArgs and StreamingPolicyContentKeysOutput values.
// You can construct a concrete instance of `StreamingPolicyContentKeysInput` via:
//
//	StreamingPolicyContentKeysArgs{...}
type StreamingPolicyContentKeysInput interface {
	pulumi.Input

	ToStreamingPolicyContentKeysOutput() StreamingPolicyContentKeysOutput
	ToStreamingPolicyContentKeysOutputWithContext(context.Context) StreamingPolicyContentKeysOutput
}

// Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeysArgs struct {
	// Default content key for an encryption scheme
	DefaultKey DefaultKeyPtrInput `pulumi:"defaultKey"`
	// Representing tracks needs separate content key
	KeyToTrackMappings StreamingPolicyContentKeyArrayInput `pulumi:"keyToTrackMappings"`
}

func (StreamingPolicyContentKeysArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKeys)(nil)).Elem()
}

func (i StreamingPolicyContentKeysArgs) ToStreamingPolicyContentKeysOutput() StreamingPolicyContentKeysOutput {
	return i.ToStreamingPolicyContentKeysOutputWithContext(context.Background())
}

func (i StreamingPolicyContentKeysArgs) ToStreamingPolicyContentKeysOutputWithContext(ctx context.Context) StreamingPolicyContentKeysOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyContentKeysOutput)
}

func (i StreamingPolicyContentKeysArgs) ToStreamingPolicyContentKeysPtrOutput() StreamingPolicyContentKeysPtrOutput {
	return i.ToStreamingPolicyContentKeysPtrOutputWithContext(context.Background())
}

func (i StreamingPolicyContentKeysArgs) ToStreamingPolicyContentKeysPtrOutputWithContext(ctx context.Context) StreamingPolicyContentKeysPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyContentKeysOutput).ToStreamingPolicyContentKeysPtrOutputWithContext(ctx)
}

// StreamingPolicyContentKeysPtrInput is an input type that accepts StreamingPolicyContentKeysArgs, StreamingPolicyContentKeysPtr and StreamingPolicyContentKeysPtrOutput values.
// You can construct a concrete instance of `StreamingPolicyContentKeysPtrInput` via:
//
//	        StreamingPolicyContentKeysArgs{...}
//
//	or:
//
//	        nil
type StreamingPolicyContentKeysPtrInput interface {
	pulumi.Input

	ToStreamingPolicyContentKeysPtrOutput() StreamingPolicyContentKeysPtrOutput
	ToStreamingPolicyContentKeysPtrOutputWithContext(context.Context) StreamingPolicyContentKeysPtrOutput
}

type streamingPolicyContentKeysPtrType StreamingPolicyContentKeysArgs

func StreamingPolicyContentKeysPtr(v *StreamingPolicyContentKeysArgs) StreamingPolicyContentKeysPtrInput {
	return (*streamingPolicyContentKeysPtrType)(v)
}

func (*streamingPolicyContentKeysPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyContentKeys)(nil)).Elem()
}

func (i *streamingPolicyContentKeysPtrType) ToStreamingPolicyContentKeysPtrOutput() StreamingPolicyContentKeysPtrOutput {
	return i.ToStreamingPolicyContentKeysPtrOutputWithContext(context.Background())
}

func (i *streamingPolicyContentKeysPtrType) ToStreamingPolicyContentKeysPtrOutputWithContext(ctx context.Context) StreamingPolicyContentKeysPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyContentKeysPtrOutput)
}

// Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeysOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeysOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKeys)(nil)).Elem()
}

func (o StreamingPolicyContentKeysOutput) ToStreamingPolicyContentKeysOutput() StreamingPolicyContentKeysOutput {
	return o
}

func (o StreamingPolicyContentKeysOutput) ToStreamingPolicyContentKeysOutputWithContext(ctx context.Context) StreamingPolicyContentKeysOutput {
	return o
}

func (o StreamingPolicyContentKeysOutput) ToStreamingPolicyContentKeysPtrOutput() StreamingPolicyContentKeysPtrOutput {
	return o.ToStreamingPolicyContentKeysPtrOutputWithContext(context.Background())
}

func (o StreamingPolicyContentKeysOutput) ToStreamingPolicyContentKeysPtrOutputWithContext(ctx context.Context) StreamingPolicyContentKeysPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StreamingPolicyContentKeys) *StreamingPolicyContentKeys {
		return &v
	}).(StreamingPolicyContentKeysPtrOutput)
}

// Default content key for an encryption scheme
func (o StreamingPolicyContentKeysOutput) DefaultKey() DefaultKeyPtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeys) *DefaultKey { return v.DefaultKey }).(DefaultKeyPtrOutput)
}

// Representing tracks needs separate content key
func (o StreamingPolicyContentKeysOutput) KeyToTrackMappings() StreamingPolicyContentKeyArrayOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeys) []StreamingPolicyContentKey { return v.KeyToTrackMappings }).(StreamingPolicyContentKeyArrayOutput)
}

type StreamingPolicyContentKeysPtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeysPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyContentKeys)(nil)).Elem()
}

func (o StreamingPolicyContentKeysPtrOutput) ToStreamingPolicyContentKeysPtrOutput() StreamingPolicyContentKeysPtrOutput {
	return o
}

func (o StreamingPolicyContentKeysPtrOutput) ToStreamingPolicyContentKeysPtrOutputWithContext(ctx context.Context) StreamingPolicyContentKeysPtrOutput {
	return o
}

func (o StreamingPolicyContentKeysPtrOutput) Elem() StreamingPolicyContentKeysOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeys) StreamingPolicyContentKeys {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyContentKeys
		return ret
	}).(StreamingPolicyContentKeysOutput)
}

// Default content key for an encryption scheme
func (o StreamingPolicyContentKeysPtrOutput) DefaultKey() DefaultKeyPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeys) *DefaultKey {
		if v == nil {
			return nil
		}
		return v.DefaultKey
	}).(DefaultKeyPtrOutput)
}

// Representing tracks needs separate content key
func (o StreamingPolicyContentKeysPtrOutput) KeyToTrackMappings() StreamingPolicyContentKeyArrayOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeys) []StreamingPolicyContentKey {
		if v == nil {
			return nil
		}
		return v.KeyToTrackMappings
	}).(StreamingPolicyContentKeyArrayOutput)
}

// Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeysResponse struct {
	// Default content key for an encryption scheme
	DefaultKey *DefaultKeyResponse `pulumi:"defaultKey"`
	// Representing tracks needs separate content key
	KeyToTrackMappings []StreamingPolicyContentKeyResponse `pulumi:"keyToTrackMappings"`
}

// Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeysResponseOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeysResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKeysResponse)(nil)).Elem()
}

func (o StreamingPolicyContentKeysResponseOutput) ToStreamingPolicyContentKeysResponseOutput() StreamingPolicyContentKeysResponseOutput {
	return o
}

func (o StreamingPolicyContentKeysResponseOutput) ToStreamingPolicyContentKeysResponseOutputWithContext(ctx context.Context) StreamingPolicyContentKeysResponseOutput {
	return o
}

// Default content key for an encryption scheme
func (o StreamingPolicyContentKeysResponseOutput) DefaultKey() DefaultKeyResponsePtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeysResponse) *DefaultKeyResponse { return v.DefaultKey }).(DefaultKeyResponsePtrOutput)
}

// Representing tracks needs separate content key
func (o StreamingPolicyContentKeysResponseOutput) KeyToTrackMappings() StreamingPolicyContentKeyResponseArrayOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeysResponse) []StreamingPolicyContentKeyResponse {
		return v.KeyToTrackMappings
	}).(StreamingPolicyContentKeyResponseArrayOutput)
}

type StreamingPolicyContentKeysResponsePtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeysResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyContentKeysResponse)(nil)).Elem()
}

func (o StreamingPolicyContentKeysResponsePtrOutput) ToStreamingPolicyContentKeysResponsePtrOutput() StreamingPolicyContentKeysResponsePtrOutput {
	return o
}

func (o StreamingPolicyContentKeysResponsePtrOutput) ToStreamingPolicyContentKeysResponsePtrOutputWithContext(ctx context.Context) StreamingPolicyContentKeysResponsePtrOutput {
	return o
}

func (o StreamingPolicyContentKeysResponsePtrOutput) Elem() StreamingPolicyContentKeysResponseOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeysResponse) StreamingPolicyContentKeysResponse {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyContentKeysResponse
		return ret
	}).(StreamingPolicyContentKeysResponseOutput)
}

// Default content key for an encryption scheme
func (o StreamingPolicyContentKeysResponsePtrOutput) DefaultKey() DefaultKeyResponsePtrOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeysResponse) *DefaultKeyResponse {
		if v == nil {
			return nil
		}
		return v.DefaultKey
	}).(DefaultKeyResponsePtrOutput)
}

// Representing tracks needs separate content key
func (o StreamingPolicyContentKeysResponsePtrOutput) KeyToTrackMappings() StreamingPolicyContentKeyResponseArrayOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeysResponse) []StreamingPolicyContentKeyResponse {
		if v == nil {
			return nil
		}
		return v.KeyToTrackMappings
	}).(StreamingPolicyContentKeyResponseArrayOutput)
}

// Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfiguration struct {
	// All license to be persistent or not
	AllowPersistentLicense bool `pulumi:"allowPersistentLicense"`
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

// StreamingPolicyFairPlayConfigurationInput is an input type that accepts StreamingPolicyFairPlayConfigurationArgs and StreamingPolicyFairPlayConfigurationOutput values.
// You can construct a concrete instance of `StreamingPolicyFairPlayConfigurationInput` via:
//
//	StreamingPolicyFairPlayConfigurationArgs{...}
type StreamingPolicyFairPlayConfigurationInput interface {
	pulumi.Input

	ToStreamingPolicyFairPlayConfigurationOutput() StreamingPolicyFairPlayConfigurationOutput
	ToStreamingPolicyFairPlayConfigurationOutputWithContext(context.Context) StreamingPolicyFairPlayConfigurationOutput
}

// Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfigurationArgs struct {
	// All license to be persistent or not
	AllowPersistentLicense pulumi.BoolInput `pulumi:"allowPersistentLicense"`
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate pulumi.StringPtrInput `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

func (StreamingPolicyFairPlayConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyFairPlayConfiguration)(nil)).Elem()
}

func (i StreamingPolicyFairPlayConfigurationArgs) ToStreamingPolicyFairPlayConfigurationOutput() StreamingPolicyFairPlayConfigurationOutput {
	return i.ToStreamingPolicyFairPlayConfigurationOutputWithContext(context.Background())
}

func (i StreamingPolicyFairPlayConfigurationArgs) ToStreamingPolicyFairPlayConfigurationOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyFairPlayConfigurationOutput)
}

func (i StreamingPolicyFairPlayConfigurationArgs) ToStreamingPolicyFairPlayConfigurationPtrOutput() StreamingPolicyFairPlayConfigurationPtrOutput {
	return i.ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(context.Background())
}

func (i StreamingPolicyFairPlayConfigurationArgs) ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyFairPlayConfigurationOutput).ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(ctx)
}

// StreamingPolicyFairPlayConfigurationPtrInput is an input type that accepts StreamingPolicyFairPlayConfigurationArgs, StreamingPolicyFairPlayConfigurationPtr and StreamingPolicyFairPlayConfigurationPtrOutput values.
// You can construct a concrete instance of `StreamingPolicyFairPlayConfigurationPtrInput` via:
//
//	        StreamingPolicyFairPlayConfigurationArgs{...}
//
//	or:
//
//	        nil
type StreamingPolicyFairPlayConfigurationPtrInput interface {
	pulumi.Input

	ToStreamingPolicyFairPlayConfigurationPtrOutput() StreamingPolicyFairPlayConfigurationPtrOutput
	ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(context.Context) StreamingPolicyFairPlayConfigurationPtrOutput
}

type streamingPolicyFairPlayConfigurationPtrType StreamingPolicyFairPlayConfigurationArgs

func StreamingPolicyFairPlayConfigurationPtr(v *StreamingPolicyFairPlayConfigurationArgs) StreamingPolicyFairPlayConfigurationPtrInput {
	return (*streamingPolicyFairPlayConfigurationPtrType)(v)
}

func (*streamingPolicyFairPlayConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyFairPlayConfiguration)(nil)).Elem()
}

func (i *streamingPolicyFairPlayConfigurationPtrType) ToStreamingPolicyFairPlayConfigurationPtrOutput() StreamingPolicyFairPlayConfigurationPtrOutput {
	return i.ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(context.Background())
}

func (i *streamingPolicyFairPlayConfigurationPtrType) ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyFairPlayConfigurationPtrOutput)
}

// Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfigurationOutput struct{ *pulumi.OutputState }

func (StreamingPolicyFairPlayConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyFairPlayConfiguration)(nil)).Elem()
}

func (o StreamingPolicyFairPlayConfigurationOutput) ToStreamingPolicyFairPlayConfigurationOutput() StreamingPolicyFairPlayConfigurationOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationOutput) ToStreamingPolicyFairPlayConfigurationOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationOutput) ToStreamingPolicyFairPlayConfigurationPtrOutput() StreamingPolicyFairPlayConfigurationPtrOutput {
	return o.ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(context.Background())
}

func (o StreamingPolicyFairPlayConfigurationOutput) ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StreamingPolicyFairPlayConfiguration) *StreamingPolicyFairPlayConfiguration {
		return &v
	}).(StreamingPolicyFairPlayConfigurationPtrOutput)
}

// All license to be persistent or not
func (o StreamingPolicyFairPlayConfigurationOutput) AllowPersistentLicense() pulumi.BoolOutput {
	return o.ApplyT(func(v StreamingPolicyFairPlayConfiguration) bool { return v.AllowPersistentLicense }).(pulumi.BoolOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyFairPlayConfigurationOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyFairPlayConfiguration) *string { return v.CustomLicenseAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

type StreamingPolicyFairPlayConfigurationPtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyFairPlayConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyFairPlayConfiguration)(nil)).Elem()
}

func (o StreamingPolicyFairPlayConfigurationPtrOutput) ToStreamingPolicyFairPlayConfigurationPtrOutput() StreamingPolicyFairPlayConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationPtrOutput) ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationPtrOutput) Elem() StreamingPolicyFairPlayConfigurationOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfiguration) StreamingPolicyFairPlayConfiguration {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyFairPlayConfiguration
		return ret
	}).(StreamingPolicyFairPlayConfigurationOutput)
}

// All license to be persistent or not
func (o StreamingPolicyFairPlayConfigurationPtrOutput) AllowPersistentLicense() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfiguration) *bool {
		if v == nil {
			return nil
		}
		return &v.AllowPersistentLicense
	}).(pulumi.BoolPtrOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyFairPlayConfigurationPtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfigurationResponse struct {
	// All license to be persistent or not
	AllowPersistentLicense bool `pulumi:"allowPersistentLicense"`
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

// Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfigurationResponseOutput struct{ *pulumi.OutputState }

func (StreamingPolicyFairPlayConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyFairPlayConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyFairPlayConfigurationResponseOutput) ToStreamingPolicyFairPlayConfigurationResponseOutput() StreamingPolicyFairPlayConfigurationResponseOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationResponseOutput) ToStreamingPolicyFairPlayConfigurationResponseOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationResponseOutput {
	return o
}

// All license to be persistent or not
func (o StreamingPolicyFairPlayConfigurationResponseOutput) AllowPersistentLicense() pulumi.BoolOutput {
	return o.ApplyT(func(v StreamingPolicyFairPlayConfigurationResponse) bool { return v.AllowPersistentLicense }).(pulumi.BoolOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyFairPlayConfigurationResponseOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyFairPlayConfigurationResponse) *string {
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

type StreamingPolicyFairPlayConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyFairPlayConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyFairPlayConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyFairPlayConfigurationResponsePtrOutput) ToStreamingPolicyFairPlayConfigurationResponsePtrOutput() StreamingPolicyFairPlayConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationResponsePtrOutput) ToStreamingPolicyFairPlayConfigurationResponsePtrOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationResponsePtrOutput) Elem() StreamingPolicyFairPlayConfigurationResponseOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfigurationResponse) StreamingPolicyFairPlayConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyFairPlayConfigurationResponse
		return ret
	}).(StreamingPolicyFairPlayConfigurationResponseOutput)
}

// All license to be persistent or not
func (o StreamingPolicyFairPlayConfigurationResponsePtrOutput) AllowPersistentLicense() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfigurationResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.AllowPersistentLicense
	}).(pulumi.BoolPtrOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyFairPlayConfigurationResponsePtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfiguration struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
	// Custom attributes for PlayReady
	PlayReadyCustomAttributes *string `pulumi:"playReadyCustomAttributes"`
}

// StreamingPolicyPlayReadyConfigurationInput is an input type that accepts StreamingPolicyPlayReadyConfigurationArgs and StreamingPolicyPlayReadyConfigurationOutput values.
// You can construct a concrete instance of `StreamingPolicyPlayReadyConfigurationInput` via:
//
//	StreamingPolicyPlayReadyConfigurationArgs{...}
type StreamingPolicyPlayReadyConfigurationInput interface {
	pulumi.Input

	ToStreamingPolicyPlayReadyConfigurationOutput() StreamingPolicyPlayReadyConfigurationOutput
	ToStreamingPolicyPlayReadyConfigurationOutputWithContext(context.Context) StreamingPolicyPlayReadyConfigurationOutput
}

// Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfigurationArgs struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate pulumi.StringPtrInput `pulumi:"customLicenseAcquisitionUrlTemplate"`
	// Custom attributes for PlayReady
	PlayReadyCustomAttributes pulumi.StringPtrInput `pulumi:"playReadyCustomAttributes"`
}

func (StreamingPolicyPlayReadyConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyPlayReadyConfiguration)(nil)).Elem()
}

func (i StreamingPolicyPlayReadyConfigurationArgs) ToStreamingPolicyPlayReadyConfigurationOutput() StreamingPolicyPlayReadyConfigurationOutput {
	return i.ToStreamingPolicyPlayReadyConfigurationOutputWithContext(context.Background())
}

func (i StreamingPolicyPlayReadyConfigurationArgs) ToStreamingPolicyPlayReadyConfigurationOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyPlayReadyConfigurationOutput)
}

func (i StreamingPolicyPlayReadyConfigurationArgs) ToStreamingPolicyPlayReadyConfigurationPtrOutput() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return i.ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(context.Background())
}

func (i StreamingPolicyPlayReadyConfigurationArgs) ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyPlayReadyConfigurationOutput).ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(ctx)
}

// StreamingPolicyPlayReadyConfigurationPtrInput is an input type that accepts StreamingPolicyPlayReadyConfigurationArgs, StreamingPolicyPlayReadyConfigurationPtr and StreamingPolicyPlayReadyConfigurationPtrOutput values.
// You can construct a concrete instance of `StreamingPolicyPlayReadyConfigurationPtrInput` via:
//
//	        StreamingPolicyPlayReadyConfigurationArgs{...}
//
//	or:
//
//	        nil
type StreamingPolicyPlayReadyConfigurationPtrInput interface {
	pulumi.Input

	ToStreamingPolicyPlayReadyConfigurationPtrOutput() StreamingPolicyPlayReadyConfigurationPtrOutput
	ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(context.Context) StreamingPolicyPlayReadyConfigurationPtrOutput
}

type streamingPolicyPlayReadyConfigurationPtrType StreamingPolicyPlayReadyConfigurationArgs

func StreamingPolicyPlayReadyConfigurationPtr(v *StreamingPolicyPlayReadyConfigurationArgs) StreamingPolicyPlayReadyConfigurationPtrInput {
	return (*streamingPolicyPlayReadyConfigurationPtrType)(v)
}

func (*streamingPolicyPlayReadyConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyPlayReadyConfiguration)(nil)).Elem()
}

func (i *streamingPolicyPlayReadyConfigurationPtrType) ToStreamingPolicyPlayReadyConfigurationPtrOutput() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return i.ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(context.Background())
}

func (i *streamingPolicyPlayReadyConfigurationPtrType) ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfigurationOutput struct{ *pulumi.OutputState }

func (StreamingPolicyPlayReadyConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyPlayReadyConfiguration)(nil)).Elem()
}

func (o StreamingPolicyPlayReadyConfigurationOutput) ToStreamingPolicyPlayReadyConfigurationOutput() StreamingPolicyPlayReadyConfigurationOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationOutput) ToStreamingPolicyPlayReadyConfigurationOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationOutput) ToStreamingPolicyPlayReadyConfigurationPtrOutput() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(context.Background())
}

func (o StreamingPolicyPlayReadyConfigurationOutput) ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StreamingPolicyPlayReadyConfiguration) *StreamingPolicyPlayReadyConfiguration {
		return &v
	}).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyPlayReadyConfigurationOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyPlayReadyConfiguration) *string { return v.CustomLicenseAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

// Custom attributes for PlayReady
func (o StreamingPolicyPlayReadyConfigurationOutput) PlayReadyCustomAttributes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyPlayReadyConfiguration) *string { return v.PlayReadyCustomAttributes }).(pulumi.StringPtrOutput)
}

type StreamingPolicyPlayReadyConfigurationPtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyPlayReadyConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyPlayReadyConfiguration)(nil)).Elem()
}

func (o StreamingPolicyPlayReadyConfigurationPtrOutput) ToStreamingPolicyPlayReadyConfigurationPtrOutput() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationPtrOutput) ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationPtrOutput) Elem() StreamingPolicyPlayReadyConfigurationOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfiguration) StreamingPolicyPlayReadyConfiguration {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyPlayReadyConfiguration
		return ret
	}).(StreamingPolicyPlayReadyConfigurationOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyPlayReadyConfigurationPtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Custom attributes for PlayReady
func (o StreamingPolicyPlayReadyConfigurationPtrOutput) PlayReadyCustomAttributes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.PlayReadyCustomAttributes
	}).(pulumi.StringPtrOutput)
}

// Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfigurationResponse struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
	// Custom attributes for PlayReady
	PlayReadyCustomAttributes *string `pulumi:"playReadyCustomAttributes"`
}

// Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfigurationResponseOutput struct{ *pulumi.OutputState }

func (StreamingPolicyPlayReadyConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyPlayReadyConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyPlayReadyConfigurationResponseOutput) ToStreamingPolicyPlayReadyConfigurationResponseOutput() StreamingPolicyPlayReadyConfigurationResponseOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationResponseOutput) ToStreamingPolicyPlayReadyConfigurationResponseOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationResponseOutput {
	return o
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyPlayReadyConfigurationResponseOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyPlayReadyConfigurationResponse) *string {
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Custom attributes for PlayReady
func (o StreamingPolicyPlayReadyConfigurationResponseOutput) PlayReadyCustomAttributes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyPlayReadyConfigurationResponse) *string { return v.PlayReadyCustomAttributes }).(pulumi.StringPtrOutput)
}

type StreamingPolicyPlayReadyConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyPlayReadyConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyPlayReadyConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyPlayReadyConfigurationResponsePtrOutput) ToStreamingPolicyPlayReadyConfigurationResponsePtrOutput() StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationResponsePtrOutput) ToStreamingPolicyPlayReadyConfigurationResponsePtrOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationResponsePtrOutput) Elem() StreamingPolicyPlayReadyConfigurationResponseOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfigurationResponse) StreamingPolicyPlayReadyConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyPlayReadyConfigurationResponse
		return ret
	}).(StreamingPolicyPlayReadyConfigurationResponseOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyPlayReadyConfigurationResponsePtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Custom attributes for PlayReady
func (o StreamingPolicyPlayReadyConfigurationResponsePtrOutput) PlayReadyCustomAttributes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.PlayReadyCustomAttributes
	}).(pulumi.StringPtrOutput)
}

// Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfiguration struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

// StreamingPolicyWidevineConfigurationInput is an input type that accepts StreamingPolicyWidevineConfigurationArgs and StreamingPolicyWidevineConfigurationOutput values.
// You can construct a concrete instance of `StreamingPolicyWidevineConfigurationInput` via:
//
//	StreamingPolicyWidevineConfigurationArgs{...}
type StreamingPolicyWidevineConfigurationInput interface {
	pulumi.Input

	ToStreamingPolicyWidevineConfigurationOutput() StreamingPolicyWidevineConfigurationOutput
	ToStreamingPolicyWidevineConfigurationOutputWithContext(context.Context) StreamingPolicyWidevineConfigurationOutput
}

// Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfigurationArgs struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate pulumi.StringPtrInput `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

func (StreamingPolicyWidevineConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyWidevineConfiguration)(nil)).Elem()
}

func (i StreamingPolicyWidevineConfigurationArgs) ToStreamingPolicyWidevineConfigurationOutput() StreamingPolicyWidevineConfigurationOutput {
	return i.ToStreamingPolicyWidevineConfigurationOutputWithContext(context.Background())
}

func (i StreamingPolicyWidevineConfigurationArgs) ToStreamingPolicyWidevineConfigurationOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyWidevineConfigurationOutput)
}

func (i StreamingPolicyWidevineConfigurationArgs) ToStreamingPolicyWidevineConfigurationPtrOutput() StreamingPolicyWidevineConfigurationPtrOutput {
	return i.ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(context.Background())
}

func (i StreamingPolicyWidevineConfigurationArgs) ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyWidevineConfigurationOutput).ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(ctx)
}

// StreamingPolicyWidevineConfigurationPtrInput is an input type that accepts StreamingPolicyWidevineConfigurationArgs, StreamingPolicyWidevineConfigurationPtr and StreamingPolicyWidevineConfigurationPtrOutput values.
// You can construct a concrete instance of `StreamingPolicyWidevineConfigurationPtrInput` via:
//
//	        StreamingPolicyWidevineConfigurationArgs{...}
//
//	or:
//
//	        nil
type StreamingPolicyWidevineConfigurationPtrInput interface {
	pulumi.Input

	ToStreamingPolicyWidevineConfigurationPtrOutput() StreamingPolicyWidevineConfigurationPtrOutput
	ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(context.Context) StreamingPolicyWidevineConfigurationPtrOutput
}

type streamingPolicyWidevineConfigurationPtrType StreamingPolicyWidevineConfigurationArgs

func StreamingPolicyWidevineConfigurationPtr(v *StreamingPolicyWidevineConfigurationArgs) StreamingPolicyWidevineConfigurationPtrInput {
	return (*streamingPolicyWidevineConfigurationPtrType)(v)
}

func (*streamingPolicyWidevineConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyWidevineConfiguration)(nil)).Elem()
}

func (i *streamingPolicyWidevineConfigurationPtrType) ToStreamingPolicyWidevineConfigurationPtrOutput() StreamingPolicyWidevineConfigurationPtrOutput {
	return i.ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(context.Background())
}

func (i *streamingPolicyWidevineConfigurationPtrType) ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyWidevineConfigurationPtrOutput)
}

// Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfigurationOutput struct{ *pulumi.OutputState }

func (StreamingPolicyWidevineConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyWidevineConfiguration)(nil)).Elem()
}

func (o StreamingPolicyWidevineConfigurationOutput) ToStreamingPolicyWidevineConfigurationOutput() StreamingPolicyWidevineConfigurationOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationOutput) ToStreamingPolicyWidevineConfigurationOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationOutput) ToStreamingPolicyWidevineConfigurationPtrOutput() StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(context.Background())
}

func (o StreamingPolicyWidevineConfigurationOutput) ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StreamingPolicyWidevineConfiguration) *StreamingPolicyWidevineConfiguration {
		return &v
	}).(StreamingPolicyWidevineConfigurationPtrOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyWidevineConfigurationOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyWidevineConfiguration) *string { return v.CustomLicenseAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

type StreamingPolicyWidevineConfigurationPtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyWidevineConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyWidevineConfiguration)(nil)).Elem()
}

func (o StreamingPolicyWidevineConfigurationPtrOutput) ToStreamingPolicyWidevineConfigurationPtrOutput() StreamingPolicyWidevineConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationPtrOutput) ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationPtrOutput) Elem() StreamingPolicyWidevineConfigurationOutput {
	return o.ApplyT(func(v *StreamingPolicyWidevineConfiguration) StreamingPolicyWidevineConfiguration {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyWidevineConfiguration
		return ret
	}).(StreamingPolicyWidevineConfigurationOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyWidevineConfigurationPtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyWidevineConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfigurationResponse struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

// Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfigurationResponseOutput struct{ *pulumi.OutputState }

func (StreamingPolicyWidevineConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyWidevineConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyWidevineConfigurationResponseOutput) ToStreamingPolicyWidevineConfigurationResponseOutput() StreamingPolicyWidevineConfigurationResponseOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationResponseOutput) ToStreamingPolicyWidevineConfigurationResponseOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationResponseOutput {
	return o
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyWidevineConfigurationResponseOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyWidevineConfigurationResponse) *string {
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

type StreamingPolicyWidevineConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyWidevineConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyWidevineConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyWidevineConfigurationResponsePtrOutput) ToStreamingPolicyWidevineConfigurationResponsePtrOutput() StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationResponsePtrOutput) ToStreamingPolicyWidevineConfigurationResponsePtrOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationResponsePtrOutput) Elem() StreamingPolicyWidevineConfigurationResponseOutput {
	return o.ApplyT(func(v *StreamingPolicyWidevineConfigurationResponse) StreamingPolicyWidevineConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyWidevineConfigurationResponse
		return ret
	}).(StreamingPolicyWidevineConfigurationResponseOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyWidevineConfigurationResponsePtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyWidevineConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponse struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *string `pulumi:"createdAt"`
	// The identity that created the resource.
	CreatedBy *string `pulumi:"createdBy"`
	// The type of identity that created the resource.
	CreatedByType *string `pulumi:"createdByType"`
	// The timestamp of resource last modification (UTC)
	LastModifiedAt *string `pulumi:"lastModifiedAt"`
	// The identity that last modified the resource.
	LastModifiedBy *string `pulumi:"lastModifiedBy"`
	// The type of identity that last modified the resource.
	LastModifiedByType *string `pulumi:"lastModifiedByType"`
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponseOutput struct{ *pulumi.OutputState }

func (SystemDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SystemDataResponse)(nil)).Elem()
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutput() SystemDataResponseOutput {
	return o
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutputWithContext(ctx context.Context) SystemDataResponseOutput {
	return o
}

// The timestamp of resource creation (UTC).
func (o SystemDataResponseOutput) CreatedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedAt }).(pulumi.StringPtrOutput)
}

// The identity that created the resource.
func (o SystemDataResponseOutput) CreatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that created the resource.
func (o SystemDataResponseOutput) CreatedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedByType }).(pulumi.StringPtrOutput)
}

// The timestamp of resource last modification (UTC)
func (o SystemDataResponseOutput) LastModifiedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedAt }).(pulumi.StringPtrOutput)
}

// The identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedByType }).(pulumi.StringPtrOutput)
}

// Represents a text track in an asset. A text track is usually used for sparse data related to the audio or video tracks.
type TextTrack struct {
	// The display name of the text track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
	DisplayName *string `pulumi:"displayName"`
	// The file name to the source file. This file is located in the storage container of the asset.
	FileName *string `pulumi:"fileName"`
	// The HLS specific setting for the text track.
	HlsSettings *HlsSettings `pulumi:"hlsSettings"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.TextTrack'.
	OdataType string `pulumi:"odataType"`
	// When PlayerVisibility is set to "Visible", the text track will be present in the DASH manifest or HLS playlist when requested by a client. When the PlayerVisibility is set to "Hidden", the text will not be available to the client. The default value is "Visible".
	PlayerVisibility *string `pulumi:"playerVisibility"`
}

// TextTrackInput is an input type that accepts TextTrackArgs and TextTrackOutput values.
// You can construct a concrete instance of `TextTrackInput` via:
//
//	TextTrackArgs{...}
type TextTrackInput interface {
	pulumi.Input

	ToTextTrackOutput() TextTrackOutput
	ToTextTrackOutputWithContext(context.Context) TextTrackOutput
}

// Represents a text track in an asset. A text track is usually used for sparse data related to the audio or video tracks.
type TextTrackArgs struct {
	// The display name of the text track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// The file name to the source file. This file is located in the storage container of the asset.
	FileName pulumi.StringPtrInput `pulumi:"fileName"`
	// The HLS specific setting for the text track.
	HlsSettings HlsSettingsPtrInput `pulumi:"hlsSettings"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.TextTrack'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// When PlayerVisibility is set to "Visible", the text track will be present in the DASH manifest or HLS playlist when requested by a client. When the PlayerVisibility is set to "Hidden", the text will not be available to the client. The default value is "Visible".
	PlayerVisibility pulumi.StringPtrInput `pulumi:"playerVisibility"`
}

func (TextTrackArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TextTrack)(nil)).Elem()
}

func (i TextTrackArgs) ToTextTrackOutput() TextTrackOutput {
	return i.ToTextTrackOutputWithContext(context.Background())
}

func (i TextTrackArgs) ToTextTrackOutputWithContext(ctx context.Context) TextTrackOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextTrackOutput)
}

func (i TextTrackArgs) ToTextTrackPtrOutput() TextTrackPtrOutput {
	return i.ToTextTrackPtrOutputWithContext(context.Background())
}

func (i TextTrackArgs) ToTextTrackPtrOutputWithContext(ctx context.Context) TextTrackPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextTrackOutput).ToTextTrackPtrOutputWithContext(ctx)
}

// TextTrackPtrInput is an input type that accepts TextTrackArgs, TextTrackPtr and TextTrackPtrOutput values.
// You can construct a concrete instance of `TextTrackPtrInput` via:
//
//	        TextTrackArgs{...}
//
//	or:
//
//	        nil
type TextTrackPtrInput interface {
	pulumi.Input

	ToTextTrackPtrOutput() TextTrackPtrOutput
	ToTextTrackPtrOutputWithContext(context.Context) TextTrackPtrOutput
}

type textTrackPtrType TextTrackArgs

func TextTrackPtr(v *TextTrackArgs) TextTrackPtrInput {
	return (*textTrackPtrType)(v)
}

func (*textTrackPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TextTrack)(nil)).Elem()
}

func (i *textTrackPtrType) ToTextTrackPtrOutput() TextTrackPtrOutput {
	return i.ToTextTrackPtrOutputWithContext(context.Background())
}

func (i *textTrackPtrType) ToTextTrackPtrOutputWithContext(ctx context.Context) TextTrackPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextTrackPtrOutput)
}

// Represents a text track in an asset. A text track is usually used for sparse data related to the audio or video tracks.
type TextTrackOutput struct{ *pulumi.OutputState }

func (TextTrackOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TextTrack)(nil)).Elem()
}

func (o TextTrackOutput) ToTextTrackOutput() TextTrackOutput {
	return o
}

func (o TextTrackOutput) ToTextTrackOutputWithContext(ctx context.Context) TextTrackOutput {
	return o
}

func (o TextTrackOutput) ToTextTrackPtrOutput() TextTrackPtrOutput {
	return o.ToTextTrackPtrOutputWithContext(context.Background())
}

func (o TextTrackOutput) ToTextTrackPtrOutputWithContext(ctx context.Context) TextTrackPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TextTrack) *TextTrack {
		return &v
	}).(TextTrackPtrOutput)
}

// The display name of the text track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
func (o TextTrackOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TextTrack) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// The file name to the source file. This file is located in the storage container of the asset.
func (o TextTrackOutput) FileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TextTrack) *string { return v.FileName }).(pulumi.StringPtrOutput)
}

// The HLS specific setting for the text track.
func (o TextTrackOutput) HlsSettings() HlsSettingsPtrOutput {
	return o.ApplyT(func(v TextTrack) *HlsSettings { return v.HlsSettings }).(HlsSettingsPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.TextTrack'.
func (o TextTrackOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v TextTrack) string { return v.OdataType }).(pulumi.StringOutput)
}

// When PlayerVisibility is set to "Visible", the text track will be present in the DASH manifest or HLS playlist when requested by a client. When the PlayerVisibility is set to "Hidden", the text will not be available to the client. The default value is "Visible".
func (o TextTrackOutput) PlayerVisibility() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TextTrack) *string { return v.PlayerVisibility }).(pulumi.StringPtrOutput)
}

type TextTrackPtrOutput struct{ *pulumi.OutputState }

func (TextTrackPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TextTrack)(nil)).Elem()
}

func (o TextTrackPtrOutput) ToTextTrackPtrOutput() TextTrackPtrOutput {
	return o
}

func (o TextTrackPtrOutput) ToTextTrackPtrOutputWithContext(ctx context.Context) TextTrackPtrOutput {
	return o
}

func (o TextTrackPtrOutput) Elem() TextTrackOutput {
	return o.ApplyT(func(v *TextTrack) TextTrack {
		if v != nil {
			return *v
		}
		var ret TextTrack
		return ret
	}).(TextTrackOutput)
}

// The display name of the text track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
func (o TextTrackPtrOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TextTrack) *string {
		if v == nil {
			return nil
		}
		return v.DisplayName
	}).(pulumi.StringPtrOutput)
}

// The file name to the source file. This file is located in the storage container of the asset.
func (o TextTrackPtrOutput) FileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TextTrack) *string {
		if v == nil {
			return nil
		}
		return v.FileName
	}).(pulumi.StringPtrOutput)
}

// The HLS specific setting for the text track.
func (o TextTrackPtrOutput) HlsSettings() HlsSettingsPtrOutput {
	return o.ApplyT(func(v *TextTrack) *HlsSettings {
		if v == nil {
			return nil
		}
		return v.HlsSettings
	}).(HlsSettingsPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.TextTrack'.
func (o TextTrackPtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TextTrack) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// When PlayerVisibility is set to "Visible", the text track will be present in the DASH manifest or HLS playlist when requested by a client. When the PlayerVisibility is set to "Hidden", the text will not be available to the client. The default value is "Visible".
func (o TextTrackPtrOutput) PlayerVisibility() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TextTrack) *string {
		if v == nil {
			return nil
		}
		return v.PlayerVisibility
	}).(pulumi.StringPtrOutput)
}

// Represents a text track in an asset. A text track is usually used for sparse data related to the audio or video tracks.
type TextTrackResponse struct {
	// The display name of the text track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
	DisplayName *string `pulumi:"displayName"`
	// The file name to the source file. This file is located in the storage container of the asset.
	FileName *string `pulumi:"fileName"`
	// The HLS specific setting for the text track.
	HlsSettings *HlsSettingsResponse `pulumi:"hlsSettings"`
	// The RFC5646 language code for the text track.
	LanguageCode string `pulumi:"languageCode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.TextTrack'.
	OdataType string `pulumi:"odataType"`
	// When PlayerVisibility is set to "Visible", the text track will be present in the DASH manifest or HLS playlist when requested by a client. When the PlayerVisibility is set to "Hidden", the text will not be available to the client. The default value is "Visible".
	PlayerVisibility *string `pulumi:"playerVisibility"`
}

// Represents a text track in an asset. A text track is usually used for sparse data related to the audio or video tracks.
type TextTrackResponseOutput struct{ *pulumi.OutputState }

func (TextTrackResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TextTrackResponse)(nil)).Elem()
}

func (o TextTrackResponseOutput) ToTextTrackResponseOutput() TextTrackResponseOutput {
	return o
}

func (o TextTrackResponseOutput) ToTextTrackResponseOutputWithContext(ctx context.Context) TextTrackResponseOutput {
	return o
}

// The display name of the text track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
func (o TextTrackResponseOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TextTrackResponse) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// The file name to the source file. This file is located in the storage container of the asset.
func (o TextTrackResponseOutput) FileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TextTrackResponse) *string { return v.FileName }).(pulumi.StringPtrOutput)
}

// The HLS specific setting for the text track.
func (o TextTrackResponseOutput) HlsSettings() HlsSettingsResponsePtrOutput {
	return o.ApplyT(func(v TextTrackResponse) *HlsSettingsResponse { return v.HlsSettings }).(HlsSettingsResponsePtrOutput)
}

// The RFC5646 language code for the text track.
func (o TextTrackResponseOutput) LanguageCode() pulumi.StringOutput {
	return o.ApplyT(func(v TextTrackResponse) string { return v.LanguageCode }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.TextTrack'.
func (o TextTrackResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v TextTrackResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// When PlayerVisibility is set to "Visible", the text track will be present in the DASH manifest or HLS playlist when requested by a client. When the PlayerVisibility is set to "Hidden", the text will not be available to the client. The default value is "Visible".
func (o TextTrackResponseOutput) PlayerVisibility() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TextTrackResponse) *string { return v.PlayerVisibility }).(pulumi.StringPtrOutput)
}

type TextTrackResponsePtrOutput struct{ *pulumi.OutputState }

func (TextTrackResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TextTrackResponse)(nil)).Elem()
}

func (o TextTrackResponsePtrOutput) ToTextTrackResponsePtrOutput() TextTrackResponsePtrOutput {
	return o
}

func (o TextTrackResponsePtrOutput) ToTextTrackResponsePtrOutputWithContext(ctx context.Context) TextTrackResponsePtrOutput {
	return o
}

func (o TextTrackResponsePtrOutput) Elem() TextTrackResponseOutput {
	return o.ApplyT(func(v *TextTrackResponse) TextTrackResponse {
		if v != nil {
			return *v
		}
		var ret TextTrackResponse
		return ret
	}).(TextTrackResponseOutput)
}

// The display name of the text track on a video player. In HLS, this maps to the NAME attribute of EXT-X-MEDIA.
func (o TextTrackResponsePtrOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TextTrackResponse) *string {
		if v == nil {
			return nil
		}
		return v.DisplayName
	}).(pulumi.StringPtrOutput)
}

// The file name to the source file. This file is located in the storage container of the asset.
func (o TextTrackResponsePtrOutput) FileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TextTrackResponse) *string {
		if v == nil {
			return nil
		}
		return v.FileName
	}).(pulumi.StringPtrOutput)
}

// The HLS specific setting for the text track.
func (o TextTrackResponsePtrOutput) HlsSettings() HlsSettingsResponsePtrOutput {
	return o.ApplyT(func(v *TextTrackResponse) *HlsSettingsResponse {
		if v == nil {
			return nil
		}
		return v.HlsSettings
	}).(HlsSettingsResponsePtrOutput)
}

// The RFC5646 language code for the text track.
func (o TextTrackResponsePtrOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TextTrackResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LanguageCode
	}).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.TextTrack'.
func (o TextTrackResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TextTrackResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// When PlayerVisibility is set to "Visible", the text track will be present in the DASH manifest or HLS playlist when requested by a client. When the PlayerVisibility is set to "Hidden", the text will not be available to the client. The default value is "Visible".
func (o TextTrackResponsePtrOutput) PlayerVisibility() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TextTrackResponse) *string {
		if v == nil {
			return nil
		}
		return v.PlayerVisibility
	}).(pulumi.StringPtrOutput)
}

// Class to specify one track property condition
type TrackPropertyCondition struct {
	// Track property condition operation
	Operation string `pulumi:"operation"`
	// Track property type
	Property string `pulumi:"property"`
	// Track property value
	Value *string `pulumi:"value"`
}

// TrackPropertyConditionInput is an input type that accepts TrackPropertyConditionArgs and TrackPropertyConditionOutput values.
// You can construct a concrete instance of `TrackPropertyConditionInput` via:
//
//	TrackPropertyConditionArgs{...}
type TrackPropertyConditionInput interface {
	pulumi.Input

	ToTrackPropertyConditionOutput() TrackPropertyConditionOutput
	ToTrackPropertyConditionOutputWithContext(context.Context) TrackPropertyConditionOutput
}

// Class to specify one track property condition
type TrackPropertyConditionArgs struct {
	// Track property condition operation
	Operation pulumi.StringInput `pulumi:"operation"`
	// Track property type
	Property pulumi.StringInput `pulumi:"property"`
	// Track property value
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (TrackPropertyConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackPropertyCondition)(nil)).Elem()
}

func (i TrackPropertyConditionArgs) ToTrackPropertyConditionOutput() TrackPropertyConditionOutput {
	return i.ToTrackPropertyConditionOutputWithContext(context.Background())
}

func (i TrackPropertyConditionArgs) ToTrackPropertyConditionOutputWithContext(ctx context.Context) TrackPropertyConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrackPropertyConditionOutput)
}

// TrackPropertyConditionArrayInput is an input type that accepts TrackPropertyConditionArray and TrackPropertyConditionArrayOutput values.
// You can construct a concrete instance of `TrackPropertyConditionArrayInput` via:
//
//	TrackPropertyConditionArray{ TrackPropertyConditionArgs{...} }
type TrackPropertyConditionArrayInput interface {
	pulumi.Input

	ToTrackPropertyConditionArrayOutput() TrackPropertyConditionArrayOutput
	ToTrackPropertyConditionArrayOutputWithContext(context.Context) TrackPropertyConditionArrayOutput
}

type TrackPropertyConditionArray []TrackPropertyConditionInput

func (TrackPropertyConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackPropertyCondition)(nil)).Elem()
}

func (i TrackPropertyConditionArray) ToTrackPropertyConditionArrayOutput() TrackPropertyConditionArrayOutput {
	return i.ToTrackPropertyConditionArrayOutputWithContext(context.Background())
}

func (i TrackPropertyConditionArray) ToTrackPropertyConditionArrayOutputWithContext(ctx context.Context) TrackPropertyConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrackPropertyConditionArrayOutput)
}

// Class to specify one track property condition
type TrackPropertyConditionOutput struct{ *pulumi.OutputState }

func (TrackPropertyConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackPropertyCondition)(nil)).Elem()
}

func (o TrackPropertyConditionOutput) ToTrackPropertyConditionOutput() TrackPropertyConditionOutput {
	return o
}

func (o TrackPropertyConditionOutput) ToTrackPropertyConditionOutputWithContext(ctx context.Context) TrackPropertyConditionOutput {
	return o
}

// Track property condition operation
func (o TrackPropertyConditionOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v TrackPropertyCondition) string { return v.Operation }).(pulumi.StringOutput)
}

// Track property type
func (o TrackPropertyConditionOutput) Property() pulumi.StringOutput {
	return o.ApplyT(func(v TrackPropertyCondition) string { return v.Property }).(pulumi.StringOutput)
}

// Track property value
func (o TrackPropertyConditionOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TrackPropertyCondition) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type TrackPropertyConditionArrayOutput struct{ *pulumi.OutputState }

func (TrackPropertyConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackPropertyCondition)(nil)).Elem()
}

func (o TrackPropertyConditionArrayOutput) ToTrackPropertyConditionArrayOutput() TrackPropertyConditionArrayOutput {
	return o
}

func (o TrackPropertyConditionArrayOutput) ToTrackPropertyConditionArrayOutputWithContext(ctx context.Context) TrackPropertyConditionArrayOutput {
	return o
}

func (o TrackPropertyConditionArrayOutput) Index(i pulumi.IntInput) TrackPropertyConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TrackPropertyCondition {
		return vs[0].([]TrackPropertyCondition)[vs[1].(int)]
	}).(TrackPropertyConditionOutput)
}

// Class to specify one track property condition
type TrackPropertyConditionResponse struct {
	// Track property condition operation
	Operation string `pulumi:"operation"`
	// Track property type
	Property string `pulumi:"property"`
	// Track property value
	Value *string `pulumi:"value"`
}

// Class to specify one track property condition
type TrackPropertyConditionResponseOutput struct{ *pulumi.OutputState }

func (TrackPropertyConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackPropertyConditionResponse)(nil)).Elem()
}

func (o TrackPropertyConditionResponseOutput) ToTrackPropertyConditionResponseOutput() TrackPropertyConditionResponseOutput {
	return o
}

func (o TrackPropertyConditionResponseOutput) ToTrackPropertyConditionResponseOutputWithContext(ctx context.Context) TrackPropertyConditionResponseOutput {
	return o
}

// Track property condition operation
func (o TrackPropertyConditionResponseOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v TrackPropertyConditionResponse) string { return v.Operation }).(pulumi.StringOutput)
}

// Track property type
func (o TrackPropertyConditionResponseOutput) Property() pulumi.StringOutput {
	return o.ApplyT(func(v TrackPropertyConditionResponse) string { return v.Property }).(pulumi.StringOutput)
}

// Track property value
func (o TrackPropertyConditionResponseOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TrackPropertyConditionResponse) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type TrackPropertyConditionResponseArrayOutput struct{ *pulumi.OutputState }

func (TrackPropertyConditionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackPropertyConditionResponse)(nil)).Elem()
}

func (o TrackPropertyConditionResponseArrayOutput) ToTrackPropertyConditionResponseArrayOutput() TrackPropertyConditionResponseArrayOutput {
	return o
}

func (o TrackPropertyConditionResponseArrayOutput) ToTrackPropertyConditionResponseArrayOutputWithContext(ctx context.Context) TrackPropertyConditionResponseArrayOutput {
	return o
}

func (o TrackPropertyConditionResponseArrayOutput) Index(i pulumi.IntInput) TrackPropertyConditionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TrackPropertyConditionResponse {
		return vs[0].([]TrackPropertyConditionResponse)[vs[1].(int)]
	}).(TrackPropertyConditionResponseOutput)
}

// Class to select a track
type TrackSelection struct {
	// TrackSelections is a track property condition list which can specify track(s)
	TrackSelections []TrackPropertyCondition `pulumi:"trackSelections"`
}

// TrackSelectionInput is an input type that accepts TrackSelectionArgs and TrackSelectionOutput values.
// You can construct a concrete instance of `TrackSelectionInput` via:
//
//	TrackSelectionArgs{...}
type TrackSelectionInput interface {
	pulumi.Input

	ToTrackSelectionOutput() TrackSelectionOutput
	ToTrackSelectionOutputWithContext(context.Context) TrackSelectionOutput
}

// Class to select a track
type TrackSelectionArgs struct {
	// TrackSelections is a track property condition list which can specify track(s)
	TrackSelections TrackPropertyConditionArrayInput `pulumi:"trackSelections"`
}

func (TrackSelectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackSelection)(nil)).Elem()
}

func (i TrackSelectionArgs) ToTrackSelectionOutput() TrackSelectionOutput {
	return i.ToTrackSelectionOutputWithContext(context.Background())
}

func (i TrackSelectionArgs) ToTrackSelectionOutputWithContext(ctx context.Context) TrackSelectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrackSelectionOutput)
}

// TrackSelectionArrayInput is an input type that accepts TrackSelectionArray and TrackSelectionArrayOutput values.
// You can construct a concrete instance of `TrackSelectionArrayInput` via:
//
//	TrackSelectionArray{ TrackSelectionArgs{...} }
type TrackSelectionArrayInput interface {
	pulumi.Input

	ToTrackSelectionArrayOutput() TrackSelectionArrayOutput
	ToTrackSelectionArrayOutputWithContext(context.Context) TrackSelectionArrayOutput
}

type TrackSelectionArray []TrackSelectionInput

func (TrackSelectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackSelection)(nil)).Elem()
}

func (i TrackSelectionArray) ToTrackSelectionArrayOutput() TrackSelectionArrayOutput {
	return i.ToTrackSelectionArrayOutputWithContext(context.Background())
}

func (i TrackSelectionArray) ToTrackSelectionArrayOutputWithContext(ctx context.Context) TrackSelectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrackSelectionArrayOutput)
}

// Class to select a track
type TrackSelectionOutput struct{ *pulumi.OutputState }

func (TrackSelectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackSelection)(nil)).Elem()
}

func (o TrackSelectionOutput) ToTrackSelectionOutput() TrackSelectionOutput {
	return o
}

func (o TrackSelectionOutput) ToTrackSelectionOutputWithContext(ctx context.Context) TrackSelectionOutput {
	return o
}

// TrackSelections is a track property condition list which can specify track(s)
func (o TrackSelectionOutput) TrackSelections() TrackPropertyConditionArrayOutput {
	return o.ApplyT(func(v TrackSelection) []TrackPropertyCondition { return v.TrackSelections }).(TrackPropertyConditionArrayOutput)
}

type TrackSelectionArrayOutput struct{ *pulumi.OutputState }

func (TrackSelectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackSelection)(nil)).Elem()
}

func (o TrackSelectionArrayOutput) ToTrackSelectionArrayOutput() TrackSelectionArrayOutput {
	return o
}

func (o TrackSelectionArrayOutput) ToTrackSelectionArrayOutputWithContext(ctx context.Context) TrackSelectionArrayOutput {
	return o
}

func (o TrackSelectionArrayOutput) Index(i pulumi.IntInput) TrackSelectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TrackSelection {
		return vs[0].([]TrackSelection)[vs[1].(int)]
	}).(TrackSelectionOutput)
}

// Class to select a track
type TrackSelectionResponse struct {
	// TrackSelections is a track property condition list which can specify track(s)
	TrackSelections []TrackPropertyConditionResponse `pulumi:"trackSelections"`
}

// Class to select a track
type TrackSelectionResponseOutput struct{ *pulumi.OutputState }

func (TrackSelectionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackSelectionResponse)(nil)).Elem()
}

func (o TrackSelectionResponseOutput) ToTrackSelectionResponseOutput() TrackSelectionResponseOutput {
	return o
}

func (o TrackSelectionResponseOutput) ToTrackSelectionResponseOutputWithContext(ctx context.Context) TrackSelectionResponseOutput {
	return o
}

// TrackSelections is a track property condition list which can specify track(s)
func (o TrackSelectionResponseOutput) TrackSelections() TrackPropertyConditionResponseArrayOutput {
	return o.ApplyT(func(v TrackSelectionResponse) []TrackPropertyConditionResponse { return v.TrackSelections }).(TrackPropertyConditionResponseArrayOutput)
}

type TrackSelectionResponseArrayOutput struct{ *pulumi.OutputState }

func (TrackSelectionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackSelectionResponse)(nil)).Elem()
}

func (o TrackSelectionResponseArrayOutput) ToTrackSelectionResponseArrayOutput() TrackSelectionResponseArrayOutput {
	return o
}

func (o TrackSelectionResponseArrayOutput) ToTrackSelectionResponseArrayOutputWithContext(ctx context.Context) TrackSelectionResponseArrayOutput {
	return o
}

func (o TrackSelectionResponseArrayOutput) Index(i pulumi.IntInput) TrackSelectionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TrackSelectionResponse {
		return vs[0].([]TrackSelectionResponse)[vs[1].(int)]
	}).(TrackSelectionResponseOutput)
}

// Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
type TransformOutputType struct {
	// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
	OnError *string `pulumi:"onError"`
	// Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
	Preset interface{} `pulumi:"preset"`
	// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
	RelativePriority *string `pulumi:"relativePriority"`
}

// TransformOutputTypeInput is an input type that accepts TransformOutputTypeArgs and TransformOutputTypeOutput values.
// You can construct a concrete instance of `TransformOutputTypeInput` via:
//
//	TransformOutputTypeArgs{...}
type TransformOutputTypeInput interface {
	pulumi.Input

	ToTransformOutputTypeOutput() TransformOutputTypeOutput
	ToTransformOutputTypeOutputWithContext(context.Context) TransformOutputTypeOutput
}

// Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
type TransformOutputTypeArgs struct {
	// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
	OnError pulumi.StringPtrInput `pulumi:"onError"`
	// Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
	Preset pulumi.Input `pulumi:"preset"`
	// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
	RelativePriority pulumi.StringPtrInput `pulumi:"relativePriority"`
}

func (TransformOutputTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputType)(nil)).Elem()
}

func (i TransformOutputTypeArgs) ToTransformOutputTypeOutput() TransformOutputTypeOutput {
	return i.ToTransformOutputTypeOutputWithContext(context.Background())
}

func (i TransformOutputTypeArgs) ToTransformOutputTypeOutputWithContext(ctx context.Context) TransformOutputTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputTypeOutput)
}

// TransformOutputTypeArrayInput is an input type that accepts TransformOutputTypeArray and TransformOutputTypeArrayOutput values.
// You can construct a concrete instance of `TransformOutputTypeArrayInput` via:
//
//	TransformOutputTypeArray{ TransformOutputTypeArgs{...} }
type TransformOutputTypeArrayInput interface {
	pulumi.Input

	ToTransformOutputTypeArrayOutput() TransformOutputTypeArrayOutput
	ToTransformOutputTypeArrayOutputWithContext(context.Context) TransformOutputTypeArrayOutput
}

type TransformOutputTypeArray []TransformOutputTypeInput

func (TransformOutputTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TransformOutputType)(nil)).Elem()
}

func (i TransformOutputTypeArray) ToTransformOutputTypeArrayOutput() TransformOutputTypeArrayOutput {
	return i.ToTransformOutputTypeArrayOutputWithContext(context.Background())
}

func (i TransformOutputTypeArray) ToTransformOutputTypeArrayOutputWithContext(ctx context.Context) TransformOutputTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputTypeArrayOutput)
}

// Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
type TransformOutputTypeOutput struct{ *pulumi.OutputState }

func (TransformOutputTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputType)(nil)).Elem()
}

func (o TransformOutputTypeOutput) ToTransformOutputTypeOutput() TransformOutputTypeOutput {
	return o
}

func (o TransformOutputTypeOutput) ToTransformOutputTypeOutputWithContext(ctx context.Context) TransformOutputTypeOutput {
	return o
}

// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
func (o TransformOutputTypeOutput) OnError() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputType) *string { return v.OnError }).(pulumi.StringPtrOutput)
}

// Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
func (o TransformOutputTypeOutput) Preset() pulumi.AnyOutput {
	return o.ApplyT(func(v TransformOutputType) interface{} { return v.Preset }).(pulumi.AnyOutput)
}

// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
func (o TransformOutputTypeOutput) RelativePriority() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputType) *string { return v.RelativePriority }).(pulumi.StringPtrOutput)
}

type TransformOutputTypeArrayOutput struct{ *pulumi.OutputState }

func (TransformOutputTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TransformOutputType)(nil)).Elem()
}

func (o TransformOutputTypeArrayOutput) ToTransformOutputTypeArrayOutput() TransformOutputTypeArrayOutput {
	return o
}

func (o TransformOutputTypeArrayOutput) ToTransformOutputTypeArrayOutputWithContext(ctx context.Context) TransformOutputTypeArrayOutput {
	return o
}

func (o TransformOutputTypeArrayOutput) Index(i pulumi.IntInput) TransformOutputTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TransformOutputType {
		return vs[0].([]TransformOutputType)[vs[1].(int)]
	}).(TransformOutputTypeOutput)
}

// Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
type TransformOutputResponse struct {
	// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
	OnError *string `pulumi:"onError"`
	// Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
	Preset interface{} `pulumi:"preset"`
	// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
	RelativePriority *string `pulumi:"relativePriority"`
}

// Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
type TransformOutputResponseOutput struct{ *pulumi.OutputState }

func (TransformOutputResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputResponse)(nil)).Elem()
}

func (o TransformOutputResponseOutput) ToTransformOutputResponseOutput() TransformOutputResponseOutput {
	return o
}

func (o TransformOutputResponseOutput) ToTransformOutputResponseOutputWithContext(ctx context.Context) TransformOutputResponseOutput {
	return o
}

// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
func (o TransformOutputResponseOutput) OnError() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputResponse) *string { return v.OnError }).(pulumi.StringPtrOutput)
}

// Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
func (o TransformOutputResponseOutput) Preset() pulumi.AnyOutput {
	return o.ApplyT(func(v TransformOutputResponse) interface{} { return v.Preset }).(pulumi.AnyOutput)
}

// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
func (o TransformOutputResponseOutput) RelativePriority() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputResponse) *string { return v.RelativePriority }).(pulumi.StringPtrOutput)
}

type TransformOutputResponseArrayOutput struct{ *pulumi.OutputState }

func (TransformOutputResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TransformOutputResponse)(nil)).Elem()
}

func (o TransformOutputResponseArrayOutput) ToTransformOutputResponseArrayOutput() TransformOutputResponseArrayOutput {
	return o
}

func (o TransformOutputResponseArrayOutput) ToTransformOutputResponseArrayOutputWithContext(ctx context.Context) TransformOutputResponseArrayOutput {
	return o
}

func (o TransformOutputResponseArrayOutput) Index(i pulumi.IntInput) TransformOutputResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TransformOutputResponse {
		return vs[0].([]TransformOutputResponse)[vs[1].(int)]
	}).(TransformOutputResponseOutput)
}

// Describes the properties for generating an MPEG-2 Transport Stream (ISO/IEC 13818-1) output video file(s).
type TransportStreamFormat struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.TransportStreamFormat'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFile `pulumi:"outputFiles"`
}

// TransportStreamFormatInput is an input type that accepts TransportStreamFormatArgs and TransportStreamFormatOutput values.
// You can construct a concrete instance of `TransportStreamFormatInput` via:
//
//	TransportStreamFormatArgs{...}
type TransportStreamFormatInput interface {
	pulumi.Input

	ToTransportStreamFormatOutput() TransportStreamFormatOutput
	ToTransportStreamFormatOutputWithContext(context.Context) TransportStreamFormatOutput
}

// Describes the properties for generating an MPEG-2 Transport Stream (ISO/IEC 13818-1) output video file(s).
type TransportStreamFormatArgs struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern pulumi.StringInput `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.TransportStreamFormat'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles OutputFileArrayInput `pulumi:"outputFiles"`
}

func (TransportStreamFormatArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TransportStreamFormat)(nil)).Elem()
}

func (i TransportStreamFormatArgs) ToTransportStreamFormatOutput() TransportStreamFormatOutput {
	return i.ToTransportStreamFormatOutputWithContext(context.Background())
}

func (i TransportStreamFormatArgs) ToTransportStreamFormatOutputWithContext(ctx context.Context) TransportStreamFormatOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransportStreamFormatOutput)
}

// Describes the properties for generating an MPEG-2 Transport Stream (ISO/IEC 13818-1) output video file(s).
type TransportStreamFormatOutput struct{ *pulumi.OutputState }

func (TransportStreamFormatOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TransportStreamFormat)(nil)).Elem()
}

func (o TransportStreamFormatOutput) ToTransportStreamFormatOutput() TransportStreamFormatOutput {
	return o
}

func (o TransportStreamFormatOutput) ToTransportStreamFormatOutputWithContext(ctx context.Context) TransportStreamFormatOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o TransportStreamFormatOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v TransportStreamFormat) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.TransportStreamFormat'.
func (o TransportStreamFormatOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v TransportStreamFormat) string { return v.OdataType }).(pulumi.StringOutput)
}

// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
func (o TransportStreamFormatOutput) OutputFiles() OutputFileArrayOutput {
	return o.ApplyT(func(v TransportStreamFormat) []OutputFile { return v.OutputFiles }).(OutputFileArrayOutput)
}

// Describes the properties for generating an MPEG-2 Transport Stream (ISO/IEC 13818-1) output video file(s).
type TransportStreamFormatResponse struct {
	// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.TransportStreamFormat'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFileResponse `pulumi:"outputFiles"`
}

// Describes the properties for generating an MPEG-2 Transport Stream (ISO/IEC 13818-1) output video file(s).
type TransportStreamFormatResponseOutput struct{ *pulumi.OutputState }

func (TransportStreamFormatResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TransportStreamFormatResponse)(nil)).Elem()
}

func (o TransportStreamFormatResponseOutput) ToTransportStreamFormatResponseOutput() TransportStreamFormatResponseOutput {
	return o
}

func (o TransportStreamFormatResponseOutput) ToTransportStreamFormatResponseOutputWithContext(ctx context.Context) TransportStreamFormatResponseOutput {
	return o
}

// The file naming pattern used for the creation of output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {AudioStream} - string "Audio" plus audio stream number(start from 1). {Bitrate} - The audio/video bitrate in kbps. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
func (o TransportStreamFormatResponseOutput) FilenamePattern() pulumi.StringOutput {
	return o.ApplyT(func(v TransportStreamFormatResponse) string { return v.FilenamePattern }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.TransportStreamFormat'.
func (o TransportStreamFormatResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v TransportStreamFormatResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
func (o TransportStreamFormatResponseOutput) OutputFiles() OutputFileResponseArrayOutput {
	return o.ApplyT(func(v TransportStreamFormatResponse) []OutputFileResponse { return v.OutputFiles }).(OutputFileResponseArrayOutput)
}

type UserAssignedManagedIdentityResponse struct {
	// The client ID.
	ClientId string `pulumi:"clientId"`
	// The principal ID.
	PrincipalId string `pulumi:"principalId"`
}

type UserAssignedManagedIdentityResponseOutput struct{ *pulumi.OutputState }

func (UserAssignedManagedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserAssignedManagedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedManagedIdentityResponseOutput) ToUserAssignedManagedIdentityResponseOutput() UserAssignedManagedIdentityResponseOutput {
	return o
}

func (o UserAssignedManagedIdentityResponseOutput) ToUserAssignedManagedIdentityResponseOutputWithContext(ctx context.Context) UserAssignedManagedIdentityResponseOutput {
	return o
}

// The client ID.
func (o UserAssignedManagedIdentityResponseOutput) ClientId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedManagedIdentityResponse) string { return v.ClientId }).(pulumi.StringOutput)
}

// The principal ID.
func (o UserAssignedManagedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedManagedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type UserAssignedManagedIdentityResponseMapOutput struct{ *pulumi.OutputState }

func (UserAssignedManagedIdentityResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]UserAssignedManagedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedManagedIdentityResponseMapOutput) ToUserAssignedManagedIdentityResponseMapOutput() UserAssignedManagedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedManagedIdentityResponseMapOutput) ToUserAssignedManagedIdentityResponseMapOutputWithContext(ctx context.Context) UserAssignedManagedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedManagedIdentityResponseMapOutput) MapIndex(k pulumi.StringInput) UserAssignedManagedIdentityResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) UserAssignedManagedIdentityResponse {
		return vs[0].(map[string]UserAssignedManagedIdentityResponse)[vs[1].(string)]
	}).(UserAssignedManagedIdentityResponseOutput)
}

// Specifies the clip time as a Utc time position in the media file.  The Utc time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type UtcClipTime struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.UtcClipTime'.
	OdataType string `pulumi:"odataType"`
	// The time position on the timeline of the input media based on Utc time.
	Time string `pulumi:"time"`
}

// UtcClipTimeInput is an input type that accepts UtcClipTimeArgs and UtcClipTimeOutput values.
// You can construct a concrete instance of `UtcClipTimeInput` via:
//
//	UtcClipTimeArgs{...}
type UtcClipTimeInput interface {
	pulumi.Input

	ToUtcClipTimeOutput() UtcClipTimeOutput
	ToUtcClipTimeOutputWithContext(context.Context) UtcClipTimeOutput
}

// Specifies the clip time as a Utc time position in the media file.  The Utc time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type UtcClipTimeArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.UtcClipTime'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The time position on the timeline of the input media based on Utc time.
	Time pulumi.StringInput `pulumi:"time"`
}

func (UtcClipTimeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UtcClipTime)(nil)).Elem()
}

func (i UtcClipTimeArgs) ToUtcClipTimeOutput() UtcClipTimeOutput {
	return i.ToUtcClipTimeOutputWithContext(context.Background())
}

func (i UtcClipTimeArgs) ToUtcClipTimeOutputWithContext(ctx context.Context) UtcClipTimeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UtcClipTimeOutput)
}

func (i UtcClipTimeArgs) ToUtcClipTimePtrOutput() UtcClipTimePtrOutput {
	return i.ToUtcClipTimePtrOutputWithContext(context.Background())
}

func (i UtcClipTimeArgs) ToUtcClipTimePtrOutputWithContext(ctx context.Context) UtcClipTimePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UtcClipTimeOutput).ToUtcClipTimePtrOutputWithContext(ctx)
}

// UtcClipTimePtrInput is an input type that accepts UtcClipTimeArgs, UtcClipTimePtr and UtcClipTimePtrOutput values.
// You can construct a concrete instance of `UtcClipTimePtrInput` via:
//
//	        UtcClipTimeArgs{...}
//
//	or:
//
//	        nil
type UtcClipTimePtrInput interface {
	pulumi.Input

	ToUtcClipTimePtrOutput() UtcClipTimePtrOutput
	ToUtcClipTimePtrOutputWithContext(context.Context) UtcClipTimePtrOutput
}

type utcClipTimePtrType UtcClipTimeArgs

func UtcClipTimePtr(v *UtcClipTimeArgs) UtcClipTimePtrInput {
	return (*utcClipTimePtrType)(v)
}

func (*utcClipTimePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UtcClipTime)(nil)).Elem()
}

func (i *utcClipTimePtrType) ToUtcClipTimePtrOutput() UtcClipTimePtrOutput {
	return i.ToUtcClipTimePtrOutputWithContext(context.Background())
}

func (i *utcClipTimePtrType) ToUtcClipTimePtrOutputWithContext(ctx context.Context) UtcClipTimePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UtcClipTimePtrOutput)
}

// Specifies the clip time as a Utc time position in the media file.  The Utc time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type UtcClipTimeOutput struct{ *pulumi.OutputState }

func (UtcClipTimeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UtcClipTime)(nil)).Elem()
}

func (o UtcClipTimeOutput) ToUtcClipTimeOutput() UtcClipTimeOutput {
	return o
}

func (o UtcClipTimeOutput) ToUtcClipTimeOutputWithContext(ctx context.Context) UtcClipTimeOutput {
	return o
}

func (o UtcClipTimeOutput) ToUtcClipTimePtrOutput() UtcClipTimePtrOutput {
	return o.ToUtcClipTimePtrOutputWithContext(context.Background())
}

func (o UtcClipTimeOutput) ToUtcClipTimePtrOutputWithContext(ctx context.Context) UtcClipTimePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UtcClipTime) *UtcClipTime {
		return &v
	}).(UtcClipTimePtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.UtcClipTime'.
func (o UtcClipTimeOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v UtcClipTime) string { return v.OdataType }).(pulumi.StringOutput)
}

// The time position on the timeline of the input media based on Utc time.
func (o UtcClipTimeOutput) Time() pulumi.StringOutput {
	return o.ApplyT(func(v UtcClipTime) string { return v.Time }).(pulumi.StringOutput)
}

type UtcClipTimePtrOutput struct{ *pulumi.OutputState }

func (UtcClipTimePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UtcClipTime)(nil)).Elem()
}

func (o UtcClipTimePtrOutput) ToUtcClipTimePtrOutput() UtcClipTimePtrOutput {
	return o
}

func (o UtcClipTimePtrOutput) ToUtcClipTimePtrOutputWithContext(ctx context.Context) UtcClipTimePtrOutput {
	return o
}

func (o UtcClipTimePtrOutput) Elem() UtcClipTimeOutput {
	return o.ApplyT(func(v *UtcClipTime) UtcClipTime {
		if v != nil {
			return *v
		}
		var ret UtcClipTime
		return ret
	}).(UtcClipTimeOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.UtcClipTime'.
func (o UtcClipTimePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UtcClipTime) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// The time position on the timeline of the input media based on Utc time.
func (o UtcClipTimePtrOutput) Time() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UtcClipTime) *string {
		if v == nil {
			return nil
		}
		return &v.Time
	}).(pulumi.StringPtrOutput)
}

// Specifies the clip time as a Utc time position in the media file.  The Utc time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type UtcClipTimeResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.UtcClipTime'.
	OdataType string `pulumi:"odataType"`
	// The time position on the timeline of the input media based on Utc time.
	Time string `pulumi:"time"`
}

// Specifies the clip time as a Utc time position in the media file.  The Utc time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type UtcClipTimeResponseOutput struct{ *pulumi.OutputState }

func (UtcClipTimeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UtcClipTimeResponse)(nil)).Elem()
}

func (o UtcClipTimeResponseOutput) ToUtcClipTimeResponseOutput() UtcClipTimeResponseOutput {
	return o
}

func (o UtcClipTimeResponseOutput) ToUtcClipTimeResponseOutputWithContext(ctx context.Context) UtcClipTimeResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.UtcClipTime'.
func (o UtcClipTimeResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v UtcClipTimeResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The time position on the timeline of the input media based on Utc time.
func (o UtcClipTimeResponseOutput) Time() pulumi.StringOutput {
	return o.ApplyT(func(v UtcClipTimeResponse) string { return v.Time }).(pulumi.StringOutput)
}

type UtcClipTimeResponsePtrOutput struct{ *pulumi.OutputState }

func (UtcClipTimeResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UtcClipTimeResponse)(nil)).Elem()
}

func (o UtcClipTimeResponsePtrOutput) ToUtcClipTimeResponsePtrOutput() UtcClipTimeResponsePtrOutput {
	return o
}

func (o UtcClipTimeResponsePtrOutput) ToUtcClipTimeResponsePtrOutputWithContext(ctx context.Context) UtcClipTimeResponsePtrOutput {
	return o
}

func (o UtcClipTimeResponsePtrOutput) Elem() UtcClipTimeResponseOutput {
	return o.ApplyT(func(v *UtcClipTimeResponse) UtcClipTimeResponse {
		if v != nil {
			return *v
		}
		var ret UtcClipTimeResponse
		return ret
	}).(UtcClipTimeResponseOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.UtcClipTime'.
func (o UtcClipTimeResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UtcClipTimeResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// The time position on the timeline of the input media based on Utc time.
func (o UtcClipTimeResponsePtrOutput) Time() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UtcClipTimeResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Time
	}).(pulumi.StringPtrOutput)
}

// Describes the basic properties for encoding the input video.
type Video struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Video'.
	OdataType string `pulumi:"odataType"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// VideoInput is an input type that accepts VideoArgs and VideoOutput values.
// You can construct a concrete instance of `VideoInput` via:
//
//	VideoArgs{...}
type VideoInput interface {
	pulumi.Input

	ToVideoOutput() VideoOutput
	ToVideoOutputWithContext(context.Context) VideoOutput
}

// Describes the basic properties for encoding the input video.
type VideoArgs struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval pulumi.StringPtrInput `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Video'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode pulumi.StringPtrInput `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode pulumi.StringPtrInput `pulumi:"syncMode"`
}

func (VideoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Video)(nil)).Elem()
}

func (i VideoArgs) ToVideoOutput() VideoOutput {
	return i.ToVideoOutputWithContext(context.Background())
}

func (i VideoArgs) ToVideoOutputWithContext(ctx context.Context) VideoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoOutput)
}

// Describes the basic properties for encoding the input video.
type VideoOutput struct{ *pulumi.OutputState }

func (VideoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Video)(nil)).Elem()
}

func (o VideoOutput) ToVideoOutput() VideoOutput {
	return o
}

func (o VideoOutput) ToVideoOutputWithContext(ctx context.Context) VideoOutput {
	return o
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o VideoOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Video) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o VideoOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Video) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.Video'.
func (o VideoOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v Video) string { return v.OdataType }).(pulumi.StringOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o VideoOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Video) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o VideoOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Video) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// A video analyzer preset that extracts insights (rich metadata) from both audio and video, and outputs a JSON format file.
type VideoAnalyzerPreset struct {
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `pulumi:"audioLanguage"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly', and 'AllInsights'. The default is AllInsights. If you set this to AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
	InsightsToExtract *string `pulumi:"insightsToExtract"`
	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoAnalyzerPreset'.
	OdataType string `pulumi:"odataType"`
}

// VideoAnalyzerPresetInput is an input type that accepts VideoAnalyzerPresetArgs and VideoAnalyzerPresetOutput values.
// You can construct a concrete instance of `VideoAnalyzerPresetInput` via:
//
//	VideoAnalyzerPresetArgs{...}
type VideoAnalyzerPresetInput interface {
	pulumi.Input

	ToVideoAnalyzerPresetOutput() VideoAnalyzerPresetOutput
	ToVideoAnalyzerPresetOutputWithContext(context.Context) VideoAnalyzerPresetOutput
}

// A video analyzer preset that extracts insights (rich metadata) from both audio and video, and outputs a JSON format file.
type VideoAnalyzerPresetArgs struct {
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage pulumi.StringPtrInput `pulumi:"audioLanguage"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions pulumi.StringMapInput `pulumi:"experimentalOptions"`
	// Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly', and 'AllInsights'. The default is AllInsights. If you set this to AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
	InsightsToExtract pulumi.StringPtrInput `pulumi:"insightsToExtract"`
	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoAnalyzerPreset'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (VideoAnalyzerPresetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoAnalyzerPreset)(nil)).Elem()
}

func (i VideoAnalyzerPresetArgs) ToVideoAnalyzerPresetOutput() VideoAnalyzerPresetOutput {
	return i.ToVideoAnalyzerPresetOutputWithContext(context.Background())
}

func (i VideoAnalyzerPresetArgs) ToVideoAnalyzerPresetOutputWithContext(ctx context.Context) VideoAnalyzerPresetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoAnalyzerPresetOutput)
}

func (i VideoAnalyzerPresetArgs) ToVideoAnalyzerPresetPtrOutput() VideoAnalyzerPresetPtrOutput {
	return i.ToVideoAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (i VideoAnalyzerPresetArgs) ToVideoAnalyzerPresetPtrOutputWithContext(ctx context.Context) VideoAnalyzerPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoAnalyzerPresetOutput).ToVideoAnalyzerPresetPtrOutputWithContext(ctx)
}

// VideoAnalyzerPresetPtrInput is an input type that accepts VideoAnalyzerPresetArgs, VideoAnalyzerPresetPtr and VideoAnalyzerPresetPtrOutput values.
// You can construct a concrete instance of `VideoAnalyzerPresetPtrInput` via:
//
//	        VideoAnalyzerPresetArgs{...}
//
//	or:
//
//	        nil
type VideoAnalyzerPresetPtrInput interface {
	pulumi.Input

	ToVideoAnalyzerPresetPtrOutput() VideoAnalyzerPresetPtrOutput
	ToVideoAnalyzerPresetPtrOutputWithContext(context.Context) VideoAnalyzerPresetPtrOutput
}

type videoAnalyzerPresetPtrType VideoAnalyzerPresetArgs

func VideoAnalyzerPresetPtr(v *VideoAnalyzerPresetArgs) VideoAnalyzerPresetPtrInput {
	return (*videoAnalyzerPresetPtrType)(v)
}

func (*videoAnalyzerPresetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoAnalyzerPreset)(nil)).Elem()
}

func (i *videoAnalyzerPresetPtrType) ToVideoAnalyzerPresetPtrOutput() VideoAnalyzerPresetPtrOutput {
	return i.ToVideoAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (i *videoAnalyzerPresetPtrType) ToVideoAnalyzerPresetPtrOutputWithContext(ctx context.Context) VideoAnalyzerPresetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoAnalyzerPresetPtrOutput)
}

// A video analyzer preset that extracts insights (rich metadata) from both audio and video, and outputs a JSON format file.
type VideoAnalyzerPresetOutput struct{ *pulumi.OutputState }

func (VideoAnalyzerPresetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoAnalyzerPreset)(nil)).Elem()
}

func (o VideoAnalyzerPresetOutput) ToVideoAnalyzerPresetOutput() VideoAnalyzerPresetOutput {
	return o
}

func (o VideoAnalyzerPresetOutput) ToVideoAnalyzerPresetOutputWithContext(ctx context.Context) VideoAnalyzerPresetOutput {
	return o
}

func (o VideoAnalyzerPresetOutput) ToVideoAnalyzerPresetPtrOutput() VideoAnalyzerPresetPtrOutput {
	return o.ToVideoAnalyzerPresetPtrOutputWithContext(context.Background())
}

func (o VideoAnalyzerPresetOutput) ToVideoAnalyzerPresetPtrOutputWithContext(ctx context.Context) VideoAnalyzerPresetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VideoAnalyzerPreset) *VideoAnalyzerPreset {
		return &v
	}).(VideoAnalyzerPresetPtrOutput)
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
func (o VideoAnalyzerPresetOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoAnalyzerPreset) *string { return v.AudioLanguage }).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o VideoAnalyzerPresetOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v VideoAnalyzerPreset) map[string]string { return v.ExperimentalOptions }).(pulumi.StringMapOutput)
}

// Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly', and 'AllInsights'. The default is AllInsights. If you set this to AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
func (o VideoAnalyzerPresetOutput) InsightsToExtract() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoAnalyzerPreset) *string { return v.InsightsToExtract }).(pulumi.StringPtrOutput)
}

// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
func (o VideoAnalyzerPresetOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoAnalyzerPreset) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoAnalyzerPreset'.
func (o VideoAnalyzerPresetOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v VideoAnalyzerPreset) string { return v.OdataType }).(pulumi.StringOutput)
}

type VideoAnalyzerPresetPtrOutput struct{ *pulumi.OutputState }

func (VideoAnalyzerPresetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoAnalyzerPreset)(nil)).Elem()
}

func (o VideoAnalyzerPresetPtrOutput) ToVideoAnalyzerPresetPtrOutput() VideoAnalyzerPresetPtrOutput {
	return o
}

func (o VideoAnalyzerPresetPtrOutput) ToVideoAnalyzerPresetPtrOutputWithContext(ctx context.Context) VideoAnalyzerPresetPtrOutput {
	return o
}

func (o VideoAnalyzerPresetPtrOutput) Elem() VideoAnalyzerPresetOutput {
	return o.ApplyT(func(v *VideoAnalyzerPreset) VideoAnalyzerPreset {
		if v != nil {
			return *v
		}
		var ret VideoAnalyzerPreset
		return ret
	}).(VideoAnalyzerPresetOutput)
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
func (o VideoAnalyzerPresetPtrOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return v.AudioLanguage
	}).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o VideoAnalyzerPresetPtrOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *VideoAnalyzerPreset) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExperimentalOptions
	}).(pulumi.StringMapOutput)
}

// Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly', and 'AllInsights'. The default is AllInsights. If you set this to AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
func (o VideoAnalyzerPresetPtrOutput) InsightsToExtract() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return v.InsightsToExtract
	}).(pulumi.StringPtrOutput)
}

// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
func (o VideoAnalyzerPresetPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoAnalyzerPreset'.
func (o VideoAnalyzerPresetPtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoAnalyzerPreset) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// A video analyzer preset that extracts insights (rich metadata) from both audio and video, and outputs a JSON format file.
type VideoAnalyzerPresetResponse struct {
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `pulumi:"audioLanguage"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly', and 'AllInsights'. The default is AllInsights. If you set this to AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
	InsightsToExtract *string `pulumi:"insightsToExtract"`
	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoAnalyzerPreset'.
	OdataType string `pulumi:"odataType"`
}

// A video analyzer preset that extracts insights (rich metadata) from both audio and video, and outputs a JSON format file.
type VideoAnalyzerPresetResponseOutput struct{ *pulumi.OutputState }

func (VideoAnalyzerPresetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoAnalyzerPresetResponse)(nil)).Elem()
}

func (o VideoAnalyzerPresetResponseOutput) ToVideoAnalyzerPresetResponseOutput() VideoAnalyzerPresetResponseOutput {
	return o
}

func (o VideoAnalyzerPresetResponseOutput) ToVideoAnalyzerPresetResponseOutputWithContext(ctx context.Context) VideoAnalyzerPresetResponseOutput {
	return o
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
func (o VideoAnalyzerPresetResponseOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoAnalyzerPresetResponse) *string { return v.AudioLanguage }).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o VideoAnalyzerPresetResponseOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v VideoAnalyzerPresetResponse) map[string]string { return v.ExperimentalOptions }).(pulumi.StringMapOutput)
}

// Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly', and 'AllInsights'. The default is AllInsights. If you set this to AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
func (o VideoAnalyzerPresetResponseOutput) InsightsToExtract() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoAnalyzerPresetResponse) *string { return v.InsightsToExtract }).(pulumi.StringPtrOutput)
}

// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
func (o VideoAnalyzerPresetResponseOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoAnalyzerPresetResponse) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoAnalyzerPreset'.
func (o VideoAnalyzerPresetResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v VideoAnalyzerPresetResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

type VideoAnalyzerPresetResponsePtrOutput struct{ *pulumi.OutputState }

func (VideoAnalyzerPresetResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoAnalyzerPresetResponse)(nil)).Elem()
}

func (o VideoAnalyzerPresetResponsePtrOutput) ToVideoAnalyzerPresetResponsePtrOutput() VideoAnalyzerPresetResponsePtrOutput {
	return o
}

func (o VideoAnalyzerPresetResponsePtrOutput) ToVideoAnalyzerPresetResponsePtrOutputWithContext(ctx context.Context) VideoAnalyzerPresetResponsePtrOutput {
	return o
}

func (o VideoAnalyzerPresetResponsePtrOutput) Elem() VideoAnalyzerPresetResponseOutput {
	return o.ApplyT(func(v *VideoAnalyzerPresetResponse) VideoAnalyzerPresetResponse {
		if v != nil {
			return *v
		}
		var ret VideoAnalyzerPresetResponse
		return ret
	}).(VideoAnalyzerPresetResponseOutput)
}

// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
func (o VideoAnalyzerPresetResponsePtrOutput) AudioLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoAnalyzerPresetResponse) *string {
		if v == nil {
			return nil
		}
		return v.AudioLanguage
	}).(pulumi.StringPtrOutput)
}

// Dictionary containing key value pairs for parameters not exposed in the preset itself
func (o VideoAnalyzerPresetResponsePtrOutput) ExperimentalOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *VideoAnalyzerPresetResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExperimentalOptions
	}).(pulumi.StringMapOutput)
}

// Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly', and 'AllInsights'. The default is AllInsights. If you set this to AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
func (o VideoAnalyzerPresetResponsePtrOutput) InsightsToExtract() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoAnalyzerPresetResponse) *string {
		if v == nil {
			return nil
		}
		return v.InsightsToExtract
	}).(pulumi.StringPtrOutput)
}

// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
func (o VideoAnalyzerPresetResponsePtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoAnalyzerPresetResponse) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoAnalyzerPreset'.
func (o VideoAnalyzerPresetResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoAnalyzerPresetResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// Describes the properties of a video overlay.
type VideoOverlay struct {
	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `pulumi:"audioGainLevel"`
	// An optional rectangular window used to crop the overlay image or video.
	CropRectangle *Rectangle `pulumi:"cropRectangle"`
	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
	End *string `pulumi:"end"`
	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `pulumi:"fadeInDuration"`
	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `pulumi:"fadeOutDuration"`
	// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel string `pulumi:"inputLabel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoOverlay'.
	OdataType string `pulumi:"odataType"`
	// The opacity of the overlay. This is a value in the range [0 - 1.0]. Default is 1.0 which mean the overlay is opaque.
	Opacity *float64 `pulumi:"opacity"`
	// The location in the input video where the overlay is applied.
	Position *Rectangle `pulumi:"position"`
	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
	Start *string `pulumi:"start"`
}

// VideoOverlayInput is an input type that accepts VideoOverlayArgs and VideoOverlayOutput values.
// You can construct a concrete instance of `VideoOverlayInput` via:
//
//	VideoOverlayArgs{...}
type VideoOverlayInput interface {
	pulumi.Input

	ToVideoOverlayOutput() VideoOverlayOutput
	ToVideoOverlayOutputWithContext(context.Context) VideoOverlayOutput
}

// Describes the properties of a video overlay.
type VideoOverlayArgs struct {
	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel pulumi.Float64PtrInput `pulumi:"audioGainLevel"`
	// An optional rectangular window used to crop the overlay image or video.
	CropRectangle RectanglePtrInput `pulumi:"cropRectangle"`
	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
	End pulumi.StringPtrInput `pulumi:"end"`
	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration pulumi.StringPtrInput `pulumi:"fadeInDuration"`
	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration pulumi.StringPtrInput `pulumi:"fadeOutDuration"`
	// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel pulumi.StringInput `pulumi:"inputLabel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoOverlay'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The opacity of the overlay. This is a value in the range [0 - 1.0]. Default is 1.0 which mean the overlay is opaque.
	Opacity pulumi.Float64PtrInput `pulumi:"opacity"`
	// The location in the input video where the overlay is applied.
	Position RectanglePtrInput `pulumi:"position"`
	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
	Start pulumi.StringPtrInput `pulumi:"start"`
}

func (VideoOverlayArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoOverlay)(nil)).Elem()
}

func (i VideoOverlayArgs) ToVideoOverlayOutput() VideoOverlayOutput {
	return i.ToVideoOverlayOutputWithContext(context.Background())
}

func (i VideoOverlayArgs) ToVideoOverlayOutputWithContext(ctx context.Context) VideoOverlayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoOverlayOutput)
}

// Describes the properties of a video overlay.
type VideoOverlayOutput struct{ *pulumi.OutputState }

func (VideoOverlayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoOverlay)(nil)).Elem()
}

func (o VideoOverlayOutput) ToVideoOverlayOutput() VideoOverlayOutput {
	return o
}

func (o VideoOverlayOutput) ToVideoOverlayOutputWithContext(ctx context.Context) VideoOverlayOutput {
	return o
}

// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
func (o VideoOverlayOutput) AudioGainLevel() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v VideoOverlay) *float64 { return v.AudioGainLevel }).(pulumi.Float64PtrOutput)
}

// An optional rectangular window used to crop the overlay image or video.
func (o VideoOverlayOutput) CropRectangle() RectanglePtrOutput {
	return o.ApplyT(func(v VideoOverlay) *Rectangle { return v.CropRectangle }).(RectanglePtrOutput)
}

// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
func (o VideoOverlayOutput) End() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoOverlay) *string { return v.End }).(pulumi.StringPtrOutput)
}

// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
func (o VideoOverlayOutput) FadeInDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoOverlay) *string { return v.FadeInDuration }).(pulumi.StringPtrOutput)
}

// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
func (o VideoOverlayOutput) FadeOutDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoOverlay) *string { return v.FadeOutDuration }).(pulumi.StringPtrOutput)
}

// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
func (o VideoOverlayOutput) InputLabel() pulumi.StringOutput {
	return o.ApplyT(func(v VideoOverlay) string { return v.InputLabel }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoOverlay'.
func (o VideoOverlayOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v VideoOverlay) string { return v.OdataType }).(pulumi.StringOutput)
}

// The opacity of the overlay. This is a value in the range [0 - 1.0]. Default is 1.0 which mean the overlay is opaque.
func (o VideoOverlayOutput) Opacity() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v VideoOverlay) *float64 { return v.Opacity }).(pulumi.Float64PtrOutput)
}

// The location in the input video where the overlay is applied.
func (o VideoOverlayOutput) Position() RectanglePtrOutput {
	return o.ApplyT(func(v VideoOverlay) *Rectangle { return v.Position }).(RectanglePtrOutput)
}

// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
func (o VideoOverlayOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoOverlay) *string { return v.Start }).(pulumi.StringPtrOutput)
}

// Describes the properties of a video overlay.
type VideoOverlayResponse struct {
	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `pulumi:"audioGainLevel"`
	// An optional rectangular window used to crop the overlay image or video.
	CropRectangle *RectangleResponse `pulumi:"cropRectangle"`
	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
	End *string `pulumi:"end"`
	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `pulumi:"fadeInDuration"`
	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `pulumi:"fadeOutDuration"`
	// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel string `pulumi:"inputLabel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoOverlay'.
	OdataType string `pulumi:"odataType"`
	// The opacity of the overlay. This is a value in the range [0 - 1.0]. Default is 1.0 which mean the overlay is opaque.
	Opacity *float64 `pulumi:"opacity"`
	// The location in the input video where the overlay is applied.
	Position *RectangleResponse `pulumi:"position"`
	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
	Start *string `pulumi:"start"`
}

// Describes the properties of a video overlay.
type VideoOverlayResponseOutput struct{ *pulumi.OutputState }

func (VideoOverlayResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoOverlayResponse)(nil)).Elem()
}

func (o VideoOverlayResponseOutput) ToVideoOverlayResponseOutput() VideoOverlayResponseOutput {
	return o
}

func (o VideoOverlayResponseOutput) ToVideoOverlayResponseOutputWithContext(ctx context.Context) VideoOverlayResponseOutput {
	return o
}

// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
func (o VideoOverlayResponseOutput) AudioGainLevel() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v VideoOverlayResponse) *float64 { return v.AudioGainLevel }).(pulumi.Float64PtrOutput)
}

// An optional rectangular window used to crop the overlay image or video.
func (o VideoOverlayResponseOutput) CropRectangle() RectangleResponsePtrOutput {
	return o.ApplyT(func(v VideoOverlayResponse) *RectangleResponse { return v.CropRectangle }).(RectangleResponsePtrOutput)
}

// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
func (o VideoOverlayResponseOutput) End() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoOverlayResponse) *string { return v.End }).(pulumi.StringPtrOutput)
}

// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
func (o VideoOverlayResponseOutput) FadeInDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoOverlayResponse) *string { return v.FadeInDuration }).(pulumi.StringPtrOutput)
}

// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
func (o VideoOverlayResponseOutput) FadeOutDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoOverlayResponse) *string { return v.FadeOutDuration }).(pulumi.StringPtrOutput)
}

// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
func (o VideoOverlayResponseOutput) InputLabel() pulumi.StringOutput {
	return o.ApplyT(func(v VideoOverlayResponse) string { return v.InputLabel }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoOverlay'.
func (o VideoOverlayResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v VideoOverlayResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The opacity of the overlay. This is a value in the range [0 - 1.0]. Default is 1.0 which mean the overlay is opaque.
func (o VideoOverlayResponseOutput) Opacity() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v VideoOverlayResponse) *float64 { return v.Opacity }).(pulumi.Float64PtrOutput)
}

// The location in the input video where the overlay is applied.
func (o VideoOverlayResponseOutput) Position() RectangleResponsePtrOutput {
	return o.ApplyT(func(v VideoOverlayResponse) *RectangleResponse { return v.Position }).(RectangleResponsePtrOutput)
}

// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
func (o VideoOverlayResponseOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoOverlayResponse) *string { return v.Start }).(pulumi.StringPtrOutput)
}

// Describes the basic properties for encoding the input video.
type VideoResponse struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Video'.
	OdataType string `pulumi:"odataType"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes the basic properties for encoding the input video.
type VideoResponseOutput struct{ *pulumi.OutputState }

func (VideoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoResponse)(nil)).Elem()
}

func (o VideoResponseOutput) ToVideoResponseOutput() VideoResponseOutput {
	return o
}

func (o VideoResponseOutput) ToVideoResponseOutputWithContext(ctx context.Context) VideoResponseOutput {
	return o
}

// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
func (o VideoResponseOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoResponse) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// An optional label for the codec. The label can be used to control muxing behavior.
func (o VideoResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.Video'.
func (o VideoResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v VideoResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
func (o VideoResponseOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoResponse) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

// The Video Sync Mode
func (o VideoResponseOutput) SyncMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoResponse) *string { return v.SyncMode }).(pulumi.StringPtrOutput)
}

// Represents a video track in the asset.
type VideoTrack struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoTrack'.
	OdataType string `pulumi:"odataType"`
}

// VideoTrackInput is an input type that accepts VideoTrackArgs and VideoTrackOutput values.
// You can construct a concrete instance of `VideoTrackInput` via:
//
//	VideoTrackArgs{...}
type VideoTrackInput interface {
	pulumi.Input

	ToVideoTrackOutput() VideoTrackOutput
	ToVideoTrackOutputWithContext(context.Context) VideoTrackOutput
}

// Represents a video track in the asset.
type VideoTrackArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoTrack'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (VideoTrackArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoTrack)(nil)).Elem()
}

func (i VideoTrackArgs) ToVideoTrackOutput() VideoTrackOutput {
	return i.ToVideoTrackOutputWithContext(context.Background())
}

func (i VideoTrackArgs) ToVideoTrackOutputWithContext(ctx context.Context) VideoTrackOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoTrackOutput)
}

func (i VideoTrackArgs) ToVideoTrackPtrOutput() VideoTrackPtrOutput {
	return i.ToVideoTrackPtrOutputWithContext(context.Background())
}

func (i VideoTrackArgs) ToVideoTrackPtrOutputWithContext(ctx context.Context) VideoTrackPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoTrackOutput).ToVideoTrackPtrOutputWithContext(ctx)
}

// VideoTrackPtrInput is an input type that accepts VideoTrackArgs, VideoTrackPtr and VideoTrackPtrOutput values.
// You can construct a concrete instance of `VideoTrackPtrInput` via:
//
//	        VideoTrackArgs{...}
//
//	or:
//
//	        nil
type VideoTrackPtrInput interface {
	pulumi.Input

	ToVideoTrackPtrOutput() VideoTrackPtrOutput
	ToVideoTrackPtrOutputWithContext(context.Context) VideoTrackPtrOutput
}

type videoTrackPtrType VideoTrackArgs

func VideoTrackPtr(v *VideoTrackArgs) VideoTrackPtrInput {
	return (*videoTrackPtrType)(v)
}

func (*videoTrackPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoTrack)(nil)).Elem()
}

func (i *videoTrackPtrType) ToVideoTrackPtrOutput() VideoTrackPtrOutput {
	return i.ToVideoTrackPtrOutputWithContext(context.Background())
}

func (i *videoTrackPtrType) ToVideoTrackPtrOutputWithContext(ctx context.Context) VideoTrackPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoTrackPtrOutput)
}

// Represents a video track in the asset.
type VideoTrackOutput struct{ *pulumi.OutputState }

func (VideoTrackOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoTrack)(nil)).Elem()
}

func (o VideoTrackOutput) ToVideoTrackOutput() VideoTrackOutput {
	return o
}

func (o VideoTrackOutput) ToVideoTrackOutputWithContext(ctx context.Context) VideoTrackOutput {
	return o
}

func (o VideoTrackOutput) ToVideoTrackPtrOutput() VideoTrackPtrOutput {
	return o.ToVideoTrackPtrOutputWithContext(context.Background())
}

func (o VideoTrackOutput) ToVideoTrackPtrOutputWithContext(ctx context.Context) VideoTrackPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VideoTrack) *VideoTrack {
		return &v
	}).(VideoTrackPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoTrack'.
func (o VideoTrackOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v VideoTrack) string { return v.OdataType }).(pulumi.StringOutput)
}

type VideoTrackPtrOutput struct{ *pulumi.OutputState }

func (VideoTrackPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoTrack)(nil)).Elem()
}

func (o VideoTrackPtrOutput) ToVideoTrackPtrOutput() VideoTrackPtrOutput {
	return o
}

func (o VideoTrackPtrOutput) ToVideoTrackPtrOutputWithContext(ctx context.Context) VideoTrackPtrOutput {
	return o
}

func (o VideoTrackPtrOutput) Elem() VideoTrackOutput {
	return o.ApplyT(func(v *VideoTrack) VideoTrack {
		if v != nil {
			return *v
		}
		var ret VideoTrack
		return ret
	}).(VideoTrackOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoTrack'.
func (o VideoTrackPtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoTrack) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

// A TrackSelection to select video tracks.
type VideoTrackDescriptor struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoTrackDescriptor'.
	OdataType string `pulumi:"odataType"`
}

// VideoTrackDescriptorInput is an input type that accepts VideoTrackDescriptorArgs and VideoTrackDescriptorOutput values.
// You can construct a concrete instance of `VideoTrackDescriptorInput` via:
//
//	VideoTrackDescriptorArgs{...}
type VideoTrackDescriptorInput interface {
	pulumi.Input

	ToVideoTrackDescriptorOutput() VideoTrackDescriptorOutput
	ToVideoTrackDescriptorOutputWithContext(context.Context) VideoTrackDescriptorOutput
}

// A TrackSelection to select video tracks.
type VideoTrackDescriptorArgs struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoTrackDescriptor'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (VideoTrackDescriptorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoTrackDescriptor)(nil)).Elem()
}

func (i VideoTrackDescriptorArgs) ToVideoTrackDescriptorOutput() VideoTrackDescriptorOutput {
	return i.ToVideoTrackDescriptorOutputWithContext(context.Background())
}

func (i VideoTrackDescriptorArgs) ToVideoTrackDescriptorOutputWithContext(ctx context.Context) VideoTrackDescriptorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoTrackDescriptorOutput)
}

// A TrackSelection to select video tracks.
type VideoTrackDescriptorOutput struct{ *pulumi.OutputState }

func (VideoTrackDescriptorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoTrackDescriptor)(nil)).Elem()
}

func (o VideoTrackDescriptorOutput) ToVideoTrackDescriptorOutput() VideoTrackDescriptorOutput {
	return o
}

func (o VideoTrackDescriptorOutput) ToVideoTrackDescriptorOutputWithContext(ctx context.Context) VideoTrackDescriptorOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoTrackDescriptor'.
func (o VideoTrackDescriptorOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v VideoTrackDescriptor) string { return v.OdataType }).(pulumi.StringOutput)
}

// A TrackSelection to select video tracks.
type VideoTrackDescriptorResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoTrackDescriptor'.
	OdataType string `pulumi:"odataType"`
}

// A TrackSelection to select video tracks.
type VideoTrackDescriptorResponseOutput struct{ *pulumi.OutputState }

func (VideoTrackDescriptorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoTrackDescriptorResponse)(nil)).Elem()
}

func (o VideoTrackDescriptorResponseOutput) ToVideoTrackDescriptorResponseOutput() VideoTrackDescriptorResponseOutput {
	return o
}

func (o VideoTrackDescriptorResponseOutput) ToVideoTrackDescriptorResponseOutputWithContext(ctx context.Context) VideoTrackDescriptorResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoTrackDescriptor'.
func (o VideoTrackDescriptorResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v VideoTrackDescriptorResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Represents a video track in the asset.
type VideoTrackResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoTrack'.
	OdataType string `pulumi:"odataType"`
}

// Represents a video track in the asset.
type VideoTrackResponseOutput struct{ *pulumi.OutputState }

func (VideoTrackResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoTrackResponse)(nil)).Elem()
}

func (o VideoTrackResponseOutput) ToVideoTrackResponseOutput() VideoTrackResponseOutput {
	return o
}

func (o VideoTrackResponseOutput) ToVideoTrackResponseOutputWithContext(ctx context.Context) VideoTrackResponseOutput {
	return o
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoTrack'.
func (o VideoTrackResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v VideoTrackResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

type VideoTrackResponsePtrOutput struct{ *pulumi.OutputState }

func (VideoTrackResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoTrackResponse)(nil)).Elem()
}

func (o VideoTrackResponsePtrOutput) ToVideoTrackResponsePtrOutput() VideoTrackResponsePtrOutput {
	return o
}

func (o VideoTrackResponsePtrOutput) ToVideoTrackResponsePtrOutputWithContext(ctx context.Context) VideoTrackResponsePtrOutput {
	return o
}

func (o VideoTrackResponsePtrOutput) Elem() VideoTrackResponseOutput {
	return o.ApplyT(func(v *VideoTrackResponse) VideoTrackResponse {
		if v != nil {
			return *v
		}
		var ret VideoTrackResponse
		return ret
	}).(VideoTrackResponseOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.VideoTrack'.
func (o VideoTrackResponsePtrOutput) OdataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoTrackResponse) *string {
		if v == nil {
			return nil
		}
		return &v.OdataType
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(AacAudioOutput{})
	pulumi.RegisterOutputType(AacAudioResponseOutput{})
	pulumi.RegisterOutputType(AbsoluteClipTimeOutput{})
	pulumi.RegisterOutputType(AbsoluteClipTimePtrOutput{})
	pulumi.RegisterOutputType(AbsoluteClipTimeResponseOutput{})
	pulumi.RegisterOutputType(AbsoluteClipTimeResponsePtrOutput{})
	pulumi.RegisterOutputType(AccessControlOutput{})
	pulumi.RegisterOutputType(AccessControlPtrOutput{})
	pulumi.RegisterOutputType(AccessControlResponseOutput{})
	pulumi.RegisterOutputType(AccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(AccountEncryptionOutput{})
	pulumi.RegisterOutputType(AccountEncryptionPtrOutput{})
	pulumi.RegisterOutputType(AccountEncryptionResponseOutput{})
	pulumi.RegisterOutputType(AccountEncryptionResponsePtrOutput{})
	pulumi.RegisterOutputType(AkamaiAccessControlOutput{})
	pulumi.RegisterOutputType(AkamaiAccessControlPtrOutput{})
	pulumi.RegisterOutputType(AkamaiAccessControlResponseOutput{})
	pulumi.RegisterOutputType(AkamaiAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(AkamaiSignatureHeaderAuthenticationKeyOutput{})
	pulumi.RegisterOutputType(AkamaiSignatureHeaderAuthenticationKeyArrayOutput{})
	pulumi.RegisterOutputType(AkamaiSignatureHeaderAuthenticationKeyResponseOutput{})
	pulumi.RegisterOutputType(AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput{})
	pulumi.RegisterOutputType(ArmStreamingEndpointCurrentSkuOutput{})
	pulumi.RegisterOutputType(ArmStreamingEndpointCurrentSkuPtrOutput{})
	pulumi.RegisterOutputType(ArmStreamingEndpointCurrentSkuResponseOutput{})
	pulumi.RegisterOutputType(ArmStreamingEndpointCurrentSkuResponsePtrOutput{})
	pulumi.RegisterOutputType(AssetFileEncryptionMetadataResponseOutput{})
	pulumi.RegisterOutputType(AssetFileEncryptionMetadataResponseArrayOutput{})
	pulumi.RegisterOutputType(AssetStreamingLocatorResponseOutput{})
	pulumi.RegisterOutputType(AssetStreamingLocatorResponseArrayOutput{})
	pulumi.RegisterOutputType(AudioOutput{})
	pulumi.RegisterOutputType(AudioAnalyzerPresetOutput{})
	pulumi.RegisterOutputType(AudioAnalyzerPresetPtrOutput{})
	pulumi.RegisterOutputType(AudioAnalyzerPresetResponseOutput{})
	pulumi.RegisterOutputType(AudioAnalyzerPresetResponsePtrOutput{})
	pulumi.RegisterOutputType(AudioOverlayOutput{})
	pulumi.RegisterOutputType(AudioOverlayResponseOutput{})
	pulumi.RegisterOutputType(AudioResponseOutput{})
	pulumi.RegisterOutputType(AudioTrackOutput{})
	pulumi.RegisterOutputType(AudioTrackPtrOutput{})
	pulumi.RegisterOutputType(AudioTrackDescriptorOutput{})
	pulumi.RegisterOutputType(AudioTrackDescriptorResponseOutput{})
	pulumi.RegisterOutputType(AudioTrackResponseOutput{})
	pulumi.RegisterOutputType(AudioTrackResponsePtrOutput{})
	pulumi.RegisterOutputType(BuiltInStandardEncoderPresetOutput{})
	pulumi.RegisterOutputType(BuiltInStandardEncoderPresetPtrOutput{})
	pulumi.RegisterOutputType(BuiltInStandardEncoderPresetResponseOutput{})
	pulumi.RegisterOutputType(BuiltInStandardEncoderPresetResponsePtrOutput{})
	pulumi.RegisterOutputType(CbcsDrmConfigurationOutput{})
	pulumi.RegisterOutputType(CbcsDrmConfigurationPtrOutput{})
	pulumi.RegisterOutputType(CbcsDrmConfigurationResponseOutput{})
	pulumi.RegisterOutputType(CbcsDrmConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(CencDrmConfigurationOutput{})
	pulumi.RegisterOutputType(CencDrmConfigurationPtrOutput{})
	pulumi.RegisterOutputType(CencDrmConfigurationResponseOutput{})
	pulumi.RegisterOutputType(CencDrmConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(ClearKeyEncryptionConfigurationOutput{})
	pulumi.RegisterOutputType(ClearKeyEncryptionConfigurationPtrOutput{})
	pulumi.RegisterOutputType(ClearKeyEncryptionConfigurationResponseOutput{})
	pulumi.RegisterOutputType(ClearKeyEncryptionConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCbcsOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCbcsPtrOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCbcsResponseOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCbcsResponsePtrOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCencOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCencPtrOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCencResponseOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCencResponsePtrOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyClearKeyConfigurationOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyClearKeyConfigurationResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyFairPlayConfigurationOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyFairPlayConfigurationResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyFairPlayOfflineRentalConfigurationOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyFairPlayOfflineRentalConfigurationPtrOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyFairPlayOfflineRentalConfigurationResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyFairPlayOfflineRentalConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyOpenRestrictionOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyOpenRestrictionResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyOptionOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyOptionArrayOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyOptionResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyOptionResponseArrayOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyConfigurationOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyConfigurationResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionPtrOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponsePtrOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyLicenseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyLicenseArrayOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyLicenseResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyLicenseResponseArrayOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyPlayRightOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyPlayRightPtrOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyPlayRightResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyPlayReadyPlayRightResponsePtrOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyRsaTokenKeyOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyRsaTokenKeyResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicySymmetricTokenKeyOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicySymmetricTokenKeyResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyTokenClaimOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyTokenClaimArrayOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyTokenClaimResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyTokenClaimResponseArrayOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyTokenRestrictionOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyTokenRestrictionResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyUnknownConfigurationOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyUnknownConfigurationResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyUnknownRestrictionOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyUnknownRestrictionResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyWidevineConfigurationOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyWidevineConfigurationResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyX509CertificateTokenKeyOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyX509CertificateTokenKeyResponseOutput{})
	pulumi.RegisterOutputType(CopyAudioOutput{})
	pulumi.RegisterOutputType(CopyAudioResponseOutput{})
	pulumi.RegisterOutputType(CopyVideoOutput{})
	pulumi.RegisterOutputType(CopyVideoResponseOutput{})
	pulumi.RegisterOutputType(CrossSiteAccessPoliciesOutput{})
	pulumi.RegisterOutputType(CrossSiteAccessPoliciesPtrOutput{})
	pulumi.RegisterOutputType(CrossSiteAccessPoliciesResponseOutput{})
	pulumi.RegisterOutputType(CrossSiteAccessPoliciesResponsePtrOutput{})
	pulumi.RegisterOutputType(DDAudioOutput{})
	pulumi.RegisterOutputType(DDAudioResponseOutput{})
	pulumi.RegisterOutputType(DashSettingsOutput{})
	pulumi.RegisterOutputType(DashSettingsPtrOutput{})
	pulumi.RegisterOutputType(DashSettingsResponseOutput{})
	pulumi.RegisterOutputType(DashSettingsResponsePtrOutput{})
	pulumi.RegisterOutputType(DefaultKeyOutput{})
	pulumi.RegisterOutputType(DefaultKeyPtrOutput{})
	pulumi.RegisterOutputType(DefaultKeyResponseOutput{})
	pulumi.RegisterOutputType(DefaultKeyResponsePtrOutput{})
	pulumi.RegisterOutputType(DeinterlaceOutput{})
	pulumi.RegisterOutputType(DeinterlacePtrOutput{})
	pulumi.RegisterOutputType(DeinterlaceResponseOutput{})
	pulumi.RegisterOutputType(DeinterlaceResponsePtrOutput{})
	pulumi.RegisterOutputType(EdgeUsageDataCollectionPolicyResponseOutput{})
	pulumi.RegisterOutputType(EdgeUsageDataCollectionPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(EdgeUsageDataEventHubResponseOutput{})
	pulumi.RegisterOutputType(EdgeUsageDataEventHubResponsePtrOutput{})
	pulumi.RegisterOutputType(EnabledProtocolsOutput{})
	pulumi.RegisterOutputType(EnabledProtocolsPtrOutput{})
	pulumi.RegisterOutputType(EnabledProtocolsResponseOutput{})
	pulumi.RegisterOutputType(EnabledProtocolsResponsePtrOutput{})
	pulumi.RegisterOutputType(EnvelopeEncryptionOutput{})
	pulumi.RegisterOutputType(EnvelopeEncryptionPtrOutput{})
	pulumi.RegisterOutputType(EnvelopeEncryptionResponseOutput{})
	pulumi.RegisterOutputType(EnvelopeEncryptionResponsePtrOutput{})
	pulumi.RegisterOutputType(FaceDetectorPresetOutput{})
	pulumi.RegisterOutputType(FaceDetectorPresetPtrOutput{})
	pulumi.RegisterOutputType(FaceDetectorPresetResponseOutput{})
	pulumi.RegisterOutputType(FaceDetectorPresetResponsePtrOutput{})
	pulumi.RegisterOutputType(FadeOutput{})
	pulumi.RegisterOutputType(FadePtrOutput{})
	pulumi.RegisterOutputType(FadeResponseOutput{})
	pulumi.RegisterOutputType(FadeResponsePtrOutput{})
	pulumi.RegisterOutputType(FilterTrackPropertyConditionOutput{})
	pulumi.RegisterOutputType(FilterTrackPropertyConditionArrayOutput{})
	pulumi.RegisterOutputType(FilterTrackPropertyConditionResponseOutput{})
	pulumi.RegisterOutputType(FilterTrackPropertyConditionResponseArrayOutput{})
	pulumi.RegisterOutputType(FilterTrackSelectionOutput{})
	pulumi.RegisterOutputType(FilterTrackSelectionArrayOutput{})
	pulumi.RegisterOutputType(FilterTrackSelectionResponseOutput{})
	pulumi.RegisterOutputType(FilterTrackSelectionResponseArrayOutput{})
	pulumi.RegisterOutputType(FiltersOutput{})
	pulumi.RegisterOutputType(FiltersPtrOutput{})
	pulumi.RegisterOutputType(FiltersResponseOutput{})
	pulumi.RegisterOutputType(FiltersResponsePtrOutput{})
	pulumi.RegisterOutputType(FirstQualityOutput{})
	pulumi.RegisterOutputType(FirstQualityPtrOutput{})
	pulumi.RegisterOutputType(FirstQualityResponseOutput{})
	pulumi.RegisterOutputType(FirstQualityResponsePtrOutput{})
	pulumi.RegisterOutputType(FromAllInputFileOutput{})
	pulumi.RegisterOutputType(FromAllInputFileResponseOutput{})
	pulumi.RegisterOutputType(FromEachInputFileOutput{})
	pulumi.RegisterOutputType(FromEachInputFileResponseOutput{})
	pulumi.RegisterOutputType(H264LayerOutput{})
	pulumi.RegisterOutputType(H264LayerArrayOutput{})
	pulumi.RegisterOutputType(H264LayerResponseOutput{})
	pulumi.RegisterOutputType(H264LayerResponseArrayOutput{})
	pulumi.RegisterOutputType(H264VideoOutput{})
	pulumi.RegisterOutputType(H264VideoResponseOutput{})
	pulumi.RegisterOutputType(H265LayerOutput{})
	pulumi.RegisterOutputType(H265LayerArrayOutput{})
	pulumi.RegisterOutputType(H265LayerResponseOutput{})
	pulumi.RegisterOutputType(H265LayerResponseArrayOutput{})
	pulumi.RegisterOutputType(H265VideoOutput{})
	pulumi.RegisterOutputType(H265VideoResponseOutput{})
	pulumi.RegisterOutputType(HlsOutput{})
	pulumi.RegisterOutputType(HlsPtrOutput{})
	pulumi.RegisterOutputType(HlsResponseOutput{})
	pulumi.RegisterOutputType(HlsResponsePtrOutput{})
	pulumi.RegisterOutputType(HlsSettingsOutput{})
	pulumi.RegisterOutputType(HlsSettingsPtrOutput{})
	pulumi.RegisterOutputType(HlsSettingsResponseOutput{})
	pulumi.RegisterOutputType(HlsSettingsResponsePtrOutput{})
	pulumi.RegisterOutputType(IPAccessControlOutput{})
	pulumi.RegisterOutputType(IPAccessControlPtrOutput{})
	pulumi.RegisterOutputType(IPAccessControlResponseOutput{})
	pulumi.RegisterOutputType(IPAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(IPRangeOutput{})
	pulumi.RegisterOutputType(IPRangeArrayOutput{})
	pulumi.RegisterOutputType(IPRangeResponseOutput{})
	pulumi.RegisterOutputType(IPRangeResponseArrayOutput{})
	pulumi.RegisterOutputType(ImageOutput{})
	pulumi.RegisterOutputType(ImageFormatOutput{})
	pulumi.RegisterOutputType(ImageFormatResponseOutput{})
	pulumi.RegisterOutputType(ImageResponseOutput{})
	pulumi.RegisterOutputType(InputFileOutput{})
	pulumi.RegisterOutputType(InputFileResponseOutput{})
	pulumi.RegisterOutputType(JobErrorDetailResponseOutput{})
	pulumi.RegisterOutputType(JobErrorDetailResponseArrayOutput{})
	pulumi.RegisterOutputType(JobErrorResponseOutput{})
	pulumi.RegisterOutputType(JobInputAssetOutput{})
	pulumi.RegisterOutputType(JobInputAssetResponseOutput{})
	pulumi.RegisterOutputType(JobInputClipOutput{})
	pulumi.RegisterOutputType(JobInputClipArrayOutput{})
	pulumi.RegisterOutputType(JobInputClipResponseOutput{})
	pulumi.RegisterOutputType(JobInputClipResponseArrayOutput{})
	pulumi.RegisterOutputType(JobInputHttpOutput{})
	pulumi.RegisterOutputType(JobInputHttpResponseOutput{})
	pulumi.RegisterOutputType(JobInputSequenceOutput{})
	pulumi.RegisterOutputType(JobInputSequenceResponseOutput{})
	pulumi.RegisterOutputType(JobInputsOutput{})
	pulumi.RegisterOutputType(JobInputsResponseOutput{})
	pulumi.RegisterOutputType(JobOutputAssetOutput{})
	pulumi.RegisterOutputType(JobOutputAssetArrayOutput{})
	pulumi.RegisterOutputType(JobOutputAssetResponseOutput{})
	pulumi.RegisterOutputType(JobOutputAssetResponseArrayOutput{})
	pulumi.RegisterOutputType(JpgFormatOutput{})
	pulumi.RegisterOutputType(JpgFormatResponseOutput{})
	pulumi.RegisterOutputType(JpgImageOutput{})
	pulumi.RegisterOutputType(JpgImageResponseOutput{})
	pulumi.RegisterOutputType(JpgLayerOutput{})
	pulumi.RegisterOutputType(JpgLayerArrayOutput{})
	pulumi.RegisterOutputType(JpgLayerResponseOutput{})
	pulumi.RegisterOutputType(JpgLayerResponseArrayOutput{})
	pulumi.RegisterOutputType(KeyDeliveryOutput{})
	pulumi.RegisterOutputType(KeyDeliveryPtrOutput{})
	pulumi.RegisterOutputType(KeyDeliveryResponseOutput{})
	pulumi.RegisterOutputType(KeyDeliveryResponsePtrOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesPtrOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesResponseOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventEncodingOutput{})
	pulumi.RegisterOutputType(LiveEventEncodingPtrOutput{})
	pulumi.RegisterOutputType(LiveEventEncodingResponseOutput{})
	pulumi.RegisterOutputType(LiveEventEncodingResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventEndpointOutput{})
	pulumi.RegisterOutputType(LiveEventEndpointArrayOutput{})
	pulumi.RegisterOutputType(LiveEventEndpointResponseOutput{})
	pulumi.RegisterOutputType(LiveEventEndpointResponseArrayOutput{})
	pulumi.RegisterOutputType(LiveEventIngestInterruptionResponseOutput{})
	pulumi.RegisterOutputType(LiveEventIngestInterruptionResponseArrayOutput{})
	pulumi.RegisterOutputType(LiveEventIngestionResponseOutput{})
	pulumi.RegisterOutputType(LiveEventIngestionResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventInputTypeOutput{})
	pulumi.RegisterOutputType(LiveEventInputAccessControlOutput{})
	pulumi.RegisterOutputType(LiveEventInputAccessControlPtrOutput{})
	pulumi.RegisterOutputType(LiveEventInputAccessControlResponseOutput{})
	pulumi.RegisterOutputType(LiveEventInputAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventInputResponseOutput{})
	pulumi.RegisterOutputType(LiveEventInputTrackSelectionOutput{})
	pulumi.RegisterOutputType(LiveEventInputTrackSelectionArrayOutput{})
	pulumi.RegisterOutputType(LiveEventInputTrackSelectionResponseOutput{})
	pulumi.RegisterOutputType(LiveEventInputTrackSelectionResponseArrayOutput{})
	pulumi.RegisterOutputType(LiveEventOutputTranscriptionTrackOutput{})
	pulumi.RegisterOutputType(LiveEventOutputTranscriptionTrackPtrOutput{})
	pulumi.RegisterOutputType(LiveEventOutputTranscriptionTrackResponseOutput{})
	pulumi.RegisterOutputType(LiveEventOutputTranscriptionTrackResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewPtrOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewAccessControlOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewAccessControlPtrOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewAccessControlResponseOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewResponseOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventStatusResponseOutput{})
	pulumi.RegisterOutputType(LiveEventStatusResponseArrayOutput{})
	pulumi.RegisterOutputType(LiveEventStreamEventDataResponseOutput{})
	pulumi.RegisterOutputType(LiveEventStreamEventDataResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventStreamEventResponseOutput{})
	pulumi.RegisterOutputType(LiveEventStreamEventResponseArrayOutput{})
	pulumi.RegisterOutputType(LiveEventTimedMetadataEndpointOutput{})
	pulumi.RegisterOutputType(LiveEventTimedMetadataEndpointArrayOutput{})
	pulumi.RegisterOutputType(LiveEventTimedMetadataEndpointResponseOutput{})
	pulumi.RegisterOutputType(LiveEventTimedMetadataEndpointResponseArrayOutput{})
	pulumi.RegisterOutputType(LiveEventTrackEventDataResponseOutput{})
	pulumi.RegisterOutputType(LiveEventTrackEventDataResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventTrackEventResponseOutput{})
	pulumi.RegisterOutputType(LiveEventTrackEventResponseArrayOutput{})
	pulumi.RegisterOutputType(LiveEventTrackStatusResponseOutput{})
	pulumi.RegisterOutputType(LiveEventTrackStatusResponseArrayOutput{})
	pulumi.RegisterOutputType(LiveEventTranscriptionOutput{})
	pulumi.RegisterOutputType(LiveEventTranscriptionArrayOutput{})
	pulumi.RegisterOutputType(LiveEventTranscriptionResponseOutput{})
	pulumi.RegisterOutputType(LiveEventTranscriptionResponseArrayOutput{})
	pulumi.RegisterOutputType(MediaGraphAssetSinkOutput{})
	pulumi.RegisterOutputType(MediaGraphAssetSinkArrayOutput{})
	pulumi.RegisterOutputType(MediaGraphAssetSinkResponseOutput{})
	pulumi.RegisterOutputType(MediaGraphAssetSinkResponseArrayOutput{})
	pulumi.RegisterOutputType(MediaGraphClearEndpointOutput{})
	pulumi.RegisterOutputType(MediaGraphClearEndpointResponseOutput{})
	pulumi.RegisterOutputType(MediaGraphPemCertificateListOutput{})
	pulumi.RegisterOutputType(MediaGraphPemCertificateListPtrOutput{})
	pulumi.RegisterOutputType(MediaGraphPemCertificateListResponseOutput{})
	pulumi.RegisterOutputType(MediaGraphPemCertificateListResponsePtrOutput{})
	pulumi.RegisterOutputType(MediaGraphRtspSourceOutput{})
	pulumi.RegisterOutputType(MediaGraphRtspSourceArrayOutput{})
	pulumi.RegisterOutputType(MediaGraphRtspSourceResponseOutput{})
	pulumi.RegisterOutputType(MediaGraphRtspSourceResponseArrayOutput{})
	pulumi.RegisterOutputType(MediaGraphTlsEndpointOutput{})
	pulumi.RegisterOutputType(MediaGraphTlsEndpointResponseOutput{})
	pulumi.RegisterOutputType(MediaGraphTlsValidationOptionsOutput{})
	pulumi.RegisterOutputType(MediaGraphTlsValidationOptionsPtrOutput{})
	pulumi.RegisterOutputType(MediaGraphTlsValidationOptionsResponseOutput{})
	pulumi.RegisterOutputType(MediaGraphTlsValidationOptionsResponsePtrOutput{})
	pulumi.RegisterOutputType(MediaGraphUsernamePasswordCredentialsOutput{})
	pulumi.RegisterOutputType(MediaGraphUsernamePasswordCredentialsPtrOutput{})
	pulumi.RegisterOutputType(MediaGraphUsernamePasswordCredentialsResponseOutput{})
	pulumi.RegisterOutputType(MediaGraphUsernamePasswordCredentialsResponsePtrOutput{})
	pulumi.RegisterOutputType(MediaServiceIdentityOutput{})
	pulumi.RegisterOutputType(MediaServiceIdentityPtrOutput{})
	pulumi.RegisterOutputType(MediaServiceIdentityResponseOutput{})
	pulumi.RegisterOutputType(MediaServiceIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(Mp4FormatOutput{})
	pulumi.RegisterOutputType(Mp4FormatResponseOutput{})
	pulumi.RegisterOutputType(MultiBitrateFormatOutput{})
	pulumi.RegisterOutputType(MultiBitrateFormatResponseOutput{})
	pulumi.RegisterOutputType(NoEncryptionOutput{})
	pulumi.RegisterOutputType(NoEncryptionPtrOutput{})
	pulumi.RegisterOutputType(NoEncryptionResponseOutput{})
	pulumi.RegisterOutputType(NoEncryptionResponsePtrOutput{})
	pulumi.RegisterOutputType(OutputFileOutput{})
	pulumi.RegisterOutputType(OutputFileArrayOutput{})
	pulumi.RegisterOutputType(OutputFileResponseOutput{})
	pulumi.RegisterOutputType(OutputFileResponseArrayOutput{})
	pulumi.RegisterOutputType(PngFormatOutput{})
	pulumi.RegisterOutputType(PngFormatResponseOutput{})
	pulumi.RegisterOutputType(PngImageOutput{})
	pulumi.RegisterOutputType(PngImageResponseOutput{})
	pulumi.RegisterOutputType(PngLayerOutput{})
	pulumi.RegisterOutputType(PngLayerArrayOutput{})
	pulumi.RegisterOutputType(PngLayerResponseOutput{})
	pulumi.RegisterOutputType(PngLayerResponseArrayOutput{})
	pulumi.RegisterOutputType(PresentationTimeRangeOutput{})
	pulumi.RegisterOutputType(PresentationTimeRangePtrOutput{})
	pulumi.RegisterOutputType(PresentationTimeRangeResponseOutput{})
	pulumi.RegisterOutputType(PresentationTimeRangeResponsePtrOutput{})
	pulumi.RegisterOutputType(PresetConfigurationsOutput{})
	pulumi.RegisterOutputType(PresetConfigurationsPtrOutput{})
	pulumi.RegisterOutputType(PresetConfigurationsResponseOutput{})
	pulumi.RegisterOutputType(PresetConfigurationsResponsePtrOutput{})
	pulumi.RegisterOutputType(PrivateEndpointConnectionResponseOutput{})
	pulumi.RegisterOutputType(PrivateEndpointConnectionResponseArrayOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResponseOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResponsePtrOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStateOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStateResponseOutput{})
	pulumi.RegisterOutputType(RectangleOutput{})
	pulumi.RegisterOutputType(RectanglePtrOutput{})
	pulumi.RegisterOutputType(RectangleResponseOutput{})
	pulumi.RegisterOutputType(RectangleResponsePtrOutput{})
	pulumi.RegisterOutputType(ResourceIdentityOutput{})
	pulumi.RegisterOutputType(ResourceIdentityPtrOutput{})
	pulumi.RegisterOutputType(ResourceIdentityResponseOutput{})
	pulumi.RegisterOutputType(ResourceIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(SelectAudioTrackByAttributeOutput{})
	pulumi.RegisterOutputType(SelectAudioTrackByAttributeResponseOutput{})
	pulumi.RegisterOutputType(SelectAudioTrackByIdOutput{})
	pulumi.RegisterOutputType(SelectAudioTrackByIdResponseOutput{})
	pulumi.RegisterOutputType(SelectVideoTrackByAttributeOutput{})
	pulumi.RegisterOutputType(SelectVideoTrackByAttributeResponseOutput{})
	pulumi.RegisterOutputType(SelectVideoTrackByIdOutput{})
	pulumi.RegisterOutputType(SelectVideoTrackByIdResponseOutput{})
	pulumi.RegisterOutputType(StandardEncoderPresetOutput{})
	pulumi.RegisterOutputType(StandardEncoderPresetPtrOutput{})
	pulumi.RegisterOutputType(StandardEncoderPresetResponseOutput{})
	pulumi.RegisterOutputType(StandardEncoderPresetResponsePtrOutput{})
	pulumi.RegisterOutputType(StorageAccountOutput{})
	pulumi.RegisterOutputType(StorageAccountArrayOutput{})
	pulumi.RegisterOutputType(StorageAccountResponseOutput{})
	pulumi.RegisterOutputType(StorageAccountResponseArrayOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlPtrOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlResponseOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(StreamingLocatorContentKeyOutput{})
	pulumi.RegisterOutputType(StreamingLocatorContentKeyArrayOutput{})
	pulumi.RegisterOutputType(StreamingLocatorContentKeyResponseOutput{})
	pulumi.RegisterOutputType(StreamingLocatorContentKeyResponseArrayOutput{})
	pulumi.RegisterOutputType(StreamingPathResponseOutput{})
	pulumi.RegisterOutputType(StreamingPathResponseArrayOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeyOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeyArrayOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeyResponseOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeyResponseArrayOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeysOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeysPtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeysResponseOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeysResponsePtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyFairPlayConfigurationOutput{})
	pulumi.RegisterOutputType(StreamingPolicyFairPlayConfigurationPtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyFairPlayConfigurationResponseOutput{})
	pulumi.RegisterOutputType(StreamingPolicyFairPlayConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyPlayReadyConfigurationOutput{})
	pulumi.RegisterOutputType(StreamingPolicyPlayReadyConfigurationPtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyPlayReadyConfigurationResponseOutput{})
	pulumi.RegisterOutputType(StreamingPolicyPlayReadyConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyWidevineConfigurationOutput{})
	pulumi.RegisterOutputType(StreamingPolicyWidevineConfigurationPtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyWidevineConfigurationResponseOutput{})
	pulumi.RegisterOutputType(StreamingPolicyWidevineConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(SystemDataResponseOutput{})
	pulumi.RegisterOutputType(TextTrackOutput{})
	pulumi.RegisterOutputType(TextTrackPtrOutput{})
	pulumi.RegisterOutputType(TextTrackResponseOutput{})
	pulumi.RegisterOutputType(TextTrackResponsePtrOutput{})
	pulumi.RegisterOutputType(TrackPropertyConditionOutput{})
	pulumi.RegisterOutputType(TrackPropertyConditionArrayOutput{})
	pulumi.RegisterOutputType(TrackPropertyConditionResponseOutput{})
	pulumi.RegisterOutputType(TrackPropertyConditionResponseArrayOutput{})
	pulumi.RegisterOutputType(TrackSelectionOutput{})
	pulumi.RegisterOutputType(TrackSelectionArrayOutput{})
	pulumi.RegisterOutputType(TrackSelectionResponseOutput{})
	pulumi.RegisterOutputType(TrackSelectionResponseArrayOutput{})
	pulumi.RegisterOutputType(TransformOutputTypeOutput{})
	pulumi.RegisterOutputType(TransformOutputTypeArrayOutput{})
	pulumi.RegisterOutputType(TransformOutputResponseOutput{})
	pulumi.RegisterOutputType(TransformOutputResponseArrayOutput{})
	pulumi.RegisterOutputType(TransportStreamFormatOutput{})
	pulumi.RegisterOutputType(TransportStreamFormatResponseOutput{})
	pulumi.RegisterOutputType(UserAssignedManagedIdentityResponseOutput{})
	pulumi.RegisterOutputType(UserAssignedManagedIdentityResponseMapOutput{})
	pulumi.RegisterOutputType(UtcClipTimeOutput{})
	pulumi.RegisterOutputType(UtcClipTimePtrOutput{})
	pulumi.RegisterOutputType(UtcClipTimeResponseOutput{})
	pulumi.RegisterOutputType(UtcClipTimeResponsePtrOutput{})
	pulumi.RegisterOutputType(VideoOutput{})
	pulumi.RegisterOutputType(VideoAnalyzerPresetOutput{})
	pulumi.RegisterOutputType(VideoAnalyzerPresetPtrOutput{})
	pulumi.RegisterOutputType(VideoAnalyzerPresetResponseOutput{})
	pulumi.RegisterOutputType(VideoAnalyzerPresetResponsePtrOutput{})
	pulumi.RegisterOutputType(VideoOverlayOutput{})
	pulumi.RegisterOutputType(VideoOverlayResponseOutput{})
	pulumi.RegisterOutputType(VideoResponseOutput{})
	pulumi.RegisterOutputType(VideoTrackOutput{})
	pulumi.RegisterOutputType(VideoTrackPtrOutput{})
	pulumi.RegisterOutputType(VideoTrackDescriptorOutput{})
	pulumi.RegisterOutputType(VideoTrackDescriptorResponseOutput{})
	pulumi.RegisterOutputType(VideoTrackResponseOutput{})
	pulumi.RegisterOutputType(VideoTrackResponsePtrOutput{})
}
