// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v20180601preview

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Type of API.
type ApiType string

const (
	ApiTypeHttp = ApiType("http")
	ApiTypeSoap = ApiType("soap")
)

// Form of an authorization grant, which the client uses to request the access token.
type BearerTokenSendingMethods string

const (
	// Access token will be transmitted in the Authorization header using Bearer schema
	BearerTokenSendingMethodsAuthorizationHeader = BearerTokenSendingMethods("authorizationHeader")
	// Access token will be transmitted as query parameters.
	BearerTokenSendingMethodsQuery = BearerTokenSendingMethods("query")
)

// Format of the Content in which the API is getting imported.
type ContentFormat string

const (
	// The contents are inline and Content type is a WADL document.
	ContentFormat_Wadl_Xml = ContentFormat("wadl-xml")
	// The WADL document is hosted on a publicly accessible internet address.
	ContentFormat_Wadl_Link_Json = ContentFormat("wadl-link-json")
	// The contents are inline and Content Type is a OpenApi 2.0 Document.
	ContentFormat_Swagger_Json = ContentFormat("swagger-json")
	// The Open Api 2.0 document is hosted on a publicly accessible internet address.
	ContentFormat_Swagger_Link_Json = ContentFormat("swagger-link-json")
	// The contents are inline and the document is a WSDL/Soap document.
	ContentFormatWsdl = ContentFormat("wsdl")
	// The WSDL document is hosted on a publicly accessible internet address.
	ContentFormat_Wsdl_Link = ContentFormat("wsdl-link")
	// The contents are inline and Content Type is a OpenApi 3.0 Document in YAML format.
	ContentFormatOpenapi = ContentFormat("openapi")
	// The contents are inline and Content Type is a OpenApi 3.0 Document in JSON format.
	ContentFormat_Openapi_json = ContentFormat("openapi+json")
	// The Open Api 3.0 document is hosted on a publicly accessible internet address.
	ContentFormat_Openapi_Link = ContentFormat("openapi-link")
)

// The Key to be used to generate token for user.
type KeyType string

const (
	KeyTypePrimary   = KeyType("primary")
	KeyTypeSecondary = KeyType("secondary")
)

func (KeyType) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyType)(nil)).Elem()
}

func (e KeyType) ToKeyTypeOutput() KeyTypeOutput {
	return pulumi.ToOutput(e).(KeyTypeOutput)
}

func (e KeyType) ToKeyTypeOutputWithContext(ctx context.Context) KeyTypeOutput {
	return pulumi.ToOutputWithContext(ctx, e).(KeyTypeOutput)
}

func (e KeyType) ToKeyTypePtrOutput() KeyTypePtrOutput {
	return e.ToKeyTypePtrOutputWithContext(context.Background())
}

func (e KeyType) ToKeyTypePtrOutputWithContext(ctx context.Context) KeyTypePtrOutput {
	return KeyType(e).ToKeyTypeOutputWithContext(ctx).ToKeyTypePtrOutputWithContext(ctx)
}

func (e KeyType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e KeyType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e KeyType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e KeyType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type KeyTypeOutput struct{ *pulumi.OutputState }

func (KeyTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyType)(nil)).Elem()
}

func (o KeyTypeOutput) ToKeyTypeOutput() KeyTypeOutput {
	return o
}

func (o KeyTypeOutput) ToKeyTypeOutputWithContext(ctx context.Context) KeyTypeOutput {
	return o
}

func (o KeyTypeOutput) ToKeyTypePtrOutput() KeyTypePtrOutput {
	return o.ToKeyTypePtrOutputWithContext(context.Background())
}

func (o KeyTypeOutput) ToKeyTypePtrOutputWithContext(ctx context.Context) KeyTypePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KeyType) *KeyType {
		return &v
	}).(KeyTypePtrOutput)
}

func (o KeyTypeOutput) ToStringOutput() pulumi.StringOutput {
	return o.ToStringOutputWithContext(context.Background())
}

func (o KeyTypeOutput) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, e KeyType) string {
		return string(e)
	}).(pulumi.StringOutput)
}

func (o KeyTypeOutput) ToStringPtrOutput() pulumi.StringPtrOutput {
	return o.ToStringPtrOutputWithContext(context.Background())
}

func (o KeyTypeOutput) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, e KeyType) *string {
		v := string(e)
		return &v
	}).(pulumi.StringPtrOutput)
}

type KeyTypePtrOutput struct{ *pulumi.OutputState }

func (KeyTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyType)(nil)).Elem()
}

func (o KeyTypePtrOutput) ToKeyTypePtrOutput() KeyTypePtrOutput {
	return o
}

func (o KeyTypePtrOutput) ToKeyTypePtrOutputWithContext(ctx context.Context) KeyTypePtrOutput {
	return o
}

func (o KeyTypePtrOutput) Elem() KeyTypeOutput {
	return o.ApplyT(func(v *KeyType) KeyType {
		if v != nil {
			return *v
		}
		var ret KeyType
		return ret
	}).(KeyTypeOutput)
}

func (o KeyTypePtrOutput) ToStringPtrOutput() pulumi.StringPtrOutput {
	return o.ToStringPtrOutputWithContext(context.Background())
}

func (o KeyTypePtrOutput) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, e *KeyType) *string {
		if e == nil {
			return nil
		}
		v := string(*e)
		return &v
	}).(pulumi.StringPtrOutput)
}

// KeyTypeInput is an input type that accepts KeyTypeArgs and KeyTypeOutput values.
// You can construct a concrete instance of `KeyTypeInput` via:
//
//	KeyTypeArgs{...}
type KeyTypeInput interface {
	pulumi.Input

	ToKeyTypeOutput() KeyTypeOutput
	ToKeyTypeOutputWithContext(context.Context) KeyTypeOutput
}

var keyTypePtrType = reflect.TypeOf((**KeyType)(nil)).Elem()

type KeyTypePtrInput interface {
	pulumi.Input

	ToKeyTypePtrOutput() KeyTypePtrOutput
	ToKeyTypePtrOutputWithContext(context.Context) KeyTypePtrOutput
}

type keyTypePtr string

func KeyTypePtr(v string) KeyTypePtrInput {
	return (*keyTypePtr)(&v)
}

func (*keyTypePtr) ElementType() reflect.Type {
	return keyTypePtrType
}

func (in *keyTypePtr) ToKeyTypePtrOutput() KeyTypePtrOutput {
	return pulumi.ToOutput(in).(KeyTypePtrOutput)
}

func (in *keyTypePtr) ToKeyTypePtrOutputWithContext(ctx context.Context) KeyTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, in).(KeyTypePtrOutput)
}

// Format of the policyContent.
type PolicyContentFormat string

const (
	// The contents are inline and Content type is an XML document.
	PolicyContentFormatXml = PolicyContentFormat("xml")
	// The policy XML document is hosted on a http endpoint accessible from the API Management service.
	PolicyContentFormat_Xml_Link = PolicyContentFormat("xml-link")
	// The contents are inline and Content type is a non XML encoded policy document.
	PolicyContentFormatRawxml = PolicyContentFormat("rawxml")
	// The policy document is not Xml encoded and is hosted on a http endpoint accessible from the API Management service.
	PolicyContentFormat_Rawxml_Link = PolicyContentFormat("rawxml-link")
)

type Protocol string

const (
	ProtocolHttp  = Protocol("http")
	ProtocolHttps = Protocol("https")
)

func (Protocol) ElementType() reflect.Type {
	return reflect.TypeOf((*Protocol)(nil)).Elem()
}

func (e Protocol) ToProtocolOutput() ProtocolOutput {
	return pulumi.ToOutput(e).(ProtocolOutput)
}

func (e Protocol) ToProtocolOutputWithContext(ctx context.Context) ProtocolOutput {
	return pulumi.ToOutputWithContext(ctx, e).(ProtocolOutput)
}

func (e Protocol) ToProtocolPtrOutput() ProtocolPtrOutput {
	return e.ToProtocolPtrOutputWithContext(context.Background())
}

func (e Protocol) ToProtocolPtrOutputWithContext(ctx context.Context) ProtocolPtrOutput {
	return Protocol(e).ToProtocolOutputWithContext(ctx).ToProtocolPtrOutputWithContext(ctx)
}

func (e Protocol) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e Protocol) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e Protocol) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e Protocol) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type ProtocolOutput struct{ *pulumi.OutputState }

func (ProtocolOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Protocol)(nil)).Elem()
}

func (o ProtocolOutput) ToProtocolOutput() ProtocolOutput {
	return o
}

func (o ProtocolOutput) ToProtocolOutputWithContext(ctx context.Context) ProtocolOutput {
	return o
}

func (o ProtocolOutput) ToProtocolPtrOutput() ProtocolPtrOutput {
	return o.ToProtocolPtrOutputWithContext(context.Background())
}

func (o ProtocolOutput) ToProtocolPtrOutputWithContext(ctx context.Context) ProtocolPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Protocol) *Protocol {
		return &v
	}).(ProtocolPtrOutput)
}

func (o ProtocolOutput) ToStringOutput() pulumi.StringOutput {
	return o.ToStringOutputWithContext(context.Background())
}

func (o ProtocolOutput) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, e Protocol) string {
		return string(e)
	}).(pulumi.StringOutput)
}

func (o ProtocolOutput) ToStringPtrOutput() pulumi.StringPtrOutput {
	return o.ToStringPtrOutputWithContext(context.Background())
}

func (o ProtocolOutput) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, e Protocol) *string {
		v := string(e)
		return &v
	}).(pulumi.StringPtrOutput)
}

type ProtocolPtrOutput struct{ *pulumi.OutputState }

func (ProtocolPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Protocol)(nil)).Elem()
}

func (o ProtocolPtrOutput) ToProtocolPtrOutput() ProtocolPtrOutput {
	return o
}

func (o ProtocolPtrOutput) ToProtocolPtrOutputWithContext(ctx context.Context) ProtocolPtrOutput {
	return o
}

func (o ProtocolPtrOutput) Elem() ProtocolOutput {
	return o.ApplyT(func(v *Protocol) Protocol {
		if v != nil {
			return *v
		}
		var ret Protocol
		return ret
	}).(ProtocolOutput)
}

func (o ProtocolPtrOutput) ToStringPtrOutput() pulumi.StringPtrOutput {
	return o.ToStringPtrOutputWithContext(context.Background())
}

func (o ProtocolPtrOutput) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, e *Protocol) *string {
		if e == nil {
			return nil
		}
		v := string(*e)
		return &v
	}).(pulumi.StringPtrOutput)
}

// ProtocolInput is an input type that accepts ProtocolArgs and ProtocolOutput values.
// You can construct a concrete instance of `ProtocolInput` via:
//
//	ProtocolArgs{...}
type ProtocolInput interface {
	pulumi.Input

	ToProtocolOutput() ProtocolOutput
	ToProtocolOutputWithContext(context.Context) ProtocolOutput
}

var protocolPtrType = reflect.TypeOf((**Protocol)(nil)).Elem()

type ProtocolPtrInput interface {
	pulumi.Input

	ToProtocolPtrOutput() ProtocolPtrOutput
	ToProtocolPtrOutputWithContext(context.Context) ProtocolPtrOutput
}

type protocolPtr string

func ProtocolPtr(v string) ProtocolPtrInput {
	return (*protocolPtr)(&v)
}

func (*protocolPtr) ElementType() reflect.Type {
	return protocolPtrType
}

func (in *protocolPtr) ToProtocolPtrOutput() ProtocolPtrOutput {
	return pulumi.ToOutput(in).(ProtocolPtrOutput)
}

func (in *protocolPtr) ToProtocolPtrOutputWithContext(ctx context.Context) ProtocolPtrOutput {
	return pulumi.ToOutputWithContext(ctx, in).(ProtocolPtrOutput)
}

// ProtocolArrayInput is an input type that accepts ProtocolArray and ProtocolArrayOutput values.
// You can construct a concrete instance of `ProtocolArrayInput` via:
//
//	ProtocolArray{ ProtocolArgs{...} }
type ProtocolArrayInput interface {
	pulumi.Input

	ToProtocolArrayOutput() ProtocolArrayOutput
	ToProtocolArrayOutputWithContext(context.Context) ProtocolArrayOutput
}

type ProtocolArray []Protocol

func (ProtocolArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Protocol)(nil)).Elem()
}

func (i ProtocolArray) ToProtocolArrayOutput() ProtocolArrayOutput {
	return i.ToProtocolArrayOutputWithContext(context.Background())
}

func (i ProtocolArray) ToProtocolArrayOutputWithContext(ctx context.Context) ProtocolArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProtocolArrayOutput)
}

type ProtocolArrayOutput struct{ *pulumi.OutputState }

func (ProtocolArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Protocol)(nil)).Elem()
}

func (o ProtocolArrayOutput) ToProtocolArrayOutput() ProtocolArrayOutput {
	return o
}

func (o ProtocolArrayOutput) ToProtocolArrayOutputWithContext(ctx context.Context) ProtocolArrayOutput {
	return o
}

func (o ProtocolArrayOutput) Index(i pulumi.IntInput) ProtocolOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Protocol {
		return vs[0].([]Protocol)[vs[1].(int)]
	}).(ProtocolOutput)
}

// Type of Api to create.
//   - `http` creates a SOAP to REST API
//   - `soap` creates a SOAP pass-through API .
type SoapApiType string

const (
	// Imports a SOAP API having a RESTful front end.
	SoapApiTypeSoapToRest = SoapApiType("http")
	// Imports the Soap API having a SOAP front end.
	SoapApiTypeSoapPassThrough = SoapApiType("soap")
)

func init() {
	pulumi.RegisterOutputType(KeyTypeOutput{})
	pulumi.RegisterOutputType(KeyTypePtrOutput{})
	pulumi.RegisterOutputType(ProtocolOutput{})
	pulumi.RegisterOutputType(ProtocolPtrOutput{})
	pulumi.RegisterOutputType(ProtocolArrayOutput{})
}
