// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v20230601preview

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A Machine Learning compute based on AKS.
type AKS struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'AKS'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// AKS properties
	Properties *AKSSchemaProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for AKS
func (val *AKS) Defaults() *AKS {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// A Machine Learning compute based on AKS.
type AKSResponse struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'AKS'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// AKS properties
	Properties *AKSSchemaResponseProperties `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for AKSResponse
func (val *AKSResponse) Defaults() *AKSResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// AKS properties
type AKSSchemaProperties struct {
	// Number of agents
	AgentCount *int `pulumi:"agentCount"`
	// Agent virtual machine size
	AgentVmSize *string `pulumi:"agentVmSize"`
	// AKS networking configuration for vnet
	AksNetworkingConfiguration *AksNetworkingConfiguration `pulumi:"aksNetworkingConfiguration"`
	// Cluster full qualified domain name
	ClusterFqdn *string `pulumi:"clusterFqdn"`
	// Intended usage of the cluster
	ClusterPurpose *string `pulumi:"clusterPurpose"`
	// Load Balancer Subnet
	LoadBalancerSubnet *string `pulumi:"loadBalancerSubnet"`
	// Load Balancer Type
	LoadBalancerType *string `pulumi:"loadBalancerType"`
	// SSL configuration
	SslConfiguration *SslConfiguration `pulumi:"sslConfiguration"`
}

// Defaults sets the appropriate defaults for AKSSchemaProperties
func (val *AKSSchemaProperties) Defaults() *AKSSchemaProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ClusterPurpose == nil {
		clusterPurpose_ := "FastProd"
		tmp.ClusterPurpose = &clusterPurpose_
	}
	if tmp.LoadBalancerType == nil {
		loadBalancerType_ := "PublicIp"
		tmp.LoadBalancerType = &loadBalancerType_
	}
	return &tmp
}

// AKS properties
type AKSSchemaResponseProperties struct {
	// Number of agents
	AgentCount *int `pulumi:"agentCount"`
	// Agent virtual machine size
	AgentVmSize *string `pulumi:"agentVmSize"`
	// AKS networking configuration for vnet
	AksNetworkingConfiguration *AksNetworkingConfigurationResponse `pulumi:"aksNetworkingConfiguration"`
	// Cluster full qualified domain name
	ClusterFqdn *string `pulumi:"clusterFqdn"`
	// Intended usage of the cluster
	ClusterPurpose *string `pulumi:"clusterPurpose"`
	// Load Balancer Subnet
	LoadBalancerSubnet *string `pulumi:"loadBalancerSubnet"`
	// Load Balancer Type
	LoadBalancerType *string `pulumi:"loadBalancerType"`
	// SSL configuration
	SslConfiguration *SslConfigurationResponse `pulumi:"sslConfiguration"`
	// System services
	SystemServices []SystemServiceResponse `pulumi:"systemServices"`
}

// Defaults sets the appropriate defaults for AKSSchemaResponseProperties
func (val *AKSSchemaResponseProperties) Defaults() *AKSSchemaResponseProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ClusterPurpose == nil {
		clusterPurpose_ := "FastProd"
		tmp.ClusterPurpose = &clusterPurpose_
	}
	if tmp.LoadBalancerType == nil {
		loadBalancerType_ := "PublicIp"
		tmp.LoadBalancerType = &loadBalancerType_
	}
	return &tmp
}

type AccessKeyAuthTypeWorkspaceConnectionProperties struct {
	// Authentication type of the connection target
	// Expected value is 'AccessKey'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category    *string                       `pulumi:"category"`
	Credentials *WorkspaceConnectionAccessKey `pulumi:"credentials"`
	ExpiryTime  *string                       `pulumi:"expiryTime"`
	Metadata    interface{}                   `pulumi:"metadata"`
	Target      *string                       `pulumi:"target"`
}

type AccessKeyAuthTypeWorkspaceConnectionPropertiesResponse struct {
	// Authentication type of the connection target
	// Expected value is 'AccessKey'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category    *string                               `pulumi:"category"`
	Credentials *WorkspaceConnectionAccessKeyResponse `pulumi:"credentials"`
	ExpiryTime  *string                               `pulumi:"expiryTime"`
	Metadata    interface{}                           `pulumi:"metadata"`
	Target      *string                               `pulumi:"target"`
}

// Account key datastore credentials configuration.
type AccountKeyDatastoreCredentials struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'AccountKey'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] Storage account secrets.
	Secrets AccountKeyDatastoreSecrets `pulumi:"secrets"`
}

// Account key datastore credentials configuration.
type AccountKeyDatastoreCredentialsResponse struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'AccountKey'.
	CredentialsType string `pulumi:"credentialsType"`
}

// Datastore account key secrets.
type AccountKeyDatastoreSecrets struct {
	// Storage account key.
	Key *string `pulumi:"key"`
	// Enum to determine the datastore secrets type.
	// Expected value is 'AccountKey'.
	SecretsType string `pulumi:"secretsType"`
}

// Details of ACR account to be used for the Registry
type AcrDetails struct {
	// Details of system created ACR account to be used for the Registry
	SystemCreatedAcrAccount *SystemCreatedAcrAccount `pulumi:"systemCreatedAcrAccount"`
	// Details of user created ACR account to be used for the Registry
	UserCreatedAcrAccount *UserCreatedAcrAccount `pulumi:"userCreatedAcrAccount"`
}

// AcrDetailsInput is an input type that accepts AcrDetailsArgs and AcrDetailsOutput values.
// You can construct a concrete instance of `AcrDetailsInput` via:
//
//	AcrDetailsArgs{...}
type AcrDetailsInput interface {
	pulumi.Input

	ToAcrDetailsOutput() AcrDetailsOutput
	ToAcrDetailsOutputWithContext(context.Context) AcrDetailsOutput
}

// Details of ACR account to be used for the Registry
type AcrDetailsArgs struct {
	// Details of system created ACR account to be used for the Registry
	SystemCreatedAcrAccount SystemCreatedAcrAccountPtrInput `pulumi:"systemCreatedAcrAccount"`
	// Details of user created ACR account to be used for the Registry
	UserCreatedAcrAccount UserCreatedAcrAccountPtrInput `pulumi:"userCreatedAcrAccount"`
}

func (AcrDetailsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AcrDetails)(nil)).Elem()
}

func (i AcrDetailsArgs) ToAcrDetailsOutput() AcrDetailsOutput {
	return i.ToAcrDetailsOutputWithContext(context.Background())
}

func (i AcrDetailsArgs) ToAcrDetailsOutputWithContext(ctx context.Context) AcrDetailsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AcrDetailsOutput)
}

// AcrDetailsArrayInput is an input type that accepts AcrDetailsArray and AcrDetailsArrayOutput values.
// You can construct a concrete instance of `AcrDetailsArrayInput` via:
//
//	AcrDetailsArray{ AcrDetailsArgs{...} }
type AcrDetailsArrayInput interface {
	pulumi.Input

	ToAcrDetailsArrayOutput() AcrDetailsArrayOutput
	ToAcrDetailsArrayOutputWithContext(context.Context) AcrDetailsArrayOutput
}

type AcrDetailsArray []AcrDetailsInput

func (AcrDetailsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AcrDetails)(nil)).Elem()
}

func (i AcrDetailsArray) ToAcrDetailsArrayOutput() AcrDetailsArrayOutput {
	return i.ToAcrDetailsArrayOutputWithContext(context.Background())
}

func (i AcrDetailsArray) ToAcrDetailsArrayOutputWithContext(ctx context.Context) AcrDetailsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AcrDetailsArrayOutput)
}

// Details of ACR account to be used for the Registry
type AcrDetailsOutput struct{ *pulumi.OutputState }

func (AcrDetailsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AcrDetails)(nil)).Elem()
}

func (o AcrDetailsOutput) ToAcrDetailsOutput() AcrDetailsOutput {
	return o
}

func (o AcrDetailsOutput) ToAcrDetailsOutputWithContext(ctx context.Context) AcrDetailsOutput {
	return o
}

// Details of system created ACR account to be used for the Registry
func (o AcrDetailsOutput) SystemCreatedAcrAccount() SystemCreatedAcrAccountPtrOutput {
	return o.ApplyT(func(v AcrDetails) *SystemCreatedAcrAccount { return v.SystemCreatedAcrAccount }).(SystemCreatedAcrAccountPtrOutput)
}

// Details of user created ACR account to be used for the Registry
func (o AcrDetailsOutput) UserCreatedAcrAccount() UserCreatedAcrAccountPtrOutput {
	return o.ApplyT(func(v AcrDetails) *UserCreatedAcrAccount { return v.UserCreatedAcrAccount }).(UserCreatedAcrAccountPtrOutput)
}

type AcrDetailsArrayOutput struct{ *pulumi.OutputState }

func (AcrDetailsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AcrDetails)(nil)).Elem()
}

func (o AcrDetailsArrayOutput) ToAcrDetailsArrayOutput() AcrDetailsArrayOutput {
	return o
}

func (o AcrDetailsArrayOutput) ToAcrDetailsArrayOutputWithContext(ctx context.Context) AcrDetailsArrayOutput {
	return o
}

func (o AcrDetailsArrayOutput) Index(i pulumi.IntInput) AcrDetailsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AcrDetails {
		return vs[0].([]AcrDetails)[vs[1].(int)]
	}).(AcrDetailsOutput)
}

// Details of ACR account to be used for the Registry
type AcrDetailsResponse struct {
	// Details of system created ACR account to be used for the Registry
	SystemCreatedAcrAccount *SystemCreatedAcrAccountResponse `pulumi:"systemCreatedAcrAccount"`
	// Details of user created ACR account to be used for the Registry
	UserCreatedAcrAccount *UserCreatedAcrAccountResponse `pulumi:"userCreatedAcrAccount"`
}

// Details of ACR account to be used for the Registry
type AcrDetailsResponseOutput struct{ *pulumi.OutputState }

func (AcrDetailsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AcrDetailsResponse)(nil)).Elem()
}

func (o AcrDetailsResponseOutput) ToAcrDetailsResponseOutput() AcrDetailsResponseOutput {
	return o
}

func (o AcrDetailsResponseOutput) ToAcrDetailsResponseOutputWithContext(ctx context.Context) AcrDetailsResponseOutput {
	return o
}

// Details of system created ACR account to be used for the Registry
func (o AcrDetailsResponseOutput) SystemCreatedAcrAccount() SystemCreatedAcrAccountResponsePtrOutput {
	return o.ApplyT(func(v AcrDetailsResponse) *SystemCreatedAcrAccountResponse { return v.SystemCreatedAcrAccount }).(SystemCreatedAcrAccountResponsePtrOutput)
}

// Details of user created ACR account to be used for the Registry
func (o AcrDetailsResponseOutput) UserCreatedAcrAccount() UserCreatedAcrAccountResponsePtrOutput {
	return o.ApplyT(func(v AcrDetailsResponse) *UserCreatedAcrAccountResponse { return v.UserCreatedAcrAccount }).(UserCreatedAcrAccountResponsePtrOutput)
}

type AcrDetailsResponseArrayOutput struct{ *pulumi.OutputState }

func (AcrDetailsResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AcrDetailsResponse)(nil)).Elem()
}

func (o AcrDetailsResponseArrayOutput) ToAcrDetailsResponseArrayOutput() AcrDetailsResponseArrayOutput {
	return o
}

func (o AcrDetailsResponseArrayOutput) ToAcrDetailsResponseArrayOutputWithContext(ctx context.Context) AcrDetailsResponseArrayOutput {
	return o
}

func (o AcrDetailsResponseArrayOutput) Index(i pulumi.IntInput) AcrDetailsResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AcrDetailsResponse {
		return vs[0].([]AcrDetailsResponse)[vs[1].(int)]
	}).(AcrDetailsResponseOutput)
}

// Advance configuration for AKS networking
type AksNetworkingConfiguration struct {
	// An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
	DnsServiceIP *string `pulumi:"dnsServiceIP"`
	// A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
	DockerBridgeCidr *string `pulumi:"dockerBridgeCidr"`
	// A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
	ServiceCidr *string `pulumi:"serviceCidr"`
	// Virtual network subnet resource ID the compute nodes belong to
	SubnetId *string `pulumi:"subnetId"`
}

// Advance configuration for AKS networking
type AksNetworkingConfigurationResponse struct {
	// An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
	DnsServiceIP *string `pulumi:"dnsServiceIP"`
	// A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
	DockerBridgeCidr *string `pulumi:"dockerBridgeCidr"`
	// A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
	ServiceCidr *string `pulumi:"serviceCidr"`
	// Virtual network subnet resource ID the compute nodes belong to
	SubnetId *string `pulumi:"subnetId"`
}

type AllFeatures struct {
	// Expected value is 'AllFeatures'.
	FilterType string `pulumi:"filterType"`
}

type AllFeaturesResponse struct {
	// Expected value is 'AllFeatures'.
	FilterType string `pulumi:"filterType"`
}

// All nodes means the service will be running on all of the nodes of the job
type AllNodes struct {
	// The enumerated types for the nodes value
	// Expected value is 'All'.
	NodesValueType string `pulumi:"nodesValueType"`
}

// AllNodesInput is an input type that accepts AllNodesArgs and AllNodesOutput values.
// You can construct a concrete instance of `AllNodesInput` via:
//
//	AllNodesArgs{...}
type AllNodesInput interface {
	pulumi.Input

	ToAllNodesOutput() AllNodesOutput
	ToAllNodesOutputWithContext(context.Context) AllNodesOutput
}

// All nodes means the service will be running on all of the nodes of the job
type AllNodesArgs struct {
	// The enumerated types for the nodes value
	// Expected value is 'All'.
	NodesValueType pulumi.StringInput `pulumi:"nodesValueType"`
}

func (AllNodesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AllNodes)(nil)).Elem()
}

func (i AllNodesArgs) ToAllNodesOutput() AllNodesOutput {
	return i.ToAllNodesOutputWithContext(context.Background())
}

func (i AllNodesArgs) ToAllNodesOutputWithContext(ctx context.Context) AllNodesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllNodesOutput)
}

func (i AllNodesArgs) ToAllNodesPtrOutput() AllNodesPtrOutput {
	return i.ToAllNodesPtrOutputWithContext(context.Background())
}

func (i AllNodesArgs) ToAllNodesPtrOutputWithContext(ctx context.Context) AllNodesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllNodesOutput).ToAllNodesPtrOutputWithContext(ctx)
}

// AllNodesPtrInput is an input type that accepts AllNodesArgs, AllNodesPtr and AllNodesPtrOutput values.
// You can construct a concrete instance of `AllNodesPtrInput` via:
//
//	        AllNodesArgs{...}
//
//	or:
//
//	        nil
type AllNodesPtrInput interface {
	pulumi.Input

	ToAllNodesPtrOutput() AllNodesPtrOutput
	ToAllNodesPtrOutputWithContext(context.Context) AllNodesPtrOutput
}

type allNodesPtrType AllNodesArgs

func AllNodesPtr(v *AllNodesArgs) AllNodesPtrInput {
	return (*allNodesPtrType)(v)
}

func (*allNodesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AllNodes)(nil)).Elem()
}

func (i *allNodesPtrType) ToAllNodesPtrOutput() AllNodesPtrOutput {
	return i.ToAllNodesPtrOutputWithContext(context.Background())
}

func (i *allNodesPtrType) ToAllNodesPtrOutputWithContext(ctx context.Context) AllNodesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllNodesPtrOutput)
}

// All nodes means the service will be running on all of the nodes of the job
type AllNodesOutput struct{ *pulumi.OutputState }

func (AllNodesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AllNodes)(nil)).Elem()
}

func (o AllNodesOutput) ToAllNodesOutput() AllNodesOutput {
	return o
}

func (o AllNodesOutput) ToAllNodesOutputWithContext(ctx context.Context) AllNodesOutput {
	return o
}

func (o AllNodesOutput) ToAllNodesPtrOutput() AllNodesPtrOutput {
	return o.ToAllNodesPtrOutputWithContext(context.Background())
}

func (o AllNodesOutput) ToAllNodesPtrOutputWithContext(ctx context.Context) AllNodesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AllNodes) *AllNodes {
		return &v
	}).(AllNodesPtrOutput)
}

// The enumerated types for the nodes value
// Expected value is 'All'.
func (o AllNodesOutput) NodesValueType() pulumi.StringOutput {
	return o.ApplyT(func(v AllNodes) string { return v.NodesValueType }).(pulumi.StringOutput)
}

type AllNodesPtrOutput struct{ *pulumi.OutputState }

func (AllNodesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AllNodes)(nil)).Elem()
}

func (o AllNodesPtrOutput) ToAllNodesPtrOutput() AllNodesPtrOutput {
	return o
}

func (o AllNodesPtrOutput) ToAllNodesPtrOutputWithContext(ctx context.Context) AllNodesPtrOutput {
	return o
}

func (o AllNodesPtrOutput) Elem() AllNodesOutput {
	return o.ApplyT(func(v *AllNodes) AllNodes {
		if v != nil {
			return *v
		}
		var ret AllNodes
		return ret
	}).(AllNodesOutput)
}

// The enumerated types for the nodes value
// Expected value is 'All'.
func (o AllNodesPtrOutput) NodesValueType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AllNodes) *string {
		if v == nil {
			return nil
		}
		return &v.NodesValueType
	}).(pulumi.StringPtrOutput)
}

// All nodes means the service will be running on all of the nodes of the job
type AllNodesResponse struct {
	// The enumerated types for the nodes value
	// Expected value is 'All'.
	NodesValueType string `pulumi:"nodesValueType"`
}

// All nodes means the service will be running on all of the nodes of the job
type AllNodesResponseOutput struct{ *pulumi.OutputState }

func (AllNodesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AllNodesResponse)(nil)).Elem()
}

func (o AllNodesResponseOutput) ToAllNodesResponseOutput() AllNodesResponseOutput {
	return o
}

func (o AllNodesResponseOutput) ToAllNodesResponseOutputWithContext(ctx context.Context) AllNodesResponseOutput {
	return o
}

// The enumerated types for the nodes value
// Expected value is 'All'.
func (o AllNodesResponseOutput) NodesValueType() pulumi.StringOutput {
	return o.ApplyT(func(v AllNodesResponse) string { return v.NodesValueType }).(pulumi.StringOutput)
}

type AllNodesResponsePtrOutput struct{ *pulumi.OutputState }

func (AllNodesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AllNodesResponse)(nil)).Elem()
}

func (o AllNodesResponsePtrOutput) ToAllNodesResponsePtrOutput() AllNodesResponsePtrOutput {
	return o
}

func (o AllNodesResponsePtrOutput) ToAllNodesResponsePtrOutputWithContext(ctx context.Context) AllNodesResponsePtrOutput {
	return o
}

func (o AllNodesResponsePtrOutput) Elem() AllNodesResponseOutput {
	return o.ApplyT(func(v *AllNodesResponse) AllNodesResponse {
		if v != nil {
			return *v
		}
		var ret AllNodesResponse
		return ret
	}).(AllNodesResponseOutput)
}

// The enumerated types for the nodes value
// Expected value is 'All'.
func (o AllNodesResponsePtrOutput) NodesValueType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AllNodesResponse) *string {
		if v == nil {
			return nil
		}
		return &v.NodesValueType
	}).(pulumi.StringPtrOutput)
}

// An Azure Machine Learning compute.
type AmlCompute struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'AmlCompute'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Properties of AmlCompute
	Properties *AmlComputeProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for AmlCompute
func (val *AmlCompute) Defaults() *AmlCompute {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// Compute node information related to a AmlCompute.
type AmlComputeNodeInformationResponse struct {
	// ID of the compute node.
	NodeId string `pulumi:"nodeId"`
	// State of the compute node. Values are idle, running, preparing, unusable, leaving and preempted.
	NodeState string `pulumi:"nodeState"`
	// SSH port number of the node.
	Port float64 `pulumi:"port"`
	// Private IP address of the compute node.
	PrivateIpAddress string `pulumi:"privateIpAddress"`
	// Public IP address of the compute node.
	PublicIpAddress string `pulumi:"publicIpAddress"`
	// ID of the Experiment running on the node, if any else null.
	RunId string `pulumi:"runId"`
}

// Compute node information related to a AmlCompute.
type AmlComputeNodeInformationResponseOutput struct{ *pulumi.OutputState }

func (AmlComputeNodeInformationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AmlComputeNodeInformationResponse)(nil)).Elem()
}

func (o AmlComputeNodeInformationResponseOutput) ToAmlComputeNodeInformationResponseOutput() AmlComputeNodeInformationResponseOutput {
	return o
}

func (o AmlComputeNodeInformationResponseOutput) ToAmlComputeNodeInformationResponseOutputWithContext(ctx context.Context) AmlComputeNodeInformationResponseOutput {
	return o
}

// ID of the compute node.
func (o AmlComputeNodeInformationResponseOutput) NodeId() pulumi.StringOutput {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) string { return v.NodeId }).(pulumi.StringOutput)
}

// State of the compute node. Values are idle, running, preparing, unusable, leaving and preempted.
func (o AmlComputeNodeInformationResponseOutput) NodeState() pulumi.StringOutput {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) string { return v.NodeState }).(pulumi.StringOutput)
}

// SSH port number of the node.
func (o AmlComputeNodeInformationResponseOutput) Port() pulumi.Float64Output {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) float64 { return v.Port }).(pulumi.Float64Output)
}

// Private IP address of the compute node.
func (o AmlComputeNodeInformationResponseOutput) PrivateIpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) string { return v.PrivateIpAddress }).(pulumi.StringOutput)
}

// Public IP address of the compute node.
func (o AmlComputeNodeInformationResponseOutput) PublicIpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) string { return v.PublicIpAddress }).(pulumi.StringOutput)
}

// ID of the Experiment running on the node, if any else null.
func (o AmlComputeNodeInformationResponseOutput) RunId() pulumi.StringOutput {
	return o.ApplyT(func(v AmlComputeNodeInformationResponse) string { return v.RunId }).(pulumi.StringOutput)
}

type AmlComputeNodeInformationResponseArrayOutput struct{ *pulumi.OutputState }

func (AmlComputeNodeInformationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AmlComputeNodeInformationResponse)(nil)).Elem()
}

func (o AmlComputeNodeInformationResponseArrayOutput) ToAmlComputeNodeInformationResponseArrayOutput() AmlComputeNodeInformationResponseArrayOutput {
	return o
}

func (o AmlComputeNodeInformationResponseArrayOutput) ToAmlComputeNodeInformationResponseArrayOutputWithContext(ctx context.Context) AmlComputeNodeInformationResponseArrayOutput {
	return o
}

func (o AmlComputeNodeInformationResponseArrayOutput) Index(i pulumi.IntInput) AmlComputeNodeInformationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AmlComputeNodeInformationResponse {
		return vs[0].([]AmlComputeNodeInformationResponse)[vs[1].(int)]
	}).(AmlComputeNodeInformationResponseOutput)
}

// AML Compute properties
type AmlComputeProperties struct {
	// Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `pulumi:"enableNodePublicIp"`
	// Network is isolated or not
	IsolatedNetwork *bool `pulumi:"isolatedNetwork"`
	// Compute OS Type
	OsType *string `pulumi:"osType"`
	// A property bag containing additional properties.
	PropertyBag interface{} `pulumi:"propertyBag"`
	// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
	RemoteLoginPortPublicAccess *string `pulumi:"remoteLoginPortPublicAccess"`
	// Scale settings for AML Compute
	ScaleSettings *ScaleSettings `pulumi:"scaleSettings"`
	// Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId `pulumi:"subnet"`
	// Credentials for an administrator user account that will be created on each compute node.
	UserAccountCredentials *UserAccountCredentials `pulumi:"userAccountCredentials"`
	// Virtual Machine image for AML Compute - windows only
	VirtualMachineImage *VirtualMachineImage `pulumi:"virtualMachineImage"`
	// Virtual Machine priority
	VmPriority *string `pulumi:"vmPriority"`
	// Virtual Machine Size
	VmSize *string `pulumi:"vmSize"`
}

// Defaults sets the appropriate defaults for AmlComputeProperties
func (val *AmlComputeProperties) Defaults() *AmlComputeProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.EnableNodePublicIp == nil {
		enableNodePublicIp_ := true
		tmp.EnableNodePublicIp = &enableNodePublicIp_
	}
	if tmp.OsType == nil {
		osType_ := "Linux"
		tmp.OsType = &osType_
	}
	if tmp.RemoteLoginPortPublicAccess == nil {
		remoteLoginPortPublicAccess_ := "NotSpecified"
		tmp.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess_
	}
	tmp.ScaleSettings = tmp.ScaleSettings.Defaults()

	return &tmp
}

// AML Compute properties
type AmlComputePropertiesResponse struct {
	// Allocation state of the compute. Possible values are: steady - Indicates that the compute is not resizing. There are no changes to the number of compute nodes in the compute in progress. A compute enters this state when it is created and when no operations are being performed on the compute to change the number of compute nodes. resizing - Indicates that the compute is resizing; that is, compute nodes are being added to or removed from the compute.
	AllocationState string `pulumi:"allocationState"`
	// The time at which the compute entered its current allocation state.
	AllocationStateTransitionTime string `pulumi:"allocationStateTransitionTime"`
	// The number of compute nodes currently assigned to the compute.
	CurrentNodeCount int `pulumi:"currentNodeCount"`
	// Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `pulumi:"enableNodePublicIp"`
	// Collection of errors encountered by various compute nodes during node setup.
	Errors []ErrorResponseResponse `pulumi:"errors"`
	// Network is isolated or not
	IsolatedNetwork *bool `pulumi:"isolatedNetwork"`
	// Counts of various node states on the compute.
	NodeStateCounts NodeStateCountsResponse `pulumi:"nodeStateCounts"`
	// Compute OS Type
	OsType *string `pulumi:"osType"`
	// A property bag containing additional properties.
	PropertyBag interface{} `pulumi:"propertyBag"`
	// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
	RemoteLoginPortPublicAccess *string `pulumi:"remoteLoginPortPublicAccess"`
	// Scale settings for AML Compute
	ScaleSettings *ScaleSettingsResponse `pulumi:"scaleSettings"`
	// Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceIdResponse `pulumi:"subnet"`
	// The target number of compute nodes for the compute. If the allocationState is resizing, this property denotes the target node count for the ongoing resize operation. If the allocationState is steady, this property denotes the target node count for the previous resize operation.
	TargetNodeCount int `pulumi:"targetNodeCount"`
	// Credentials for an administrator user account that will be created on each compute node.
	UserAccountCredentials *UserAccountCredentialsResponse `pulumi:"userAccountCredentials"`
	// Virtual Machine image for AML Compute - windows only
	VirtualMachineImage *VirtualMachineImageResponse `pulumi:"virtualMachineImage"`
	// Virtual Machine priority
	VmPriority *string `pulumi:"vmPriority"`
	// Virtual Machine Size
	VmSize *string `pulumi:"vmSize"`
}

// Defaults sets the appropriate defaults for AmlComputePropertiesResponse
func (val *AmlComputePropertiesResponse) Defaults() *AmlComputePropertiesResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.EnableNodePublicIp == nil {
		enableNodePublicIp_ := true
		tmp.EnableNodePublicIp = &enableNodePublicIp_
	}
	if tmp.OsType == nil {
		osType_ := "Linux"
		tmp.OsType = &osType_
	}
	if tmp.RemoteLoginPortPublicAccess == nil {
		remoteLoginPortPublicAccess_ := "NotSpecified"
		tmp.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess_
	}
	tmp.ScaleSettings = tmp.ScaleSettings.Defaults()

	return &tmp
}

// An Azure Machine Learning compute.
type AmlComputeResponse struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'AmlCompute'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// Properties of AmlCompute
	Properties *AmlComputePropertiesResponse `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for AmlComputeResponse
func (val *AmlComputeResponse) Defaults() *AmlComputeResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// AML Token identity configuration.
type AmlToken struct {
	// Enum to determine identity framework.
	// Expected value is 'AMLToken'.
	IdentityType string `pulumi:"identityType"`
}

// AML token compute identity definition.
type AmlTokenComputeIdentity struct {
	// Monitor compute identity type enum.
	// Expected value is 'AmlToken'.
	ComputeIdentityType string `pulumi:"computeIdentityType"`
}

// AML token compute identity definition.
type AmlTokenComputeIdentityResponse struct {
	// Monitor compute identity type enum.
	// Expected value is 'AmlToken'.
	ComputeIdentityType string `pulumi:"computeIdentityType"`
}

// AML Token identity configuration.
type AmlTokenResponse struct {
	// Enum to determine identity framework.
	// Expected value is 'AMLToken'.
	IdentityType string `pulumi:"identityType"`
}

// This connection type covers the generic ApiKey auth connection categories, for examples:
// AzureOpenAI:
//
//	Category:= AzureOpenAI
//	AuthType:= ApiKey (as type discriminator)
//	Credentials:= {ApiKey} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
//	Target:= {ApiBase}
//
// CognitiveService:
//
//	Category:= CognitiveService
//	AuthType:= ApiKey (as type discriminator)
//	Credentials:= {SubscriptionKey} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
//	Target:= ServiceRegion={serviceRegion}
//
// CognitiveSearch:
//
//	Category:= CognitiveSearch
//	AuthType:= ApiKey (as type discriminator)
//	Credentials:= {Key} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
//	Target:= {Endpoint}
//
// Use Metadata property bag for ApiType, ApiVersion, Kind and other metadata fields
type ApiKeyAuthWorkspaceConnectionProperties struct {
	// Authentication type of the connection target
	// Expected value is 'ApiKey'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category *string `pulumi:"category"`
	// Api key object for workspace connection credential.
	Credentials *WorkspaceConnectionApiKey `pulumi:"credentials"`
	ExpiryTime  *string                    `pulumi:"expiryTime"`
	Metadata    interface{}                `pulumi:"metadata"`
	Target      *string                    `pulumi:"target"`
}

// This connection type covers the generic ApiKey auth connection categories, for examples:
// AzureOpenAI:
//
//	Category:= AzureOpenAI
//	AuthType:= ApiKey (as type discriminator)
//	Credentials:= {ApiKey} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
//	Target:= {ApiBase}
//
// CognitiveService:
//
//	Category:= CognitiveService
//	AuthType:= ApiKey (as type discriminator)
//	Credentials:= {SubscriptionKey} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
//	Target:= ServiceRegion={serviceRegion}
//
// CognitiveSearch:
//
//	Category:= CognitiveSearch
//	AuthType:= ApiKey (as type discriminator)
//	Credentials:= {Key} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
//	Target:= {Endpoint}
//
// Use Metadata property bag for ApiType, ApiVersion, Kind and other metadata fields
type ApiKeyAuthWorkspaceConnectionPropertiesResponse struct {
	// Authentication type of the connection target
	// Expected value is 'ApiKey'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category *string `pulumi:"category"`
	// Api key object for workspace connection credential.
	Credentials *WorkspaceConnectionApiKeyResponse `pulumi:"credentials"`
	ExpiryTime  *string                            `pulumi:"expiryTime"`
	Metadata    interface{}                        `pulumi:"metadata"`
	Target      *string                            `pulumi:"target"`
}

// ARM ResourceId of a resource
type ArmResourceId struct {
	// Arm ResourceId is in the format "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
	// or "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}"
	ResourceId *string `pulumi:"resourceId"`
}

// ArmResourceIdInput is an input type that accepts ArmResourceIdArgs and ArmResourceIdOutput values.
// You can construct a concrete instance of `ArmResourceIdInput` via:
//
//	ArmResourceIdArgs{...}
type ArmResourceIdInput interface {
	pulumi.Input

	ToArmResourceIdOutput() ArmResourceIdOutput
	ToArmResourceIdOutputWithContext(context.Context) ArmResourceIdOutput
}

// ARM ResourceId of a resource
type ArmResourceIdArgs struct {
	// Arm ResourceId is in the format "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
	// or "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}"
	ResourceId pulumi.StringPtrInput `pulumi:"resourceId"`
}

func (ArmResourceIdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ArmResourceId)(nil)).Elem()
}

func (i ArmResourceIdArgs) ToArmResourceIdOutput() ArmResourceIdOutput {
	return i.ToArmResourceIdOutputWithContext(context.Background())
}

func (i ArmResourceIdArgs) ToArmResourceIdOutputWithContext(ctx context.Context) ArmResourceIdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArmResourceIdOutput)
}

func (i ArmResourceIdArgs) ToArmResourceIdPtrOutput() ArmResourceIdPtrOutput {
	return i.ToArmResourceIdPtrOutputWithContext(context.Background())
}

func (i ArmResourceIdArgs) ToArmResourceIdPtrOutputWithContext(ctx context.Context) ArmResourceIdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArmResourceIdOutput).ToArmResourceIdPtrOutputWithContext(ctx)
}

// ArmResourceIdPtrInput is an input type that accepts ArmResourceIdArgs, ArmResourceIdPtr and ArmResourceIdPtrOutput values.
// You can construct a concrete instance of `ArmResourceIdPtrInput` via:
//
//	        ArmResourceIdArgs{...}
//
//	or:
//
//	        nil
type ArmResourceIdPtrInput interface {
	pulumi.Input

	ToArmResourceIdPtrOutput() ArmResourceIdPtrOutput
	ToArmResourceIdPtrOutputWithContext(context.Context) ArmResourceIdPtrOutput
}

type armResourceIdPtrType ArmResourceIdArgs

func ArmResourceIdPtr(v *ArmResourceIdArgs) ArmResourceIdPtrInput {
	return (*armResourceIdPtrType)(v)
}

func (*armResourceIdPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ArmResourceId)(nil)).Elem()
}

func (i *armResourceIdPtrType) ToArmResourceIdPtrOutput() ArmResourceIdPtrOutput {
	return i.ToArmResourceIdPtrOutputWithContext(context.Background())
}

func (i *armResourceIdPtrType) ToArmResourceIdPtrOutputWithContext(ctx context.Context) ArmResourceIdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArmResourceIdPtrOutput)
}

// ARM ResourceId of a resource
type ArmResourceIdOutput struct{ *pulumi.OutputState }

func (ArmResourceIdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ArmResourceId)(nil)).Elem()
}

func (o ArmResourceIdOutput) ToArmResourceIdOutput() ArmResourceIdOutput {
	return o
}

func (o ArmResourceIdOutput) ToArmResourceIdOutputWithContext(ctx context.Context) ArmResourceIdOutput {
	return o
}

func (o ArmResourceIdOutput) ToArmResourceIdPtrOutput() ArmResourceIdPtrOutput {
	return o.ToArmResourceIdPtrOutputWithContext(context.Background())
}

func (o ArmResourceIdOutput) ToArmResourceIdPtrOutputWithContext(ctx context.Context) ArmResourceIdPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ArmResourceId) *ArmResourceId {
		return &v
	}).(ArmResourceIdPtrOutput)
}

// Arm ResourceId is in the format "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
// or "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}"
func (o ArmResourceIdOutput) ResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ArmResourceId) *string { return v.ResourceId }).(pulumi.StringPtrOutput)
}

type ArmResourceIdPtrOutput struct{ *pulumi.OutputState }

func (ArmResourceIdPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ArmResourceId)(nil)).Elem()
}

func (o ArmResourceIdPtrOutput) ToArmResourceIdPtrOutput() ArmResourceIdPtrOutput {
	return o
}

func (o ArmResourceIdPtrOutput) ToArmResourceIdPtrOutputWithContext(ctx context.Context) ArmResourceIdPtrOutput {
	return o
}

func (o ArmResourceIdPtrOutput) Elem() ArmResourceIdOutput {
	return o.ApplyT(func(v *ArmResourceId) ArmResourceId {
		if v != nil {
			return *v
		}
		var ret ArmResourceId
		return ret
	}).(ArmResourceIdOutput)
}

// Arm ResourceId is in the format "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
// or "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}"
func (o ArmResourceIdPtrOutput) ResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ArmResourceId) *string {
		if v == nil {
			return nil
		}
		return v.ResourceId
	}).(pulumi.StringPtrOutput)
}

// ARM ResourceId of a resource
type ArmResourceIdResponse struct {
	// Arm ResourceId is in the format "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
	// or "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}"
	ResourceId *string `pulumi:"resourceId"`
}

// ARM ResourceId of a resource
type ArmResourceIdResponseOutput struct{ *pulumi.OutputState }

func (ArmResourceIdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ArmResourceIdResponse)(nil)).Elem()
}

func (o ArmResourceIdResponseOutput) ToArmResourceIdResponseOutput() ArmResourceIdResponseOutput {
	return o
}

func (o ArmResourceIdResponseOutput) ToArmResourceIdResponseOutputWithContext(ctx context.Context) ArmResourceIdResponseOutput {
	return o
}

// Arm ResourceId is in the format "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
// or "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}"
func (o ArmResourceIdResponseOutput) ResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ArmResourceIdResponse) *string { return v.ResourceId }).(pulumi.StringPtrOutput)
}

type ArmResourceIdResponsePtrOutput struct{ *pulumi.OutputState }

func (ArmResourceIdResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ArmResourceIdResponse)(nil)).Elem()
}

func (o ArmResourceIdResponsePtrOutput) ToArmResourceIdResponsePtrOutput() ArmResourceIdResponsePtrOutput {
	return o
}

func (o ArmResourceIdResponsePtrOutput) ToArmResourceIdResponsePtrOutputWithContext(ctx context.Context) ArmResourceIdResponsePtrOutput {
	return o
}

func (o ArmResourceIdResponsePtrOutput) Elem() ArmResourceIdResponseOutput {
	return o.ApplyT(func(v *ArmResourceIdResponse) ArmResourceIdResponse {
		if v != nil {
			return *v
		}
		var ret ArmResourceIdResponse
		return ret
	}).(ArmResourceIdResponseOutput)
}

// Arm ResourceId is in the format "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
// or "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}"
func (o ArmResourceIdResponsePtrOutput) ResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ArmResourceIdResponse) *string {
		if v == nil {
			return nil
		}
		return v.ResourceId
	}).(pulumi.StringPtrOutput)
}

// A user that can be assigned to a compute instance.
type AssignedUser struct {
	// User’s AAD Object Id.
	ObjectId string `pulumi:"objectId"`
	// User’s AAD Tenant Id.
	TenantId string `pulumi:"tenantId"`
}

// A user that can be assigned to a compute instance.
type AssignedUserResponse struct {
	// User’s AAD Object Id.
	ObjectId string `pulumi:"objectId"`
	// User’s AAD Tenant Id.
	TenantId string `pulumi:"tenantId"`
}

type AutoDeleteSetting struct {
	// When to check if an asset is expired
	Condition *string `pulumi:"condition"`
	// Expiration condition value.
	Value *string `pulumi:"value"`
}

// Defaults sets the appropriate defaults for AutoDeleteSetting
func (val *AutoDeleteSetting) Defaults() *AutoDeleteSetting {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Condition == nil {
		condition_ := "CreatedGreaterThan"
		tmp.Condition = &condition_
	}
	return &tmp
}

// AutoDeleteSettingInput is an input type that accepts AutoDeleteSettingArgs and AutoDeleteSettingOutput values.
// You can construct a concrete instance of `AutoDeleteSettingInput` via:
//
//	AutoDeleteSettingArgs{...}
type AutoDeleteSettingInput interface {
	pulumi.Input

	ToAutoDeleteSettingOutput() AutoDeleteSettingOutput
	ToAutoDeleteSettingOutputWithContext(context.Context) AutoDeleteSettingOutput
}

type AutoDeleteSettingArgs struct {
	// When to check if an asset is expired
	Condition pulumi.StringPtrInput `pulumi:"condition"`
	// Expiration condition value.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

// Defaults sets the appropriate defaults for AutoDeleteSettingArgs
func (val *AutoDeleteSettingArgs) Defaults() *AutoDeleteSettingArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Condition == nil {
		tmp.Condition = pulumi.StringPtr("CreatedGreaterThan")
	}
	return &tmp
}
func (AutoDeleteSettingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AutoDeleteSetting)(nil)).Elem()
}

func (i AutoDeleteSettingArgs) ToAutoDeleteSettingOutput() AutoDeleteSettingOutput {
	return i.ToAutoDeleteSettingOutputWithContext(context.Background())
}

func (i AutoDeleteSettingArgs) ToAutoDeleteSettingOutputWithContext(ctx context.Context) AutoDeleteSettingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoDeleteSettingOutput)
}

func (i AutoDeleteSettingArgs) ToAutoDeleteSettingPtrOutput() AutoDeleteSettingPtrOutput {
	return i.ToAutoDeleteSettingPtrOutputWithContext(context.Background())
}

func (i AutoDeleteSettingArgs) ToAutoDeleteSettingPtrOutputWithContext(ctx context.Context) AutoDeleteSettingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoDeleteSettingOutput).ToAutoDeleteSettingPtrOutputWithContext(ctx)
}

// AutoDeleteSettingPtrInput is an input type that accepts AutoDeleteSettingArgs, AutoDeleteSettingPtr and AutoDeleteSettingPtrOutput values.
// You can construct a concrete instance of `AutoDeleteSettingPtrInput` via:
//
//	        AutoDeleteSettingArgs{...}
//
//	or:
//
//	        nil
type AutoDeleteSettingPtrInput interface {
	pulumi.Input

	ToAutoDeleteSettingPtrOutput() AutoDeleteSettingPtrOutput
	ToAutoDeleteSettingPtrOutputWithContext(context.Context) AutoDeleteSettingPtrOutput
}

type autoDeleteSettingPtrType AutoDeleteSettingArgs

func AutoDeleteSettingPtr(v *AutoDeleteSettingArgs) AutoDeleteSettingPtrInput {
	return (*autoDeleteSettingPtrType)(v)
}

func (*autoDeleteSettingPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AutoDeleteSetting)(nil)).Elem()
}

func (i *autoDeleteSettingPtrType) ToAutoDeleteSettingPtrOutput() AutoDeleteSettingPtrOutput {
	return i.ToAutoDeleteSettingPtrOutputWithContext(context.Background())
}

func (i *autoDeleteSettingPtrType) ToAutoDeleteSettingPtrOutputWithContext(ctx context.Context) AutoDeleteSettingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoDeleteSettingPtrOutput)
}

type AutoDeleteSettingOutput struct{ *pulumi.OutputState }

func (AutoDeleteSettingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AutoDeleteSetting)(nil)).Elem()
}

func (o AutoDeleteSettingOutput) ToAutoDeleteSettingOutput() AutoDeleteSettingOutput {
	return o
}

func (o AutoDeleteSettingOutput) ToAutoDeleteSettingOutputWithContext(ctx context.Context) AutoDeleteSettingOutput {
	return o
}

func (o AutoDeleteSettingOutput) ToAutoDeleteSettingPtrOutput() AutoDeleteSettingPtrOutput {
	return o.ToAutoDeleteSettingPtrOutputWithContext(context.Background())
}

func (o AutoDeleteSettingOutput) ToAutoDeleteSettingPtrOutputWithContext(ctx context.Context) AutoDeleteSettingPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AutoDeleteSetting) *AutoDeleteSetting {
		return &v
	}).(AutoDeleteSettingPtrOutput)
}

// When to check if an asset is expired
func (o AutoDeleteSettingOutput) Condition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AutoDeleteSetting) *string { return v.Condition }).(pulumi.StringPtrOutput)
}

// Expiration condition value.
func (o AutoDeleteSettingOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AutoDeleteSetting) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type AutoDeleteSettingPtrOutput struct{ *pulumi.OutputState }

func (AutoDeleteSettingPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AutoDeleteSetting)(nil)).Elem()
}

func (o AutoDeleteSettingPtrOutput) ToAutoDeleteSettingPtrOutput() AutoDeleteSettingPtrOutput {
	return o
}

func (o AutoDeleteSettingPtrOutput) ToAutoDeleteSettingPtrOutputWithContext(ctx context.Context) AutoDeleteSettingPtrOutput {
	return o
}

func (o AutoDeleteSettingPtrOutput) Elem() AutoDeleteSettingOutput {
	return o.ApplyT(func(v *AutoDeleteSetting) AutoDeleteSetting {
		if v != nil {
			return *v
		}
		var ret AutoDeleteSetting
		return ret
	}).(AutoDeleteSettingOutput)
}

// When to check if an asset is expired
func (o AutoDeleteSettingPtrOutput) Condition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AutoDeleteSetting) *string {
		if v == nil {
			return nil
		}
		return v.Condition
	}).(pulumi.StringPtrOutput)
}

// Expiration condition value.
func (o AutoDeleteSettingPtrOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AutoDeleteSetting) *string {
		if v == nil {
			return nil
		}
		return v.Value
	}).(pulumi.StringPtrOutput)
}

type AutoDeleteSettingResponse struct {
	// When to check if an asset is expired
	Condition *string `pulumi:"condition"`
	// Expiration condition value.
	Value *string `pulumi:"value"`
}

// Defaults sets the appropriate defaults for AutoDeleteSettingResponse
func (val *AutoDeleteSettingResponse) Defaults() *AutoDeleteSettingResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Condition == nil {
		condition_ := "CreatedGreaterThan"
		tmp.Condition = &condition_
	}
	return &tmp
}

type AutoDeleteSettingResponseOutput struct{ *pulumi.OutputState }

func (AutoDeleteSettingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AutoDeleteSettingResponse)(nil)).Elem()
}

func (o AutoDeleteSettingResponseOutput) ToAutoDeleteSettingResponseOutput() AutoDeleteSettingResponseOutput {
	return o
}

func (o AutoDeleteSettingResponseOutput) ToAutoDeleteSettingResponseOutputWithContext(ctx context.Context) AutoDeleteSettingResponseOutput {
	return o
}

// When to check if an asset is expired
func (o AutoDeleteSettingResponseOutput) Condition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AutoDeleteSettingResponse) *string { return v.Condition }).(pulumi.StringPtrOutput)
}

// Expiration condition value.
func (o AutoDeleteSettingResponseOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AutoDeleteSettingResponse) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type AutoDeleteSettingResponsePtrOutput struct{ *pulumi.OutputState }

func (AutoDeleteSettingResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AutoDeleteSettingResponse)(nil)).Elem()
}

func (o AutoDeleteSettingResponsePtrOutput) ToAutoDeleteSettingResponsePtrOutput() AutoDeleteSettingResponsePtrOutput {
	return o
}

func (o AutoDeleteSettingResponsePtrOutput) ToAutoDeleteSettingResponsePtrOutputWithContext(ctx context.Context) AutoDeleteSettingResponsePtrOutput {
	return o
}

func (o AutoDeleteSettingResponsePtrOutput) Elem() AutoDeleteSettingResponseOutput {
	return o.ApplyT(func(v *AutoDeleteSettingResponse) AutoDeleteSettingResponse {
		if v != nil {
			return *v
		}
		var ret AutoDeleteSettingResponse
		return ret
	}).(AutoDeleteSettingResponseOutput)
}

// When to check if an asset is expired
func (o AutoDeleteSettingResponsePtrOutput) Condition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AutoDeleteSettingResponse) *string {
		if v == nil {
			return nil
		}
		return v.Condition
	}).(pulumi.StringPtrOutput)
}

// Expiration condition value.
func (o AutoDeleteSettingResponsePtrOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AutoDeleteSettingResponse) *string {
		if v == nil {
			return nil
		}
		return v.Value
	}).(pulumi.StringPtrOutput)
}

// Forecast horizon determined automatically by system.
type AutoForecastHorizon struct {
	// Enum to determine forecast horizon selection mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// Forecast horizon determined automatically by system.
type AutoForecastHorizonResponse struct {
	// Enum to determine forecast horizon selection mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// AutoMLJob class.
// Use this class for executing AutoML tasks like Classification/Regression etc.
// See TaskType enum for all the tasks supported.
type AutoMLJob struct {
	// ARM resource ID of the component resource.
	ComponentId *string `pulumi:"componentId"`
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// The ARM resource ID of the Environment specification for the job.
	// This is optional value to provide, if not provided, AutoML will default this to Production AutoML curated environment version when running the job.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables included in the job.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'AutoML'.
	JobType string `pulumi:"jobType"`
	// Notification setting for the job
	NotificationSetting *NotificationSetting `pulumi:"notificationSetting"`
	// Mapping of output data bindings used in the job.
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Queue settings for the job
	QueueSettings *QueueSettings `pulumi:"queueSettings"`
	// Compute Resource configuration for the job.
	Resources *JobResourceConfiguration `pulumi:"resources"`
	// Configuration for secrets to be made available during runtime.
	SecretsConfiguration map[string]SecretConfiguration `pulumi:"secretsConfiguration"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobService `pulumi:"services"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
	// [Required] This represents scenario which can be one of Tables/NLP/Image
	TaskDetails interface{} `pulumi:"taskDetails"`
}

// Defaults sets the appropriate defaults for AutoMLJob
func (val *AutoMLJob) Defaults() *AutoMLJob {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ExperimentName == nil {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.QueueSettings = tmp.QueueSettings.Defaults()

	tmp.Resources = tmp.Resources.Defaults()

	return &tmp
}

// AutoMLJob class.
// Use this class for executing AutoML tasks like Classification/Regression etc.
// See TaskType enum for all the tasks supported.
type AutoMLJobResponse struct {
	// ARM resource ID of the component resource.
	ComponentId *string `pulumi:"componentId"`
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// The ARM resource ID of the Environment specification for the job.
	// This is optional value to provide, if not provided, AutoML will default this to Production AutoML curated environment version when running the job.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables included in the job.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'AutoML'.
	JobType string `pulumi:"jobType"`
	// Notification setting for the job
	NotificationSetting *NotificationSettingResponse `pulumi:"notificationSetting"`
	// Mapping of output data bindings used in the job.
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Queue settings for the job
	QueueSettings *QueueSettingsResponse `pulumi:"queueSettings"`
	// Compute Resource configuration for the job.
	Resources *JobResourceConfigurationResponse `pulumi:"resources"`
	// Configuration for secrets to be made available during runtime.
	SecretsConfiguration map[string]SecretConfigurationResponse `pulumi:"secretsConfiguration"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobServiceResponse `pulumi:"services"`
	// Status of the job.
	Status string `pulumi:"status"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
	// [Required] This represents scenario which can be one of Tables/NLP/Image
	TaskDetails interface{} `pulumi:"taskDetails"`
}

// Defaults sets the appropriate defaults for AutoMLJobResponse
func (val *AutoMLJobResponse) Defaults() *AutoMLJobResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ExperimentName == nil {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.QueueSettings = tmp.QueueSettings.Defaults()

	tmp.Resources = tmp.Resources.Defaults()

	return &tmp
}

// N-Cross validations determined automatically.
type AutoNCrossValidations struct {
	// Determines how N-Cross validations value is determined.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// N-Cross validations determined automatically.
type AutoNCrossValidationsResponse struct {
	// Determines how N-Cross validations value is determined.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// Auto pause properties
type AutoPauseProperties struct {
	DelayInMinutes *int  `pulumi:"delayInMinutes"`
	Enabled        *bool `pulumi:"enabled"`
}

// Auto pause properties
type AutoPausePropertiesResponse struct {
	DelayInMinutes *int  `pulumi:"delayInMinutes"`
	Enabled        *bool `pulumi:"enabled"`
}

// Auto scale properties
type AutoScaleProperties struct {
	Enabled      *bool `pulumi:"enabled"`
	MaxNodeCount *int  `pulumi:"maxNodeCount"`
	MinNodeCount *int  `pulumi:"minNodeCount"`
}

// Auto scale properties
type AutoScalePropertiesResponse struct {
	Enabled      *bool `pulumi:"enabled"`
	MaxNodeCount *int  `pulumi:"maxNodeCount"`
	MinNodeCount *int  `pulumi:"minNodeCount"`
}

type AutoSeasonality struct {
	// Forecasting seasonality mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

type AutoSeasonalityResponse struct {
	// Forecasting seasonality mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

type AutoTargetLags struct {
	// Target lags selection modes.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

type AutoTargetLagsResponse struct {
	// Target lags selection modes.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// Target lags rolling window determined automatically.
type AutoTargetRollingWindowSize struct {
	// Target rolling windows size mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// Target lags rolling window determined automatically.
type AutoTargetRollingWindowSizeResponse struct {
	// Target rolling windows size mode.
	// Expected value is 'Auto'.
	Mode string `pulumi:"mode"`
}

// Settings for Autologger.
type AutologgerSettings struct {
	// [Required] Indicates whether mlflow autologger is enabled.
	MlflowAutologger string `pulumi:"mlflowAutologger"`
}

// Settings for Autologger.
type AutologgerSettingsResponse struct {
	// [Required] Indicates whether mlflow autologger is enabled.
	MlflowAutologger string `pulumi:"mlflowAutologger"`
}

type AzMonMonitoringAlertNotificationSettings struct {
	// Expected value is 'AzureMonitor'.
	AlertNotificationType string `pulumi:"alertNotificationType"`
}

type AzMonMonitoringAlertNotificationSettingsResponse struct {
	// Expected value is 'AzureMonitor'.
	AlertNotificationType string `pulumi:"alertNotificationType"`
}

// Azure Blob datastore configuration.
type AzureBlobDatastore struct {
	// Storage account name.
	AccountName *string `pulumi:"accountName"`
	// Storage account container name.
	ContainerName *string `pulumi:"containerName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureBlob'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualProperty `pulumi:"intellectualProperty"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Azure Resource Group name
	ResourceGroup *string `pulumi:"resourceGroup"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Azure Subscription Id
	SubscriptionId *string `pulumi:"subscriptionId"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureBlobDatastore
func (val *AzureBlobDatastore) Defaults() *AzureBlobDatastore {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.ServiceDataAccessAuthIdentity == nil {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure Blob datastore configuration.
type AzureBlobDatastoreResponse struct {
	// Storage account name.
	AccountName *string `pulumi:"accountName"`
	// Storage account container name.
	ContainerName *string `pulumi:"containerName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureBlob'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualPropertyResponse `pulumi:"intellectualProperty"`
	// Readonly property to indicate if datastore is the workspace default datastore
	IsDefault bool `pulumi:"isDefault"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Azure Resource Group name
	ResourceGroup *string `pulumi:"resourceGroup"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Azure Subscription Id
	SubscriptionId *string `pulumi:"subscriptionId"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureBlobDatastoreResponse
func (val *AzureBlobDatastoreResponse) Defaults() *AzureBlobDatastoreResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.ServiceDataAccessAuthIdentity == nil {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure Data Lake Gen1 datastore configuration.
type AzureDataLakeGen1Datastore struct {
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureDataLakeGen1'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualProperty `pulumi:"intellectualProperty"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Azure Resource Group name
	ResourceGroup *string `pulumi:"resourceGroup"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// [Required] Azure Data Lake store name.
	StoreName string `pulumi:"storeName"`
	// Azure Subscription Id
	SubscriptionId *string `pulumi:"subscriptionId"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureDataLakeGen1Datastore
func (val *AzureDataLakeGen1Datastore) Defaults() *AzureDataLakeGen1Datastore {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.ServiceDataAccessAuthIdentity == nil {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure Data Lake Gen1 datastore configuration.
type AzureDataLakeGen1DatastoreResponse struct {
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureDataLakeGen1'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualPropertyResponse `pulumi:"intellectualProperty"`
	// Readonly property to indicate if datastore is the workspace default datastore
	IsDefault bool `pulumi:"isDefault"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Azure Resource Group name
	ResourceGroup *string `pulumi:"resourceGroup"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// [Required] Azure Data Lake store name.
	StoreName string `pulumi:"storeName"`
	// Azure Subscription Id
	SubscriptionId *string `pulumi:"subscriptionId"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureDataLakeGen1DatastoreResponse
func (val *AzureDataLakeGen1DatastoreResponse) Defaults() *AzureDataLakeGen1DatastoreResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.ServiceDataAccessAuthIdentity == nil {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure Data Lake Gen2 datastore configuration.
type AzureDataLakeGen2Datastore struct {
	// [Required] Storage account name.
	AccountName string `pulumi:"accountName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureDataLakeGen2'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// [Required] The name of the Data Lake Gen2 filesystem.
	Filesystem string `pulumi:"filesystem"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualProperty `pulumi:"intellectualProperty"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Azure Resource Group name
	ResourceGroup *string `pulumi:"resourceGroup"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Azure Subscription Id
	SubscriptionId *string `pulumi:"subscriptionId"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureDataLakeGen2Datastore
func (val *AzureDataLakeGen2Datastore) Defaults() *AzureDataLakeGen2Datastore {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.ServiceDataAccessAuthIdentity == nil {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure Data Lake Gen2 datastore configuration.
type AzureDataLakeGen2DatastoreResponse struct {
	// [Required] Storage account name.
	AccountName string `pulumi:"accountName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureDataLakeGen2'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// [Required] The name of the Data Lake Gen2 filesystem.
	Filesystem string `pulumi:"filesystem"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualPropertyResponse `pulumi:"intellectualProperty"`
	// Readonly property to indicate if datastore is the workspace default datastore
	IsDefault bool `pulumi:"isDefault"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Azure Resource Group name
	ResourceGroup *string `pulumi:"resourceGroup"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Azure Subscription Id
	SubscriptionId *string `pulumi:"subscriptionId"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureDataLakeGen2DatastoreResponse
func (val *AzureDataLakeGen2DatastoreResponse) Defaults() *AzureDataLakeGen2DatastoreResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.ServiceDataAccessAuthIdentity == nil {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Webhook details specific for Azure DevOps
type AzureDevOpsWebhook struct {
	// Send callback on a specified notification event
	EventType *string `pulumi:"eventType"`
	// Enum to determine the webhook callback service type.
	// Expected value is 'AzureDevOps'.
	WebhookType string `pulumi:"webhookType"`
}

// AzureDevOpsWebhookInput is an input type that accepts AzureDevOpsWebhookArgs and AzureDevOpsWebhookOutput values.
// You can construct a concrete instance of `AzureDevOpsWebhookInput` via:
//
//	AzureDevOpsWebhookArgs{...}
type AzureDevOpsWebhookInput interface {
	pulumi.Input

	ToAzureDevOpsWebhookOutput() AzureDevOpsWebhookOutput
	ToAzureDevOpsWebhookOutputWithContext(context.Context) AzureDevOpsWebhookOutput
}

// Webhook details specific for Azure DevOps
type AzureDevOpsWebhookArgs struct {
	// Send callback on a specified notification event
	EventType pulumi.StringPtrInput `pulumi:"eventType"`
	// Enum to determine the webhook callback service type.
	// Expected value is 'AzureDevOps'.
	WebhookType pulumi.StringInput `pulumi:"webhookType"`
}

func (AzureDevOpsWebhookArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureDevOpsWebhook)(nil)).Elem()
}

func (i AzureDevOpsWebhookArgs) ToAzureDevOpsWebhookOutput() AzureDevOpsWebhookOutput {
	return i.ToAzureDevOpsWebhookOutputWithContext(context.Background())
}

func (i AzureDevOpsWebhookArgs) ToAzureDevOpsWebhookOutputWithContext(ctx context.Context) AzureDevOpsWebhookOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureDevOpsWebhookOutput)
}

// AzureDevOpsWebhookMapInput is an input type that accepts AzureDevOpsWebhookMap and AzureDevOpsWebhookMapOutput values.
// You can construct a concrete instance of `AzureDevOpsWebhookMapInput` via:
//
//	AzureDevOpsWebhookMap{ "key": AzureDevOpsWebhookArgs{...} }
type AzureDevOpsWebhookMapInput interface {
	pulumi.Input

	ToAzureDevOpsWebhookMapOutput() AzureDevOpsWebhookMapOutput
	ToAzureDevOpsWebhookMapOutputWithContext(context.Context) AzureDevOpsWebhookMapOutput
}

type AzureDevOpsWebhookMap map[string]AzureDevOpsWebhookInput

func (AzureDevOpsWebhookMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]AzureDevOpsWebhook)(nil)).Elem()
}

func (i AzureDevOpsWebhookMap) ToAzureDevOpsWebhookMapOutput() AzureDevOpsWebhookMapOutput {
	return i.ToAzureDevOpsWebhookMapOutputWithContext(context.Background())
}

func (i AzureDevOpsWebhookMap) ToAzureDevOpsWebhookMapOutputWithContext(ctx context.Context) AzureDevOpsWebhookMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureDevOpsWebhookMapOutput)
}

// Webhook details specific for Azure DevOps
type AzureDevOpsWebhookOutput struct{ *pulumi.OutputState }

func (AzureDevOpsWebhookOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureDevOpsWebhook)(nil)).Elem()
}

func (o AzureDevOpsWebhookOutput) ToAzureDevOpsWebhookOutput() AzureDevOpsWebhookOutput {
	return o
}

func (o AzureDevOpsWebhookOutput) ToAzureDevOpsWebhookOutputWithContext(ctx context.Context) AzureDevOpsWebhookOutput {
	return o
}

// Send callback on a specified notification event
func (o AzureDevOpsWebhookOutput) EventType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureDevOpsWebhook) *string { return v.EventType }).(pulumi.StringPtrOutput)
}

// Enum to determine the webhook callback service type.
// Expected value is 'AzureDevOps'.
func (o AzureDevOpsWebhookOutput) WebhookType() pulumi.StringOutput {
	return o.ApplyT(func(v AzureDevOpsWebhook) string { return v.WebhookType }).(pulumi.StringOutput)
}

type AzureDevOpsWebhookMapOutput struct{ *pulumi.OutputState }

func (AzureDevOpsWebhookMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]AzureDevOpsWebhook)(nil)).Elem()
}

func (o AzureDevOpsWebhookMapOutput) ToAzureDevOpsWebhookMapOutput() AzureDevOpsWebhookMapOutput {
	return o
}

func (o AzureDevOpsWebhookMapOutput) ToAzureDevOpsWebhookMapOutputWithContext(ctx context.Context) AzureDevOpsWebhookMapOutput {
	return o
}

func (o AzureDevOpsWebhookMapOutput) MapIndex(k pulumi.StringInput) AzureDevOpsWebhookOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) AzureDevOpsWebhook {
		return vs[0].(map[string]AzureDevOpsWebhook)[vs[1].(string)]
	}).(AzureDevOpsWebhookOutput)
}

// Webhook details specific for Azure DevOps
type AzureDevOpsWebhookResponse struct {
	// Send callback on a specified notification event
	EventType *string `pulumi:"eventType"`
	// Enum to determine the webhook callback service type.
	// Expected value is 'AzureDevOps'.
	WebhookType string `pulumi:"webhookType"`
}

// Webhook details specific for Azure DevOps
type AzureDevOpsWebhookResponseOutput struct{ *pulumi.OutputState }

func (AzureDevOpsWebhookResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureDevOpsWebhookResponse)(nil)).Elem()
}

func (o AzureDevOpsWebhookResponseOutput) ToAzureDevOpsWebhookResponseOutput() AzureDevOpsWebhookResponseOutput {
	return o
}

func (o AzureDevOpsWebhookResponseOutput) ToAzureDevOpsWebhookResponseOutputWithContext(ctx context.Context) AzureDevOpsWebhookResponseOutput {
	return o
}

// Send callback on a specified notification event
func (o AzureDevOpsWebhookResponseOutput) EventType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureDevOpsWebhookResponse) *string { return v.EventType }).(pulumi.StringPtrOutput)
}

// Enum to determine the webhook callback service type.
// Expected value is 'AzureDevOps'.
func (o AzureDevOpsWebhookResponseOutput) WebhookType() pulumi.StringOutput {
	return o.ApplyT(func(v AzureDevOpsWebhookResponse) string { return v.WebhookType }).(pulumi.StringOutput)
}

type AzureDevOpsWebhookResponseMapOutput struct{ *pulumi.OutputState }

func (AzureDevOpsWebhookResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]AzureDevOpsWebhookResponse)(nil)).Elem()
}

func (o AzureDevOpsWebhookResponseMapOutput) ToAzureDevOpsWebhookResponseMapOutput() AzureDevOpsWebhookResponseMapOutput {
	return o
}

func (o AzureDevOpsWebhookResponseMapOutput) ToAzureDevOpsWebhookResponseMapOutputWithContext(ctx context.Context) AzureDevOpsWebhookResponseMapOutput {
	return o
}

func (o AzureDevOpsWebhookResponseMapOutput) MapIndex(k pulumi.StringInput) AzureDevOpsWebhookResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) AzureDevOpsWebhookResponse {
		return vs[0].(map[string]AzureDevOpsWebhookResponse)[vs[1].(string)]
	}).(AzureDevOpsWebhookResponseOutput)
}

// Azure File datastore configuration.
type AzureFileDatastore struct {
	// [Required] Storage account name.
	AccountName string `pulumi:"accountName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureFile'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// [Required] The name of the Azure file share that the datastore points to.
	FileShareName string `pulumi:"fileShareName"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualProperty `pulumi:"intellectualProperty"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Azure Resource Group name
	ResourceGroup *string `pulumi:"resourceGroup"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Azure Subscription Id
	SubscriptionId *string `pulumi:"subscriptionId"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureFileDatastore
func (val *AzureFileDatastore) Defaults() *AzureFileDatastore {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.ServiceDataAccessAuthIdentity == nil {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Azure File datastore configuration.
type AzureFileDatastoreResponse struct {
	// [Required] Storage account name.
	AccountName string `pulumi:"accountName"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'AzureFile'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Azure cloud endpoint for the storage account.
	Endpoint *string `pulumi:"endpoint"`
	// [Required] The name of the Azure file share that the datastore points to.
	FileShareName string `pulumi:"fileShareName"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualPropertyResponse `pulumi:"intellectualProperty"`
	// Readonly property to indicate if datastore is the workspace default datastore
	IsDefault bool `pulumi:"isDefault"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account.
	Protocol *string `pulumi:"protocol"`
	// Azure Resource Group name
	ResourceGroup *string `pulumi:"resourceGroup"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Azure Subscription Id
	SubscriptionId *string `pulumi:"subscriptionId"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for AzureFileDatastoreResponse
func (val *AzureFileDatastoreResponse) Defaults() *AzureFileDatastoreResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.ServiceDataAccessAuthIdentity == nil {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Defines an early termination policy based on slack criteria, and a frequency and delay interval for evaluation
type BanditPolicy struct {
	// Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int `pulumi:"delayEvaluation"`
	// Interval (number of runs) between policy evaluations.
	EvaluationInterval *int `pulumi:"evaluationInterval"`
	// Expected value is 'Bandit'.
	PolicyType string `pulumi:"policyType"`
	// Absolute distance allowed from the best performing run.
	SlackAmount *float64 `pulumi:"slackAmount"`
	// Ratio of the allowed distance from the best performing run.
	SlackFactor *float64 `pulumi:"slackFactor"`
}

// Defaults sets the appropriate defaults for BanditPolicy
func (val *BanditPolicy) Defaults() *BanditPolicy {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DelayEvaluation == nil {
		delayEvaluation_ := 0
		tmp.DelayEvaluation = &delayEvaluation_
	}
	if tmp.EvaluationInterval == nil {
		evaluationInterval_ := 0
		tmp.EvaluationInterval = &evaluationInterval_
	}
	if tmp.SlackAmount == nil {
		slackAmount_ := 0.0
		tmp.SlackAmount = &slackAmount_
	}
	if tmp.SlackFactor == nil {
		slackFactor_ := 0.0
		tmp.SlackFactor = &slackFactor_
	}
	return &tmp
}

// Defines an early termination policy based on slack criteria, and a frequency and delay interval for evaluation
type BanditPolicyResponse struct {
	// Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int `pulumi:"delayEvaluation"`
	// Interval (number of runs) between policy evaluations.
	EvaluationInterval *int `pulumi:"evaluationInterval"`
	// Expected value is 'Bandit'.
	PolicyType string `pulumi:"policyType"`
	// Absolute distance allowed from the best performing run.
	SlackAmount *float64 `pulumi:"slackAmount"`
	// Ratio of the allowed distance from the best performing run.
	SlackFactor *float64 `pulumi:"slackFactor"`
}

// Defaults sets the appropriate defaults for BanditPolicyResponse
func (val *BanditPolicyResponse) Defaults() *BanditPolicyResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DelayEvaluation == nil {
		delayEvaluation_ := 0
		tmp.DelayEvaluation = &delayEvaluation_
	}
	if tmp.EvaluationInterval == nil {
		evaluationInterval_ := 0
		tmp.EvaluationInterval = &evaluationInterval_
	}
	if tmp.SlackAmount == nil {
		slackAmount_ := 0.0
		tmp.SlackAmount = &slackAmount_
	}
	if tmp.SlackFactor == nil {
		slackFactor_ := 0.0
		tmp.SlackFactor = &slackFactor_
	}
	return &tmp
}

// Batch inference settings per deployment.
type BatchDeploymentType struct {
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfiguration `pulumi:"codeConfiguration"`
	// Compute target for batch inference operation.
	Compute *string `pulumi:"compute"`
	// Properties relevant to different deployment types.
	DeploymentConfiguration *BatchPipelineComponentDeploymentConfiguration `pulumi:"deploymentConfiguration"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Error threshold, if the error count for the entire input goes above this value,
	// the batch inference will be aborted. Range is [-1, int.MaxValue].
	// For FileDataset, this value is the count of file failures.
	// For TabularDataset, this value is the count of record failures.
	// If set to -1 (the lower bound), all failures during batch inference will be ignored.
	ErrorThreshold *int `pulumi:"errorThreshold"`
	// Logging level for batch inference operation.
	LoggingLevel *string `pulumi:"loggingLevel"`
	// Indicates maximum number of parallelism per instance.
	MaxConcurrencyPerInstance *int `pulumi:"maxConcurrencyPerInstance"`
	// Size of the mini-batch passed to each batch invocation.
	// For FileDataset, this is the number of files per mini-batch.
	// For TabularDataset, this is the size of the records in bytes, per mini-batch.
	MiniBatchSize *float64 `pulumi:"miniBatchSize"`
	// Reference to the model asset for the endpoint deployment.
	Model interface{} `pulumi:"model"`
	// Indicates how the output will be organized.
	OutputAction *string `pulumi:"outputAction"`
	// Customized output file name for append_row output action.
	OutputFileName *string `pulumi:"outputFileName"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Indicates compute configuration for the job.
	// If not provided, will default to the defaults defined in ResourceConfiguration.
	Resources *DeploymentResourceConfiguration `pulumi:"resources"`
	// Retry Settings for the batch inference operation.
	// If not provided, will default to the defaults defined in BatchRetrySettings.
	RetrySettings *BatchRetrySettings `pulumi:"retrySettings"`
}

// Defaults sets the appropriate defaults for BatchDeploymentType
func (val *BatchDeploymentType) Defaults() *BatchDeploymentType {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ErrorThreshold == nil {
		errorThreshold_ := -1
		tmp.ErrorThreshold = &errorThreshold_
	}
	if tmp.LoggingLevel == nil {
		loggingLevel_ := "Info"
		tmp.LoggingLevel = &loggingLevel_
	}
	if tmp.MaxConcurrencyPerInstance == nil {
		maxConcurrencyPerInstance_ := 1
		tmp.MaxConcurrencyPerInstance = &maxConcurrencyPerInstance_
	}
	if tmp.MiniBatchSize == nil {
		miniBatchSize_ := 10.0
		tmp.MiniBatchSize = &miniBatchSize_
	}
	if tmp.OutputAction == nil {
		outputAction_ := "AppendRow"
		tmp.OutputAction = &outputAction_
	}
	if tmp.OutputFileName == nil {
		outputFileName_ := "predictions.csv"
		tmp.OutputFileName = &outputFileName_
	}
	tmp.Resources = tmp.Resources.Defaults()

	tmp.RetrySettings = tmp.RetrySettings.Defaults()

	return &tmp
}

// BatchDeploymentTypeInput is an input type that accepts BatchDeploymentTypeArgs and BatchDeploymentTypeOutput values.
// You can construct a concrete instance of `BatchDeploymentTypeInput` via:
//
//	BatchDeploymentTypeArgs{...}
type BatchDeploymentTypeInput interface {
	pulumi.Input

	ToBatchDeploymentTypeOutput() BatchDeploymentTypeOutput
	ToBatchDeploymentTypeOutputWithContext(context.Context) BatchDeploymentTypeOutput
}

// Batch inference settings per deployment.
type BatchDeploymentTypeArgs struct {
	// Code configuration for the endpoint deployment.
	CodeConfiguration CodeConfigurationPtrInput `pulumi:"codeConfiguration"`
	// Compute target for batch inference operation.
	Compute pulumi.StringPtrInput `pulumi:"compute"`
	// Properties relevant to different deployment types.
	DeploymentConfiguration BatchPipelineComponentDeploymentConfigurationPtrInput `pulumi:"deploymentConfiguration"`
	// Description of the endpoint deployment.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId pulumi.StringPtrInput `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables pulumi.StringMapInput `pulumi:"environmentVariables"`
	// Error threshold, if the error count for the entire input goes above this value,
	// the batch inference will be aborted. Range is [-1, int.MaxValue].
	// For FileDataset, this value is the count of file failures.
	// For TabularDataset, this value is the count of record failures.
	// If set to -1 (the lower bound), all failures during batch inference will be ignored.
	ErrorThreshold pulumi.IntPtrInput `pulumi:"errorThreshold"`
	// Logging level for batch inference operation.
	LoggingLevel pulumi.StringPtrInput `pulumi:"loggingLevel"`
	// Indicates maximum number of parallelism per instance.
	MaxConcurrencyPerInstance pulumi.IntPtrInput `pulumi:"maxConcurrencyPerInstance"`
	// Size of the mini-batch passed to each batch invocation.
	// For FileDataset, this is the number of files per mini-batch.
	// For TabularDataset, this is the size of the records in bytes, per mini-batch.
	MiniBatchSize pulumi.Float64PtrInput `pulumi:"miniBatchSize"`
	// Reference to the model asset for the endpoint deployment.
	Model pulumi.Input `pulumi:"model"`
	// Indicates how the output will be organized.
	OutputAction pulumi.StringPtrInput `pulumi:"outputAction"`
	// Customized output file name for append_row output action.
	OutputFileName pulumi.StringPtrInput `pulumi:"outputFileName"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Indicates compute configuration for the job.
	// If not provided, will default to the defaults defined in ResourceConfiguration.
	Resources DeploymentResourceConfigurationPtrInput `pulumi:"resources"`
	// Retry Settings for the batch inference operation.
	// If not provided, will default to the defaults defined in BatchRetrySettings.
	RetrySettings BatchRetrySettingsPtrInput `pulumi:"retrySettings"`
}

// Defaults sets the appropriate defaults for BatchDeploymentTypeArgs
func (val *BatchDeploymentTypeArgs) Defaults() *BatchDeploymentTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ErrorThreshold == nil {
		tmp.ErrorThreshold = pulumi.IntPtr(-1)
	}
	if tmp.LoggingLevel == nil {
		tmp.LoggingLevel = pulumi.StringPtr("Info")
	}
	if tmp.MaxConcurrencyPerInstance == nil {
		tmp.MaxConcurrencyPerInstance = pulumi.IntPtr(1)
	}
	if tmp.MiniBatchSize == nil {
		tmp.MiniBatchSize = pulumi.Float64Ptr(10.0)
	}
	if tmp.OutputAction == nil {
		tmp.OutputAction = pulumi.StringPtr("AppendRow")
	}
	if tmp.OutputFileName == nil {
		tmp.OutputFileName = pulumi.StringPtr("predictions.csv")
	}

	return &tmp
}
func (BatchDeploymentTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchDeploymentType)(nil)).Elem()
}

func (i BatchDeploymentTypeArgs) ToBatchDeploymentTypeOutput() BatchDeploymentTypeOutput {
	return i.ToBatchDeploymentTypeOutputWithContext(context.Background())
}

func (i BatchDeploymentTypeArgs) ToBatchDeploymentTypeOutputWithContext(ctx context.Context) BatchDeploymentTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchDeploymentTypeOutput)
}

// Batch inference settings per deployment.
type BatchDeploymentTypeOutput struct{ *pulumi.OutputState }

func (BatchDeploymentTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchDeploymentType)(nil)).Elem()
}

func (o BatchDeploymentTypeOutput) ToBatchDeploymentTypeOutput() BatchDeploymentTypeOutput {
	return o
}

func (o BatchDeploymentTypeOutput) ToBatchDeploymentTypeOutputWithContext(ctx context.Context) BatchDeploymentTypeOutput {
	return o
}

// Code configuration for the endpoint deployment.
func (o BatchDeploymentTypeOutput) CodeConfiguration() CodeConfigurationPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *CodeConfiguration { return v.CodeConfiguration }).(CodeConfigurationPtrOutput)
}

// Compute target for batch inference operation.
func (o BatchDeploymentTypeOutput) Compute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.Compute }).(pulumi.StringPtrOutput)
}

// Properties relevant to different deployment types.
func (o BatchDeploymentTypeOutput) DeploymentConfiguration() BatchPipelineComponentDeploymentConfigurationPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *BatchPipelineComponentDeploymentConfiguration {
		return v.DeploymentConfiguration
	}).(BatchPipelineComponentDeploymentConfigurationPtrOutput)
}

// Description of the endpoint deployment.
func (o BatchDeploymentTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// ARM resource ID of the environment specification for the endpoint deployment.
func (o BatchDeploymentTypeOutput) EnvironmentId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.EnvironmentId }).(pulumi.StringPtrOutput)
}

// Environment variables configuration for the deployment.
func (o BatchDeploymentTypeOutput) EnvironmentVariables() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchDeploymentType) map[string]string { return v.EnvironmentVariables }).(pulumi.StringMapOutput)
}

// Error threshold, if the error count for the entire input goes above this value,
// the batch inference will be aborted. Range is [-1, int.MaxValue].
// For FileDataset, this value is the count of file failures.
// For TabularDataset, this value is the count of record failures.
// If set to -1 (the lower bound), all failures during batch inference will be ignored.
func (o BatchDeploymentTypeOutput) ErrorThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *int { return v.ErrorThreshold }).(pulumi.IntPtrOutput)
}

// Logging level for batch inference operation.
func (o BatchDeploymentTypeOutput) LoggingLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.LoggingLevel }).(pulumi.StringPtrOutput)
}

// Indicates maximum number of parallelism per instance.
func (o BatchDeploymentTypeOutput) MaxConcurrencyPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *int { return v.MaxConcurrencyPerInstance }).(pulumi.IntPtrOutput)
}

// Size of the mini-batch passed to each batch invocation.
// For FileDataset, this is the number of files per mini-batch.
// For TabularDataset, this is the size of the records in bytes, per mini-batch.
func (o BatchDeploymentTypeOutput) MiniBatchSize() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *float64 { return v.MiniBatchSize }).(pulumi.Float64PtrOutput)
}

// Reference to the model asset for the endpoint deployment.
func (o BatchDeploymentTypeOutput) Model() pulumi.AnyOutput {
	return o.ApplyT(func(v BatchDeploymentType) interface{} { return v.Model }).(pulumi.AnyOutput)
}

// Indicates how the output will be organized.
func (o BatchDeploymentTypeOutput) OutputAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.OutputAction }).(pulumi.StringPtrOutput)
}

// Customized output file name for append_row output action.
func (o BatchDeploymentTypeOutput) OutputFileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *string { return v.OutputFileName }).(pulumi.StringPtrOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o BatchDeploymentTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchDeploymentType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Indicates compute configuration for the job.
// If not provided, will default to the defaults defined in ResourceConfiguration.
func (o BatchDeploymentTypeOutput) Resources() DeploymentResourceConfigurationPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *DeploymentResourceConfiguration { return v.Resources }).(DeploymentResourceConfigurationPtrOutput)
}

// Retry Settings for the batch inference operation.
// If not provided, will default to the defaults defined in BatchRetrySettings.
func (o BatchDeploymentTypeOutput) RetrySettings() BatchRetrySettingsPtrOutput {
	return o.ApplyT(func(v BatchDeploymentType) *BatchRetrySettings { return v.RetrySettings }).(BatchRetrySettingsPtrOutput)
}

// Batch inference settings per deployment.
type BatchDeploymentResponse struct {
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfigurationResponse `pulumi:"codeConfiguration"`
	// Compute target for batch inference operation.
	Compute *string `pulumi:"compute"`
	// Properties relevant to different deployment types.
	DeploymentConfiguration *BatchPipelineComponentDeploymentConfigurationResponse `pulumi:"deploymentConfiguration"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Error threshold, if the error count for the entire input goes above this value,
	// the batch inference will be aborted. Range is [-1, int.MaxValue].
	// For FileDataset, this value is the count of file failures.
	// For TabularDataset, this value is the count of record failures.
	// If set to -1 (the lower bound), all failures during batch inference will be ignored.
	ErrorThreshold *int `pulumi:"errorThreshold"`
	// Logging level for batch inference operation.
	LoggingLevel *string `pulumi:"loggingLevel"`
	// Indicates maximum number of parallelism per instance.
	MaxConcurrencyPerInstance *int `pulumi:"maxConcurrencyPerInstance"`
	// Size of the mini-batch passed to each batch invocation.
	// For FileDataset, this is the number of files per mini-batch.
	// For TabularDataset, this is the size of the records in bytes, per mini-batch.
	MiniBatchSize *float64 `pulumi:"miniBatchSize"`
	// Reference to the model asset for the endpoint deployment.
	Model interface{} `pulumi:"model"`
	// Indicates how the output will be organized.
	OutputAction *string `pulumi:"outputAction"`
	// Customized output file name for append_row output action.
	OutputFileName *string `pulumi:"outputFileName"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the endpoint deployment.
	ProvisioningState string `pulumi:"provisioningState"`
	// Indicates compute configuration for the job.
	// If not provided, will default to the defaults defined in ResourceConfiguration.
	Resources *DeploymentResourceConfigurationResponse `pulumi:"resources"`
	// Retry Settings for the batch inference operation.
	// If not provided, will default to the defaults defined in BatchRetrySettings.
	RetrySettings *BatchRetrySettingsResponse `pulumi:"retrySettings"`
}

// Defaults sets the appropriate defaults for BatchDeploymentResponse
func (val *BatchDeploymentResponse) Defaults() *BatchDeploymentResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ErrorThreshold == nil {
		errorThreshold_ := -1
		tmp.ErrorThreshold = &errorThreshold_
	}
	if tmp.LoggingLevel == nil {
		loggingLevel_ := "Info"
		tmp.LoggingLevel = &loggingLevel_
	}
	if tmp.MaxConcurrencyPerInstance == nil {
		maxConcurrencyPerInstance_ := 1
		tmp.MaxConcurrencyPerInstance = &maxConcurrencyPerInstance_
	}
	if tmp.MiniBatchSize == nil {
		miniBatchSize_ := 10.0
		tmp.MiniBatchSize = &miniBatchSize_
	}
	if tmp.OutputAction == nil {
		outputAction_ := "AppendRow"
		tmp.OutputAction = &outputAction_
	}
	if tmp.OutputFileName == nil {
		outputFileName_ := "predictions.csv"
		tmp.OutputFileName = &outputFileName_
	}
	tmp.Resources = tmp.Resources.Defaults()

	tmp.RetrySettings = tmp.RetrySettings.Defaults()

	return &tmp
}

// Batch inference settings per deployment.
type BatchDeploymentResponseOutput struct{ *pulumi.OutputState }

func (BatchDeploymentResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchDeploymentResponse)(nil)).Elem()
}

func (o BatchDeploymentResponseOutput) ToBatchDeploymentResponseOutput() BatchDeploymentResponseOutput {
	return o
}

func (o BatchDeploymentResponseOutput) ToBatchDeploymentResponseOutputWithContext(ctx context.Context) BatchDeploymentResponseOutput {
	return o
}

// Code configuration for the endpoint deployment.
func (o BatchDeploymentResponseOutput) CodeConfiguration() CodeConfigurationResponsePtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *CodeConfigurationResponse { return v.CodeConfiguration }).(CodeConfigurationResponsePtrOutput)
}

// Compute target for batch inference operation.
func (o BatchDeploymentResponseOutput) Compute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.Compute }).(pulumi.StringPtrOutput)
}

// Properties relevant to different deployment types.
func (o BatchDeploymentResponseOutput) DeploymentConfiguration() BatchPipelineComponentDeploymentConfigurationResponsePtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *BatchPipelineComponentDeploymentConfigurationResponse {
		return v.DeploymentConfiguration
	}).(BatchPipelineComponentDeploymentConfigurationResponsePtrOutput)
}

// Description of the endpoint deployment.
func (o BatchDeploymentResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// ARM resource ID of the environment specification for the endpoint deployment.
func (o BatchDeploymentResponseOutput) EnvironmentId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.EnvironmentId }).(pulumi.StringPtrOutput)
}

// Environment variables configuration for the deployment.
func (o BatchDeploymentResponseOutput) EnvironmentVariables() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) map[string]string { return v.EnvironmentVariables }).(pulumi.StringMapOutput)
}

// Error threshold, if the error count for the entire input goes above this value,
// the batch inference will be aborted. Range is [-1, int.MaxValue].
// For FileDataset, this value is the count of file failures.
// For TabularDataset, this value is the count of record failures.
// If set to -1 (the lower bound), all failures during batch inference will be ignored.
func (o BatchDeploymentResponseOutput) ErrorThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *int { return v.ErrorThreshold }).(pulumi.IntPtrOutput)
}

// Logging level for batch inference operation.
func (o BatchDeploymentResponseOutput) LoggingLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.LoggingLevel }).(pulumi.StringPtrOutput)
}

// Indicates maximum number of parallelism per instance.
func (o BatchDeploymentResponseOutput) MaxConcurrencyPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *int { return v.MaxConcurrencyPerInstance }).(pulumi.IntPtrOutput)
}

// Size of the mini-batch passed to each batch invocation.
// For FileDataset, this is the number of files per mini-batch.
// For TabularDataset, this is the size of the records in bytes, per mini-batch.
func (o BatchDeploymentResponseOutput) MiniBatchSize() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *float64 { return v.MiniBatchSize }).(pulumi.Float64PtrOutput)
}

// Reference to the model asset for the endpoint deployment.
func (o BatchDeploymentResponseOutput) Model() pulumi.AnyOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) interface{} { return v.Model }).(pulumi.AnyOutput)
}

// Indicates how the output will be organized.
func (o BatchDeploymentResponseOutput) OutputAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.OutputAction }).(pulumi.StringPtrOutput)
}

// Customized output file name for append_row output action.
func (o BatchDeploymentResponseOutput) OutputFileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *string { return v.OutputFileName }).(pulumi.StringPtrOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o BatchDeploymentResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the endpoint deployment.
func (o BatchDeploymentResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Indicates compute configuration for the job.
// If not provided, will default to the defaults defined in ResourceConfiguration.
func (o BatchDeploymentResponseOutput) Resources() DeploymentResourceConfigurationResponsePtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *DeploymentResourceConfigurationResponse { return v.Resources }).(DeploymentResourceConfigurationResponsePtrOutput)
}

// Retry Settings for the batch inference operation.
// If not provided, will default to the defaults defined in BatchRetrySettings.
func (o BatchDeploymentResponseOutput) RetrySettings() BatchRetrySettingsResponsePtrOutput {
	return o.ApplyT(func(v BatchDeploymentResponse) *BatchRetrySettingsResponse { return v.RetrySettings }).(BatchRetrySettingsResponsePtrOutput)
}

// Batch endpoint configuration.
type BatchEndpointType struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode string `pulumi:"authMode"`
	// Default values for Batch Endpoint.
	Defaults *BatchEndpointDefaults `pulumi:"defaults"`
	// Description of the inference endpoint.
	Description *string `pulumi:"description"`
	// EndpointAuthKeys to set initially on an Endpoint.
	// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
	Keys *EndpointAuthKeys `pulumi:"keys"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
}

// BatchEndpointTypeInput is an input type that accepts BatchEndpointTypeArgs and BatchEndpointTypeOutput values.
// You can construct a concrete instance of `BatchEndpointTypeInput` via:
//
//	BatchEndpointTypeArgs{...}
type BatchEndpointTypeInput interface {
	pulumi.Input

	ToBatchEndpointTypeOutput() BatchEndpointTypeOutput
	ToBatchEndpointTypeOutputWithContext(context.Context) BatchEndpointTypeOutput
}

// Batch endpoint configuration.
type BatchEndpointTypeArgs struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode pulumi.StringInput `pulumi:"authMode"`
	// Default values for Batch Endpoint.
	Defaults BatchEndpointDefaultsPtrInput `pulumi:"defaults"`
	// Description of the inference endpoint.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// EndpointAuthKeys to set initially on an Endpoint.
	// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
	Keys EndpointAuthKeysPtrInput `pulumi:"keys"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties pulumi.StringMapInput `pulumi:"properties"`
}

func (BatchEndpointTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointType)(nil)).Elem()
}

func (i BatchEndpointTypeArgs) ToBatchEndpointTypeOutput() BatchEndpointTypeOutput {
	return i.ToBatchEndpointTypeOutputWithContext(context.Background())
}

func (i BatchEndpointTypeArgs) ToBatchEndpointTypeOutputWithContext(ctx context.Context) BatchEndpointTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchEndpointTypeOutput)
}

// Batch endpoint configuration.
type BatchEndpointTypeOutput struct{ *pulumi.OutputState }

func (BatchEndpointTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointType)(nil)).Elem()
}

func (o BatchEndpointTypeOutput) ToBatchEndpointTypeOutput() BatchEndpointTypeOutput {
	return o
}

func (o BatchEndpointTypeOutput) ToBatchEndpointTypeOutputWithContext(ctx context.Context) BatchEndpointTypeOutput {
	return o
}

// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
func (o BatchEndpointTypeOutput) AuthMode() pulumi.StringOutput {
	return o.ApplyT(func(v BatchEndpointType) string { return v.AuthMode }).(pulumi.StringOutput)
}

// Default values for Batch Endpoint.
func (o BatchEndpointTypeOutput) Defaults() BatchEndpointDefaultsPtrOutput {
	return o.ApplyT(func(v BatchEndpointType) *BatchEndpointDefaults { return v.Defaults }).(BatchEndpointDefaultsPtrOutput)
}

// Description of the inference endpoint.
func (o BatchEndpointTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchEndpointType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// EndpointAuthKeys to set initially on an Endpoint.
// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
func (o BatchEndpointTypeOutput) Keys() EndpointAuthKeysPtrOutput {
	return o.ApplyT(func(v BatchEndpointType) *EndpointAuthKeys { return v.Keys }).(EndpointAuthKeysPtrOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o BatchEndpointTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchEndpointType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Batch endpoint default values
type BatchEndpointDefaults struct {
	// Name of the deployment that will be default for the endpoint.
	// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
	DeploymentName *string `pulumi:"deploymentName"`
}

// BatchEndpointDefaultsInput is an input type that accepts BatchEndpointDefaultsArgs and BatchEndpointDefaultsOutput values.
// You can construct a concrete instance of `BatchEndpointDefaultsInput` via:
//
//	BatchEndpointDefaultsArgs{...}
type BatchEndpointDefaultsInput interface {
	pulumi.Input

	ToBatchEndpointDefaultsOutput() BatchEndpointDefaultsOutput
	ToBatchEndpointDefaultsOutputWithContext(context.Context) BatchEndpointDefaultsOutput
}

// Batch endpoint default values
type BatchEndpointDefaultsArgs struct {
	// Name of the deployment that will be default for the endpoint.
	// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
	DeploymentName pulumi.StringPtrInput `pulumi:"deploymentName"`
}

func (BatchEndpointDefaultsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointDefaults)(nil)).Elem()
}

func (i BatchEndpointDefaultsArgs) ToBatchEndpointDefaultsOutput() BatchEndpointDefaultsOutput {
	return i.ToBatchEndpointDefaultsOutputWithContext(context.Background())
}

func (i BatchEndpointDefaultsArgs) ToBatchEndpointDefaultsOutputWithContext(ctx context.Context) BatchEndpointDefaultsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchEndpointDefaultsOutput)
}

func (i BatchEndpointDefaultsArgs) ToBatchEndpointDefaultsPtrOutput() BatchEndpointDefaultsPtrOutput {
	return i.ToBatchEndpointDefaultsPtrOutputWithContext(context.Background())
}

func (i BatchEndpointDefaultsArgs) ToBatchEndpointDefaultsPtrOutputWithContext(ctx context.Context) BatchEndpointDefaultsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchEndpointDefaultsOutput).ToBatchEndpointDefaultsPtrOutputWithContext(ctx)
}

// BatchEndpointDefaultsPtrInput is an input type that accepts BatchEndpointDefaultsArgs, BatchEndpointDefaultsPtr and BatchEndpointDefaultsPtrOutput values.
// You can construct a concrete instance of `BatchEndpointDefaultsPtrInput` via:
//
//	        BatchEndpointDefaultsArgs{...}
//
//	or:
//
//	        nil
type BatchEndpointDefaultsPtrInput interface {
	pulumi.Input

	ToBatchEndpointDefaultsPtrOutput() BatchEndpointDefaultsPtrOutput
	ToBatchEndpointDefaultsPtrOutputWithContext(context.Context) BatchEndpointDefaultsPtrOutput
}

type batchEndpointDefaultsPtrType BatchEndpointDefaultsArgs

func BatchEndpointDefaultsPtr(v *BatchEndpointDefaultsArgs) BatchEndpointDefaultsPtrInput {
	return (*batchEndpointDefaultsPtrType)(v)
}

func (*batchEndpointDefaultsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchEndpointDefaults)(nil)).Elem()
}

func (i *batchEndpointDefaultsPtrType) ToBatchEndpointDefaultsPtrOutput() BatchEndpointDefaultsPtrOutput {
	return i.ToBatchEndpointDefaultsPtrOutputWithContext(context.Background())
}

func (i *batchEndpointDefaultsPtrType) ToBatchEndpointDefaultsPtrOutputWithContext(ctx context.Context) BatchEndpointDefaultsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchEndpointDefaultsPtrOutput)
}

// Batch endpoint default values
type BatchEndpointDefaultsOutput struct{ *pulumi.OutputState }

func (BatchEndpointDefaultsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointDefaults)(nil)).Elem()
}

func (o BatchEndpointDefaultsOutput) ToBatchEndpointDefaultsOutput() BatchEndpointDefaultsOutput {
	return o
}

func (o BatchEndpointDefaultsOutput) ToBatchEndpointDefaultsOutputWithContext(ctx context.Context) BatchEndpointDefaultsOutput {
	return o
}

func (o BatchEndpointDefaultsOutput) ToBatchEndpointDefaultsPtrOutput() BatchEndpointDefaultsPtrOutput {
	return o.ToBatchEndpointDefaultsPtrOutputWithContext(context.Background())
}

func (o BatchEndpointDefaultsOutput) ToBatchEndpointDefaultsPtrOutputWithContext(ctx context.Context) BatchEndpointDefaultsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BatchEndpointDefaults) *BatchEndpointDefaults {
		return &v
	}).(BatchEndpointDefaultsPtrOutput)
}

// Name of the deployment that will be default for the endpoint.
// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
func (o BatchEndpointDefaultsOutput) DeploymentName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchEndpointDefaults) *string { return v.DeploymentName }).(pulumi.StringPtrOutput)
}

type BatchEndpointDefaultsPtrOutput struct{ *pulumi.OutputState }

func (BatchEndpointDefaultsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchEndpointDefaults)(nil)).Elem()
}

func (o BatchEndpointDefaultsPtrOutput) ToBatchEndpointDefaultsPtrOutput() BatchEndpointDefaultsPtrOutput {
	return o
}

func (o BatchEndpointDefaultsPtrOutput) ToBatchEndpointDefaultsPtrOutputWithContext(ctx context.Context) BatchEndpointDefaultsPtrOutput {
	return o
}

func (o BatchEndpointDefaultsPtrOutput) Elem() BatchEndpointDefaultsOutput {
	return o.ApplyT(func(v *BatchEndpointDefaults) BatchEndpointDefaults {
		if v != nil {
			return *v
		}
		var ret BatchEndpointDefaults
		return ret
	}).(BatchEndpointDefaultsOutput)
}

// Name of the deployment that will be default for the endpoint.
// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
func (o BatchEndpointDefaultsPtrOutput) DeploymentName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchEndpointDefaults) *string {
		if v == nil {
			return nil
		}
		return v.DeploymentName
	}).(pulumi.StringPtrOutput)
}

// Batch endpoint default values
type BatchEndpointDefaultsResponse struct {
	// Name of the deployment that will be default for the endpoint.
	// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
	DeploymentName *string `pulumi:"deploymentName"`
}

// Batch endpoint default values
type BatchEndpointDefaultsResponseOutput struct{ *pulumi.OutputState }

func (BatchEndpointDefaultsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointDefaultsResponse)(nil)).Elem()
}

func (o BatchEndpointDefaultsResponseOutput) ToBatchEndpointDefaultsResponseOutput() BatchEndpointDefaultsResponseOutput {
	return o
}

func (o BatchEndpointDefaultsResponseOutput) ToBatchEndpointDefaultsResponseOutputWithContext(ctx context.Context) BatchEndpointDefaultsResponseOutput {
	return o
}

// Name of the deployment that will be default for the endpoint.
// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
func (o BatchEndpointDefaultsResponseOutput) DeploymentName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchEndpointDefaultsResponse) *string { return v.DeploymentName }).(pulumi.StringPtrOutput)
}

type BatchEndpointDefaultsResponsePtrOutput struct{ *pulumi.OutputState }

func (BatchEndpointDefaultsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchEndpointDefaultsResponse)(nil)).Elem()
}

func (o BatchEndpointDefaultsResponsePtrOutput) ToBatchEndpointDefaultsResponsePtrOutput() BatchEndpointDefaultsResponsePtrOutput {
	return o
}

func (o BatchEndpointDefaultsResponsePtrOutput) ToBatchEndpointDefaultsResponsePtrOutputWithContext(ctx context.Context) BatchEndpointDefaultsResponsePtrOutput {
	return o
}

func (o BatchEndpointDefaultsResponsePtrOutput) Elem() BatchEndpointDefaultsResponseOutput {
	return o.ApplyT(func(v *BatchEndpointDefaultsResponse) BatchEndpointDefaultsResponse {
		if v != nil {
			return *v
		}
		var ret BatchEndpointDefaultsResponse
		return ret
	}).(BatchEndpointDefaultsResponseOutput)
}

// Name of the deployment that will be default for the endpoint.
// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
func (o BatchEndpointDefaultsResponsePtrOutput) DeploymentName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchEndpointDefaultsResponse) *string {
		if v == nil {
			return nil
		}
		return v.DeploymentName
	}).(pulumi.StringPtrOutput)
}

// Batch endpoint configuration.
type BatchEndpointResponse struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode string `pulumi:"authMode"`
	// Default values for Batch Endpoint.
	Defaults *BatchEndpointDefaultsResponse `pulumi:"defaults"`
	// Description of the inference endpoint.
	Description *string `pulumi:"description"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the endpoint.
	ProvisioningState string `pulumi:"provisioningState"`
	// Endpoint URI.
	ScoringUri string `pulumi:"scoringUri"`
	// Endpoint Swagger URI.
	SwaggerUri string `pulumi:"swaggerUri"`
}

// Batch endpoint configuration.
type BatchEndpointResponseOutput struct{ *pulumi.OutputState }

func (BatchEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchEndpointResponse)(nil)).Elem()
}

func (o BatchEndpointResponseOutput) ToBatchEndpointResponseOutput() BatchEndpointResponseOutput {
	return o
}

func (o BatchEndpointResponseOutput) ToBatchEndpointResponseOutputWithContext(ctx context.Context) BatchEndpointResponseOutput {
	return o
}

// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
func (o BatchEndpointResponseOutput) AuthMode() pulumi.StringOutput {
	return o.ApplyT(func(v BatchEndpointResponse) string { return v.AuthMode }).(pulumi.StringOutput)
}

// Default values for Batch Endpoint.
func (o BatchEndpointResponseOutput) Defaults() BatchEndpointDefaultsResponsePtrOutput {
	return o.ApplyT(func(v BatchEndpointResponse) *BatchEndpointDefaultsResponse { return v.Defaults }).(BatchEndpointDefaultsResponsePtrOutput)
}

// Description of the inference endpoint.
func (o BatchEndpointResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchEndpointResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o BatchEndpointResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchEndpointResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the endpoint.
func (o BatchEndpointResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v BatchEndpointResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Endpoint URI.
func (o BatchEndpointResponseOutput) ScoringUri() pulumi.StringOutput {
	return o.ApplyT(func(v BatchEndpointResponse) string { return v.ScoringUri }).(pulumi.StringOutput)
}

// Endpoint Swagger URI.
func (o BatchEndpointResponseOutput) SwaggerUri() pulumi.StringOutput {
	return o.ApplyT(func(v BatchEndpointResponse) string { return v.SwaggerUri }).(pulumi.StringOutput)
}

// Properties for a Batch Pipeline Component Deployment.
type BatchPipelineComponentDeploymentConfiguration struct {
	// The ARM id of the component to be run.
	ComponentId *IdAssetReference `pulumi:"componentId"`
	// The enumerated property types for batch deployments.
	// Expected value is 'PipelineComponent'.
	DeploymentConfigurationType string `pulumi:"deploymentConfigurationType"`
	// The description which will be applied to the job.
	Description *string `pulumi:"description"`
	// Run-time settings for the pipeline job.
	Settings map[string]string `pulumi:"settings"`
	// The tags which will be applied to the job.
	Tags map[string]string `pulumi:"tags"`
}

// BatchPipelineComponentDeploymentConfigurationInput is an input type that accepts BatchPipelineComponentDeploymentConfigurationArgs and BatchPipelineComponentDeploymentConfigurationOutput values.
// You can construct a concrete instance of `BatchPipelineComponentDeploymentConfigurationInput` via:
//
//	BatchPipelineComponentDeploymentConfigurationArgs{...}
type BatchPipelineComponentDeploymentConfigurationInput interface {
	pulumi.Input

	ToBatchPipelineComponentDeploymentConfigurationOutput() BatchPipelineComponentDeploymentConfigurationOutput
	ToBatchPipelineComponentDeploymentConfigurationOutputWithContext(context.Context) BatchPipelineComponentDeploymentConfigurationOutput
}

// Properties for a Batch Pipeline Component Deployment.
type BatchPipelineComponentDeploymentConfigurationArgs struct {
	// The ARM id of the component to be run.
	ComponentId IdAssetReferencePtrInput `pulumi:"componentId"`
	// The enumerated property types for batch deployments.
	// Expected value is 'PipelineComponent'.
	DeploymentConfigurationType pulumi.StringInput `pulumi:"deploymentConfigurationType"`
	// The description which will be applied to the job.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Run-time settings for the pipeline job.
	Settings pulumi.StringMapInput `pulumi:"settings"`
	// The tags which will be applied to the job.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

func (BatchPipelineComponentDeploymentConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchPipelineComponentDeploymentConfiguration)(nil)).Elem()
}

func (i BatchPipelineComponentDeploymentConfigurationArgs) ToBatchPipelineComponentDeploymentConfigurationOutput() BatchPipelineComponentDeploymentConfigurationOutput {
	return i.ToBatchPipelineComponentDeploymentConfigurationOutputWithContext(context.Background())
}

func (i BatchPipelineComponentDeploymentConfigurationArgs) ToBatchPipelineComponentDeploymentConfigurationOutputWithContext(ctx context.Context) BatchPipelineComponentDeploymentConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchPipelineComponentDeploymentConfigurationOutput)
}

func (i BatchPipelineComponentDeploymentConfigurationArgs) ToBatchPipelineComponentDeploymentConfigurationPtrOutput() BatchPipelineComponentDeploymentConfigurationPtrOutput {
	return i.ToBatchPipelineComponentDeploymentConfigurationPtrOutputWithContext(context.Background())
}

func (i BatchPipelineComponentDeploymentConfigurationArgs) ToBatchPipelineComponentDeploymentConfigurationPtrOutputWithContext(ctx context.Context) BatchPipelineComponentDeploymentConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchPipelineComponentDeploymentConfigurationOutput).ToBatchPipelineComponentDeploymentConfigurationPtrOutputWithContext(ctx)
}

// BatchPipelineComponentDeploymentConfigurationPtrInput is an input type that accepts BatchPipelineComponentDeploymentConfigurationArgs, BatchPipelineComponentDeploymentConfigurationPtr and BatchPipelineComponentDeploymentConfigurationPtrOutput values.
// You can construct a concrete instance of `BatchPipelineComponentDeploymentConfigurationPtrInput` via:
//
//	        BatchPipelineComponentDeploymentConfigurationArgs{...}
//
//	or:
//
//	        nil
type BatchPipelineComponentDeploymentConfigurationPtrInput interface {
	pulumi.Input

	ToBatchPipelineComponentDeploymentConfigurationPtrOutput() BatchPipelineComponentDeploymentConfigurationPtrOutput
	ToBatchPipelineComponentDeploymentConfigurationPtrOutputWithContext(context.Context) BatchPipelineComponentDeploymentConfigurationPtrOutput
}

type batchPipelineComponentDeploymentConfigurationPtrType BatchPipelineComponentDeploymentConfigurationArgs

func BatchPipelineComponentDeploymentConfigurationPtr(v *BatchPipelineComponentDeploymentConfigurationArgs) BatchPipelineComponentDeploymentConfigurationPtrInput {
	return (*batchPipelineComponentDeploymentConfigurationPtrType)(v)
}

func (*batchPipelineComponentDeploymentConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchPipelineComponentDeploymentConfiguration)(nil)).Elem()
}

func (i *batchPipelineComponentDeploymentConfigurationPtrType) ToBatchPipelineComponentDeploymentConfigurationPtrOutput() BatchPipelineComponentDeploymentConfigurationPtrOutput {
	return i.ToBatchPipelineComponentDeploymentConfigurationPtrOutputWithContext(context.Background())
}

func (i *batchPipelineComponentDeploymentConfigurationPtrType) ToBatchPipelineComponentDeploymentConfigurationPtrOutputWithContext(ctx context.Context) BatchPipelineComponentDeploymentConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchPipelineComponentDeploymentConfigurationPtrOutput)
}

// Properties for a Batch Pipeline Component Deployment.
type BatchPipelineComponentDeploymentConfigurationOutput struct{ *pulumi.OutputState }

func (BatchPipelineComponentDeploymentConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchPipelineComponentDeploymentConfiguration)(nil)).Elem()
}

func (o BatchPipelineComponentDeploymentConfigurationOutput) ToBatchPipelineComponentDeploymentConfigurationOutput() BatchPipelineComponentDeploymentConfigurationOutput {
	return o
}

func (o BatchPipelineComponentDeploymentConfigurationOutput) ToBatchPipelineComponentDeploymentConfigurationOutputWithContext(ctx context.Context) BatchPipelineComponentDeploymentConfigurationOutput {
	return o
}

func (o BatchPipelineComponentDeploymentConfigurationOutput) ToBatchPipelineComponentDeploymentConfigurationPtrOutput() BatchPipelineComponentDeploymentConfigurationPtrOutput {
	return o.ToBatchPipelineComponentDeploymentConfigurationPtrOutputWithContext(context.Background())
}

func (o BatchPipelineComponentDeploymentConfigurationOutput) ToBatchPipelineComponentDeploymentConfigurationPtrOutputWithContext(ctx context.Context) BatchPipelineComponentDeploymentConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BatchPipelineComponentDeploymentConfiguration) *BatchPipelineComponentDeploymentConfiguration {
		return &v
	}).(BatchPipelineComponentDeploymentConfigurationPtrOutput)
}

// The ARM id of the component to be run.
func (o BatchPipelineComponentDeploymentConfigurationOutput) ComponentId() IdAssetReferencePtrOutput {
	return o.ApplyT(func(v BatchPipelineComponentDeploymentConfiguration) *IdAssetReference { return v.ComponentId }).(IdAssetReferencePtrOutput)
}

// The enumerated property types for batch deployments.
// Expected value is 'PipelineComponent'.
func (o BatchPipelineComponentDeploymentConfigurationOutput) DeploymentConfigurationType() pulumi.StringOutput {
	return o.ApplyT(func(v BatchPipelineComponentDeploymentConfiguration) string { return v.DeploymentConfigurationType }).(pulumi.StringOutput)
}

// The description which will be applied to the job.
func (o BatchPipelineComponentDeploymentConfigurationOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchPipelineComponentDeploymentConfiguration) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Run-time settings for the pipeline job.
func (o BatchPipelineComponentDeploymentConfigurationOutput) Settings() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchPipelineComponentDeploymentConfiguration) map[string]string { return v.Settings }).(pulumi.StringMapOutput)
}

// The tags which will be applied to the job.
func (o BatchPipelineComponentDeploymentConfigurationOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchPipelineComponentDeploymentConfiguration) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

type BatchPipelineComponentDeploymentConfigurationPtrOutput struct{ *pulumi.OutputState }

func (BatchPipelineComponentDeploymentConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchPipelineComponentDeploymentConfiguration)(nil)).Elem()
}

func (o BatchPipelineComponentDeploymentConfigurationPtrOutput) ToBatchPipelineComponentDeploymentConfigurationPtrOutput() BatchPipelineComponentDeploymentConfigurationPtrOutput {
	return o
}

func (o BatchPipelineComponentDeploymentConfigurationPtrOutput) ToBatchPipelineComponentDeploymentConfigurationPtrOutputWithContext(ctx context.Context) BatchPipelineComponentDeploymentConfigurationPtrOutput {
	return o
}

func (o BatchPipelineComponentDeploymentConfigurationPtrOutput) Elem() BatchPipelineComponentDeploymentConfigurationOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfiguration) BatchPipelineComponentDeploymentConfiguration {
		if v != nil {
			return *v
		}
		var ret BatchPipelineComponentDeploymentConfiguration
		return ret
	}).(BatchPipelineComponentDeploymentConfigurationOutput)
}

// The ARM id of the component to be run.
func (o BatchPipelineComponentDeploymentConfigurationPtrOutput) ComponentId() IdAssetReferencePtrOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfiguration) *IdAssetReference {
		if v == nil {
			return nil
		}
		return v.ComponentId
	}).(IdAssetReferencePtrOutput)
}

// The enumerated property types for batch deployments.
// Expected value is 'PipelineComponent'.
func (o BatchPipelineComponentDeploymentConfigurationPtrOutput) DeploymentConfigurationType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.DeploymentConfigurationType
	}).(pulumi.StringPtrOutput)
}

// The description which will be applied to the job.
func (o BatchPipelineComponentDeploymentConfigurationPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Run-time settings for the pipeline job.
func (o BatchPipelineComponentDeploymentConfigurationPtrOutput) Settings() pulumi.StringMapOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfiguration) map[string]string {
		if v == nil {
			return nil
		}
		return v.Settings
	}).(pulumi.StringMapOutput)
}

// The tags which will be applied to the job.
func (o BatchPipelineComponentDeploymentConfigurationPtrOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfiguration) map[string]string {
		if v == nil {
			return nil
		}
		return v.Tags
	}).(pulumi.StringMapOutput)
}

// Properties for a Batch Pipeline Component Deployment.
type BatchPipelineComponentDeploymentConfigurationResponse struct {
	// The ARM id of the component to be run.
	ComponentId *IdAssetReferenceResponse `pulumi:"componentId"`
	// The enumerated property types for batch deployments.
	// Expected value is 'PipelineComponent'.
	DeploymentConfigurationType string `pulumi:"deploymentConfigurationType"`
	// The description which will be applied to the job.
	Description *string `pulumi:"description"`
	// Run-time settings for the pipeline job.
	Settings map[string]string `pulumi:"settings"`
	// The tags which will be applied to the job.
	Tags map[string]string `pulumi:"tags"`
}

// Properties for a Batch Pipeline Component Deployment.
type BatchPipelineComponentDeploymentConfigurationResponseOutput struct{ *pulumi.OutputState }

func (BatchPipelineComponentDeploymentConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchPipelineComponentDeploymentConfigurationResponse)(nil)).Elem()
}

func (o BatchPipelineComponentDeploymentConfigurationResponseOutput) ToBatchPipelineComponentDeploymentConfigurationResponseOutput() BatchPipelineComponentDeploymentConfigurationResponseOutput {
	return o
}

func (o BatchPipelineComponentDeploymentConfigurationResponseOutput) ToBatchPipelineComponentDeploymentConfigurationResponseOutputWithContext(ctx context.Context) BatchPipelineComponentDeploymentConfigurationResponseOutput {
	return o
}

// The ARM id of the component to be run.
func (o BatchPipelineComponentDeploymentConfigurationResponseOutput) ComponentId() IdAssetReferenceResponsePtrOutput {
	return o.ApplyT(func(v BatchPipelineComponentDeploymentConfigurationResponse) *IdAssetReferenceResponse {
		return v.ComponentId
	}).(IdAssetReferenceResponsePtrOutput)
}

// The enumerated property types for batch deployments.
// Expected value is 'PipelineComponent'.
func (o BatchPipelineComponentDeploymentConfigurationResponseOutput) DeploymentConfigurationType() pulumi.StringOutput {
	return o.ApplyT(func(v BatchPipelineComponentDeploymentConfigurationResponse) string {
		return v.DeploymentConfigurationType
	}).(pulumi.StringOutput)
}

// The description which will be applied to the job.
func (o BatchPipelineComponentDeploymentConfigurationResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchPipelineComponentDeploymentConfigurationResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Run-time settings for the pipeline job.
func (o BatchPipelineComponentDeploymentConfigurationResponseOutput) Settings() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchPipelineComponentDeploymentConfigurationResponse) map[string]string { return v.Settings }).(pulumi.StringMapOutput)
}

// The tags which will be applied to the job.
func (o BatchPipelineComponentDeploymentConfigurationResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v BatchPipelineComponentDeploymentConfigurationResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

type BatchPipelineComponentDeploymentConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (BatchPipelineComponentDeploymentConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchPipelineComponentDeploymentConfigurationResponse)(nil)).Elem()
}

func (o BatchPipelineComponentDeploymentConfigurationResponsePtrOutput) ToBatchPipelineComponentDeploymentConfigurationResponsePtrOutput() BatchPipelineComponentDeploymentConfigurationResponsePtrOutput {
	return o
}

func (o BatchPipelineComponentDeploymentConfigurationResponsePtrOutput) ToBatchPipelineComponentDeploymentConfigurationResponsePtrOutputWithContext(ctx context.Context) BatchPipelineComponentDeploymentConfigurationResponsePtrOutput {
	return o
}

func (o BatchPipelineComponentDeploymentConfigurationResponsePtrOutput) Elem() BatchPipelineComponentDeploymentConfigurationResponseOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfigurationResponse) BatchPipelineComponentDeploymentConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret BatchPipelineComponentDeploymentConfigurationResponse
		return ret
	}).(BatchPipelineComponentDeploymentConfigurationResponseOutput)
}

// The ARM id of the component to be run.
func (o BatchPipelineComponentDeploymentConfigurationResponsePtrOutput) ComponentId() IdAssetReferenceResponsePtrOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfigurationResponse) *IdAssetReferenceResponse {
		if v == nil {
			return nil
		}
		return v.ComponentId
	}).(IdAssetReferenceResponsePtrOutput)
}

// The enumerated property types for batch deployments.
// Expected value is 'PipelineComponent'.
func (o BatchPipelineComponentDeploymentConfigurationResponsePtrOutput) DeploymentConfigurationType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.DeploymentConfigurationType
	}).(pulumi.StringPtrOutput)
}

// The description which will be applied to the job.
func (o BatchPipelineComponentDeploymentConfigurationResponsePtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Run-time settings for the pipeline job.
func (o BatchPipelineComponentDeploymentConfigurationResponsePtrOutput) Settings() pulumi.StringMapOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfigurationResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.Settings
	}).(pulumi.StringMapOutput)
}

// The tags which will be applied to the job.
func (o BatchPipelineComponentDeploymentConfigurationResponsePtrOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *BatchPipelineComponentDeploymentConfigurationResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.Tags
	}).(pulumi.StringMapOutput)
}

// Retry settings for a batch inference operation.
type BatchRetrySettings struct {
	// Maximum retry count for a mini-batch
	MaxRetries *int `pulumi:"maxRetries"`
	// Invocation timeout for a mini-batch, in ISO 8601 format.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for BatchRetrySettings
func (val *BatchRetrySettings) Defaults() *BatchRetrySettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MaxRetries == nil {
		maxRetries_ := 3
		tmp.MaxRetries = &maxRetries_
	}
	if tmp.Timeout == nil {
		timeout_ := "PT30S"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// BatchRetrySettingsInput is an input type that accepts BatchRetrySettingsArgs and BatchRetrySettingsOutput values.
// You can construct a concrete instance of `BatchRetrySettingsInput` via:
//
//	BatchRetrySettingsArgs{...}
type BatchRetrySettingsInput interface {
	pulumi.Input

	ToBatchRetrySettingsOutput() BatchRetrySettingsOutput
	ToBatchRetrySettingsOutputWithContext(context.Context) BatchRetrySettingsOutput
}

// Retry settings for a batch inference operation.
type BatchRetrySettingsArgs struct {
	// Maximum retry count for a mini-batch
	MaxRetries pulumi.IntPtrInput `pulumi:"maxRetries"`
	// Invocation timeout for a mini-batch, in ISO 8601 format.
	Timeout pulumi.StringPtrInput `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for BatchRetrySettingsArgs
func (val *BatchRetrySettingsArgs) Defaults() *BatchRetrySettingsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MaxRetries == nil {
		tmp.MaxRetries = pulumi.IntPtr(3)
	}
	if tmp.Timeout == nil {
		tmp.Timeout = pulumi.StringPtr("PT30S")
	}
	return &tmp
}
func (BatchRetrySettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchRetrySettings)(nil)).Elem()
}

func (i BatchRetrySettingsArgs) ToBatchRetrySettingsOutput() BatchRetrySettingsOutput {
	return i.ToBatchRetrySettingsOutputWithContext(context.Background())
}

func (i BatchRetrySettingsArgs) ToBatchRetrySettingsOutputWithContext(ctx context.Context) BatchRetrySettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchRetrySettingsOutput)
}

func (i BatchRetrySettingsArgs) ToBatchRetrySettingsPtrOutput() BatchRetrySettingsPtrOutput {
	return i.ToBatchRetrySettingsPtrOutputWithContext(context.Background())
}

func (i BatchRetrySettingsArgs) ToBatchRetrySettingsPtrOutputWithContext(ctx context.Context) BatchRetrySettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchRetrySettingsOutput).ToBatchRetrySettingsPtrOutputWithContext(ctx)
}

// BatchRetrySettingsPtrInput is an input type that accepts BatchRetrySettingsArgs, BatchRetrySettingsPtr and BatchRetrySettingsPtrOutput values.
// You can construct a concrete instance of `BatchRetrySettingsPtrInput` via:
//
//	        BatchRetrySettingsArgs{...}
//
//	or:
//
//	        nil
type BatchRetrySettingsPtrInput interface {
	pulumi.Input

	ToBatchRetrySettingsPtrOutput() BatchRetrySettingsPtrOutput
	ToBatchRetrySettingsPtrOutputWithContext(context.Context) BatchRetrySettingsPtrOutput
}

type batchRetrySettingsPtrType BatchRetrySettingsArgs

func BatchRetrySettingsPtr(v *BatchRetrySettingsArgs) BatchRetrySettingsPtrInput {
	return (*batchRetrySettingsPtrType)(v)
}

func (*batchRetrySettingsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchRetrySettings)(nil)).Elem()
}

func (i *batchRetrySettingsPtrType) ToBatchRetrySettingsPtrOutput() BatchRetrySettingsPtrOutput {
	return i.ToBatchRetrySettingsPtrOutputWithContext(context.Background())
}

func (i *batchRetrySettingsPtrType) ToBatchRetrySettingsPtrOutputWithContext(ctx context.Context) BatchRetrySettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BatchRetrySettingsPtrOutput)
}

// Retry settings for a batch inference operation.
type BatchRetrySettingsOutput struct{ *pulumi.OutputState }

func (BatchRetrySettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchRetrySettings)(nil)).Elem()
}

func (o BatchRetrySettingsOutput) ToBatchRetrySettingsOutput() BatchRetrySettingsOutput {
	return o
}

func (o BatchRetrySettingsOutput) ToBatchRetrySettingsOutputWithContext(ctx context.Context) BatchRetrySettingsOutput {
	return o
}

func (o BatchRetrySettingsOutput) ToBatchRetrySettingsPtrOutput() BatchRetrySettingsPtrOutput {
	return o.ToBatchRetrySettingsPtrOutputWithContext(context.Background())
}

func (o BatchRetrySettingsOutput) ToBatchRetrySettingsPtrOutputWithContext(ctx context.Context) BatchRetrySettingsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BatchRetrySettings) *BatchRetrySettings {
		return &v
	}).(BatchRetrySettingsPtrOutput)
}

// Maximum retry count for a mini-batch
func (o BatchRetrySettingsOutput) MaxRetries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchRetrySettings) *int { return v.MaxRetries }).(pulumi.IntPtrOutput)
}

// Invocation timeout for a mini-batch, in ISO 8601 format.
func (o BatchRetrySettingsOutput) Timeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchRetrySettings) *string { return v.Timeout }).(pulumi.StringPtrOutput)
}

type BatchRetrySettingsPtrOutput struct{ *pulumi.OutputState }

func (BatchRetrySettingsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchRetrySettings)(nil)).Elem()
}

func (o BatchRetrySettingsPtrOutput) ToBatchRetrySettingsPtrOutput() BatchRetrySettingsPtrOutput {
	return o
}

func (o BatchRetrySettingsPtrOutput) ToBatchRetrySettingsPtrOutputWithContext(ctx context.Context) BatchRetrySettingsPtrOutput {
	return o
}

func (o BatchRetrySettingsPtrOutput) Elem() BatchRetrySettingsOutput {
	return o.ApplyT(func(v *BatchRetrySettings) BatchRetrySettings {
		if v != nil {
			return *v
		}
		var ret BatchRetrySettings
		return ret
	}).(BatchRetrySettingsOutput)
}

// Maximum retry count for a mini-batch
func (o BatchRetrySettingsPtrOutput) MaxRetries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BatchRetrySettings) *int {
		if v == nil {
			return nil
		}
		return v.MaxRetries
	}).(pulumi.IntPtrOutput)
}

// Invocation timeout for a mini-batch, in ISO 8601 format.
func (o BatchRetrySettingsPtrOutput) Timeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchRetrySettings) *string {
		if v == nil {
			return nil
		}
		return v.Timeout
	}).(pulumi.StringPtrOutput)
}

// Retry settings for a batch inference operation.
type BatchRetrySettingsResponse struct {
	// Maximum retry count for a mini-batch
	MaxRetries *int `pulumi:"maxRetries"`
	// Invocation timeout for a mini-batch, in ISO 8601 format.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for BatchRetrySettingsResponse
func (val *BatchRetrySettingsResponse) Defaults() *BatchRetrySettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MaxRetries == nil {
		maxRetries_ := 3
		tmp.MaxRetries = &maxRetries_
	}
	if tmp.Timeout == nil {
		timeout_ := "PT30S"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// Retry settings for a batch inference operation.
type BatchRetrySettingsResponseOutput struct{ *pulumi.OutputState }

func (BatchRetrySettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BatchRetrySettingsResponse)(nil)).Elem()
}

func (o BatchRetrySettingsResponseOutput) ToBatchRetrySettingsResponseOutput() BatchRetrySettingsResponseOutput {
	return o
}

func (o BatchRetrySettingsResponseOutput) ToBatchRetrySettingsResponseOutputWithContext(ctx context.Context) BatchRetrySettingsResponseOutput {
	return o
}

// Maximum retry count for a mini-batch
func (o BatchRetrySettingsResponseOutput) MaxRetries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BatchRetrySettingsResponse) *int { return v.MaxRetries }).(pulumi.IntPtrOutput)
}

// Invocation timeout for a mini-batch, in ISO 8601 format.
func (o BatchRetrySettingsResponseOutput) Timeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BatchRetrySettingsResponse) *string { return v.Timeout }).(pulumi.StringPtrOutput)
}

type BatchRetrySettingsResponsePtrOutput struct{ *pulumi.OutputState }

func (BatchRetrySettingsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BatchRetrySettingsResponse)(nil)).Elem()
}

func (o BatchRetrySettingsResponsePtrOutput) ToBatchRetrySettingsResponsePtrOutput() BatchRetrySettingsResponsePtrOutput {
	return o
}

func (o BatchRetrySettingsResponsePtrOutput) ToBatchRetrySettingsResponsePtrOutputWithContext(ctx context.Context) BatchRetrySettingsResponsePtrOutput {
	return o
}

func (o BatchRetrySettingsResponsePtrOutput) Elem() BatchRetrySettingsResponseOutput {
	return o.ApplyT(func(v *BatchRetrySettingsResponse) BatchRetrySettingsResponse {
		if v != nil {
			return *v
		}
		var ret BatchRetrySettingsResponse
		return ret
	}).(BatchRetrySettingsResponseOutput)
}

// Maximum retry count for a mini-batch
func (o BatchRetrySettingsResponsePtrOutput) MaxRetries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *BatchRetrySettingsResponse) *int {
		if v == nil {
			return nil
		}
		return v.MaxRetries
	}).(pulumi.IntPtrOutput)
}

// Invocation timeout for a mini-batch, in ISO 8601 format.
func (o BatchRetrySettingsResponsePtrOutput) Timeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BatchRetrySettingsResponse) *string {
		if v == nil {
			return nil
		}
		return v.Timeout
	}).(pulumi.StringPtrOutput)
}

// Defines a Sampling Algorithm that generates values based on previous values
type BayesianSamplingAlgorithm struct {
	// Expected value is 'Bayesian'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
}

// Defines a Sampling Algorithm that generates values based on previous values
type BayesianSamplingAlgorithmResponse struct {
	// Expected value is 'Bayesian'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
}

type BindOptions struct {
	// Indicate whether to create host path.
	CreateHostPath *bool `pulumi:"createHostPath"`
	// Type of Bind Option
	Propagation *string `pulumi:"propagation"`
	// Mention the selinux options.
	Selinux *string `pulumi:"selinux"`
}

type BindOptionsResponse struct {
	// Indicate whether to create host path.
	CreateHostPath *bool `pulumi:"createHostPath"`
	// Type of Bind Option
	Propagation *string `pulumi:"propagation"`
	// Mention the selinux options.
	Selinux *string `pulumi:"selinux"`
}

// Configuration settings for Docker build context
type BuildContext struct {
	// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
	// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
	ContextUri string `pulumi:"contextUri"`
	// Path to the Dockerfile in the build context.
	// <seealso href="https://docs.docker.com/engine/reference/builder/" />
	DockerfilePath *string `pulumi:"dockerfilePath"`
}

// Defaults sets the appropriate defaults for BuildContext
func (val *BuildContext) Defaults() *BuildContext {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DockerfilePath == nil {
		dockerfilePath_ := "Dockerfile"
		tmp.DockerfilePath = &dockerfilePath_
	}
	return &tmp
}

// BuildContextInput is an input type that accepts BuildContextArgs and BuildContextOutput values.
// You can construct a concrete instance of `BuildContextInput` via:
//
//	BuildContextArgs{...}
type BuildContextInput interface {
	pulumi.Input

	ToBuildContextOutput() BuildContextOutput
	ToBuildContextOutputWithContext(context.Context) BuildContextOutput
}

// Configuration settings for Docker build context
type BuildContextArgs struct {
	// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
	// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
	ContextUri pulumi.StringInput `pulumi:"contextUri"`
	// Path to the Dockerfile in the build context.
	// <seealso href="https://docs.docker.com/engine/reference/builder/" />
	DockerfilePath pulumi.StringPtrInput `pulumi:"dockerfilePath"`
}

// Defaults sets the appropriate defaults for BuildContextArgs
func (val *BuildContextArgs) Defaults() *BuildContextArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DockerfilePath == nil {
		tmp.DockerfilePath = pulumi.StringPtr("Dockerfile")
	}
	return &tmp
}
func (BuildContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildContext)(nil)).Elem()
}

func (i BuildContextArgs) ToBuildContextOutput() BuildContextOutput {
	return i.ToBuildContextOutputWithContext(context.Background())
}

func (i BuildContextArgs) ToBuildContextOutputWithContext(ctx context.Context) BuildContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildContextOutput)
}

func (i BuildContextArgs) ToBuildContextPtrOutput() BuildContextPtrOutput {
	return i.ToBuildContextPtrOutputWithContext(context.Background())
}

func (i BuildContextArgs) ToBuildContextPtrOutputWithContext(ctx context.Context) BuildContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildContextOutput).ToBuildContextPtrOutputWithContext(ctx)
}

// BuildContextPtrInput is an input type that accepts BuildContextArgs, BuildContextPtr and BuildContextPtrOutput values.
// You can construct a concrete instance of `BuildContextPtrInput` via:
//
//	        BuildContextArgs{...}
//
//	or:
//
//	        nil
type BuildContextPtrInput interface {
	pulumi.Input

	ToBuildContextPtrOutput() BuildContextPtrOutput
	ToBuildContextPtrOutputWithContext(context.Context) BuildContextPtrOutput
}

type buildContextPtrType BuildContextArgs

func BuildContextPtr(v *BuildContextArgs) BuildContextPtrInput {
	return (*buildContextPtrType)(v)
}

func (*buildContextPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildContext)(nil)).Elem()
}

func (i *buildContextPtrType) ToBuildContextPtrOutput() BuildContextPtrOutput {
	return i.ToBuildContextPtrOutputWithContext(context.Background())
}

func (i *buildContextPtrType) ToBuildContextPtrOutputWithContext(ctx context.Context) BuildContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildContextPtrOutput)
}

// Configuration settings for Docker build context
type BuildContextOutput struct{ *pulumi.OutputState }

func (BuildContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildContext)(nil)).Elem()
}

func (o BuildContextOutput) ToBuildContextOutput() BuildContextOutput {
	return o
}

func (o BuildContextOutput) ToBuildContextOutputWithContext(ctx context.Context) BuildContextOutput {
	return o
}

func (o BuildContextOutput) ToBuildContextPtrOutput() BuildContextPtrOutput {
	return o.ToBuildContextPtrOutputWithContext(context.Background())
}

func (o BuildContextOutput) ToBuildContextPtrOutputWithContext(ctx context.Context) BuildContextPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BuildContext) *BuildContext {
		return &v
	}).(BuildContextPtrOutput)
}

// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
func (o BuildContextOutput) ContextUri() pulumi.StringOutput {
	return o.ApplyT(func(v BuildContext) string { return v.ContextUri }).(pulumi.StringOutput)
}

// Path to the Dockerfile in the build context.
// <seealso href="https://docs.docker.com/engine/reference/builder/" />
func (o BuildContextOutput) DockerfilePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildContext) *string { return v.DockerfilePath }).(pulumi.StringPtrOutput)
}

type BuildContextPtrOutput struct{ *pulumi.OutputState }

func (BuildContextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildContext)(nil)).Elem()
}

func (o BuildContextPtrOutput) ToBuildContextPtrOutput() BuildContextPtrOutput {
	return o
}

func (o BuildContextPtrOutput) ToBuildContextPtrOutputWithContext(ctx context.Context) BuildContextPtrOutput {
	return o
}

func (o BuildContextPtrOutput) Elem() BuildContextOutput {
	return o.ApplyT(func(v *BuildContext) BuildContext {
		if v != nil {
			return *v
		}
		var ret BuildContext
		return ret
	}).(BuildContextOutput)
}

// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
func (o BuildContextPtrOutput) ContextUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildContext) *string {
		if v == nil {
			return nil
		}
		return &v.ContextUri
	}).(pulumi.StringPtrOutput)
}

// Path to the Dockerfile in the build context.
// <seealso href="https://docs.docker.com/engine/reference/builder/" />
func (o BuildContextPtrOutput) DockerfilePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildContext) *string {
		if v == nil {
			return nil
		}
		return v.DockerfilePath
	}).(pulumi.StringPtrOutput)
}

// Configuration settings for Docker build context
type BuildContextResponse struct {
	// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
	// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
	ContextUri string `pulumi:"contextUri"`
	// Path to the Dockerfile in the build context.
	// <seealso href="https://docs.docker.com/engine/reference/builder/" />
	DockerfilePath *string `pulumi:"dockerfilePath"`
}

// Defaults sets the appropriate defaults for BuildContextResponse
func (val *BuildContextResponse) Defaults() *BuildContextResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DockerfilePath == nil {
		dockerfilePath_ := "Dockerfile"
		tmp.DockerfilePath = &dockerfilePath_
	}
	return &tmp
}

// Configuration settings for Docker build context
type BuildContextResponseOutput struct{ *pulumi.OutputState }

func (BuildContextResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildContextResponse)(nil)).Elem()
}

func (o BuildContextResponseOutput) ToBuildContextResponseOutput() BuildContextResponseOutput {
	return o
}

func (o BuildContextResponseOutput) ToBuildContextResponseOutputWithContext(ctx context.Context) BuildContextResponseOutput {
	return o
}

// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
func (o BuildContextResponseOutput) ContextUri() pulumi.StringOutput {
	return o.ApplyT(func(v BuildContextResponse) string { return v.ContextUri }).(pulumi.StringOutput)
}

// Path to the Dockerfile in the build context.
// <seealso href="https://docs.docker.com/engine/reference/builder/" />
func (o BuildContextResponseOutput) DockerfilePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildContextResponse) *string { return v.DockerfilePath }).(pulumi.StringPtrOutput)
}

type BuildContextResponsePtrOutput struct{ *pulumi.OutputState }

func (BuildContextResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildContextResponse)(nil)).Elem()
}

func (o BuildContextResponsePtrOutput) ToBuildContextResponsePtrOutput() BuildContextResponsePtrOutput {
	return o
}

func (o BuildContextResponsePtrOutput) ToBuildContextResponsePtrOutputWithContext(ctx context.Context) BuildContextResponsePtrOutput {
	return o
}

func (o BuildContextResponsePtrOutput) Elem() BuildContextResponseOutput {
	return o.ApplyT(func(v *BuildContextResponse) BuildContextResponse {
		if v != nil {
			return *v
		}
		var ret BuildContextResponse
		return ret
	}).(BuildContextResponseOutput)
}

// [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
func (o BuildContextResponsePtrOutput) ContextUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildContextResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ContextUri
	}).(pulumi.StringPtrOutput)
}

// Path to the Dockerfile in the build context.
// <seealso href="https://docs.docker.com/engine/reference/builder/" />
func (o BuildContextResponsePtrOutput) DockerfilePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildContextResponse) *string {
		if v == nil {
			return nil
		}
		return v.DockerfilePath
	}).(pulumi.StringPtrOutput)
}

type CategoricalDataDriftMetricThreshold struct {
	// Expected value is 'Categorical'.
	DataType string `pulumi:"dataType"`
	// [Required] The categorical data drift metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

type CategoricalDataDriftMetricThresholdResponse struct {
	// Expected value is 'Categorical'.
	DataType string `pulumi:"dataType"`
	// [Required] The categorical data drift metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

type CategoricalDataQualityMetricThreshold struct {
	// Expected value is 'Categorical'.
	DataType string `pulumi:"dataType"`
	// [Required] The categorical data quality metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

type CategoricalDataQualityMetricThresholdResponse struct {
	// Expected value is 'Categorical'.
	DataType string `pulumi:"dataType"`
	// [Required] The categorical data quality metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

type CategoricalPredictionDriftMetricThreshold struct {
	// Expected value is 'Categorical'.
	DataType string `pulumi:"dataType"`
	// [Required] The categorical prediction drift metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

type CategoricalPredictionDriftMetricThresholdResponse struct {
	// Expected value is 'Categorical'.
	DataType string `pulumi:"dataType"`
	// [Required] The categorical prediction drift metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

// Certificate datastore credentials configuration.
type CertificateDatastoreCredentials struct {
	// Authority URL used for authentication.
	AuthorityUrl *string `pulumi:"authorityUrl"`
	// [Required] Service principal client ID.
	ClientId string `pulumi:"clientId"`
	// Enum to determine the datastore credentials type.
	// Expected value is 'Certificate'.
	CredentialsType string `pulumi:"credentialsType"`
	// Resource the service principal has access to.
	ResourceUrl *string `pulumi:"resourceUrl"`
	// [Required] Service principal secrets.
	Secrets CertificateDatastoreSecrets `pulumi:"secrets"`
	// [Required] ID of the tenant to which the service principal belongs.
	TenantId string `pulumi:"tenantId"`
	// [Required] Thumbprint of the certificate used for authentication.
	Thumbprint string `pulumi:"thumbprint"`
}

// Certificate datastore credentials configuration.
type CertificateDatastoreCredentialsResponse struct {
	// Authority URL used for authentication.
	AuthorityUrl *string `pulumi:"authorityUrl"`
	// [Required] Service principal client ID.
	ClientId string `pulumi:"clientId"`
	// Enum to determine the datastore credentials type.
	// Expected value is 'Certificate'.
	CredentialsType string `pulumi:"credentialsType"`
	// Resource the service principal has access to.
	ResourceUrl *string `pulumi:"resourceUrl"`
	// [Required] ID of the tenant to which the service principal belongs.
	TenantId string `pulumi:"tenantId"`
	// [Required] Thumbprint of the certificate used for authentication.
	Thumbprint string `pulumi:"thumbprint"`
}

// Datastore certificate secrets.
type CertificateDatastoreSecrets struct {
	// Service principal certificate.
	Certificate *string `pulumi:"certificate"`
	// Enum to determine the datastore secrets type.
	// Expected value is 'Certificate'.
	SecretsType string `pulumi:"secretsType"`
}

// Classification task in AutoML Table vertical.
type Classification struct {
	// Columns to use for CVSplit data.
	CvSplitColumnNames []string `pulumi:"cvSplitColumnNames"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettings `pulumi:"featurizationSettings"`
	// Model/training parameters that will remain constant throughout training.
	FixedParameters *TableFixedParameters `pulumi:"fixedParameters"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Number of cross validation folds to be applied on training dataset
	// when validation dataset is not provided.
	NCrossValidations interface{} `pulumi:"nCrossValidations"`
	// Positive label for binary metrics calculation.
	PositiveLabel *string `pulumi:"positiveLabel"`
	// Primary metric for the task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []TableParameterSubspace `pulumi:"searchSpace"`
	// Settings for model sweeping and hyperparameter tuning.
	SweepSettings *TableSweepSettings `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'Classification'.
	TaskType string `pulumi:"taskType"`
	// Test data input.
	TestData *MLTableJobInput `pulumi:"testData"`
	// The fraction of test dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	TestDataSize *float64 `pulumi:"testDataSize"`
	// [Required] Training data input.
	TrainingData MLTableJobInput `pulumi:"trainingData"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *ClassificationTrainingSettings `pulumi:"trainingSettings"`
	// Validation data inputs.
	ValidationData *MLTableJobInput `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
	// The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
	WeightColumnName *string `pulumi:"weightColumnName"`
}

// Defaults sets the appropriate defaults for Classification
func (val *Classification) Defaults() *Classification {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.FixedParameters = tmp.FixedParameters.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "AUCWeighted"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

type ClassificationModelPerformanceMetricThreshold struct {
	// [Required] The classification model performance to calculate.
	Metric string `pulumi:"metric"`
	// Expected value is 'Classification'.
	ModelType string `pulumi:"modelType"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

type ClassificationModelPerformanceMetricThresholdResponse struct {
	// [Required] The classification model performance to calculate.
	Metric string `pulumi:"metric"`
	// Expected value is 'Classification'.
	ModelType string `pulumi:"modelType"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

// Classification task in AutoML Table vertical.
type ClassificationResponse struct {
	// Columns to use for CVSplit data.
	CvSplitColumnNames []string `pulumi:"cvSplitColumnNames"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettingsResponse `pulumi:"featurizationSettings"`
	// Model/training parameters that will remain constant throughout training.
	FixedParameters *TableFixedParametersResponse `pulumi:"fixedParameters"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Number of cross validation folds to be applied on training dataset
	// when validation dataset is not provided.
	NCrossValidations interface{} `pulumi:"nCrossValidations"`
	// Positive label for binary metrics calculation.
	PositiveLabel *string `pulumi:"positiveLabel"`
	// Primary metric for the task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []TableParameterSubspaceResponse `pulumi:"searchSpace"`
	// Settings for model sweeping and hyperparameter tuning.
	SweepSettings *TableSweepSettingsResponse `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'Classification'.
	TaskType string `pulumi:"taskType"`
	// Test data input.
	TestData *MLTableJobInputResponse `pulumi:"testData"`
	// The fraction of test dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	TestDataSize *float64 `pulumi:"testDataSize"`
	// [Required] Training data input.
	TrainingData MLTableJobInputResponse `pulumi:"trainingData"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *ClassificationTrainingSettingsResponse `pulumi:"trainingSettings"`
	// Validation data inputs.
	ValidationData *MLTableJobInputResponse `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
	// The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
	WeightColumnName *string `pulumi:"weightColumnName"`
}

// Defaults sets the appropriate defaults for ClassificationResponse
func (val *ClassificationResponse) Defaults() *ClassificationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.FixedParameters = tmp.FixedParameters.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "AUCWeighted"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Classification Training related configuration.
type ClassificationTrainingSettings struct {
	// Allowed models for classification task.
	AllowedTrainingAlgorithms []string `pulumi:"allowedTrainingAlgorithms"`
	// Blocked models for classification task.
	BlockedTrainingAlgorithms []string `pulumi:"blockedTrainingAlgorithms"`
	// Enable recommendation of DNN models.
	EnableDnnTraining *bool `pulumi:"enableDnnTraining"`
	// Flag to turn on explainability on best model.
	EnableModelExplainability *bool `pulumi:"enableModelExplainability"`
	// Flag for enabling onnx compatible models.
	EnableOnnxCompatibleModels *bool `pulumi:"enableOnnxCompatibleModels"`
	// Enable stack ensemble run.
	EnableStackEnsemble *bool `pulumi:"enableStackEnsemble"`
	// Enable voting ensemble run.
	EnableVoteEnsemble *bool `pulumi:"enableVoteEnsemble"`
	// During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
	// Configure this parameter with a higher value than 300 secs, if more time is needed.
	EnsembleModelDownloadTimeout *string `pulumi:"ensembleModelDownloadTimeout"`
	// Stack ensemble settings for stack ensemble run.
	StackEnsembleSettings *StackEnsembleSettings `pulumi:"stackEnsembleSettings"`
	// TrainingMode mode - Setting to 'auto' is same as setting it to 'non-distributed' for now, however in the future may result in mixed mode or heuristics based mode selection. Default is 'auto'.
	// If 'Distributed' then only distributed featurization is used and distributed algorithms are chosen.
	// If 'NonDistributed' then only non distributed algorithms are chosen.
	TrainingMode *string `pulumi:"trainingMode"`
}

// Defaults sets the appropriate defaults for ClassificationTrainingSettings
func (val *ClassificationTrainingSettings) Defaults() *ClassificationTrainingSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.EnableDnnTraining == nil {
		enableDnnTraining_ := false
		tmp.EnableDnnTraining = &enableDnnTraining_
	}
	if tmp.EnableModelExplainability == nil {
		enableModelExplainability_ := true
		tmp.EnableModelExplainability = &enableModelExplainability_
	}
	if tmp.EnableOnnxCompatibleModels == nil {
		enableOnnxCompatibleModels_ := false
		tmp.EnableOnnxCompatibleModels = &enableOnnxCompatibleModels_
	}
	if tmp.EnableStackEnsemble == nil {
		enableStackEnsemble_ := true
		tmp.EnableStackEnsemble = &enableStackEnsemble_
	}
	if tmp.EnableVoteEnsemble == nil {
		enableVoteEnsemble_ := true
		tmp.EnableVoteEnsemble = &enableVoteEnsemble_
	}
	if tmp.EnsembleModelDownloadTimeout == nil {
		ensembleModelDownloadTimeout_ := "PT5M"
		tmp.EnsembleModelDownloadTimeout = &ensembleModelDownloadTimeout_
	}
	tmp.StackEnsembleSettings = tmp.StackEnsembleSettings.Defaults()

	if tmp.TrainingMode == nil {
		trainingMode_ := "Auto"
		tmp.TrainingMode = &trainingMode_
	}
	return &tmp
}

// Classification Training related configuration.
type ClassificationTrainingSettingsResponse struct {
	// Allowed models for classification task.
	AllowedTrainingAlgorithms []string `pulumi:"allowedTrainingAlgorithms"`
	// Blocked models for classification task.
	BlockedTrainingAlgorithms []string `pulumi:"blockedTrainingAlgorithms"`
	// Enable recommendation of DNN models.
	EnableDnnTraining *bool `pulumi:"enableDnnTraining"`
	// Flag to turn on explainability on best model.
	EnableModelExplainability *bool `pulumi:"enableModelExplainability"`
	// Flag for enabling onnx compatible models.
	EnableOnnxCompatibleModels *bool `pulumi:"enableOnnxCompatibleModels"`
	// Enable stack ensemble run.
	EnableStackEnsemble *bool `pulumi:"enableStackEnsemble"`
	// Enable voting ensemble run.
	EnableVoteEnsemble *bool `pulumi:"enableVoteEnsemble"`
	// During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
	// Configure this parameter with a higher value than 300 secs, if more time is needed.
	EnsembleModelDownloadTimeout *string `pulumi:"ensembleModelDownloadTimeout"`
	// Stack ensemble settings for stack ensemble run.
	StackEnsembleSettings *StackEnsembleSettingsResponse `pulumi:"stackEnsembleSettings"`
	// TrainingMode mode - Setting to 'auto' is same as setting it to 'non-distributed' for now, however in the future may result in mixed mode or heuristics based mode selection. Default is 'auto'.
	// If 'Distributed' then only distributed featurization is used and distributed algorithms are chosen.
	// If 'NonDistributed' then only non distributed algorithms are chosen.
	TrainingMode *string `pulumi:"trainingMode"`
}

// Defaults sets the appropriate defaults for ClassificationTrainingSettingsResponse
func (val *ClassificationTrainingSettingsResponse) Defaults() *ClassificationTrainingSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.EnableDnnTraining == nil {
		enableDnnTraining_ := false
		tmp.EnableDnnTraining = &enableDnnTraining_
	}
	if tmp.EnableModelExplainability == nil {
		enableModelExplainability_ := true
		tmp.EnableModelExplainability = &enableModelExplainability_
	}
	if tmp.EnableOnnxCompatibleModels == nil {
		enableOnnxCompatibleModels_ := false
		tmp.EnableOnnxCompatibleModels = &enableOnnxCompatibleModels_
	}
	if tmp.EnableStackEnsemble == nil {
		enableStackEnsemble_ := true
		tmp.EnableStackEnsemble = &enableStackEnsemble_
	}
	if tmp.EnableVoteEnsemble == nil {
		enableVoteEnsemble_ := true
		tmp.EnableVoteEnsemble = &enableVoteEnsemble_
	}
	if tmp.EnsembleModelDownloadTimeout == nil {
		ensembleModelDownloadTimeout_ := "PT5M"
		tmp.EnsembleModelDownloadTimeout = &ensembleModelDownloadTimeout_
	}
	tmp.StackEnsembleSettings = tmp.StackEnsembleSettings.Defaults()

	if tmp.TrainingMode == nil {
		trainingMode_ := "Auto"
		tmp.TrainingMode = &trainingMode_
	}
	return &tmp
}

// Configuration for a scoring code asset.
type CodeConfiguration struct {
	// ARM resource ID of the code asset.
	CodeId *string `pulumi:"codeId"`
	// [Required] The script to execute on startup. eg. "score.py"
	ScoringScript string `pulumi:"scoringScript"`
}

// CodeConfigurationInput is an input type that accepts CodeConfigurationArgs and CodeConfigurationOutput values.
// You can construct a concrete instance of `CodeConfigurationInput` via:
//
//	CodeConfigurationArgs{...}
type CodeConfigurationInput interface {
	pulumi.Input

	ToCodeConfigurationOutput() CodeConfigurationOutput
	ToCodeConfigurationOutputWithContext(context.Context) CodeConfigurationOutput
}

// Configuration for a scoring code asset.
type CodeConfigurationArgs struct {
	// ARM resource ID of the code asset.
	CodeId pulumi.StringPtrInput `pulumi:"codeId"`
	// [Required] The script to execute on startup. eg. "score.py"
	ScoringScript pulumi.StringInput `pulumi:"scoringScript"`
}

func (CodeConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeConfiguration)(nil)).Elem()
}

func (i CodeConfigurationArgs) ToCodeConfigurationOutput() CodeConfigurationOutput {
	return i.ToCodeConfigurationOutputWithContext(context.Background())
}

func (i CodeConfigurationArgs) ToCodeConfigurationOutputWithContext(ctx context.Context) CodeConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CodeConfigurationOutput)
}

func (i CodeConfigurationArgs) ToCodeConfigurationPtrOutput() CodeConfigurationPtrOutput {
	return i.ToCodeConfigurationPtrOutputWithContext(context.Background())
}

func (i CodeConfigurationArgs) ToCodeConfigurationPtrOutputWithContext(ctx context.Context) CodeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CodeConfigurationOutput).ToCodeConfigurationPtrOutputWithContext(ctx)
}

// CodeConfigurationPtrInput is an input type that accepts CodeConfigurationArgs, CodeConfigurationPtr and CodeConfigurationPtrOutput values.
// You can construct a concrete instance of `CodeConfigurationPtrInput` via:
//
//	        CodeConfigurationArgs{...}
//
//	or:
//
//	        nil
type CodeConfigurationPtrInput interface {
	pulumi.Input

	ToCodeConfigurationPtrOutput() CodeConfigurationPtrOutput
	ToCodeConfigurationPtrOutputWithContext(context.Context) CodeConfigurationPtrOutput
}

type codeConfigurationPtrType CodeConfigurationArgs

func CodeConfigurationPtr(v *CodeConfigurationArgs) CodeConfigurationPtrInput {
	return (*codeConfigurationPtrType)(v)
}

func (*codeConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CodeConfiguration)(nil)).Elem()
}

func (i *codeConfigurationPtrType) ToCodeConfigurationPtrOutput() CodeConfigurationPtrOutput {
	return i.ToCodeConfigurationPtrOutputWithContext(context.Background())
}

func (i *codeConfigurationPtrType) ToCodeConfigurationPtrOutputWithContext(ctx context.Context) CodeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CodeConfigurationPtrOutput)
}

// Configuration for a scoring code asset.
type CodeConfigurationOutput struct{ *pulumi.OutputState }

func (CodeConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeConfiguration)(nil)).Elem()
}

func (o CodeConfigurationOutput) ToCodeConfigurationOutput() CodeConfigurationOutput {
	return o
}

func (o CodeConfigurationOutput) ToCodeConfigurationOutputWithContext(ctx context.Context) CodeConfigurationOutput {
	return o
}

func (o CodeConfigurationOutput) ToCodeConfigurationPtrOutput() CodeConfigurationPtrOutput {
	return o.ToCodeConfigurationPtrOutputWithContext(context.Background())
}

func (o CodeConfigurationOutput) ToCodeConfigurationPtrOutputWithContext(ctx context.Context) CodeConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CodeConfiguration) *CodeConfiguration {
		return &v
	}).(CodeConfigurationPtrOutput)
}

// ARM resource ID of the code asset.
func (o CodeConfigurationOutput) CodeId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeConfiguration) *string { return v.CodeId }).(pulumi.StringPtrOutput)
}

// [Required] The script to execute on startup. eg. "score.py"
func (o CodeConfigurationOutput) ScoringScript() pulumi.StringOutput {
	return o.ApplyT(func(v CodeConfiguration) string { return v.ScoringScript }).(pulumi.StringOutput)
}

type CodeConfigurationPtrOutput struct{ *pulumi.OutputState }

func (CodeConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CodeConfiguration)(nil)).Elem()
}

func (o CodeConfigurationPtrOutput) ToCodeConfigurationPtrOutput() CodeConfigurationPtrOutput {
	return o
}

func (o CodeConfigurationPtrOutput) ToCodeConfigurationPtrOutputWithContext(ctx context.Context) CodeConfigurationPtrOutput {
	return o
}

func (o CodeConfigurationPtrOutput) Elem() CodeConfigurationOutput {
	return o.ApplyT(func(v *CodeConfiguration) CodeConfiguration {
		if v != nil {
			return *v
		}
		var ret CodeConfiguration
		return ret
	}).(CodeConfigurationOutput)
}

// ARM resource ID of the code asset.
func (o CodeConfigurationPtrOutput) CodeId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CodeConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.CodeId
	}).(pulumi.StringPtrOutput)
}

// [Required] The script to execute on startup. eg. "score.py"
func (o CodeConfigurationPtrOutput) ScoringScript() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CodeConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.ScoringScript
	}).(pulumi.StringPtrOutput)
}

// Configuration for a scoring code asset.
type CodeConfigurationResponse struct {
	// ARM resource ID of the code asset.
	CodeId *string `pulumi:"codeId"`
	// [Required] The script to execute on startup. eg. "score.py"
	ScoringScript string `pulumi:"scoringScript"`
}

// Configuration for a scoring code asset.
type CodeConfigurationResponseOutput struct{ *pulumi.OutputState }

func (CodeConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeConfigurationResponse)(nil)).Elem()
}

func (o CodeConfigurationResponseOutput) ToCodeConfigurationResponseOutput() CodeConfigurationResponseOutput {
	return o
}

func (o CodeConfigurationResponseOutput) ToCodeConfigurationResponseOutputWithContext(ctx context.Context) CodeConfigurationResponseOutput {
	return o
}

// ARM resource ID of the code asset.
func (o CodeConfigurationResponseOutput) CodeId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeConfigurationResponse) *string { return v.CodeId }).(pulumi.StringPtrOutput)
}

// [Required] The script to execute on startup. eg. "score.py"
func (o CodeConfigurationResponseOutput) ScoringScript() pulumi.StringOutput {
	return o.ApplyT(func(v CodeConfigurationResponse) string { return v.ScoringScript }).(pulumi.StringOutput)
}

type CodeConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (CodeConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CodeConfigurationResponse)(nil)).Elem()
}

func (o CodeConfigurationResponsePtrOutput) ToCodeConfigurationResponsePtrOutput() CodeConfigurationResponsePtrOutput {
	return o
}

func (o CodeConfigurationResponsePtrOutput) ToCodeConfigurationResponsePtrOutputWithContext(ctx context.Context) CodeConfigurationResponsePtrOutput {
	return o
}

func (o CodeConfigurationResponsePtrOutput) Elem() CodeConfigurationResponseOutput {
	return o.ApplyT(func(v *CodeConfigurationResponse) CodeConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret CodeConfigurationResponse
		return ret
	}).(CodeConfigurationResponseOutput)
}

// ARM resource ID of the code asset.
func (o CodeConfigurationResponsePtrOutput) CodeId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CodeConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.CodeId
	}).(pulumi.StringPtrOutput)
}

// [Required] The script to execute on startup. eg. "score.py"
func (o CodeConfigurationResponsePtrOutput) ScoringScript() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CodeConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ScoringScript
	}).(pulumi.StringPtrOutput)
}

// Container for code asset versions.
type CodeContainerType struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeContainerType
func (val *CodeContainerType) Defaults() *CodeContainerType {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// CodeContainerTypeInput is an input type that accepts CodeContainerTypeArgs and CodeContainerTypeOutput values.
// You can construct a concrete instance of `CodeContainerTypeInput` via:
//
//	CodeContainerTypeArgs{...}
type CodeContainerTypeInput interface {
	pulumi.Input

	ToCodeContainerTypeOutput() CodeContainerTypeOutput
	ToCodeContainerTypeOutputWithContext(context.Context) CodeContainerTypeOutput
}

// Container for code asset versions.
type CodeContainerTypeArgs struct {
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeContainerTypeArgs
func (val *CodeContainerTypeArgs) Defaults() *CodeContainerTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (CodeContainerTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeContainerType)(nil)).Elem()
}

func (i CodeContainerTypeArgs) ToCodeContainerTypeOutput() CodeContainerTypeOutput {
	return i.ToCodeContainerTypeOutputWithContext(context.Background())
}

func (i CodeContainerTypeArgs) ToCodeContainerTypeOutputWithContext(ctx context.Context) CodeContainerTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CodeContainerTypeOutput)
}

// Container for code asset versions.
type CodeContainerTypeOutput struct{ *pulumi.OutputState }

func (CodeContainerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeContainerType)(nil)).Elem()
}

func (o CodeContainerTypeOutput) ToCodeContainerTypeOutput() CodeContainerTypeOutput {
	return o
}

func (o CodeContainerTypeOutput) ToCodeContainerTypeOutputWithContext(ctx context.Context) CodeContainerTypeOutput {
	return o
}

// The asset description text.
func (o CodeContainerTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeContainerType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o CodeContainerTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeContainerType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o CodeContainerTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeContainerType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o CodeContainerTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeContainerType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Container for code asset versions.
type CodeContainerResponse struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the code container.
	ProvisioningState string `pulumi:"provisioningState"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeContainerResponse
func (val *CodeContainerResponse) Defaults() *CodeContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Container for code asset versions.
type CodeContainerResponseOutput struct{ *pulumi.OutputState }

func (CodeContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeContainerResponse)(nil)).Elem()
}

func (o CodeContainerResponseOutput) ToCodeContainerResponseOutput() CodeContainerResponseOutput {
	return o
}

func (o CodeContainerResponseOutput) ToCodeContainerResponseOutputWithContext(ctx context.Context) CodeContainerResponseOutput {
	return o
}

// The asset description text.
func (o CodeContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o CodeContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o CodeContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v CodeContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o CodeContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v CodeContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o CodeContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the code container.
func (o CodeContainerResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v CodeContainerResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o CodeContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Code asset version details.
type CodeVersionType struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSetting `pulumi:"autoDeleteSetting"`
	// Uri where code is located
	CodeUri *string `pulumi:"codeUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeVersionType
func (val *CodeVersionType) Defaults() *CodeVersionType {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// CodeVersionTypeInput is an input type that accepts CodeVersionTypeArgs and CodeVersionTypeOutput values.
// You can construct a concrete instance of `CodeVersionTypeInput` via:
//
//	CodeVersionTypeArgs{...}
type CodeVersionTypeInput interface {
	pulumi.Input

	ToCodeVersionTypeOutput() CodeVersionTypeOutput
	ToCodeVersionTypeOutputWithContext(context.Context) CodeVersionTypeOutput
}

// Code asset version details.
type CodeVersionTypeArgs struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting AutoDeleteSettingPtrInput `pulumi:"autoDeleteSetting"`
	// Uri where code is located
	CodeUri pulumi.StringPtrInput `pulumi:"codeUri"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous pulumi.BoolPtrInput `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeVersionTypeArgs
func (val *CodeVersionTypeArgs) Defaults() *CodeVersionTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	if tmp.IsAnonymous == nil {
		tmp.IsAnonymous = pulumi.BoolPtr(false)
	}
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (CodeVersionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeVersionType)(nil)).Elem()
}

func (i CodeVersionTypeArgs) ToCodeVersionTypeOutput() CodeVersionTypeOutput {
	return i.ToCodeVersionTypeOutputWithContext(context.Background())
}

func (i CodeVersionTypeArgs) ToCodeVersionTypeOutputWithContext(ctx context.Context) CodeVersionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CodeVersionTypeOutput)
}

// Code asset version details.
type CodeVersionTypeOutput struct{ *pulumi.OutputState }

func (CodeVersionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeVersionType)(nil)).Elem()
}

func (o CodeVersionTypeOutput) ToCodeVersionTypeOutput() CodeVersionTypeOutput {
	return o
}

func (o CodeVersionTypeOutput) ToCodeVersionTypeOutputWithContext(ctx context.Context) CodeVersionTypeOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o CodeVersionTypeOutput) AutoDeleteSetting() AutoDeleteSettingPtrOutput {
	return o.ApplyT(func(v CodeVersionType) *AutoDeleteSetting { return v.AutoDeleteSetting }).(AutoDeleteSettingPtrOutput)
}

// Uri where code is located
func (o CodeVersionTypeOutput) CodeUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeVersionType) *string { return v.CodeUri }).(pulumi.StringPtrOutput)
}

// The asset description text.
func (o CodeVersionTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeVersionType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o CodeVersionTypeOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeVersionType) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o CodeVersionTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeVersionType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o CodeVersionTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeVersionType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o CodeVersionTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeVersionType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Code asset version details.
type CodeVersionResponse struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSettingResponse `pulumi:"autoDeleteSetting"`
	// Uri where code is located
	CodeUri *string `pulumi:"codeUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the code version.
	ProvisioningState string `pulumi:"provisioningState"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CodeVersionResponse
func (val *CodeVersionResponse) Defaults() *CodeVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Code asset version details.
type CodeVersionResponseOutput struct{ *pulumi.OutputState }

func (CodeVersionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CodeVersionResponse)(nil)).Elem()
}

func (o CodeVersionResponseOutput) ToCodeVersionResponseOutput() CodeVersionResponseOutput {
	return o
}

func (o CodeVersionResponseOutput) ToCodeVersionResponseOutputWithContext(ctx context.Context) CodeVersionResponseOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o CodeVersionResponseOutput) AutoDeleteSetting() AutoDeleteSettingResponsePtrOutput {
	return o.ApplyT(func(v CodeVersionResponse) *AutoDeleteSettingResponse { return v.AutoDeleteSetting }).(AutoDeleteSettingResponsePtrOutput)
}

// Uri where code is located
func (o CodeVersionResponseOutput) CodeUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeVersionResponse) *string { return v.CodeUri }).(pulumi.StringPtrOutput)
}

// The asset description text.
func (o CodeVersionResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CodeVersionResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o CodeVersionResponseOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeVersionResponse) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o CodeVersionResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CodeVersionResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o CodeVersionResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeVersionResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the code version.
func (o CodeVersionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v CodeVersionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o CodeVersionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CodeVersionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

type Collection struct {
	// The msi client id used to collect logging to blob storage. If it's null,backend will pick a registered endpoint identity to auth.
	ClientId *string `pulumi:"clientId"`
	// Enable or disable data collection.
	DataCollectionMode *string `pulumi:"dataCollectionMode"`
	// The data asset arm resource id. Client side will ensure data asset is pointing to the blob storage, and backend will collect data to the blob storage.
	DataId *string `pulumi:"dataId"`
	// The sampling rate for collection. Sampling rate 1.0 means we collect 100% of data by default.
	SamplingRate *float64 `pulumi:"samplingRate"`
}

// Defaults sets the appropriate defaults for Collection
func (val *Collection) Defaults() *Collection {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DataCollectionMode == nil {
		dataCollectionMode_ := "Disabled"
		tmp.DataCollectionMode = &dataCollectionMode_
	}
	if tmp.SamplingRate == nil {
		samplingRate_ := 1.0
		tmp.SamplingRate = &samplingRate_
	}
	return &tmp
}

type CollectionResponse struct {
	// The msi client id used to collect logging to blob storage. If it's null,backend will pick a registered endpoint identity to auth.
	ClientId *string `pulumi:"clientId"`
	// Enable or disable data collection.
	DataCollectionMode *string `pulumi:"dataCollectionMode"`
	// The data asset arm resource id. Client side will ensure data asset is pointing to the blob storage, and backend will collect data to the blob storage.
	DataId *string `pulumi:"dataId"`
	// The sampling rate for collection. Sampling rate 1.0 means we collect 100% of data by default.
	SamplingRate *float64 `pulumi:"samplingRate"`
}

// Defaults sets the appropriate defaults for CollectionResponse
func (val *CollectionResponse) Defaults() *CollectionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DataCollectionMode == nil {
		dataCollectionMode_ := "Disabled"
		tmp.DataCollectionMode = &dataCollectionMode_
	}
	if tmp.SamplingRate == nil {
		samplingRate_ := 1.0
		tmp.SamplingRate = &samplingRate_
	}
	return &tmp
}

// Column transformer parameters.
type ColumnTransformer struct {
	// Fields to apply transformer logic on.
	Fields []string `pulumi:"fields"`
	// Different properties to be passed to transformer.
	// Input expected is dictionary of key,value pairs in JSON format.
	Parameters interface{} `pulumi:"parameters"`
}

// Column transformer parameters.
type ColumnTransformerResponse struct {
	// Fields to apply transformer logic on.
	Fields []string `pulumi:"fields"`
	// Different properties to be passed to transformer.
	// Input expected is dictionary of key,value pairs in JSON format.
	Parameters interface{} `pulumi:"parameters"`
}

// Command job definition.
type CommandJob struct {
	// Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
	AutologgerSettings *AutologgerSettings `pulumi:"autologgerSettings"`
	// ARM resource ID of the code asset.
	CodeId *string `pulumi:"codeId"`
	// [Required] The command to execute on startup of the job. eg. "python train.py"
	Command string `pulumi:"command"`
	// ARM resource ID of the component resource.
	ComponentId *string `pulumi:"componentId"`
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, Ray, or null.
	Distribution interface{} `pulumi:"distribution"`
	// [Required] The ARM resource ID of the Environment specification for the job.
	EnvironmentId string `pulumi:"environmentId"`
	// Environment variables included in the job.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Mapping of input data bindings used in the job.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'Command'.
	JobType string `pulumi:"jobType"`
	// Command Job limit.
	Limits *CommandJobLimits `pulumi:"limits"`
	// Notification setting for the job
	NotificationSetting *NotificationSetting `pulumi:"notificationSetting"`
	// Mapping of output data bindings used in the job.
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Queue settings for the job
	QueueSettings *QueueSettings `pulumi:"queueSettings"`
	// Compute Resource configuration for the job.
	Resources *JobResourceConfiguration `pulumi:"resources"`
	// Configuration for secrets to be made available during runtime.
	SecretsConfiguration map[string]SecretConfiguration `pulumi:"secretsConfiguration"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobService `pulumi:"services"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CommandJob
func (val *CommandJob) Defaults() *CommandJob {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ExperimentName == nil {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.QueueSettings = tmp.QueueSettings.Defaults()

	tmp.Resources = tmp.Resources.Defaults()

	return &tmp
}

// Command Job limit class.
type CommandJobLimits struct {
	// Expected value is 'Command'.
	JobLimitsType string `pulumi:"jobLimitsType"`
	// The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
	Timeout *string `pulumi:"timeout"`
}

// Command Job limit class.
type CommandJobLimitsResponse struct {
	// Expected value is 'Command'.
	JobLimitsType string `pulumi:"jobLimitsType"`
	// The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
	Timeout *string `pulumi:"timeout"`
}

// Command job definition.
type CommandJobResponse struct {
	// Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
	AutologgerSettings *AutologgerSettingsResponse `pulumi:"autologgerSettings"`
	// ARM resource ID of the code asset.
	CodeId *string `pulumi:"codeId"`
	// [Required] The command to execute on startup of the job. eg. "python train.py"
	Command string `pulumi:"command"`
	// ARM resource ID of the component resource.
	ComponentId *string `pulumi:"componentId"`
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, Ray, or null.
	Distribution interface{} `pulumi:"distribution"`
	// [Required] The ARM resource ID of the Environment specification for the job.
	EnvironmentId string `pulumi:"environmentId"`
	// Environment variables included in the job.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Mapping of input data bindings used in the job.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'Command'.
	JobType string `pulumi:"jobType"`
	// Command Job limit.
	Limits *CommandJobLimitsResponse `pulumi:"limits"`
	// Notification setting for the job
	NotificationSetting *NotificationSettingResponse `pulumi:"notificationSetting"`
	// Mapping of output data bindings used in the job.
	Outputs map[string]interface{} `pulumi:"outputs"`
	// Input parameters.
	Parameters interface{} `pulumi:"parameters"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Queue settings for the job
	QueueSettings *QueueSettingsResponse `pulumi:"queueSettings"`
	// Compute Resource configuration for the job.
	Resources *JobResourceConfigurationResponse `pulumi:"resources"`
	// Configuration for secrets to be made available during runtime.
	SecretsConfiguration map[string]SecretConfigurationResponse `pulumi:"secretsConfiguration"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobServiceResponse `pulumi:"services"`
	// Status of the job.
	Status string `pulumi:"status"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for CommandJobResponse
func (val *CommandJobResponse) Defaults() *CommandJobResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ExperimentName == nil {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.QueueSettings = tmp.QueueSettings.Defaults()

	tmp.Resources = tmp.Resources.Defaults()

	return &tmp
}

// Component container definition.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
type ComponentContainerType struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentContainerType
func (val *ComponentContainerType) Defaults() *ComponentContainerType {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// ComponentContainerTypeInput is an input type that accepts ComponentContainerTypeArgs and ComponentContainerTypeOutput values.
// You can construct a concrete instance of `ComponentContainerTypeInput` via:
//
//	ComponentContainerTypeArgs{...}
type ComponentContainerTypeInput interface {
	pulumi.Input

	ToComponentContainerTypeOutput() ComponentContainerTypeOutput
	ToComponentContainerTypeOutputWithContext(context.Context) ComponentContainerTypeOutput
}

// Component container definition.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
type ComponentContainerTypeArgs struct {
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentContainerTypeArgs
func (val *ComponentContainerTypeArgs) Defaults() *ComponentContainerTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (ComponentContainerTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentContainerType)(nil)).Elem()
}

func (i ComponentContainerTypeArgs) ToComponentContainerTypeOutput() ComponentContainerTypeOutput {
	return i.ToComponentContainerTypeOutputWithContext(context.Background())
}

func (i ComponentContainerTypeArgs) ToComponentContainerTypeOutputWithContext(ctx context.Context) ComponentContainerTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComponentContainerTypeOutput)
}

// Component container definition.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
type ComponentContainerTypeOutput struct{ *pulumi.OutputState }

func (ComponentContainerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentContainerType)(nil)).Elem()
}

func (o ComponentContainerTypeOutput) ToComponentContainerTypeOutput() ComponentContainerTypeOutput {
	return o
}

func (o ComponentContainerTypeOutput) ToComponentContainerTypeOutputWithContext(ctx context.Context) ComponentContainerTypeOutput {
	return o
}

// The asset description text.
func (o ComponentContainerTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComponentContainerType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o ComponentContainerTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentContainerType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o ComponentContainerTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentContainerType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ComponentContainerTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentContainerType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Component container definition.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
type ComponentContainerResponse struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the component container.
	ProvisioningState string `pulumi:"provisioningState"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentContainerResponse
func (val *ComponentContainerResponse) Defaults() *ComponentContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Component container definition.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
type ComponentContainerResponseOutput struct{ *pulumi.OutputState }

func (ComponentContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentContainerResponse)(nil)).Elem()
}

func (o ComponentContainerResponseOutput) ToComponentContainerResponseOutput() ComponentContainerResponseOutput {
	return o
}

func (o ComponentContainerResponseOutput) ToComponentContainerResponseOutputWithContext(ctx context.Context) ComponentContainerResponseOutput {
	return o
}

// The asset description text.
func (o ComponentContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComponentContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o ComponentContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o ComponentContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v ComponentContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o ComponentContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v ComponentContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o ComponentContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the component container.
func (o ComponentContainerResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v ComponentContainerResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ComponentContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Definition of a component version: defines resources that span component types.
type ComponentVersionType struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSetting `pulumi:"autoDeleteSetting"`
	// Defines Component definition details.
	// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
	ComponentSpec interface{} `pulumi:"componentSpec"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Stage in the component lifecycle
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentVersionType
func (val *ComponentVersionType) Defaults() *ComponentVersionType {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// ComponentVersionTypeInput is an input type that accepts ComponentVersionTypeArgs and ComponentVersionTypeOutput values.
// You can construct a concrete instance of `ComponentVersionTypeInput` via:
//
//	ComponentVersionTypeArgs{...}
type ComponentVersionTypeInput interface {
	pulumi.Input

	ToComponentVersionTypeOutput() ComponentVersionTypeOutput
	ToComponentVersionTypeOutputWithContext(context.Context) ComponentVersionTypeOutput
}

// Definition of a component version: defines resources that span component types.
type ComponentVersionTypeArgs struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting AutoDeleteSettingPtrInput `pulumi:"autoDeleteSetting"`
	// Defines Component definition details.
	// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
	ComponentSpec pulumi.Input `pulumi:"componentSpec"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous pulumi.BoolPtrInput `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Stage in the component lifecycle
	Stage pulumi.StringPtrInput `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentVersionTypeArgs
func (val *ComponentVersionTypeArgs) Defaults() *ComponentVersionTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	if tmp.IsAnonymous == nil {
		tmp.IsAnonymous = pulumi.BoolPtr(false)
	}
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (ComponentVersionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentVersionType)(nil)).Elem()
}

func (i ComponentVersionTypeArgs) ToComponentVersionTypeOutput() ComponentVersionTypeOutput {
	return i.ToComponentVersionTypeOutputWithContext(context.Background())
}

func (i ComponentVersionTypeArgs) ToComponentVersionTypeOutputWithContext(ctx context.Context) ComponentVersionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComponentVersionTypeOutput)
}

// Definition of a component version: defines resources that span component types.
type ComponentVersionTypeOutput struct{ *pulumi.OutputState }

func (ComponentVersionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentVersionType)(nil)).Elem()
}

func (o ComponentVersionTypeOutput) ToComponentVersionTypeOutput() ComponentVersionTypeOutput {
	return o
}

func (o ComponentVersionTypeOutput) ToComponentVersionTypeOutputWithContext(ctx context.Context) ComponentVersionTypeOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o ComponentVersionTypeOutput) AutoDeleteSetting() AutoDeleteSettingPtrOutput {
	return o.ApplyT(func(v ComponentVersionType) *AutoDeleteSetting { return v.AutoDeleteSetting }).(AutoDeleteSettingPtrOutput)
}

// Defines Component definition details.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
func (o ComponentVersionTypeOutput) ComponentSpec() pulumi.AnyOutput {
	return o.ApplyT(func(v ComponentVersionType) interface{} { return v.ComponentSpec }).(pulumi.AnyOutput)
}

// The asset description text.
func (o ComponentVersionTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComponentVersionType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o ComponentVersionTypeOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentVersionType) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o ComponentVersionTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentVersionType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o ComponentVersionTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentVersionType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Stage in the component lifecycle
func (o ComponentVersionTypeOutput) Stage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComponentVersionType) *string { return v.Stage }).(pulumi.StringPtrOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ComponentVersionTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentVersionType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Definition of a component version: defines resources that span component types.
type ComponentVersionResponse struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSettingResponse `pulumi:"autoDeleteSetting"`
	// Defines Component definition details.
	// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
	ComponentSpec interface{} `pulumi:"componentSpec"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the component version.
	ProvisioningState string `pulumi:"provisioningState"`
	// Stage in the component lifecycle
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ComponentVersionResponse
func (val *ComponentVersionResponse) Defaults() *ComponentVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Definition of a component version: defines resources that span component types.
type ComponentVersionResponseOutput struct{ *pulumi.OutputState }

func (ComponentVersionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComponentVersionResponse)(nil)).Elem()
}

func (o ComponentVersionResponseOutput) ToComponentVersionResponseOutput() ComponentVersionResponseOutput {
	return o
}

func (o ComponentVersionResponseOutput) ToComponentVersionResponseOutputWithContext(ctx context.Context) ComponentVersionResponseOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o ComponentVersionResponseOutput) AutoDeleteSetting() AutoDeleteSettingResponsePtrOutput {
	return o.ApplyT(func(v ComponentVersionResponse) *AutoDeleteSettingResponse { return v.AutoDeleteSetting }).(AutoDeleteSettingResponsePtrOutput)
}

// Defines Component definition details.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
func (o ComponentVersionResponseOutput) ComponentSpec() pulumi.AnyOutput {
	return o.ApplyT(func(v ComponentVersionResponse) interface{} { return v.ComponentSpec }).(pulumi.AnyOutput)
}

// The asset description text.
func (o ComponentVersionResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComponentVersionResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o ComponentVersionResponseOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentVersionResponse) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o ComponentVersionResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ComponentVersionResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o ComponentVersionResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentVersionResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the component version.
func (o ComponentVersionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v ComponentVersionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Stage in the component lifecycle
func (o ComponentVersionResponseOutput) Stage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComponentVersionResponse) *string { return v.Stage }).(pulumi.StringPtrOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ComponentVersionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ComponentVersionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// An Azure Machine Learning compute instance.
type ComputeInstance struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'ComputeInstance'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Properties of ComputeInstance
	Properties *ComputeInstanceProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for ComputeInstance
func (val *ComputeInstance) Defaults() *ComputeInstance {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// Defines an Aml Instance application and its connectivity endpoint URI.
type ComputeInstanceApplicationResponse struct {
	// Name of the ComputeInstance application.
	DisplayName *string `pulumi:"displayName"`
	// Application' endpoint URI.
	EndpointUri *string `pulumi:"endpointUri"`
}

// Specifies settings for autologger.
type ComputeInstanceAutologgerSettings struct {
	// Indicates whether mlflow autologger is enabled for notebooks.
	MlflowAutologger *string `pulumi:"mlflowAutologger"`
}

// Specifies settings for autologger.
type ComputeInstanceAutologgerSettingsResponse struct {
	// Indicates whether mlflow autologger is enabled for notebooks.
	MlflowAutologger *string `pulumi:"mlflowAutologger"`
}

// Defines all connectivity endpoints and properties for an ComputeInstance.
type ComputeInstanceConnectivityEndpointsResponse struct {
	// Private IP Address of this ComputeInstance (local to the VNET in which the compute instance is deployed).
	PrivateIpAddress string `pulumi:"privateIpAddress"`
	// Public IP Address of this ComputeInstance.
	PublicIpAddress string `pulumi:"publicIpAddress"`
}

// Defines an Aml Instance container.
type ComputeInstanceContainerResponse struct {
	// Auto save settings.
	Autosave *string `pulumi:"autosave"`
	// Environment information of this container.
	Environment *ComputeInstanceEnvironmentInfoResponse `pulumi:"environment"`
	// Information of GPU.
	Gpu *string `pulumi:"gpu"`
	// Name of the ComputeInstance container.
	Name *string `pulumi:"name"`
	// network of this container.
	Network *string `pulumi:"network"`
	// services of this containers.
	Services []interface{} `pulumi:"services"`
}

// Describes information on user who created this ComputeInstance.
type ComputeInstanceCreatedByResponse struct {
	// Uniquely identifies the user within his/her organization.
	UserId string `pulumi:"userId"`
	// Name of the user.
	UserName string `pulumi:"userName"`
	// Uniquely identifies user' Azure Active Directory organization.
	UserOrgId string `pulumi:"userOrgId"`
}

// Defines an Aml Instance DataDisk.
type ComputeInstanceDataDiskResponse struct {
	// Caching type of Data Disk.
	Caching *string `pulumi:"caching"`
	// The initial disk size in gigabytes.
	DiskSizeGB *int `pulumi:"diskSizeGB"`
	// The lun is used to uniquely identify each data disk. If attaching multiple disks, each should have a distinct lun.
	Lun *int `pulumi:"lun"`
	// type of this storage account.
	StorageAccountType *string `pulumi:"storageAccountType"`
}

// Defaults sets the appropriate defaults for ComputeInstanceDataDiskResponse
func (val *ComputeInstanceDataDiskResponse) Defaults() *ComputeInstanceDataDiskResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.StorageAccountType == nil {
		storageAccountType_ := "Standard_LRS"
		tmp.StorageAccountType = &storageAccountType_
	}
	return &tmp
}

// Defines an Aml Instance DataMount.
type ComputeInstanceDataMountResponse struct {
	// who this data mount created by.
	CreatedBy *string `pulumi:"createdBy"`
	// Error of this data mount.
	Error *string `pulumi:"error"`
	// Mount Action.
	MountAction *string `pulumi:"mountAction"`
	// name of the ComputeInstance data mount.
	MountName *string `pulumi:"mountName"`
	// Path of this data mount.
	MountPath *string `pulumi:"mountPath"`
	// Mount state.
	MountState *string `pulumi:"mountState"`
	// The time when the disk mounted.
	MountedOn *string `pulumi:"mountedOn"`
	// Source of the ComputeInstance data mount.
	Source *string `pulumi:"source"`
	// Data source type.
	SourceType *string `pulumi:"sourceType"`
}

// Environment information
type ComputeInstanceEnvironmentInfoResponse struct {
	// name of environment.
	Name *string `pulumi:"name"`
	// version of environment.
	Version *string `pulumi:"version"`
}

// The last operation on ComputeInstance.
type ComputeInstanceLastOperationResponse struct {
	// Name of the last operation.
	OperationName *string `pulumi:"operationName"`
	// Operation status.
	OperationStatus *string `pulumi:"operationStatus"`
	// Time of the last operation.
	OperationTime *string `pulumi:"operationTime"`
	// Trigger of operation.
	OperationTrigger *string `pulumi:"operationTrigger"`
}

// Compute Instance properties
type ComputeInstanceProperties struct {
	// Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
	ApplicationSharingPolicy *string `pulumi:"applicationSharingPolicy"`
	// Specifies settings for autologger.
	AutologgerSettings *ComputeInstanceAutologgerSettings `pulumi:"autologgerSettings"`
	// The Compute Instance Authorization type. Available values are personal (default).
	ComputeInstanceAuthorizationType *string `pulumi:"computeInstanceAuthorizationType"`
	// List of Custom Services added to the compute.
	CustomServices []CustomService `pulumi:"customServices"`
	// Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `pulumi:"enableNodePublicIp"`
	// Stops compute instance after user defined period of inactivity. Time is defined in ISO8601 format. Minimum is 15 min, maximum is 3 days.
	IdleTimeBeforeShutdown *string `pulumi:"idleTimeBeforeShutdown"`
	// Settings for a personal compute instance.
	PersonalComputeInstanceSettings *PersonalComputeInstanceSettings `pulumi:"personalComputeInstanceSettings"`
	// The list of schedules to be applied on the computes.
	Schedules *ComputeSchedules `pulumi:"schedules"`
	// Details of customized scripts to execute for setting up the cluster.
	SetupScripts *SetupScripts `pulumi:"setupScripts"`
	// Specifies policy and settings for SSH access.
	SshSettings *ComputeInstanceSshSettings `pulumi:"sshSettings"`
	// Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId `pulumi:"subnet"`
	// Virtual Machine Size
	VmSize *string `pulumi:"vmSize"`
}

// Defaults sets the appropriate defaults for ComputeInstanceProperties
func (val *ComputeInstanceProperties) Defaults() *ComputeInstanceProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ApplicationSharingPolicy == nil {
		applicationSharingPolicy_ := "Shared"
		tmp.ApplicationSharingPolicy = &applicationSharingPolicy_
	}
	if tmp.ComputeInstanceAuthorizationType == nil {
		computeInstanceAuthorizationType_ := "personal"
		tmp.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType_
	}
	if tmp.EnableNodePublicIp == nil {
		enableNodePublicIp_ := true
		tmp.EnableNodePublicIp = &enableNodePublicIp_
	}
	tmp.SshSettings = tmp.SshSettings.Defaults()

	return &tmp
}

// Compute Instance properties
type ComputeInstancePropertiesResponse struct {
	// Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
	ApplicationSharingPolicy *string `pulumi:"applicationSharingPolicy"`
	// Describes available applications and their endpoints on this ComputeInstance.
	Applications []ComputeInstanceApplicationResponse `pulumi:"applications"`
	// Specifies settings for autologger.
	AutologgerSettings *ComputeInstanceAutologgerSettingsResponse `pulumi:"autologgerSettings"`
	// The Compute Instance Authorization type. Available values are personal (default).
	ComputeInstanceAuthorizationType *string `pulumi:"computeInstanceAuthorizationType"`
	// Describes all connectivity endpoints available for this ComputeInstance.
	ConnectivityEndpoints ComputeInstanceConnectivityEndpointsResponse `pulumi:"connectivityEndpoints"`
	// Describes informations of containers on this ComputeInstance.
	Containers []ComputeInstanceContainerResponse `pulumi:"containers"`
	// Describes information on user who created this ComputeInstance.
	CreatedBy ComputeInstanceCreatedByResponse `pulumi:"createdBy"`
	// List of Custom Services added to the compute.
	CustomServices []CustomServiceResponse `pulumi:"customServices"`
	// Describes informations of dataDisks on this ComputeInstance.
	DataDisks []ComputeInstanceDataDiskResponse `pulumi:"dataDisks"`
	// Describes informations of dataMounts on this ComputeInstance.
	DataMounts []ComputeInstanceDataMountResponse `pulumi:"dataMounts"`
	// Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `pulumi:"enableNodePublicIp"`
	// Collection of errors encountered on this ComputeInstance.
	Errors []ErrorResponseResponse `pulumi:"errors"`
	// Stops compute instance after user defined period of inactivity. Time is defined in ISO8601 format. Minimum is 15 min, maximum is 3 days.
	IdleTimeBeforeShutdown *string `pulumi:"idleTimeBeforeShutdown"`
	// The last operation on ComputeInstance.
	LastOperation ComputeInstanceLastOperationResponse `pulumi:"lastOperation"`
	// Returns metadata about the operating system image for this compute instance.
	OsImageMetadata ImageMetadataResponse `pulumi:"osImageMetadata"`
	// Settings for a personal compute instance.
	PersonalComputeInstanceSettings *PersonalComputeInstanceSettingsResponse `pulumi:"personalComputeInstanceSettings"`
	// The list of schedules to be applied on the computes.
	Schedules *ComputeSchedulesResponse `pulumi:"schedules"`
	// Details of customized scripts to execute for setting up the cluster.
	SetupScripts *SetupScriptsResponse `pulumi:"setupScripts"`
	// Specifies policy and settings for SSH access.
	SshSettings *ComputeInstanceSshSettingsResponse `pulumi:"sshSettings"`
	// The current state of this ComputeInstance.
	State string `pulumi:"state"`
	// Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceIdResponse `pulumi:"subnet"`
	// ComputeInstance version.
	Versions ComputeInstanceVersionResponse `pulumi:"versions"`
	// Virtual Machine Size
	VmSize *string `pulumi:"vmSize"`
}

// Defaults sets the appropriate defaults for ComputeInstancePropertiesResponse
func (val *ComputeInstancePropertiesResponse) Defaults() *ComputeInstancePropertiesResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ApplicationSharingPolicy == nil {
		applicationSharingPolicy_ := "Shared"
		tmp.ApplicationSharingPolicy = &applicationSharingPolicy_
	}
	if tmp.ComputeInstanceAuthorizationType == nil {
		computeInstanceAuthorizationType_ := "personal"
		tmp.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType_
	}
	if tmp.EnableNodePublicIp == nil {
		enableNodePublicIp_ := true
		tmp.EnableNodePublicIp = &enableNodePublicIp_
	}
	tmp.SshSettings = tmp.SshSettings.Defaults()

	return &tmp
}

// An Azure Machine Learning compute instance.
type ComputeInstanceResponse struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'ComputeInstance'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// Properties of ComputeInstance
	Properties *ComputeInstancePropertiesResponse `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for ComputeInstanceResponse
func (val *ComputeInstanceResponse) Defaults() *ComputeInstanceResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// Specifies policy and settings for SSH access.
type ComputeInstanceSshSettings struct {
	// Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH key pairs.
	AdminPublicKey *string `pulumi:"adminPublicKey"`
	// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
	SshPublicAccess *string `pulumi:"sshPublicAccess"`
}

// Defaults sets the appropriate defaults for ComputeInstanceSshSettings
func (val *ComputeInstanceSshSettings) Defaults() *ComputeInstanceSshSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.SshPublicAccess == nil {
		sshPublicAccess_ := "Disabled"
		tmp.SshPublicAccess = &sshPublicAccess_
	}
	return &tmp
}

// Specifies policy and settings for SSH access.
type ComputeInstanceSshSettingsResponse struct {
	// Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH key pairs.
	AdminPublicKey *string `pulumi:"adminPublicKey"`
	// Describes the admin user name.
	AdminUserName string `pulumi:"adminUserName"`
	// Describes the port for connecting through SSH.
	SshPort int `pulumi:"sshPort"`
	// State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
	SshPublicAccess *string `pulumi:"sshPublicAccess"`
}

// Defaults sets the appropriate defaults for ComputeInstanceSshSettingsResponse
func (val *ComputeInstanceSshSettingsResponse) Defaults() *ComputeInstanceSshSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.SshPublicAccess == nil {
		sshPublicAccess_ := "Disabled"
		tmp.SshPublicAccess = &sshPublicAccess_
	}
	return &tmp
}

// Version of computeInstance.
type ComputeInstanceVersionResponse struct {
	// Runtime of compute instance.
	Runtime *string `pulumi:"runtime"`
}

type ComputeRuntimeDto struct {
	SparkRuntimeVersion *string `pulumi:"sparkRuntimeVersion"`
}

// ComputeRuntimeDtoInput is an input type that accepts ComputeRuntimeDtoArgs and ComputeRuntimeDtoOutput values.
// You can construct a concrete instance of `ComputeRuntimeDtoInput` via:
//
//	ComputeRuntimeDtoArgs{...}
type ComputeRuntimeDtoInput interface {
	pulumi.Input

	ToComputeRuntimeDtoOutput() ComputeRuntimeDtoOutput
	ToComputeRuntimeDtoOutputWithContext(context.Context) ComputeRuntimeDtoOutput
}

type ComputeRuntimeDtoArgs struct {
	SparkRuntimeVersion pulumi.StringPtrInput `pulumi:"sparkRuntimeVersion"`
}

func (ComputeRuntimeDtoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ComputeRuntimeDto)(nil)).Elem()
}

func (i ComputeRuntimeDtoArgs) ToComputeRuntimeDtoOutput() ComputeRuntimeDtoOutput {
	return i.ToComputeRuntimeDtoOutputWithContext(context.Background())
}

func (i ComputeRuntimeDtoArgs) ToComputeRuntimeDtoOutputWithContext(ctx context.Context) ComputeRuntimeDtoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeRuntimeDtoOutput)
}

func (i ComputeRuntimeDtoArgs) ToComputeRuntimeDtoPtrOutput() ComputeRuntimeDtoPtrOutput {
	return i.ToComputeRuntimeDtoPtrOutputWithContext(context.Background())
}

func (i ComputeRuntimeDtoArgs) ToComputeRuntimeDtoPtrOutputWithContext(ctx context.Context) ComputeRuntimeDtoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeRuntimeDtoOutput).ToComputeRuntimeDtoPtrOutputWithContext(ctx)
}

// ComputeRuntimeDtoPtrInput is an input type that accepts ComputeRuntimeDtoArgs, ComputeRuntimeDtoPtr and ComputeRuntimeDtoPtrOutput values.
// You can construct a concrete instance of `ComputeRuntimeDtoPtrInput` via:
//
//	        ComputeRuntimeDtoArgs{...}
//
//	or:
//
//	        nil
type ComputeRuntimeDtoPtrInput interface {
	pulumi.Input

	ToComputeRuntimeDtoPtrOutput() ComputeRuntimeDtoPtrOutput
	ToComputeRuntimeDtoPtrOutputWithContext(context.Context) ComputeRuntimeDtoPtrOutput
}

type computeRuntimeDtoPtrType ComputeRuntimeDtoArgs

func ComputeRuntimeDtoPtr(v *ComputeRuntimeDtoArgs) ComputeRuntimeDtoPtrInput {
	return (*computeRuntimeDtoPtrType)(v)
}

func (*computeRuntimeDtoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ComputeRuntimeDto)(nil)).Elem()
}

func (i *computeRuntimeDtoPtrType) ToComputeRuntimeDtoPtrOutput() ComputeRuntimeDtoPtrOutput {
	return i.ToComputeRuntimeDtoPtrOutputWithContext(context.Background())
}

func (i *computeRuntimeDtoPtrType) ToComputeRuntimeDtoPtrOutputWithContext(ctx context.Context) ComputeRuntimeDtoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeRuntimeDtoPtrOutput)
}

type ComputeRuntimeDtoOutput struct{ *pulumi.OutputState }

func (ComputeRuntimeDtoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComputeRuntimeDto)(nil)).Elem()
}

func (o ComputeRuntimeDtoOutput) ToComputeRuntimeDtoOutput() ComputeRuntimeDtoOutput {
	return o
}

func (o ComputeRuntimeDtoOutput) ToComputeRuntimeDtoOutputWithContext(ctx context.Context) ComputeRuntimeDtoOutput {
	return o
}

func (o ComputeRuntimeDtoOutput) ToComputeRuntimeDtoPtrOutput() ComputeRuntimeDtoPtrOutput {
	return o.ToComputeRuntimeDtoPtrOutputWithContext(context.Background())
}

func (o ComputeRuntimeDtoOutput) ToComputeRuntimeDtoPtrOutputWithContext(ctx context.Context) ComputeRuntimeDtoPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ComputeRuntimeDto) *ComputeRuntimeDto {
		return &v
	}).(ComputeRuntimeDtoPtrOutput)
}

func (o ComputeRuntimeDtoOutput) SparkRuntimeVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComputeRuntimeDto) *string { return v.SparkRuntimeVersion }).(pulumi.StringPtrOutput)
}

type ComputeRuntimeDtoPtrOutput struct{ *pulumi.OutputState }

func (ComputeRuntimeDtoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ComputeRuntimeDto)(nil)).Elem()
}

func (o ComputeRuntimeDtoPtrOutput) ToComputeRuntimeDtoPtrOutput() ComputeRuntimeDtoPtrOutput {
	return o
}

func (o ComputeRuntimeDtoPtrOutput) ToComputeRuntimeDtoPtrOutputWithContext(ctx context.Context) ComputeRuntimeDtoPtrOutput {
	return o
}

func (o ComputeRuntimeDtoPtrOutput) Elem() ComputeRuntimeDtoOutput {
	return o.ApplyT(func(v *ComputeRuntimeDto) ComputeRuntimeDto {
		if v != nil {
			return *v
		}
		var ret ComputeRuntimeDto
		return ret
	}).(ComputeRuntimeDtoOutput)
}

func (o ComputeRuntimeDtoPtrOutput) SparkRuntimeVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ComputeRuntimeDto) *string {
		if v == nil {
			return nil
		}
		return v.SparkRuntimeVersion
	}).(pulumi.StringPtrOutput)
}

type ComputeRuntimeDtoResponse struct {
	SparkRuntimeVersion *string `pulumi:"sparkRuntimeVersion"`
}

type ComputeRuntimeDtoResponseOutput struct{ *pulumi.OutputState }

func (ComputeRuntimeDtoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComputeRuntimeDtoResponse)(nil)).Elem()
}

func (o ComputeRuntimeDtoResponseOutput) ToComputeRuntimeDtoResponseOutput() ComputeRuntimeDtoResponseOutput {
	return o
}

func (o ComputeRuntimeDtoResponseOutput) ToComputeRuntimeDtoResponseOutputWithContext(ctx context.Context) ComputeRuntimeDtoResponseOutput {
	return o
}

func (o ComputeRuntimeDtoResponseOutput) SparkRuntimeVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComputeRuntimeDtoResponse) *string { return v.SparkRuntimeVersion }).(pulumi.StringPtrOutput)
}

type ComputeRuntimeDtoResponsePtrOutput struct{ *pulumi.OutputState }

func (ComputeRuntimeDtoResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ComputeRuntimeDtoResponse)(nil)).Elem()
}

func (o ComputeRuntimeDtoResponsePtrOutput) ToComputeRuntimeDtoResponsePtrOutput() ComputeRuntimeDtoResponsePtrOutput {
	return o
}

func (o ComputeRuntimeDtoResponsePtrOutput) ToComputeRuntimeDtoResponsePtrOutputWithContext(ctx context.Context) ComputeRuntimeDtoResponsePtrOutput {
	return o
}

func (o ComputeRuntimeDtoResponsePtrOutput) Elem() ComputeRuntimeDtoResponseOutput {
	return o.ApplyT(func(v *ComputeRuntimeDtoResponse) ComputeRuntimeDtoResponse {
		if v != nil {
			return *v
		}
		var ret ComputeRuntimeDtoResponse
		return ret
	}).(ComputeRuntimeDtoResponseOutput)
}

func (o ComputeRuntimeDtoResponsePtrOutput) SparkRuntimeVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ComputeRuntimeDtoResponse) *string {
		if v == nil {
			return nil
		}
		return v.SparkRuntimeVersion
	}).(pulumi.StringPtrOutput)
}

// The list of schedules to be applied on the computes
type ComputeSchedules struct {
	// The list of compute start stop schedules to be applied.
	ComputeStartStop []ComputeStartStopSchedule `pulumi:"computeStartStop"`
}

// The list of schedules to be applied on the computes
type ComputeSchedulesResponse struct {
	// The list of compute start stop schedules to be applied.
	ComputeStartStop []ComputeStartStopScheduleResponse `pulumi:"computeStartStop"`
}

// Compute start stop schedule properties
type ComputeStartStopSchedule struct {
	// [Required] The compute power action.
	Action *string `pulumi:"action"`
	// Required if triggerType is Cron.
	Cron *Cron `pulumi:"cron"`
	// Required if triggerType is Recurrence.
	Recurrence *Recurrence `pulumi:"recurrence"`
	// [Deprecated] Not used any more.
	Schedule *ScheduleBase `pulumi:"schedule"`
	// Is the schedule enabled or disabled?
	Status *string `pulumi:"status"`
	// [Required] The schedule trigger type.
	TriggerType *string `pulumi:"triggerType"`
}

// Defaults sets the appropriate defaults for ComputeStartStopSchedule
func (val *ComputeStartStopSchedule) Defaults() *ComputeStartStopSchedule {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Cron = tmp.Cron.Defaults()

	tmp.Recurrence = tmp.Recurrence.Defaults()

	return &tmp
}

// Compute start stop schedule properties
type ComputeStartStopScheduleResponse struct {
	// [Required] The compute power action.
	Action *string `pulumi:"action"`
	// Required if triggerType is Cron.
	Cron *CronResponse `pulumi:"cron"`
	// A system assigned id for the schedule.
	Id string `pulumi:"id"`
	// The current deployment state of schedule.
	ProvisioningStatus string `pulumi:"provisioningStatus"`
	// Required if triggerType is Recurrence.
	Recurrence *RecurrenceResponse `pulumi:"recurrence"`
	// [Deprecated] Not used any more.
	Schedule *ScheduleBaseResponse `pulumi:"schedule"`
	// Is the schedule enabled or disabled?
	Status *string `pulumi:"status"`
	// [Required] The schedule trigger type.
	TriggerType *string `pulumi:"triggerType"`
}

// Defaults sets the appropriate defaults for ComputeStartStopScheduleResponse
func (val *ComputeStartStopScheduleResponse) Defaults() *ComputeStartStopScheduleResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Cron = tmp.Cron.Defaults()

	tmp.Recurrence = tmp.Recurrence.Defaults()

	return &tmp
}

// Resource requirements for each container instance within an online deployment.
type ContainerResourceRequirements struct {
	// Container resource limit info:
	ContainerResourceLimits *ContainerResourceSettings `pulumi:"containerResourceLimits"`
	// Container resource request info:
	ContainerResourceRequests *ContainerResourceSettings `pulumi:"containerResourceRequests"`
}

// Resource requirements for each container instance within an online deployment.
type ContainerResourceRequirementsResponse struct {
	// Container resource limit info:
	ContainerResourceLimits *ContainerResourceSettingsResponse `pulumi:"containerResourceLimits"`
	// Container resource request info:
	ContainerResourceRequests *ContainerResourceSettingsResponse `pulumi:"containerResourceRequests"`
}

type ContainerResourceSettings struct {
	// Number of vCPUs request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Cpu *string `pulumi:"cpu"`
	// Number of Nvidia GPU cards request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Gpu *string `pulumi:"gpu"`
	// Memory size request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Memory *string `pulumi:"memory"`
}

type ContainerResourceSettingsResponse struct {
	// Number of vCPUs request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Cpu *string `pulumi:"cpu"`
	// Number of Nvidia GPU cards request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Gpu *string `pulumi:"gpu"`
	// Memory size request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Memory *string `pulumi:"memory"`
}

type CosmosDbSettings struct {
	CollectionsThroughput *int `pulumi:"collectionsThroughput"`
}

// CosmosDbSettingsInput is an input type that accepts CosmosDbSettingsArgs and CosmosDbSettingsOutput values.
// You can construct a concrete instance of `CosmosDbSettingsInput` via:
//
//	CosmosDbSettingsArgs{...}
type CosmosDbSettingsInput interface {
	pulumi.Input

	ToCosmosDbSettingsOutput() CosmosDbSettingsOutput
	ToCosmosDbSettingsOutputWithContext(context.Context) CosmosDbSettingsOutput
}

type CosmosDbSettingsArgs struct {
	CollectionsThroughput pulumi.IntPtrInput `pulumi:"collectionsThroughput"`
}

func (CosmosDbSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CosmosDbSettings)(nil)).Elem()
}

func (i CosmosDbSettingsArgs) ToCosmosDbSettingsOutput() CosmosDbSettingsOutput {
	return i.ToCosmosDbSettingsOutputWithContext(context.Background())
}

func (i CosmosDbSettingsArgs) ToCosmosDbSettingsOutputWithContext(ctx context.Context) CosmosDbSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CosmosDbSettingsOutput)
}

func (i CosmosDbSettingsArgs) ToCosmosDbSettingsPtrOutput() CosmosDbSettingsPtrOutput {
	return i.ToCosmosDbSettingsPtrOutputWithContext(context.Background())
}

func (i CosmosDbSettingsArgs) ToCosmosDbSettingsPtrOutputWithContext(ctx context.Context) CosmosDbSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CosmosDbSettingsOutput).ToCosmosDbSettingsPtrOutputWithContext(ctx)
}

// CosmosDbSettingsPtrInput is an input type that accepts CosmosDbSettingsArgs, CosmosDbSettingsPtr and CosmosDbSettingsPtrOutput values.
// You can construct a concrete instance of `CosmosDbSettingsPtrInput` via:
//
//	        CosmosDbSettingsArgs{...}
//
//	or:
//
//	        nil
type CosmosDbSettingsPtrInput interface {
	pulumi.Input

	ToCosmosDbSettingsPtrOutput() CosmosDbSettingsPtrOutput
	ToCosmosDbSettingsPtrOutputWithContext(context.Context) CosmosDbSettingsPtrOutput
}

type cosmosDbSettingsPtrType CosmosDbSettingsArgs

func CosmosDbSettingsPtr(v *CosmosDbSettingsArgs) CosmosDbSettingsPtrInput {
	return (*cosmosDbSettingsPtrType)(v)
}

func (*cosmosDbSettingsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CosmosDbSettings)(nil)).Elem()
}

func (i *cosmosDbSettingsPtrType) ToCosmosDbSettingsPtrOutput() CosmosDbSettingsPtrOutput {
	return i.ToCosmosDbSettingsPtrOutputWithContext(context.Background())
}

func (i *cosmosDbSettingsPtrType) ToCosmosDbSettingsPtrOutputWithContext(ctx context.Context) CosmosDbSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CosmosDbSettingsPtrOutput)
}

type CosmosDbSettingsOutput struct{ *pulumi.OutputState }

func (CosmosDbSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CosmosDbSettings)(nil)).Elem()
}

func (o CosmosDbSettingsOutput) ToCosmosDbSettingsOutput() CosmosDbSettingsOutput {
	return o
}

func (o CosmosDbSettingsOutput) ToCosmosDbSettingsOutputWithContext(ctx context.Context) CosmosDbSettingsOutput {
	return o
}

func (o CosmosDbSettingsOutput) ToCosmosDbSettingsPtrOutput() CosmosDbSettingsPtrOutput {
	return o.ToCosmosDbSettingsPtrOutputWithContext(context.Background())
}

func (o CosmosDbSettingsOutput) ToCosmosDbSettingsPtrOutputWithContext(ctx context.Context) CosmosDbSettingsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CosmosDbSettings) *CosmosDbSettings {
		return &v
	}).(CosmosDbSettingsPtrOutput)
}

func (o CosmosDbSettingsOutput) CollectionsThroughput() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CosmosDbSettings) *int { return v.CollectionsThroughput }).(pulumi.IntPtrOutput)
}

type CosmosDbSettingsPtrOutput struct{ *pulumi.OutputState }

func (CosmosDbSettingsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CosmosDbSettings)(nil)).Elem()
}

func (o CosmosDbSettingsPtrOutput) ToCosmosDbSettingsPtrOutput() CosmosDbSettingsPtrOutput {
	return o
}

func (o CosmosDbSettingsPtrOutput) ToCosmosDbSettingsPtrOutputWithContext(ctx context.Context) CosmosDbSettingsPtrOutput {
	return o
}

func (o CosmosDbSettingsPtrOutput) Elem() CosmosDbSettingsOutput {
	return o.ApplyT(func(v *CosmosDbSettings) CosmosDbSettings {
		if v != nil {
			return *v
		}
		var ret CosmosDbSettings
		return ret
	}).(CosmosDbSettingsOutput)
}

func (o CosmosDbSettingsPtrOutput) CollectionsThroughput() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CosmosDbSettings) *int {
		if v == nil {
			return nil
		}
		return v.CollectionsThroughput
	}).(pulumi.IntPtrOutput)
}

type CosmosDbSettingsResponse struct {
	CollectionsThroughput *int `pulumi:"collectionsThroughput"`
}

type CosmosDbSettingsResponseOutput struct{ *pulumi.OutputState }

func (CosmosDbSettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CosmosDbSettingsResponse)(nil)).Elem()
}

func (o CosmosDbSettingsResponseOutput) ToCosmosDbSettingsResponseOutput() CosmosDbSettingsResponseOutput {
	return o
}

func (o CosmosDbSettingsResponseOutput) ToCosmosDbSettingsResponseOutputWithContext(ctx context.Context) CosmosDbSettingsResponseOutput {
	return o
}

func (o CosmosDbSettingsResponseOutput) CollectionsThroughput() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CosmosDbSettingsResponse) *int { return v.CollectionsThroughput }).(pulumi.IntPtrOutput)
}

type CosmosDbSettingsResponsePtrOutput struct{ *pulumi.OutputState }

func (CosmosDbSettingsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CosmosDbSettingsResponse)(nil)).Elem()
}

func (o CosmosDbSettingsResponsePtrOutput) ToCosmosDbSettingsResponsePtrOutput() CosmosDbSettingsResponsePtrOutput {
	return o
}

func (o CosmosDbSettingsResponsePtrOutput) ToCosmosDbSettingsResponsePtrOutputWithContext(ctx context.Context) CosmosDbSettingsResponsePtrOutput {
	return o
}

func (o CosmosDbSettingsResponsePtrOutput) Elem() CosmosDbSettingsResponseOutput {
	return o.ApplyT(func(v *CosmosDbSettingsResponse) CosmosDbSettingsResponse {
		if v != nil {
			return *v
		}
		var ret CosmosDbSettingsResponse
		return ret
	}).(CosmosDbSettingsResponseOutput)
}

func (o CosmosDbSettingsResponsePtrOutput) CollectionsThroughput() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CosmosDbSettingsResponse) *int {
		if v == nil {
			return nil
		}
		return v.CollectionsThroughput
	}).(pulumi.IntPtrOutput)
}

type CreateMonitorAction struct {
	// Expected value is 'CreateMonitor'.
	ActionType string `pulumi:"actionType"`
	// [Required] Defines the monitor.
	MonitorDefinition MonitorDefinition `pulumi:"monitorDefinition"`
}

type CreateMonitorActionResponse struct {
	// Expected value is 'CreateMonitor'.
	ActionType string `pulumi:"actionType"`
	// [Required] Defines the monitor.
	MonitorDefinition MonitorDefinitionResponse `pulumi:"monitorDefinition"`
}

// The workflow trigger cron for ComputeStartStop schedule type.
type Cron struct {
	// [Required] Specifies cron expression of schedule.
	// The expression should follow NCronTab format.
	Expression *string `pulumi:"expression"`
	// The start time in yyyy-MM-ddTHH:mm:ss format.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `pulumi:"timeZone"`
}

// Defaults sets the appropriate defaults for Cron
func (val *Cron) Defaults() *Cron {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.TimeZone == nil {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

// The workflow trigger cron for ComputeStartStop schedule type.
type CronResponse struct {
	// [Required] Specifies cron expression of schedule.
	// The expression should follow NCronTab format.
	Expression *string `pulumi:"expression"`
	// The start time in yyyy-MM-ddTHH:mm:ss format.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `pulumi:"timeZone"`
}

// Defaults sets the appropriate defaults for CronResponse
func (val *CronResponse) Defaults() *CronResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.TimeZone == nil {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

type CronTrigger struct {
	// Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
	// Recommented format would be "2022-06-01T00:00:01"
	// If not present, the schedule will run indefinitely
	EndTime *string `pulumi:"endTime"`
	// [Required] Specifies cron expression of schedule.
	// The expression should follow NCronTab format.
	Expression string `pulumi:"expression"`
	// Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `pulumi:"timeZone"`
	// Expected value is 'Cron'.
	TriggerType string `pulumi:"triggerType"`
}

// Defaults sets the appropriate defaults for CronTrigger
func (val *CronTrigger) Defaults() *CronTrigger {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.TimeZone == nil {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

type CronTriggerResponse struct {
	// Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
	// Recommented format would be "2022-06-01T00:00:01"
	// If not present, the schedule will run indefinitely
	EndTime *string `pulumi:"endTime"`
	// [Required] Specifies cron expression of schedule.
	// The expression should follow NCronTab format.
	Expression string `pulumi:"expression"`
	// Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `pulumi:"timeZone"`
	// Expected value is 'Cron'.
	TriggerType string `pulumi:"triggerType"`
}

// Defaults sets the appropriate defaults for CronTriggerResponse
func (val *CronTriggerResponse) Defaults() *CronTriggerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.TimeZone == nil {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

// The desired maximum forecast horizon in units of time-series frequency.
type CustomForecastHorizon struct {
	// Enum to determine forecast horizon selection mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Forecast horizon value.
	Value int `pulumi:"value"`
}

// The desired maximum forecast horizon in units of time-series frequency.
type CustomForecastHorizonResponse struct {
	// Enum to determine forecast horizon selection mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Forecast horizon value.
	Value int `pulumi:"value"`
}

// Custom Keys credential object
type CustomKeys struct {
	Keys map[string]string `pulumi:"keys"`
}

// Custom Keys credential object
type CustomKeysResponse struct {
	Keys map[string]string `pulumi:"keys"`
}

// Category:= CustomKeys
// AuthType:= CustomKeys (as type discriminator)
// Credentials:= {CustomKeys} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.CustomKeys
// Target:= {any value}
// Use Metadata property bag for ApiVersion and other metadata fields
type CustomKeysWorkspaceConnectionProperties struct {
	// Authentication type of the connection target
	// Expected value is 'CustomKeys'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category *string `pulumi:"category"`
	// Custom Keys credential object
	Credentials *CustomKeys `pulumi:"credentials"`
	ExpiryTime  *string     `pulumi:"expiryTime"`
	Metadata    interface{} `pulumi:"metadata"`
	Target      *string     `pulumi:"target"`
}

// Category:= CustomKeys
// AuthType:= CustomKeys (as type discriminator)
// Credentials:= {CustomKeys} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.CustomKeys
// Target:= {any value}
// Use Metadata property bag for ApiVersion and other metadata fields
type CustomKeysWorkspaceConnectionPropertiesResponse struct {
	// Authentication type of the connection target
	// Expected value is 'CustomKeys'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category *string `pulumi:"category"`
	// Custom Keys credential object
	Credentials *CustomKeysResponse `pulumi:"credentials"`
	ExpiryTime  *string             `pulumi:"expiryTime"`
	Metadata    interface{}         `pulumi:"metadata"`
	Target      *string             `pulumi:"target"`
}

type CustomMetricThreshold struct {
	// [Required] The user-defined metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

type CustomMetricThresholdResponse struct {
	// [Required] The user-defined metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

type CustomModelJobInput struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'custom_model'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for CustomModelJobInput
func (val *CustomModelJobInput) Defaults() *CustomModelJobInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type CustomModelJobInputResponse struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'custom_model'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for CustomModelJobInputResponse
func (val *CustomModelJobInputResponse) Defaults() *CustomModelJobInputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type CustomModelJobOutput struct {
	// Output Asset Name.
	AssetName *string `pulumi:"assetName"`
	// Output Asset Version.
	AssetVersion *string `pulumi:"assetVersion"`
	// Auto delete setting of output data asset.
	AutoDeleteSetting *AutoDeleteSetting `pulumi:"autoDeleteSetting"`
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'custom_model'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for CustomModelJobOutput
func (val *CustomModelJobOutput) Defaults() *CustomModelJobOutput {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.Mode == nil {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type CustomModelJobOutputResponse struct {
	// Output Asset Name.
	AssetName *string `pulumi:"assetName"`
	// Output Asset Version.
	AssetVersion *string `pulumi:"assetVersion"`
	// Auto delete setting of output data asset.
	AutoDeleteSetting *AutoDeleteSettingResponse `pulumi:"autoDeleteSetting"`
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'custom_model'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for CustomModelJobOutputResponse
func (val *CustomModelJobOutputResponse) Defaults() *CustomModelJobOutputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.Mode == nil {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type CustomMonitoringSignal struct {
	// [Required] ARM resource ID of the component resource used to calculate the custom metrics.
	ComponentId string `pulumi:"componentId"`
	// Monitoring assets to take as input. Key is the component input port name, value is the data asset.
	InputAssets map[string]interface{} `pulumi:"inputAssets"`
	// Extra component parameters to take as input. Key is the component literal input port name, value is the parameter value.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThresholds []CustomMetricThreshold `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Expected value is 'Custom'.
	SignalType string `pulumi:"signalType"`
	// [Required] A list of metrics to calculate and their associated thresholds.
	WorkspaceConnection MonitoringWorkspaceConnection `pulumi:"workspaceConnection"`
}

// Defaults sets the appropriate defaults for CustomMonitoringSignal
func (val *CustomMonitoringSignal) Defaults() *CustomMonitoringSignal {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

type CustomMonitoringSignalResponse struct {
	// [Required] ARM resource ID of the component resource used to calculate the custom metrics.
	ComponentId string `pulumi:"componentId"`
	// Monitoring assets to take as input. Key is the component input port name, value is the data asset.
	InputAssets map[string]interface{} `pulumi:"inputAssets"`
	// Extra component parameters to take as input. Key is the component literal input port name, value is the parameter value.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThresholds []CustomMetricThresholdResponse `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Expected value is 'Custom'.
	SignalType string `pulumi:"signalType"`
	// [Required] A list of metrics to calculate and their associated thresholds.
	WorkspaceConnection MonitoringWorkspaceConnectionResponse `pulumi:"workspaceConnection"`
}

// Defaults sets the appropriate defaults for CustomMonitoringSignalResponse
func (val *CustomMonitoringSignalResponse) Defaults() *CustomMonitoringSignalResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

// N-Cross validations are specified by user.
type CustomNCrossValidations struct {
	// Determines how N-Cross validations value is determined.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] N-Cross validations value.
	Value int `pulumi:"value"`
}

// N-Cross validations are specified by user.
type CustomNCrossValidationsResponse struct {
	// Determines how N-Cross validations value is determined.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] N-Cross validations value.
	Value int `pulumi:"value"`
}

type CustomSeasonality struct {
	// Forecasting seasonality mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Seasonality value.
	Value int `pulumi:"value"`
}

type CustomSeasonalityResponse struct {
	// Forecasting seasonality mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Seasonality value.
	Value int `pulumi:"value"`
}

// Specifies the custom service configuration
type CustomService struct {
	// Describes the docker settings for the image
	Docker *Docker `pulumi:"docker"`
	// Configuring the endpoints for the container
	Endpoints []Endpoint `pulumi:"endpoints"`
	// Environment Variable for the container
	EnvironmentVariables map[string]EnvironmentVariable `pulumi:"environmentVariables"`
	// Describes the Image Specifications
	Image *Image `pulumi:"image"`
	// Name of the Custom Service
	Name *string `pulumi:"name"`
	// Configuring the volumes for the container
	Volumes []VolumeDefinition `pulumi:"volumes"`
}

// Defaults sets the appropriate defaults for CustomService
func (val *CustomService) Defaults() *CustomService {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Image = tmp.Image.Defaults()

	return &tmp
}

// Specifies the custom service configuration
type CustomServiceResponse struct {
	// Describes the docker settings for the image
	Docker *DockerResponse `pulumi:"docker"`
	// Configuring the endpoints for the container
	Endpoints []EndpointResponse `pulumi:"endpoints"`
	// Environment Variable for the container
	EnvironmentVariables map[string]EnvironmentVariableResponse `pulumi:"environmentVariables"`
	// Describes the Image Specifications
	Image *ImageResponse `pulumi:"image"`
	// Name of the Custom Service
	Name *string `pulumi:"name"`
	// Configuring the volumes for the container
	Volumes []VolumeDefinitionResponse `pulumi:"volumes"`
}

// Defaults sets the appropriate defaults for CustomServiceResponse
func (val *CustomServiceResponse) Defaults() *CustomServiceResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Image = tmp.Image.Defaults()

	return &tmp
}

type CustomTargetLags struct {
	// Target lags selection modes.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Set target lags values.
	Values []int `pulumi:"values"`
}

type CustomTargetLagsResponse struct {
	// Target lags selection modes.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] Set target lags values.
	Values []int `pulumi:"values"`
}

type CustomTargetRollingWindowSize struct {
	// Target rolling windows size mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] TargetRollingWindowSize value.
	Value int `pulumi:"value"`
}

type CustomTargetRollingWindowSizeResponse struct {
	// Target rolling windows size mode.
	// Expected value is 'Custom'.
	Mode string `pulumi:"mode"`
	// [Required] TargetRollingWindowSize value.
	Value int `pulumi:"value"`
}

type DataCollector struct {
	// [Required] The collection configuration. Each collection has it own configuration to collect model data and the name of collection can be arbitrary string.
	// Model data collector can be used for either payload logging or custom logging or both of them. Collection request and response are reserved for payload logging, others are for custom logging.
	Collections map[string]Collection `pulumi:"collections"`
	// The request logging configuration for mdc, it includes advanced logging settings for all collections. It's optional.
	RequestLogging *RequestLogging `pulumi:"requestLogging"`
	// When model data is collected to blob storage, we need to roll the data to different path to avoid logging all of them in a single blob file.
	// If the rolling rate is hour, all data will be collected in the blob path /yyyy/MM/dd/HH/.
	// If it's day, all data will be collected in blob path /yyyy/MM/dd/.
	// The other benefit of rolling path is that model monitoring ui is able to select a time range of data very quickly.
	RollingRate *string `pulumi:"rollingRate"`
}

// Defaults sets the appropriate defaults for DataCollector
func (val *DataCollector) Defaults() *DataCollector {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.RollingRate == nil {
		rollingRate_ := "Hour"
		tmp.RollingRate = &rollingRate_
	}
	return &tmp
}

type DataCollectorResponse struct {
	// [Required] The collection configuration. Each collection has it own configuration to collect model data and the name of collection can be arbitrary string.
	// Model data collector can be used for either payload logging or custom logging or both of them. Collection request and response are reserved for payload logging, others are for custom logging.
	Collections map[string]CollectionResponse `pulumi:"collections"`
	// The request logging configuration for mdc, it includes advanced logging settings for all collections. It's optional.
	RequestLogging *RequestLoggingResponse `pulumi:"requestLogging"`
	// When model data is collected to blob storage, we need to roll the data to different path to avoid logging all of them in a single blob file.
	// If the rolling rate is hour, all data will be collected in the blob path /yyyy/MM/dd/HH/.
	// If it's day, all data will be collected in blob path /yyyy/MM/dd/.
	// The other benefit of rolling path is that model monitoring ui is able to select a time range of data very quickly.
	RollingRate *string `pulumi:"rollingRate"`
}

// Defaults sets the appropriate defaults for DataCollectorResponse
func (val *DataCollectorResponse) Defaults() *DataCollectorResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.RollingRate == nil {
		rollingRate_ := "Hour"
		tmp.RollingRate = &rollingRate_
	}
	return &tmp
}

// Container for data asset versions.
type DataContainerType struct {
	// [Required] Specifies the type of data.
	DataType string `pulumi:"dataType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for DataContainerType
func (val *DataContainerType) Defaults() *DataContainerType {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// DataContainerTypeInput is an input type that accepts DataContainerTypeArgs and DataContainerTypeOutput values.
// You can construct a concrete instance of `DataContainerTypeInput` via:
//
//	DataContainerTypeArgs{...}
type DataContainerTypeInput interface {
	pulumi.Input

	ToDataContainerTypeOutput() DataContainerTypeOutput
	ToDataContainerTypeOutputWithContext(context.Context) DataContainerTypeOutput
}

// Container for data asset versions.
type DataContainerTypeArgs struct {
	// [Required] Specifies the type of data.
	DataType pulumi.StringInput `pulumi:"dataType"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for DataContainerTypeArgs
func (val *DataContainerTypeArgs) Defaults() *DataContainerTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (DataContainerTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DataContainerType)(nil)).Elem()
}

func (i DataContainerTypeArgs) ToDataContainerTypeOutput() DataContainerTypeOutput {
	return i.ToDataContainerTypeOutputWithContext(context.Background())
}

func (i DataContainerTypeArgs) ToDataContainerTypeOutputWithContext(ctx context.Context) DataContainerTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataContainerTypeOutput)
}

// Container for data asset versions.
type DataContainerTypeOutput struct{ *pulumi.OutputState }

func (DataContainerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DataContainerType)(nil)).Elem()
}

func (o DataContainerTypeOutput) ToDataContainerTypeOutput() DataContainerTypeOutput {
	return o
}

func (o DataContainerTypeOutput) ToDataContainerTypeOutputWithContext(ctx context.Context) DataContainerTypeOutput {
	return o
}

// [Required] Specifies the type of data.
func (o DataContainerTypeOutput) DataType() pulumi.StringOutput {
	return o.ApplyT(func(v DataContainerType) string { return v.DataType }).(pulumi.StringOutput)
}

// The asset description text.
func (o DataContainerTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DataContainerType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o DataContainerTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DataContainerType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o DataContainerTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v DataContainerType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o DataContainerTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v DataContainerType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Container for data asset versions.
type DataContainerResponse struct {
	// [Required] Specifies the type of data.
	DataType string `pulumi:"dataType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for DataContainerResponse
func (val *DataContainerResponse) Defaults() *DataContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Container for data asset versions.
type DataContainerResponseOutput struct{ *pulumi.OutputState }

func (DataContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DataContainerResponse)(nil)).Elem()
}

func (o DataContainerResponseOutput) ToDataContainerResponseOutput() DataContainerResponseOutput {
	return o
}

func (o DataContainerResponseOutput) ToDataContainerResponseOutputWithContext(ctx context.Context) DataContainerResponseOutput {
	return o
}

// [Required] Specifies the type of data.
func (o DataContainerResponseOutput) DataType() pulumi.StringOutput {
	return o.ApplyT(func(v DataContainerResponse) string { return v.DataType }).(pulumi.StringOutput)
}

// The asset description text.
func (o DataContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DataContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o DataContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DataContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o DataContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v DataContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o DataContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v DataContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o DataContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v DataContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o DataContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v DataContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

type DataDriftMonitoringSignal struct {
	// The data segment used for scoping on a subset of the data population.
	DataSegment *MonitoringDataSegment `pulumi:"dataSegment"`
	// A dictionary that maps feature names to their respective data types.
	FeatureDataTypeOverride map[string]string `pulumi:"featureDataTypeOverride"`
	// The feature filter which identifies which feature to calculate drift over.
	Features interface{} `pulumi:"features"`
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThresholds []interface{} `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// [Required] The data which drift will be calculated for.
	ProductionData interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The data to calculate drift against.
	ReferenceData interface{} `pulumi:"referenceData"`
	// Expected value is 'DataDrift'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for DataDriftMonitoringSignal
func (val *DataDriftMonitoringSignal) Defaults() *DataDriftMonitoringSignal {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

type DataDriftMonitoringSignalResponse struct {
	// The data segment used for scoping on a subset of the data population.
	DataSegment *MonitoringDataSegmentResponse `pulumi:"dataSegment"`
	// A dictionary that maps feature names to their respective data types.
	FeatureDataTypeOverride map[string]string `pulumi:"featureDataTypeOverride"`
	// The feature filter which identifies which feature to calculate drift over.
	Features interface{} `pulumi:"features"`
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThresholds []interface{} `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// [Required] The data which drift will be calculated for.
	ProductionData interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The data to calculate drift against.
	ReferenceData interface{} `pulumi:"referenceData"`
	// Expected value is 'DataDrift'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for DataDriftMonitoringSignalResponse
func (val *DataDriftMonitoringSignalResponse) Defaults() *DataDriftMonitoringSignalResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

// A DataFactory compute.
type DataFactory struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'DataFactory'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// A DataFactory compute.
type DataFactoryResponse struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'DataFactory'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

type DataImport struct {
	// Name of the asset for data import job to create
	AssetName *string `pulumi:"assetName"`
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSetting `pulumi:"autoDeleteSetting"`
	// Enum to determine the type of data.
	// Expected value is 'uri_folder'.
	DataType string `pulumi:"dataType"`
	// [Required] Uri of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330
	DataUri string `pulumi:"dataUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Intellectual Property details. Used if data is an Intellectual Property.
	IntellectualProperty *IntellectualProperty `pulumi:"intellectualProperty"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Source data of the asset to import from
	Source interface{} `pulumi:"source"`
	// Stage in the data lifecycle assigned to this data asset
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for DataImport
func (val *DataImport) Defaults() *DataImport {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

type DataImportResponse struct {
	// Name of the asset for data import job to create
	AssetName *string `pulumi:"assetName"`
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSettingResponse `pulumi:"autoDeleteSetting"`
	// Enum to determine the type of data.
	// Expected value is 'uri_folder'.
	DataType string `pulumi:"dataType"`
	// [Required] Uri of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330
	DataUri string `pulumi:"dataUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Intellectual Property details. Used if data is an Intellectual Property.
	IntellectualProperty *IntellectualPropertyResponse `pulumi:"intellectualProperty"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Source data of the asset to import from
	Source interface{} `pulumi:"source"`
	// Stage in the data lifecycle assigned to this data asset
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for DataImportResponse
func (val *DataImportResponse) Defaults() *DataImportResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// A DataLakeAnalytics compute.
type DataLakeAnalytics struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'DataLakeAnalytics'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool                              `pulumi:"disableLocalAuth"`
	Properties       *DataLakeAnalyticsSchemaProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// A DataLakeAnalytics compute.
type DataLakeAnalyticsResponse struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'DataLakeAnalytics'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string                                     `pulumi:"modifiedOn"`
	Properties *DataLakeAnalyticsSchemaResponseProperties `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

type DataLakeAnalyticsSchemaProperties struct {
	// DataLake Store Account Name
	DataLakeStoreAccountName *string `pulumi:"dataLakeStoreAccountName"`
}

type DataLakeAnalyticsSchemaResponseProperties struct {
	// DataLake Store Account Name
	DataLakeStoreAccountName *string `pulumi:"dataLakeStoreAccountName"`
}

// Reference to an asset via its path in a datastore.
type DataPathAssetReference struct {
	// ARM resource ID of the datastore where the asset is located.
	DatastoreId *string `pulumi:"datastoreId"`
	// The path of the file/directory in the datastore.
	Path *string `pulumi:"path"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'DataPath'.
	ReferenceType string `pulumi:"referenceType"`
}

// Reference to an asset via its path in a datastore.
type DataPathAssetReferenceResponse struct {
	// ARM resource ID of the datastore where the asset is located.
	DatastoreId *string `pulumi:"datastoreId"`
	// The path of the file/directory in the datastore.
	Path *string `pulumi:"path"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'DataPath'.
	ReferenceType string `pulumi:"referenceType"`
}

type DataQualityMonitoringSignal struct {
	// A dictionary that maps feature names to their respective data types.
	FeatureDataTypeOverride map[string]string `pulumi:"featureDataTypeOverride"`
	// The features to calculate drift over.
	Features interface{} `pulumi:"features"`
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThresholds []interface{} `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// [Required] The data produced by the production service which drift will be calculated for.
	ProductionData interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The data to calculate drift against.
	ReferenceData interface{} `pulumi:"referenceData"`
	// Expected value is 'DataQuality'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for DataQualityMonitoringSignal
func (val *DataQualityMonitoringSignal) Defaults() *DataQualityMonitoringSignal {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

type DataQualityMonitoringSignalResponse struct {
	// A dictionary that maps feature names to their respective data types.
	FeatureDataTypeOverride map[string]string `pulumi:"featureDataTypeOverride"`
	// The features to calculate drift over.
	Features interface{} `pulumi:"features"`
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThresholds []interface{} `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// [Required] The data produced by the production service which drift will be calculated for.
	ProductionData interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The data to calculate drift against.
	ReferenceData interface{} `pulumi:"referenceData"`
	// Expected value is 'DataQuality'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for DataQualityMonitoringSignalResponse
func (val *DataQualityMonitoringSignalResponse) Defaults() *DataQualityMonitoringSignalResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

type DatabaseSource struct {
	// Workspace connection for data import source storage
	Connection *string `pulumi:"connection"`
	// SQL Query statement for data import Database source
	Query *string `pulumi:"query"`
	// Enum to determine the type of data.
	// Expected value is 'database'.
	SourceType string `pulumi:"sourceType"`
	// SQL StoredProcedure on data import Database source
	StoredProcedure *string `pulumi:"storedProcedure"`
	// SQL StoredProcedure parameters
	StoredProcedureParams []map[string]string `pulumi:"storedProcedureParams"`
	// Name of the table on data import Database source
	TableName *string `pulumi:"tableName"`
}

type DatabaseSourceResponse struct {
	// Workspace connection for data import source storage
	Connection *string `pulumi:"connection"`
	// SQL Query statement for data import Database source
	Query *string `pulumi:"query"`
	// Enum to determine the type of data.
	// Expected value is 'database'.
	SourceType string `pulumi:"sourceType"`
	// SQL StoredProcedure on data import Database source
	StoredProcedure *string `pulumi:"storedProcedure"`
	// SQL StoredProcedure parameters
	StoredProcedureParams []map[string]string `pulumi:"storedProcedureParams"`
	// Name of the table on data import Database source
	TableName *string `pulumi:"tableName"`
}

// A DataFactory compute.
type Databricks struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'Databricks'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Properties of Databricks
	Properties *DatabricksProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Properties of Databricks
type DatabricksProperties struct {
	// Databricks access token
	DatabricksAccessToken *string `pulumi:"databricksAccessToken"`
	// Workspace Url
	WorkspaceUrl *string `pulumi:"workspaceUrl"`
}

// Properties of Databricks
type DatabricksPropertiesResponse struct {
	// Databricks access token
	DatabricksAccessToken *string `pulumi:"databricksAccessToken"`
	// Workspace Url
	WorkspaceUrl *string `pulumi:"workspaceUrl"`
}

// A DataFactory compute.
type DatabricksResponse struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'Databricks'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// Properties of Databricks
	Properties *DatabricksPropertiesResponse `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

type DefaultScaleSettings struct {
	// Expected value is 'Default'.
	ScaleType string `pulumi:"scaleType"`
}

type DefaultScaleSettingsResponse struct {
	// Expected value is 'Default'.
	ScaleType string `pulumi:"scaleType"`
}

type DeploymentResourceConfiguration struct {
	// Optional number of instances or nodes used by the compute target.
	InstanceCount *int `pulumi:"instanceCount"`
	// Optional type of VM used as supported by the compute target.
	InstanceType *string `pulumi:"instanceType"`
	// Locations where the job can run.
	Locations []string `pulumi:"locations"`
	// Optional max allowed number of instances or nodes to be used by the compute target.
	// For use with elastic training, currently supported by PyTorch distribution type only.
	MaxInstanceCount *int `pulumi:"maxInstanceCount"`
	// Additional properties bag.
	Properties map[string]interface{} `pulumi:"properties"`
}

// Defaults sets the appropriate defaults for DeploymentResourceConfiguration
func (val *DeploymentResourceConfiguration) Defaults() *DeploymentResourceConfiguration {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.InstanceCount == nil {
		instanceCount_ := 1
		tmp.InstanceCount = &instanceCount_
	}
	return &tmp
}

// DeploymentResourceConfigurationInput is an input type that accepts DeploymentResourceConfigurationArgs and DeploymentResourceConfigurationOutput values.
// You can construct a concrete instance of `DeploymentResourceConfigurationInput` via:
//
//	DeploymentResourceConfigurationArgs{...}
type DeploymentResourceConfigurationInput interface {
	pulumi.Input

	ToDeploymentResourceConfigurationOutput() DeploymentResourceConfigurationOutput
	ToDeploymentResourceConfigurationOutputWithContext(context.Context) DeploymentResourceConfigurationOutput
}

type DeploymentResourceConfigurationArgs struct {
	// Optional number of instances or nodes used by the compute target.
	InstanceCount pulumi.IntPtrInput `pulumi:"instanceCount"`
	// Optional type of VM used as supported by the compute target.
	InstanceType pulumi.StringPtrInput `pulumi:"instanceType"`
	// Locations where the job can run.
	Locations pulumi.StringArrayInput `pulumi:"locations"`
	// Optional max allowed number of instances or nodes to be used by the compute target.
	// For use with elastic training, currently supported by PyTorch distribution type only.
	MaxInstanceCount pulumi.IntPtrInput `pulumi:"maxInstanceCount"`
	// Additional properties bag.
	Properties pulumi.MapInput `pulumi:"properties"`
}

// Defaults sets the appropriate defaults for DeploymentResourceConfigurationArgs
func (val *DeploymentResourceConfigurationArgs) Defaults() *DeploymentResourceConfigurationArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.InstanceCount == nil {
		tmp.InstanceCount = pulumi.IntPtr(1)
	}
	return &tmp
}
func (DeploymentResourceConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentResourceConfiguration)(nil)).Elem()
}

func (i DeploymentResourceConfigurationArgs) ToDeploymentResourceConfigurationOutput() DeploymentResourceConfigurationOutput {
	return i.ToDeploymentResourceConfigurationOutputWithContext(context.Background())
}

func (i DeploymentResourceConfigurationArgs) ToDeploymentResourceConfigurationOutputWithContext(ctx context.Context) DeploymentResourceConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentResourceConfigurationOutput)
}

func (i DeploymentResourceConfigurationArgs) ToDeploymentResourceConfigurationPtrOutput() DeploymentResourceConfigurationPtrOutput {
	return i.ToDeploymentResourceConfigurationPtrOutputWithContext(context.Background())
}

func (i DeploymentResourceConfigurationArgs) ToDeploymentResourceConfigurationPtrOutputWithContext(ctx context.Context) DeploymentResourceConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentResourceConfigurationOutput).ToDeploymentResourceConfigurationPtrOutputWithContext(ctx)
}

// DeploymentResourceConfigurationPtrInput is an input type that accepts DeploymentResourceConfigurationArgs, DeploymentResourceConfigurationPtr and DeploymentResourceConfigurationPtrOutput values.
// You can construct a concrete instance of `DeploymentResourceConfigurationPtrInput` via:
//
//	        DeploymentResourceConfigurationArgs{...}
//
//	or:
//
//	        nil
type DeploymentResourceConfigurationPtrInput interface {
	pulumi.Input

	ToDeploymentResourceConfigurationPtrOutput() DeploymentResourceConfigurationPtrOutput
	ToDeploymentResourceConfigurationPtrOutputWithContext(context.Context) DeploymentResourceConfigurationPtrOutput
}

type deploymentResourceConfigurationPtrType DeploymentResourceConfigurationArgs

func DeploymentResourceConfigurationPtr(v *DeploymentResourceConfigurationArgs) DeploymentResourceConfigurationPtrInput {
	return (*deploymentResourceConfigurationPtrType)(v)
}

func (*deploymentResourceConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentResourceConfiguration)(nil)).Elem()
}

func (i *deploymentResourceConfigurationPtrType) ToDeploymentResourceConfigurationPtrOutput() DeploymentResourceConfigurationPtrOutput {
	return i.ToDeploymentResourceConfigurationPtrOutputWithContext(context.Background())
}

func (i *deploymentResourceConfigurationPtrType) ToDeploymentResourceConfigurationPtrOutputWithContext(ctx context.Context) DeploymentResourceConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentResourceConfigurationPtrOutput)
}

type DeploymentResourceConfigurationOutput struct{ *pulumi.OutputState }

func (DeploymentResourceConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentResourceConfiguration)(nil)).Elem()
}

func (o DeploymentResourceConfigurationOutput) ToDeploymentResourceConfigurationOutput() DeploymentResourceConfigurationOutput {
	return o
}

func (o DeploymentResourceConfigurationOutput) ToDeploymentResourceConfigurationOutputWithContext(ctx context.Context) DeploymentResourceConfigurationOutput {
	return o
}

func (o DeploymentResourceConfigurationOutput) ToDeploymentResourceConfigurationPtrOutput() DeploymentResourceConfigurationPtrOutput {
	return o.ToDeploymentResourceConfigurationPtrOutputWithContext(context.Background())
}

func (o DeploymentResourceConfigurationOutput) ToDeploymentResourceConfigurationPtrOutputWithContext(ctx context.Context) DeploymentResourceConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeploymentResourceConfiguration) *DeploymentResourceConfiguration {
		return &v
	}).(DeploymentResourceConfigurationPtrOutput)
}

// Optional number of instances or nodes used by the compute target.
func (o DeploymentResourceConfigurationOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentResourceConfiguration) *int { return v.InstanceCount }).(pulumi.IntPtrOutput)
}

// Optional type of VM used as supported by the compute target.
func (o DeploymentResourceConfigurationOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeploymentResourceConfiguration) *string { return v.InstanceType }).(pulumi.StringPtrOutput)
}

// Locations where the job can run.
func (o DeploymentResourceConfigurationOutput) Locations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeploymentResourceConfiguration) []string { return v.Locations }).(pulumi.StringArrayOutput)
}

// Optional max allowed number of instances or nodes to be used by the compute target.
// For use with elastic training, currently supported by PyTorch distribution type only.
func (o DeploymentResourceConfigurationOutput) MaxInstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentResourceConfiguration) *int { return v.MaxInstanceCount }).(pulumi.IntPtrOutput)
}

// Additional properties bag.
func (o DeploymentResourceConfigurationOutput) Properties() pulumi.MapOutput {
	return o.ApplyT(func(v DeploymentResourceConfiguration) map[string]interface{} { return v.Properties }).(pulumi.MapOutput)
}

type DeploymentResourceConfigurationPtrOutput struct{ *pulumi.OutputState }

func (DeploymentResourceConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentResourceConfiguration)(nil)).Elem()
}

func (o DeploymentResourceConfigurationPtrOutput) ToDeploymentResourceConfigurationPtrOutput() DeploymentResourceConfigurationPtrOutput {
	return o
}

func (o DeploymentResourceConfigurationPtrOutput) ToDeploymentResourceConfigurationPtrOutputWithContext(ctx context.Context) DeploymentResourceConfigurationPtrOutput {
	return o
}

func (o DeploymentResourceConfigurationPtrOutput) Elem() DeploymentResourceConfigurationOutput {
	return o.ApplyT(func(v *DeploymentResourceConfiguration) DeploymentResourceConfiguration {
		if v != nil {
			return *v
		}
		var ret DeploymentResourceConfiguration
		return ret
	}).(DeploymentResourceConfigurationOutput)
}

// Optional number of instances or nodes used by the compute target.
func (o DeploymentResourceConfigurationPtrOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentResourceConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.InstanceCount
	}).(pulumi.IntPtrOutput)
}

// Optional type of VM used as supported by the compute target.
func (o DeploymentResourceConfigurationPtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeploymentResourceConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// Locations where the job can run.
func (o DeploymentResourceConfigurationPtrOutput) Locations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DeploymentResourceConfiguration) []string {
		if v == nil {
			return nil
		}
		return v.Locations
	}).(pulumi.StringArrayOutput)
}

// Optional max allowed number of instances or nodes to be used by the compute target.
// For use with elastic training, currently supported by PyTorch distribution type only.
func (o DeploymentResourceConfigurationPtrOutput) MaxInstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentResourceConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.MaxInstanceCount
	}).(pulumi.IntPtrOutput)
}

// Additional properties bag.
func (o DeploymentResourceConfigurationPtrOutput) Properties() pulumi.MapOutput {
	return o.ApplyT(func(v *DeploymentResourceConfiguration) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Properties
	}).(pulumi.MapOutput)
}

type DeploymentResourceConfigurationResponse struct {
	// Optional number of instances or nodes used by the compute target.
	InstanceCount *int `pulumi:"instanceCount"`
	// Optional type of VM used as supported by the compute target.
	InstanceType *string `pulumi:"instanceType"`
	// Locations where the job can run.
	Locations []string `pulumi:"locations"`
	// Optional max allowed number of instances or nodes to be used by the compute target.
	// For use with elastic training, currently supported by PyTorch distribution type only.
	MaxInstanceCount *int `pulumi:"maxInstanceCount"`
	// Additional properties bag.
	Properties map[string]interface{} `pulumi:"properties"`
}

// Defaults sets the appropriate defaults for DeploymentResourceConfigurationResponse
func (val *DeploymentResourceConfigurationResponse) Defaults() *DeploymentResourceConfigurationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.InstanceCount == nil {
		instanceCount_ := 1
		tmp.InstanceCount = &instanceCount_
	}
	return &tmp
}

type DeploymentResourceConfigurationResponseOutput struct{ *pulumi.OutputState }

func (DeploymentResourceConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentResourceConfigurationResponse)(nil)).Elem()
}

func (o DeploymentResourceConfigurationResponseOutput) ToDeploymentResourceConfigurationResponseOutput() DeploymentResourceConfigurationResponseOutput {
	return o
}

func (o DeploymentResourceConfigurationResponseOutput) ToDeploymentResourceConfigurationResponseOutputWithContext(ctx context.Context) DeploymentResourceConfigurationResponseOutput {
	return o
}

// Optional number of instances or nodes used by the compute target.
func (o DeploymentResourceConfigurationResponseOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentResourceConfigurationResponse) *int { return v.InstanceCount }).(pulumi.IntPtrOutput)
}

// Optional type of VM used as supported by the compute target.
func (o DeploymentResourceConfigurationResponseOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeploymentResourceConfigurationResponse) *string { return v.InstanceType }).(pulumi.StringPtrOutput)
}

// Locations where the job can run.
func (o DeploymentResourceConfigurationResponseOutput) Locations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeploymentResourceConfigurationResponse) []string { return v.Locations }).(pulumi.StringArrayOutput)
}

// Optional max allowed number of instances or nodes to be used by the compute target.
// For use with elastic training, currently supported by PyTorch distribution type only.
func (o DeploymentResourceConfigurationResponseOutput) MaxInstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DeploymentResourceConfigurationResponse) *int { return v.MaxInstanceCount }).(pulumi.IntPtrOutput)
}

// Additional properties bag.
func (o DeploymentResourceConfigurationResponseOutput) Properties() pulumi.MapOutput {
	return o.ApplyT(func(v DeploymentResourceConfigurationResponse) map[string]interface{} { return v.Properties }).(pulumi.MapOutput)
}

type DeploymentResourceConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (DeploymentResourceConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentResourceConfigurationResponse)(nil)).Elem()
}

func (o DeploymentResourceConfigurationResponsePtrOutput) ToDeploymentResourceConfigurationResponsePtrOutput() DeploymentResourceConfigurationResponsePtrOutput {
	return o
}

func (o DeploymentResourceConfigurationResponsePtrOutput) ToDeploymentResourceConfigurationResponsePtrOutputWithContext(ctx context.Context) DeploymentResourceConfigurationResponsePtrOutput {
	return o
}

func (o DeploymentResourceConfigurationResponsePtrOutput) Elem() DeploymentResourceConfigurationResponseOutput {
	return o.ApplyT(func(v *DeploymentResourceConfigurationResponse) DeploymentResourceConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret DeploymentResourceConfigurationResponse
		return ret
	}).(DeploymentResourceConfigurationResponseOutput)
}

// Optional number of instances or nodes used by the compute target.
func (o DeploymentResourceConfigurationResponsePtrOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentResourceConfigurationResponse) *int {
		if v == nil {
			return nil
		}
		return v.InstanceCount
	}).(pulumi.IntPtrOutput)
}

// Optional type of VM used as supported by the compute target.
func (o DeploymentResourceConfigurationResponsePtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeploymentResourceConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// Locations where the job can run.
func (o DeploymentResourceConfigurationResponsePtrOutput) Locations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DeploymentResourceConfigurationResponse) []string {
		if v == nil {
			return nil
		}
		return v.Locations
	}).(pulumi.StringArrayOutput)
}

// Optional max allowed number of instances or nodes to be used by the compute target.
// For use with elastic training, currently supported by PyTorch distribution type only.
func (o DeploymentResourceConfigurationResponsePtrOutput) MaxInstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DeploymentResourceConfigurationResponse) *int {
		if v == nil {
			return nil
		}
		return v.MaxInstanceCount
	}).(pulumi.IntPtrOutput)
}

// Additional properties bag.
func (o DeploymentResourceConfigurationResponsePtrOutput) Properties() pulumi.MapOutput {
	return o.ApplyT(func(v *DeploymentResourceConfigurationResponse) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Properties
	}).(pulumi.MapOutput)
}

type Docker struct {
	// Indicate whether container shall run in privileged or non-privileged mode.
	Privileged *bool `pulumi:"privileged"`
}

type DockerResponse struct {
	// Indicate whether container shall run in privileged or non-privileged mode.
	Privileged *bool `pulumi:"privileged"`
}

type EmailMonitoringAlertNotificationSettings struct {
	// Expected value is 'Email'.
	AlertNotificationType string `pulumi:"alertNotificationType"`
	// Configuration for notification.
	EmailNotificationSetting *NotificationSetting `pulumi:"emailNotificationSetting"`
}

type EmailMonitoringAlertNotificationSettingsResponse struct {
	// Expected value is 'Email'.
	AlertNotificationType string `pulumi:"alertNotificationType"`
	// Configuration for notification.
	EmailNotificationSetting *NotificationSettingResponse `pulumi:"emailNotificationSetting"`
}

type EncryptionProperty struct {
	// The byok cosmosdb account that customer brings to store customer's data
	// with encryption
	CosmosDbResourceId *string `pulumi:"cosmosDbResourceId"`
	// Identity to be used with the keyVault
	Identity *IdentityForCmk `pulumi:"identity"`
	// KeyVault details to do the encryption
	KeyVaultProperties KeyVaultProperties `pulumi:"keyVaultProperties"`
	// The byok search account that customer brings to store customer's data
	// with encryption
	SearchAccountResourceId *string `pulumi:"searchAccountResourceId"`
	// Indicates whether or not the encryption is enabled for the workspace.
	Status string `pulumi:"status"`
	// The byok storage account that customer brings to store customer's data
	// with encryption
	StorageAccountResourceId *string `pulumi:"storageAccountResourceId"`
}

// EncryptionPropertyInput is an input type that accepts EncryptionPropertyArgs and EncryptionPropertyOutput values.
// You can construct a concrete instance of `EncryptionPropertyInput` via:
//
//	EncryptionPropertyArgs{...}
type EncryptionPropertyInput interface {
	pulumi.Input

	ToEncryptionPropertyOutput() EncryptionPropertyOutput
	ToEncryptionPropertyOutputWithContext(context.Context) EncryptionPropertyOutput
}

type EncryptionPropertyArgs struct {
	// The byok cosmosdb account that customer brings to store customer's data
	// with encryption
	CosmosDbResourceId pulumi.StringPtrInput `pulumi:"cosmosDbResourceId"`
	// Identity to be used with the keyVault
	Identity IdentityForCmkPtrInput `pulumi:"identity"`
	// KeyVault details to do the encryption
	KeyVaultProperties KeyVaultPropertiesInput `pulumi:"keyVaultProperties"`
	// The byok search account that customer brings to store customer's data
	// with encryption
	SearchAccountResourceId pulumi.StringPtrInput `pulumi:"searchAccountResourceId"`
	// Indicates whether or not the encryption is enabled for the workspace.
	Status pulumi.StringInput `pulumi:"status"`
	// The byok storage account that customer brings to store customer's data
	// with encryption
	StorageAccountResourceId pulumi.StringPtrInput `pulumi:"storageAccountResourceId"`
}

func (EncryptionPropertyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EncryptionProperty)(nil)).Elem()
}

func (i EncryptionPropertyArgs) ToEncryptionPropertyOutput() EncryptionPropertyOutput {
	return i.ToEncryptionPropertyOutputWithContext(context.Background())
}

func (i EncryptionPropertyArgs) ToEncryptionPropertyOutputWithContext(ctx context.Context) EncryptionPropertyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionPropertyOutput)
}

func (i EncryptionPropertyArgs) ToEncryptionPropertyPtrOutput() EncryptionPropertyPtrOutput {
	return i.ToEncryptionPropertyPtrOutputWithContext(context.Background())
}

func (i EncryptionPropertyArgs) ToEncryptionPropertyPtrOutputWithContext(ctx context.Context) EncryptionPropertyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionPropertyOutput).ToEncryptionPropertyPtrOutputWithContext(ctx)
}

// EncryptionPropertyPtrInput is an input type that accepts EncryptionPropertyArgs, EncryptionPropertyPtr and EncryptionPropertyPtrOutput values.
// You can construct a concrete instance of `EncryptionPropertyPtrInput` via:
//
//	        EncryptionPropertyArgs{...}
//
//	or:
//
//	        nil
type EncryptionPropertyPtrInput interface {
	pulumi.Input

	ToEncryptionPropertyPtrOutput() EncryptionPropertyPtrOutput
	ToEncryptionPropertyPtrOutputWithContext(context.Context) EncryptionPropertyPtrOutput
}

type encryptionPropertyPtrType EncryptionPropertyArgs

func EncryptionPropertyPtr(v *EncryptionPropertyArgs) EncryptionPropertyPtrInput {
	return (*encryptionPropertyPtrType)(v)
}

func (*encryptionPropertyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionProperty)(nil)).Elem()
}

func (i *encryptionPropertyPtrType) ToEncryptionPropertyPtrOutput() EncryptionPropertyPtrOutput {
	return i.ToEncryptionPropertyPtrOutputWithContext(context.Background())
}

func (i *encryptionPropertyPtrType) ToEncryptionPropertyPtrOutputWithContext(ctx context.Context) EncryptionPropertyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionPropertyPtrOutput)
}

type EncryptionPropertyOutput struct{ *pulumi.OutputState }

func (EncryptionPropertyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EncryptionProperty)(nil)).Elem()
}

func (o EncryptionPropertyOutput) ToEncryptionPropertyOutput() EncryptionPropertyOutput {
	return o
}

func (o EncryptionPropertyOutput) ToEncryptionPropertyOutputWithContext(ctx context.Context) EncryptionPropertyOutput {
	return o
}

func (o EncryptionPropertyOutput) ToEncryptionPropertyPtrOutput() EncryptionPropertyPtrOutput {
	return o.ToEncryptionPropertyPtrOutputWithContext(context.Background())
}

func (o EncryptionPropertyOutput) ToEncryptionPropertyPtrOutputWithContext(ctx context.Context) EncryptionPropertyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EncryptionProperty) *EncryptionProperty {
		return &v
	}).(EncryptionPropertyPtrOutput)
}

// The byok cosmosdb account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyOutput) CosmosDbResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EncryptionProperty) *string { return v.CosmosDbResourceId }).(pulumi.StringPtrOutput)
}

// Identity to be used with the keyVault
func (o EncryptionPropertyOutput) Identity() IdentityForCmkPtrOutput {
	return o.ApplyT(func(v EncryptionProperty) *IdentityForCmk { return v.Identity }).(IdentityForCmkPtrOutput)
}

// KeyVault details to do the encryption
func (o EncryptionPropertyOutput) KeyVaultProperties() KeyVaultPropertiesOutput {
	return o.ApplyT(func(v EncryptionProperty) KeyVaultProperties { return v.KeyVaultProperties }).(KeyVaultPropertiesOutput)
}

// The byok search account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyOutput) SearchAccountResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EncryptionProperty) *string { return v.SearchAccountResourceId }).(pulumi.StringPtrOutput)
}

// Indicates whether or not the encryption is enabled for the workspace.
func (o EncryptionPropertyOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v EncryptionProperty) string { return v.Status }).(pulumi.StringOutput)
}

// The byok storage account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyOutput) StorageAccountResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EncryptionProperty) *string { return v.StorageAccountResourceId }).(pulumi.StringPtrOutput)
}

type EncryptionPropertyPtrOutput struct{ *pulumi.OutputState }

func (EncryptionPropertyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionProperty)(nil)).Elem()
}

func (o EncryptionPropertyPtrOutput) ToEncryptionPropertyPtrOutput() EncryptionPropertyPtrOutput {
	return o
}

func (o EncryptionPropertyPtrOutput) ToEncryptionPropertyPtrOutputWithContext(ctx context.Context) EncryptionPropertyPtrOutput {
	return o
}

func (o EncryptionPropertyPtrOutput) Elem() EncryptionPropertyOutput {
	return o.ApplyT(func(v *EncryptionProperty) EncryptionProperty {
		if v != nil {
			return *v
		}
		var ret EncryptionProperty
		return ret
	}).(EncryptionPropertyOutput)
}

// The byok cosmosdb account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyPtrOutput) CosmosDbResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionProperty) *string {
		if v == nil {
			return nil
		}
		return v.CosmosDbResourceId
	}).(pulumi.StringPtrOutput)
}

// Identity to be used with the keyVault
func (o EncryptionPropertyPtrOutput) Identity() IdentityForCmkPtrOutput {
	return o.ApplyT(func(v *EncryptionProperty) *IdentityForCmk {
		if v == nil {
			return nil
		}
		return v.Identity
	}).(IdentityForCmkPtrOutput)
}

// KeyVault details to do the encryption
func (o EncryptionPropertyPtrOutput) KeyVaultProperties() KeyVaultPropertiesPtrOutput {
	return o.ApplyT(func(v *EncryptionProperty) *KeyVaultProperties {
		if v == nil {
			return nil
		}
		return &v.KeyVaultProperties
	}).(KeyVaultPropertiesPtrOutput)
}

// The byok search account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyPtrOutput) SearchAccountResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionProperty) *string {
		if v == nil {
			return nil
		}
		return v.SearchAccountResourceId
	}).(pulumi.StringPtrOutput)
}

// Indicates whether or not the encryption is enabled for the workspace.
func (o EncryptionPropertyPtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionProperty) *string {
		if v == nil {
			return nil
		}
		return &v.Status
	}).(pulumi.StringPtrOutput)
}

// The byok storage account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyPtrOutput) StorageAccountResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionProperty) *string {
		if v == nil {
			return nil
		}
		return v.StorageAccountResourceId
	}).(pulumi.StringPtrOutput)
}

type EncryptionPropertyResponse struct {
	// The byok cosmosdb account that customer brings to store customer's data
	// with encryption
	CosmosDbResourceId *string `pulumi:"cosmosDbResourceId"`
	// Identity to be used with the keyVault
	Identity *IdentityForCmkResponse `pulumi:"identity"`
	// KeyVault details to do the encryption
	KeyVaultProperties KeyVaultPropertiesResponse `pulumi:"keyVaultProperties"`
	// The byok search account that customer brings to store customer's data
	// with encryption
	SearchAccountResourceId *string `pulumi:"searchAccountResourceId"`
	// Indicates whether or not the encryption is enabled for the workspace.
	Status string `pulumi:"status"`
	// The byok storage account that customer brings to store customer's data
	// with encryption
	StorageAccountResourceId *string `pulumi:"storageAccountResourceId"`
}

type EncryptionPropertyResponseOutput struct{ *pulumi.OutputState }

func (EncryptionPropertyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EncryptionPropertyResponse)(nil)).Elem()
}

func (o EncryptionPropertyResponseOutput) ToEncryptionPropertyResponseOutput() EncryptionPropertyResponseOutput {
	return o
}

func (o EncryptionPropertyResponseOutput) ToEncryptionPropertyResponseOutputWithContext(ctx context.Context) EncryptionPropertyResponseOutput {
	return o
}

// The byok cosmosdb account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyResponseOutput) CosmosDbResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EncryptionPropertyResponse) *string { return v.CosmosDbResourceId }).(pulumi.StringPtrOutput)
}

// Identity to be used with the keyVault
func (o EncryptionPropertyResponseOutput) Identity() IdentityForCmkResponsePtrOutput {
	return o.ApplyT(func(v EncryptionPropertyResponse) *IdentityForCmkResponse { return v.Identity }).(IdentityForCmkResponsePtrOutput)
}

// KeyVault details to do the encryption
func (o EncryptionPropertyResponseOutput) KeyVaultProperties() KeyVaultPropertiesResponseOutput {
	return o.ApplyT(func(v EncryptionPropertyResponse) KeyVaultPropertiesResponse { return v.KeyVaultProperties }).(KeyVaultPropertiesResponseOutput)
}

// The byok search account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyResponseOutput) SearchAccountResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EncryptionPropertyResponse) *string { return v.SearchAccountResourceId }).(pulumi.StringPtrOutput)
}

// Indicates whether or not the encryption is enabled for the workspace.
func (o EncryptionPropertyResponseOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v EncryptionPropertyResponse) string { return v.Status }).(pulumi.StringOutput)
}

// The byok storage account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyResponseOutput) StorageAccountResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EncryptionPropertyResponse) *string { return v.StorageAccountResourceId }).(pulumi.StringPtrOutput)
}

type EncryptionPropertyResponsePtrOutput struct{ *pulumi.OutputState }

func (EncryptionPropertyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionPropertyResponse)(nil)).Elem()
}

func (o EncryptionPropertyResponsePtrOutput) ToEncryptionPropertyResponsePtrOutput() EncryptionPropertyResponsePtrOutput {
	return o
}

func (o EncryptionPropertyResponsePtrOutput) ToEncryptionPropertyResponsePtrOutputWithContext(ctx context.Context) EncryptionPropertyResponsePtrOutput {
	return o
}

func (o EncryptionPropertyResponsePtrOutput) Elem() EncryptionPropertyResponseOutput {
	return o.ApplyT(func(v *EncryptionPropertyResponse) EncryptionPropertyResponse {
		if v != nil {
			return *v
		}
		var ret EncryptionPropertyResponse
		return ret
	}).(EncryptionPropertyResponseOutput)
}

// The byok cosmosdb account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyResponsePtrOutput) CosmosDbResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionPropertyResponse) *string {
		if v == nil {
			return nil
		}
		return v.CosmosDbResourceId
	}).(pulumi.StringPtrOutput)
}

// Identity to be used with the keyVault
func (o EncryptionPropertyResponsePtrOutput) Identity() IdentityForCmkResponsePtrOutput {
	return o.ApplyT(func(v *EncryptionPropertyResponse) *IdentityForCmkResponse {
		if v == nil {
			return nil
		}
		return v.Identity
	}).(IdentityForCmkResponsePtrOutput)
}

// KeyVault details to do the encryption
func (o EncryptionPropertyResponsePtrOutput) KeyVaultProperties() KeyVaultPropertiesResponsePtrOutput {
	return o.ApplyT(func(v *EncryptionPropertyResponse) *KeyVaultPropertiesResponse {
		if v == nil {
			return nil
		}
		return &v.KeyVaultProperties
	}).(KeyVaultPropertiesResponsePtrOutput)
}

// The byok search account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyResponsePtrOutput) SearchAccountResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionPropertyResponse) *string {
		if v == nil {
			return nil
		}
		return v.SearchAccountResourceId
	}).(pulumi.StringPtrOutput)
}

// Indicates whether or not the encryption is enabled for the workspace.
func (o EncryptionPropertyResponsePtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionPropertyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Status
	}).(pulumi.StringPtrOutput)
}

// The byok storage account that customer brings to store customer's data
// with encryption
func (o EncryptionPropertyResponsePtrOutput) StorageAccountResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EncryptionPropertyResponse) *string {
		if v == nil {
			return nil
		}
		return v.StorageAccountResourceId
	}).(pulumi.StringPtrOutput)
}

type Endpoint struct {
	// Host IP over which the application is exposed from the container
	HostIp *string `pulumi:"hostIp"`
	// Name of the Endpoint
	Name *string `pulumi:"name"`
	// Protocol over which communication will happen over this endpoint
	Protocol *string `pulumi:"protocol"`
	// Port over which the application is exposed from container.
	Published *int `pulumi:"published"`
	// Application port inside the container.
	Target *int `pulumi:"target"`
}

// Defaults sets the appropriate defaults for Endpoint
func (val *Endpoint) Defaults() *Endpoint {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Protocol == nil {
		protocol_ := "tcp"
		tmp.Protocol = &protocol_
	}
	return &tmp
}

// Keys for endpoint authentication.
type EndpointAuthKeys struct {
	// The primary key.
	PrimaryKey *string `pulumi:"primaryKey"`
	// The secondary key.
	SecondaryKey *string `pulumi:"secondaryKey"`
}

// EndpointAuthKeysInput is an input type that accepts EndpointAuthKeysArgs and EndpointAuthKeysOutput values.
// You can construct a concrete instance of `EndpointAuthKeysInput` via:
//
//	EndpointAuthKeysArgs{...}
type EndpointAuthKeysInput interface {
	pulumi.Input

	ToEndpointAuthKeysOutput() EndpointAuthKeysOutput
	ToEndpointAuthKeysOutputWithContext(context.Context) EndpointAuthKeysOutput
}

// Keys for endpoint authentication.
type EndpointAuthKeysArgs struct {
	// The primary key.
	PrimaryKey pulumi.StringPtrInput `pulumi:"primaryKey"`
	// The secondary key.
	SecondaryKey pulumi.StringPtrInput `pulumi:"secondaryKey"`
}

func (EndpointAuthKeysArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointAuthKeys)(nil)).Elem()
}

func (i EndpointAuthKeysArgs) ToEndpointAuthKeysOutput() EndpointAuthKeysOutput {
	return i.ToEndpointAuthKeysOutputWithContext(context.Background())
}

func (i EndpointAuthKeysArgs) ToEndpointAuthKeysOutputWithContext(ctx context.Context) EndpointAuthKeysOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointAuthKeysOutput)
}

func (i EndpointAuthKeysArgs) ToEndpointAuthKeysPtrOutput() EndpointAuthKeysPtrOutput {
	return i.ToEndpointAuthKeysPtrOutputWithContext(context.Background())
}

func (i EndpointAuthKeysArgs) ToEndpointAuthKeysPtrOutputWithContext(ctx context.Context) EndpointAuthKeysPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointAuthKeysOutput).ToEndpointAuthKeysPtrOutputWithContext(ctx)
}

// EndpointAuthKeysPtrInput is an input type that accepts EndpointAuthKeysArgs, EndpointAuthKeysPtr and EndpointAuthKeysPtrOutput values.
// You can construct a concrete instance of `EndpointAuthKeysPtrInput` via:
//
//	        EndpointAuthKeysArgs{...}
//
//	or:
//
//	        nil
type EndpointAuthKeysPtrInput interface {
	pulumi.Input

	ToEndpointAuthKeysPtrOutput() EndpointAuthKeysPtrOutput
	ToEndpointAuthKeysPtrOutputWithContext(context.Context) EndpointAuthKeysPtrOutput
}

type endpointAuthKeysPtrType EndpointAuthKeysArgs

func EndpointAuthKeysPtr(v *EndpointAuthKeysArgs) EndpointAuthKeysPtrInput {
	return (*endpointAuthKeysPtrType)(v)
}

func (*endpointAuthKeysPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointAuthKeys)(nil)).Elem()
}

func (i *endpointAuthKeysPtrType) ToEndpointAuthKeysPtrOutput() EndpointAuthKeysPtrOutput {
	return i.ToEndpointAuthKeysPtrOutputWithContext(context.Background())
}

func (i *endpointAuthKeysPtrType) ToEndpointAuthKeysPtrOutputWithContext(ctx context.Context) EndpointAuthKeysPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointAuthKeysPtrOutput)
}

// Keys for endpoint authentication.
type EndpointAuthKeysOutput struct{ *pulumi.OutputState }

func (EndpointAuthKeysOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointAuthKeys)(nil)).Elem()
}

func (o EndpointAuthKeysOutput) ToEndpointAuthKeysOutput() EndpointAuthKeysOutput {
	return o
}

func (o EndpointAuthKeysOutput) ToEndpointAuthKeysOutputWithContext(ctx context.Context) EndpointAuthKeysOutput {
	return o
}

func (o EndpointAuthKeysOutput) ToEndpointAuthKeysPtrOutput() EndpointAuthKeysPtrOutput {
	return o.ToEndpointAuthKeysPtrOutputWithContext(context.Background())
}

func (o EndpointAuthKeysOutput) ToEndpointAuthKeysPtrOutputWithContext(ctx context.Context) EndpointAuthKeysPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EndpointAuthKeys) *EndpointAuthKeys {
		return &v
	}).(EndpointAuthKeysPtrOutput)
}

// The primary key.
func (o EndpointAuthKeysOutput) PrimaryKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EndpointAuthKeys) *string { return v.PrimaryKey }).(pulumi.StringPtrOutput)
}

// The secondary key.
func (o EndpointAuthKeysOutput) SecondaryKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EndpointAuthKeys) *string { return v.SecondaryKey }).(pulumi.StringPtrOutput)
}

type EndpointAuthKeysPtrOutput struct{ *pulumi.OutputState }

func (EndpointAuthKeysPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointAuthKeys)(nil)).Elem()
}

func (o EndpointAuthKeysPtrOutput) ToEndpointAuthKeysPtrOutput() EndpointAuthKeysPtrOutput {
	return o
}

func (o EndpointAuthKeysPtrOutput) ToEndpointAuthKeysPtrOutputWithContext(ctx context.Context) EndpointAuthKeysPtrOutput {
	return o
}

func (o EndpointAuthKeysPtrOutput) Elem() EndpointAuthKeysOutput {
	return o.ApplyT(func(v *EndpointAuthKeys) EndpointAuthKeys {
		if v != nil {
			return *v
		}
		var ret EndpointAuthKeys
		return ret
	}).(EndpointAuthKeysOutput)
}

// The primary key.
func (o EndpointAuthKeysPtrOutput) PrimaryKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EndpointAuthKeys) *string {
		if v == nil {
			return nil
		}
		return v.PrimaryKey
	}).(pulumi.StringPtrOutput)
}

// The secondary key.
func (o EndpointAuthKeysPtrOutput) SecondaryKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EndpointAuthKeys) *string {
		if v == nil {
			return nil
		}
		return v.SecondaryKey
	}).(pulumi.StringPtrOutput)
}

type EndpointResponse struct {
	// Host IP over which the application is exposed from the container
	HostIp *string `pulumi:"hostIp"`
	// Name of the Endpoint
	Name *string `pulumi:"name"`
	// Protocol over which communication will happen over this endpoint
	Protocol *string `pulumi:"protocol"`
	// Port over which the application is exposed from container.
	Published *int `pulumi:"published"`
	// Application port inside the container.
	Target *int `pulumi:"target"`
}

// Defaults sets the appropriate defaults for EndpointResponse
func (val *EndpointResponse) Defaults() *EndpointResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Protocol == nil {
		protocol_ := "tcp"
		tmp.Protocol = &protocol_
	}
	return &tmp
}

type EndpointScheduleAction struct {
	// Expected value is 'InvokeBatchEndpoint'.
	ActionType string `pulumi:"actionType"`
	// [Required] Defines Schedule action definition details.
	// <see href="TBD" />
	EndpointInvocationDefinition interface{} `pulumi:"endpointInvocationDefinition"`
}

type EndpointScheduleActionResponse struct {
	// Expected value is 'InvokeBatchEndpoint'.
	ActionType string `pulumi:"actionType"`
	// [Required] Defines Schedule action definition details.
	// <see href="TBD" />
	EndpointInvocationDefinition interface{} `pulumi:"endpointInvocationDefinition"`
}

// Container for environment specification versions.
type EnvironmentContainerType struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentContainerType
func (val *EnvironmentContainerType) Defaults() *EnvironmentContainerType {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// EnvironmentContainerTypeInput is an input type that accepts EnvironmentContainerTypeArgs and EnvironmentContainerTypeOutput values.
// You can construct a concrete instance of `EnvironmentContainerTypeInput` via:
//
//	EnvironmentContainerTypeArgs{...}
type EnvironmentContainerTypeInput interface {
	pulumi.Input

	ToEnvironmentContainerTypeOutput() EnvironmentContainerTypeOutput
	ToEnvironmentContainerTypeOutputWithContext(context.Context) EnvironmentContainerTypeOutput
}

// Container for environment specification versions.
type EnvironmentContainerTypeArgs struct {
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentContainerTypeArgs
func (val *EnvironmentContainerTypeArgs) Defaults() *EnvironmentContainerTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (EnvironmentContainerTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentContainerType)(nil)).Elem()
}

func (i EnvironmentContainerTypeArgs) ToEnvironmentContainerTypeOutput() EnvironmentContainerTypeOutput {
	return i.ToEnvironmentContainerTypeOutputWithContext(context.Background())
}

func (i EnvironmentContainerTypeArgs) ToEnvironmentContainerTypeOutputWithContext(ctx context.Context) EnvironmentContainerTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentContainerTypeOutput)
}

// Container for environment specification versions.
type EnvironmentContainerTypeOutput struct{ *pulumi.OutputState }

func (EnvironmentContainerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentContainerType)(nil)).Elem()
}

func (o EnvironmentContainerTypeOutput) ToEnvironmentContainerTypeOutput() EnvironmentContainerTypeOutput {
	return o
}

func (o EnvironmentContainerTypeOutput) ToEnvironmentContainerTypeOutputWithContext(ctx context.Context) EnvironmentContainerTypeOutput {
	return o
}

// The asset description text.
func (o EnvironmentContainerTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentContainerType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o EnvironmentContainerTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentContainerType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o EnvironmentContainerTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentContainerType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o EnvironmentContainerTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentContainerType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Container for environment specification versions.
type EnvironmentContainerResponse struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the environment container.
	ProvisioningState string `pulumi:"provisioningState"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentContainerResponse
func (val *EnvironmentContainerResponse) Defaults() *EnvironmentContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Container for environment specification versions.
type EnvironmentContainerResponseOutput struct{ *pulumi.OutputState }

func (EnvironmentContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentContainerResponse)(nil)).Elem()
}

func (o EnvironmentContainerResponseOutput) ToEnvironmentContainerResponseOutput() EnvironmentContainerResponseOutput {
	return o
}

func (o EnvironmentContainerResponseOutput) ToEnvironmentContainerResponseOutputWithContext(ctx context.Context) EnvironmentContainerResponseOutput {
	return o
}

// The asset description text.
func (o EnvironmentContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o EnvironmentContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o EnvironmentContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o EnvironmentContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o EnvironmentContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the environment container.
func (o EnvironmentContainerResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o EnvironmentContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

type EnvironmentVariable struct {
	// Type of the Environment Variable. Possible values are: local - For local variable
	Type *string `pulumi:"type"`
	// Value of the Environment variable
	Value *string `pulumi:"value"`
}

// Defaults sets the appropriate defaults for EnvironmentVariable
func (val *EnvironmentVariable) Defaults() *EnvironmentVariable {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := "local"
		tmp.Type = &type_
	}
	return &tmp
}

type EnvironmentVariableResponse struct {
	// Type of the Environment Variable. Possible values are: local - For local variable
	Type *string `pulumi:"type"`
	// Value of the Environment variable
	Value *string `pulumi:"value"`
}

// Defaults sets the appropriate defaults for EnvironmentVariableResponse
func (val *EnvironmentVariableResponse) Defaults() *EnvironmentVariableResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := "local"
		tmp.Type = &type_
	}
	return &tmp
}

// Environment version details.
type EnvironmentVersionType struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSetting `pulumi:"autoDeleteSetting"`
	// Defines if image needs to be rebuilt based on base image changes.
	AutoRebuild *string `pulumi:"autoRebuild"`
	// Configuration settings for Docker build context.
	Build *BuildContext `pulumi:"build"`
	// Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
	// <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
	CondaFile *string `pulumi:"condaFile"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Name of the image that will be used for the environment.
	// <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
	Image *string `pulumi:"image"`
	// Defines configuration specific to inference.
	InferenceConfig *InferenceContainerProperties `pulumi:"inferenceConfig"`
	// Intellectual Property details. Used if environment is an Intellectual Property.
	IntellectualProperty *IntellectualProperty `pulumi:"intellectualProperty"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The OS type of the environment.
	OsType *string `pulumi:"osType"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Stage in the environment lifecycle assigned to this environment
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentVersionType
func (val *EnvironmentVersionType) Defaults() *EnvironmentVersionType {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.AutoRebuild == nil {
		autoRebuild_ := "Disabled"
		tmp.AutoRebuild = &autoRebuild_
	}
	tmp.Build = tmp.Build.Defaults()

	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	if tmp.OsType == nil {
		osType_ := "Linux"
		tmp.OsType = &osType_
	}
	return &tmp
}

// EnvironmentVersionTypeInput is an input type that accepts EnvironmentVersionTypeArgs and EnvironmentVersionTypeOutput values.
// You can construct a concrete instance of `EnvironmentVersionTypeInput` via:
//
//	EnvironmentVersionTypeArgs{...}
type EnvironmentVersionTypeInput interface {
	pulumi.Input

	ToEnvironmentVersionTypeOutput() EnvironmentVersionTypeOutput
	ToEnvironmentVersionTypeOutputWithContext(context.Context) EnvironmentVersionTypeOutput
}

// Environment version details.
type EnvironmentVersionTypeArgs struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting AutoDeleteSettingPtrInput `pulumi:"autoDeleteSetting"`
	// Defines if image needs to be rebuilt based on base image changes.
	AutoRebuild pulumi.StringPtrInput `pulumi:"autoRebuild"`
	// Configuration settings for Docker build context.
	Build BuildContextPtrInput `pulumi:"build"`
	// Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
	// <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
	CondaFile pulumi.StringPtrInput `pulumi:"condaFile"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Name of the image that will be used for the environment.
	// <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
	Image pulumi.StringPtrInput `pulumi:"image"`
	// Defines configuration specific to inference.
	InferenceConfig InferenceContainerPropertiesPtrInput `pulumi:"inferenceConfig"`
	// Intellectual Property details. Used if environment is an Intellectual Property.
	IntellectualProperty IntellectualPropertyPtrInput `pulumi:"intellectualProperty"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous pulumi.BoolPtrInput `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The OS type of the environment.
	OsType pulumi.StringPtrInput `pulumi:"osType"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Stage in the environment lifecycle assigned to this environment
	Stage pulumi.StringPtrInput `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentVersionTypeArgs
func (val *EnvironmentVersionTypeArgs) Defaults() *EnvironmentVersionTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	if tmp.AutoRebuild == nil {
		tmp.AutoRebuild = pulumi.StringPtr("Disabled")
	}

	if tmp.IsAnonymous == nil {
		tmp.IsAnonymous = pulumi.BoolPtr(false)
	}
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	if tmp.OsType == nil {
		tmp.OsType = pulumi.StringPtr("Linux")
	}
	return &tmp
}
func (EnvironmentVersionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentVersionType)(nil)).Elem()
}

func (i EnvironmentVersionTypeArgs) ToEnvironmentVersionTypeOutput() EnvironmentVersionTypeOutput {
	return i.ToEnvironmentVersionTypeOutputWithContext(context.Background())
}

func (i EnvironmentVersionTypeArgs) ToEnvironmentVersionTypeOutputWithContext(ctx context.Context) EnvironmentVersionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentVersionTypeOutput)
}

// Environment version details.
type EnvironmentVersionTypeOutput struct{ *pulumi.OutputState }

func (EnvironmentVersionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentVersionType)(nil)).Elem()
}

func (o EnvironmentVersionTypeOutput) ToEnvironmentVersionTypeOutput() EnvironmentVersionTypeOutput {
	return o
}

func (o EnvironmentVersionTypeOutput) ToEnvironmentVersionTypeOutputWithContext(ctx context.Context) EnvironmentVersionTypeOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o EnvironmentVersionTypeOutput) AutoDeleteSetting() AutoDeleteSettingPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *AutoDeleteSetting { return v.AutoDeleteSetting }).(AutoDeleteSettingPtrOutput)
}

// Defines if image needs to be rebuilt based on base image changes.
func (o EnvironmentVersionTypeOutput) AutoRebuild() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *string { return v.AutoRebuild }).(pulumi.StringPtrOutput)
}

// Configuration settings for Docker build context.
func (o EnvironmentVersionTypeOutput) Build() BuildContextPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *BuildContext { return v.Build }).(BuildContextPtrOutput)
}

// Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
// <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
func (o EnvironmentVersionTypeOutput) CondaFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *string { return v.CondaFile }).(pulumi.StringPtrOutput)
}

// The asset description text.
func (o EnvironmentVersionTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Name of the image that will be used for the environment.
// <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
func (o EnvironmentVersionTypeOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Defines configuration specific to inference.
func (o EnvironmentVersionTypeOutput) InferenceConfig() InferenceContainerPropertiesPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *InferenceContainerProperties { return v.InferenceConfig }).(InferenceContainerPropertiesPtrOutput)
}

// Intellectual Property details. Used if environment is an Intellectual Property.
func (o EnvironmentVersionTypeOutput) IntellectualProperty() IntellectualPropertyPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *IntellectualProperty { return v.IntellectualProperty }).(IntellectualPropertyPtrOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o EnvironmentVersionTypeOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o EnvironmentVersionTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The OS type of the environment.
func (o EnvironmentVersionTypeOutput) OsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *string { return v.OsType }).(pulumi.StringPtrOutput)
}

// The asset property dictionary.
func (o EnvironmentVersionTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentVersionType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Stage in the environment lifecycle assigned to this environment
func (o EnvironmentVersionTypeOutput) Stage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionType) *string { return v.Stage }).(pulumi.StringPtrOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o EnvironmentVersionTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentVersionType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Environment version details.
type EnvironmentVersionResponse struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSettingResponse `pulumi:"autoDeleteSetting"`
	// Defines if image needs to be rebuilt based on base image changes.
	AutoRebuild *string `pulumi:"autoRebuild"`
	// Configuration settings for Docker build context.
	Build *BuildContextResponse `pulumi:"build"`
	// Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
	// <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
	CondaFile *string `pulumi:"condaFile"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Environment type is either user managed or curated by the Azure ML service
	// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
	EnvironmentType string `pulumi:"environmentType"`
	// Name of the image that will be used for the environment.
	// <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
	Image *string `pulumi:"image"`
	// Defines configuration specific to inference.
	InferenceConfig *InferenceContainerPropertiesResponse `pulumi:"inferenceConfig"`
	// Intellectual Property details. Used if environment is an Intellectual Property.
	IntellectualProperty *IntellectualPropertyResponse `pulumi:"intellectualProperty"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The OS type of the environment.
	OsType *string `pulumi:"osType"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the environment version.
	ProvisioningState string `pulumi:"provisioningState"`
	// Stage in the environment lifecycle assigned to this environment
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for EnvironmentVersionResponse
func (val *EnvironmentVersionResponse) Defaults() *EnvironmentVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.AutoRebuild == nil {
		autoRebuild_ := "Disabled"
		tmp.AutoRebuild = &autoRebuild_
	}
	tmp.Build = tmp.Build.Defaults()

	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	if tmp.OsType == nil {
		osType_ := "Linux"
		tmp.OsType = &osType_
	}
	return &tmp
}

// Environment version details.
type EnvironmentVersionResponseOutput struct{ *pulumi.OutputState }

func (EnvironmentVersionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentVersionResponse)(nil)).Elem()
}

func (o EnvironmentVersionResponseOutput) ToEnvironmentVersionResponseOutput() EnvironmentVersionResponseOutput {
	return o
}

func (o EnvironmentVersionResponseOutput) ToEnvironmentVersionResponseOutputWithContext(ctx context.Context) EnvironmentVersionResponseOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o EnvironmentVersionResponseOutput) AutoDeleteSetting() AutoDeleteSettingResponsePtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *AutoDeleteSettingResponse { return v.AutoDeleteSetting }).(AutoDeleteSettingResponsePtrOutput)
}

// Defines if image needs to be rebuilt based on base image changes.
func (o EnvironmentVersionResponseOutput) AutoRebuild() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *string { return v.AutoRebuild }).(pulumi.StringPtrOutput)
}

// Configuration settings for Docker build context.
func (o EnvironmentVersionResponseOutput) Build() BuildContextResponsePtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *BuildContextResponse { return v.Build }).(BuildContextResponsePtrOutput)
}

// Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
// <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
func (o EnvironmentVersionResponseOutput) CondaFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *string { return v.CondaFile }).(pulumi.StringPtrOutput)
}

// The asset description text.
func (o EnvironmentVersionResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Environment type is either user managed or curated by the Azure ML service
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
func (o EnvironmentVersionResponseOutput) EnvironmentType() pulumi.StringOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) string { return v.EnvironmentType }).(pulumi.StringOutput)
}

// Name of the image that will be used for the environment.
// <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
func (o EnvironmentVersionResponseOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Defines configuration specific to inference.
func (o EnvironmentVersionResponseOutput) InferenceConfig() InferenceContainerPropertiesResponsePtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *InferenceContainerPropertiesResponse { return v.InferenceConfig }).(InferenceContainerPropertiesResponsePtrOutput)
}

// Intellectual Property details. Used if environment is an Intellectual Property.
func (o EnvironmentVersionResponseOutput) IntellectualProperty() IntellectualPropertyResponsePtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *IntellectualPropertyResponse { return v.IntellectualProperty }).(IntellectualPropertyResponsePtrOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o EnvironmentVersionResponseOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o EnvironmentVersionResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The OS type of the environment.
func (o EnvironmentVersionResponseOutput) OsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *string { return v.OsType }).(pulumi.StringPtrOutput)
}

// The asset property dictionary.
func (o EnvironmentVersionResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the environment version.
func (o EnvironmentVersionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Stage in the environment lifecycle assigned to this environment
func (o EnvironmentVersionResponseOutput) Stage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) *string { return v.Stage }).(pulumi.StringPtrOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o EnvironmentVersionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentVersionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// The resource management error additional info.
type ErrorAdditionalInfoResponse struct {
	// The additional info.
	Info interface{} `pulumi:"info"`
	// The additional info type.
	Type string `pulumi:"type"`
}

// The error detail.
type ErrorDetailResponse struct {
	// The error additional info.
	AdditionalInfo []ErrorAdditionalInfoResponse `pulumi:"additionalInfo"`
	// The error code.
	Code string `pulumi:"code"`
	// The error details.
	Details []ErrorDetailResponse `pulumi:"details"`
	// The error message.
	Message string `pulumi:"message"`
	// The error target.
	Target string `pulumi:"target"`
}

// Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.).
type ErrorResponseResponse struct {
	// The error object.
	Error *ErrorDetailResponse `pulumi:"error"`
}

type FeatureAttributionDriftMonitoringSignal struct {
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThreshold FeatureAttributionMetricThreshold `pulumi:"metricThreshold"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// [Required] The data which drift will be calculated for.
	ProductionData []interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The data to calculate drift against.
	ReferenceData interface{} `pulumi:"referenceData"`
	// Expected value is 'FeatureAttributionDrift'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for FeatureAttributionDriftMonitoringSignal
func (val *FeatureAttributionDriftMonitoringSignal) Defaults() *FeatureAttributionDriftMonitoringSignal {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

type FeatureAttributionDriftMonitoringSignalResponse struct {
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThreshold FeatureAttributionMetricThresholdResponse `pulumi:"metricThreshold"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// [Required] The data which drift will be calculated for.
	ProductionData []interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The data to calculate drift against.
	ReferenceData interface{} `pulumi:"referenceData"`
	// Expected value is 'FeatureAttributionDrift'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for FeatureAttributionDriftMonitoringSignalResponse
func (val *FeatureAttributionDriftMonitoringSignalResponse) Defaults() *FeatureAttributionDriftMonitoringSignalResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

type FeatureAttributionMetricThreshold struct {
	// [Required] The feature attribution metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

type FeatureAttributionMetricThresholdResponse struct {
	// [Required] The feature attribution metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

type FeatureStoreSettings struct {
	ComputeRuntime             *ComputeRuntimeDto `pulumi:"computeRuntime"`
	OfflineStoreConnectionName *string            `pulumi:"offlineStoreConnectionName"`
	OnlineStoreConnectionName  *string            `pulumi:"onlineStoreConnectionName"`
}

// FeatureStoreSettingsInput is an input type that accepts FeatureStoreSettingsArgs and FeatureStoreSettingsOutput values.
// You can construct a concrete instance of `FeatureStoreSettingsInput` via:
//
//	FeatureStoreSettingsArgs{...}
type FeatureStoreSettingsInput interface {
	pulumi.Input

	ToFeatureStoreSettingsOutput() FeatureStoreSettingsOutput
	ToFeatureStoreSettingsOutputWithContext(context.Context) FeatureStoreSettingsOutput
}

type FeatureStoreSettingsArgs struct {
	ComputeRuntime             ComputeRuntimeDtoPtrInput `pulumi:"computeRuntime"`
	OfflineStoreConnectionName pulumi.StringPtrInput     `pulumi:"offlineStoreConnectionName"`
	OnlineStoreConnectionName  pulumi.StringPtrInput     `pulumi:"onlineStoreConnectionName"`
}

func (FeatureStoreSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FeatureStoreSettings)(nil)).Elem()
}

func (i FeatureStoreSettingsArgs) ToFeatureStoreSettingsOutput() FeatureStoreSettingsOutput {
	return i.ToFeatureStoreSettingsOutputWithContext(context.Background())
}

func (i FeatureStoreSettingsArgs) ToFeatureStoreSettingsOutputWithContext(ctx context.Context) FeatureStoreSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeatureStoreSettingsOutput)
}

func (i FeatureStoreSettingsArgs) ToFeatureStoreSettingsPtrOutput() FeatureStoreSettingsPtrOutput {
	return i.ToFeatureStoreSettingsPtrOutputWithContext(context.Background())
}

func (i FeatureStoreSettingsArgs) ToFeatureStoreSettingsPtrOutputWithContext(ctx context.Context) FeatureStoreSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeatureStoreSettingsOutput).ToFeatureStoreSettingsPtrOutputWithContext(ctx)
}

// FeatureStoreSettingsPtrInput is an input type that accepts FeatureStoreSettingsArgs, FeatureStoreSettingsPtr and FeatureStoreSettingsPtrOutput values.
// You can construct a concrete instance of `FeatureStoreSettingsPtrInput` via:
//
//	        FeatureStoreSettingsArgs{...}
//
//	or:
//
//	        nil
type FeatureStoreSettingsPtrInput interface {
	pulumi.Input

	ToFeatureStoreSettingsPtrOutput() FeatureStoreSettingsPtrOutput
	ToFeatureStoreSettingsPtrOutputWithContext(context.Context) FeatureStoreSettingsPtrOutput
}

type featureStoreSettingsPtrType FeatureStoreSettingsArgs

func FeatureStoreSettingsPtr(v *FeatureStoreSettingsArgs) FeatureStoreSettingsPtrInput {
	return (*featureStoreSettingsPtrType)(v)
}

func (*featureStoreSettingsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FeatureStoreSettings)(nil)).Elem()
}

func (i *featureStoreSettingsPtrType) ToFeatureStoreSettingsPtrOutput() FeatureStoreSettingsPtrOutput {
	return i.ToFeatureStoreSettingsPtrOutputWithContext(context.Background())
}

func (i *featureStoreSettingsPtrType) ToFeatureStoreSettingsPtrOutputWithContext(ctx context.Context) FeatureStoreSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeatureStoreSettingsPtrOutput)
}

type FeatureStoreSettingsOutput struct{ *pulumi.OutputState }

func (FeatureStoreSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeatureStoreSettings)(nil)).Elem()
}

func (o FeatureStoreSettingsOutput) ToFeatureStoreSettingsOutput() FeatureStoreSettingsOutput {
	return o
}

func (o FeatureStoreSettingsOutput) ToFeatureStoreSettingsOutputWithContext(ctx context.Context) FeatureStoreSettingsOutput {
	return o
}

func (o FeatureStoreSettingsOutput) ToFeatureStoreSettingsPtrOutput() FeatureStoreSettingsPtrOutput {
	return o.ToFeatureStoreSettingsPtrOutputWithContext(context.Background())
}

func (o FeatureStoreSettingsOutput) ToFeatureStoreSettingsPtrOutputWithContext(ctx context.Context) FeatureStoreSettingsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FeatureStoreSettings) *FeatureStoreSettings {
		return &v
	}).(FeatureStoreSettingsPtrOutput)
}

func (o FeatureStoreSettingsOutput) ComputeRuntime() ComputeRuntimeDtoPtrOutput {
	return o.ApplyT(func(v FeatureStoreSettings) *ComputeRuntimeDto { return v.ComputeRuntime }).(ComputeRuntimeDtoPtrOutput)
}

func (o FeatureStoreSettingsOutput) OfflineStoreConnectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeatureStoreSettings) *string { return v.OfflineStoreConnectionName }).(pulumi.StringPtrOutput)
}

func (o FeatureStoreSettingsOutput) OnlineStoreConnectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeatureStoreSettings) *string { return v.OnlineStoreConnectionName }).(pulumi.StringPtrOutput)
}

type FeatureStoreSettingsPtrOutput struct{ *pulumi.OutputState }

func (FeatureStoreSettingsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FeatureStoreSettings)(nil)).Elem()
}

func (o FeatureStoreSettingsPtrOutput) ToFeatureStoreSettingsPtrOutput() FeatureStoreSettingsPtrOutput {
	return o
}

func (o FeatureStoreSettingsPtrOutput) ToFeatureStoreSettingsPtrOutputWithContext(ctx context.Context) FeatureStoreSettingsPtrOutput {
	return o
}

func (o FeatureStoreSettingsPtrOutput) Elem() FeatureStoreSettingsOutput {
	return o.ApplyT(func(v *FeatureStoreSettings) FeatureStoreSettings {
		if v != nil {
			return *v
		}
		var ret FeatureStoreSettings
		return ret
	}).(FeatureStoreSettingsOutput)
}

func (o FeatureStoreSettingsPtrOutput) ComputeRuntime() ComputeRuntimeDtoPtrOutput {
	return o.ApplyT(func(v *FeatureStoreSettings) *ComputeRuntimeDto {
		if v == nil {
			return nil
		}
		return v.ComputeRuntime
	}).(ComputeRuntimeDtoPtrOutput)
}

func (o FeatureStoreSettingsPtrOutput) OfflineStoreConnectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FeatureStoreSettings) *string {
		if v == nil {
			return nil
		}
		return v.OfflineStoreConnectionName
	}).(pulumi.StringPtrOutput)
}

func (o FeatureStoreSettingsPtrOutput) OnlineStoreConnectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FeatureStoreSettings) *string {
		if v == nil {
			return nil
		}
		return v.OnlineStoreConnectionName
	}).(pulumi.StringPtrOutput)
}

type FeatureStoreSettingsResponse struct {
	ComputeRuntime             *ComputeRuntimeDtoResponse `pulumi:"computeRuntime"`
	OfflineStoreConnectionName *string                    `pulumi:"offlineStoreConnectionName"`
	OnlineStoreConnectionName  *string                    `pulumi:"onlineStoreConnectionName"`
}

type FeatureStoreSettingsResponseOutput struct{ *pulumi.OutputState }

func (FeatureStoreSettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeatureStoreSettingsResponse)(nil)).Elem()
}

func (o FeatureStoreSettingsResponseOutput) ToFeatureStoreSettingsResponseOutput() FeatureStoreSettingsResponseOutput {
	return o
}

func (o FeatureStoreSettingsResponseOutput) ToFeatureStoreSettingsResponseOutputWithContext(ctx context.Context) FeatureStoreSettingsResponseOutput {
	return o
}

func (o FeatureStoreSettingsResponseOutput) ComputeRuntime() ComputeRuntimeDtoResponsePtrOutput {
	return o.ApplyT(func(v FeatureStoreSettingsResponse) *ComputeRuntimeDtoResponse { return v.ComputeRuntime }).(ComputeRuntimeDtoResponsePtrOutput)
}

func (o FeatureStoreSettingsResponseOutput) OfflineStoreConnectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeatureStoreSettingsResponse) *string { return v.OfflineStoreConnectionName }).(pulumi.StringPtrOutput)
}

func (o FeatureStoreSettingsResponseOutput) OnlineStoreConnectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeatureStoreSettingsResponse) *string { return v.OnlineStoreConnectionName }).(pulumi.StringPtrOutput)
}

type FeatureStoreSettingsResponsePtrOutput struct{ *pulumi.OutputState }

func (FeatureStoreSettingsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FeatureStoreSettingsResponse)(nil)).Elem()
}

func (o FeatureStoreSettingsResponsePtrOutput) ToFeatureStoreSettingsResponsePtrOutput() FeatureStoreSettingsResponsePtrOutput {
	return o
}

func (o FeatureStoreSettingsResponsePtrOutput) ToFeatureStoreSettingsResponsePtrOutputWithContext(ctx context.Context) FeatureStoreSettingsResponsePtrOutput {
	return o
}

func (o FeatureStoreSettingsResponsePtrOutput) Elem() FeatureStoreSettingsResponseOutput {
	return o.ApplyT(func(v *FeatureStoreSettingsResponse) FeatureStoreSettingsResponse {
		if v != nil {
			return *v
		}
		var ret FeatureStoreSettingsResponse
		return ret
	}).(FeatureStoreSettingsResponseOutput)
}

func (o FeatureStoreSettingsResponsePtrOutput) ComputeRuntime() ComputeRuntimeDtoResponsePtrOutput {
	return o.ApplyT(func(v *FeatureStoreSettingsResponse) *ComputeRuntimeDtoResponse {
		if v == nil {
			return nil
		}
		return v.ComputeRuntime
	}).(ComputeRuntimeDtoResponsePtrOutput)
}

func (o FeatureStoreSettingsResponsePtrOutput) OfflineStoreConnectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FeatureStoreSettingsResponse) *string {
		if v == nil {
			return nil
		}
		return v.OfflineStoreConnectionName
	}).(pulumi.StringPtrOutput)
}

func (o FeatureStoreSettingsResponsePtrOutput) OnlineStoreConnectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FeatureStoreSettingsResponse) *string {
		if v == nil {
			return nil
		}
		return v.OnlineStoreConnectionName
	}).(pulumi.StringPtrOutput)
}

type FeatureSubset struct {
	// [Required] The list of features to include.
	Features []string `pulumi:"features"`
	// Expected value is 'FeatureSubset'.
	FilterType string `pulumi:"filterType"`
}

type FeatureSubsetResponse struct {
	// [Required] The list of features to include.
	Features []string `pulumi:"features"`
	// Expected value is 'FeatureSubset'.
	FilterType string `pulumi:"filterType"`
}

// Specifies the feature window
type FeatureWindowResponse struct {
	// Specifies the feature window end time
	FeatureWindowEnd *string `pulumi:"featureWindowEnd"`
	// Specifies the feature window start time
	FeatureWindowStart *string `pulumi:"featureWindowStart"`
}

// Specifies the feature window
type FeatureWindowResponseOutput struct{ *pulumi.OutputState }

func (FeatureWindowResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeatureWindowResponse)(nil)).Elem()
}

func (o FeatureWindowResponseOutput) ToFeatureWindowResponseOutput() FeatureWindowResponseOutput {
	return o
}

func (o FeatureWindowResponseOutput) ToFeatureWindowResponseOutputWithContext(ctx context.Context) FeatureWindowResponseOutput {
	return o
}

// Specifies the feature window end time
func (o FeatureWindowResponseOutput) FeatureWindowEnd() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeatureWindowResponse) *string { return v.FeatureWindowEnd }).(pulumi.StringPtrOutput)
}

// Specifies the feature window start time
func (o FeatureWindowResponseOutput) FeatureWindowStart() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeatureWindowResponse) *string { return v.FeatureWindowStart }).(pulumi.StringPtrOutput)
}

type FeatureWindowResponsePtrOutput struct{ *pulumi.OutputState }

func (FeatureWindowResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FeatureWindowResponse)(nil)).Elem()
}

func (o FeatureWindowResponsePtrOutput) ToFeatureWindowResponsePtrOutput() FeatureWindowResponsePtrOutput {
	return o
}

func (o FeatureWindowResponsePtrOutput) ToFeatureWindowResponsePtrOutputWithContext(ctx context.Context) FeatureWindowResponsePtrOutput {
	return o
}

func (o FeatureWindowResponsePtrOutput) Elem() FeatureWindowResponseOutput {
	return o.ApplyT(func(v *FeatureWindowResponse) FeatureWindowResponse {
		if v != nil {
			return *v
		}
		var ret FeatureWindowResponse
		return ret
	}).(FeatureWindowResponseOutput)
}

// Specifies the feature window end time
func (o FeatureWindowResponsePtrOutput) FeatureWindowEnd() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FeatureWindowResponse) *string {
		if v == nil {
			return nil
		}
		return v.FeatureWindowEnd
	}).(pulumi.StringPtrOutput)
}

// Specifies the feature window start time
func (o FeatureWindowResponsePtrOutput) FeatureWindowStart() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FeatureWindowResponse) *string {
		if v == nil {
			return nil
		}
		return v.FeatureWindowStart
	}).(pulumi.StringPtrOutput)
}

// Dto object representing feature set
type FeaturesetContainer struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturesetContainer
func (val *FeaturesetContainer) Defaults() *FeaturesetContainer {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// FeaturesetContainerInput is an input type that accepts FeaturesetContainerArgs and FeaturesetContainerOutput values.
// You can construct a concrete instance of `FeaturesetContainerInput` via:
//
//	FeaturesetContainerArgs{...}
type FeaturesetContainerInput interface {
	pulumi.Input

	ToFeaturesetContainerOutput() FeaturesetContainerOutput
	ToFeaturesetContainerOutputWithContext(context.Context) FeaturesetContainerOutput
}

// Dto object representing feature set
type FeaturesetContainerArgs struct {
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturesetContainerArgs
func (val *FeaturesetContainerArgs) Defaults() *FeaturesetContainerArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (FeaturesetContainerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturesetContainer)(nil)).Elem()
}

func (i FeaturesetContainerArgs) ToFeaturesetContainerOutput() FeaturesetContainerOutput {
	return i.ToFeaturesetContainerOutputWithContext(context.Background())
}

func (i FeaturesetContainerArgs) ToFeaturesetContainerOutputWithContext(ctx context.Context) FeaturesetContainerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeaturesetContainerOutput)
}

// Dto object representing feature set
type FeaturesetContainerOutput struct{ *pulumi.OutputState }

func (FeaturesetContainerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturesetContainer)(nil)).Elem()
}

func (o FeaturesetContainerOutput) ToFeaturesetContainerOutput() FeaturesetContainerOutput {
	return o
}

func (o FeaturesetContainerOutput) ToFeaturesetContainerOutputWithContext(ctx context.Context) FeaturesetContainerOutput {
	return o
}

// The asset description text.
func (o FeaturesetContainerOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetContainer) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o FeaturesetContainerOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturesetContainer) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o FeaturesetContainerOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturesetContainer) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o FeaturesetContainerOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturesetContainer) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Dto object representing feature set
type FeaturesetContainerResponse struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the featureset container.
	ProvisioningState string `pulumi:"provisioningState"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturesetContainerResponse
func (val *FeaturesetContainerResponse) Defaults() *FeaturesetContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Dto object representing feature set
type FeaturesetContainerResponseOutput struct{ *pulumi.OutputState }

func (FeaturesetContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturesetContainerResponse)(nil)).Elem()
}

func (o FeaturesetContainerResponseOutput) ToFeaturesetContainerResponseOutput() FeaturesetContainerResponseOutput {
	return o
}

func (o FeaturesetContainerResponseOutput) ToFeaturesetContainerResponseOutputWithContext(ctx context.Context) FeaturesetContainerResponseOutput {
	return o
}

// The asset description text.
func (o FeaturesetContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o FeaturesetContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturesetContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o FeaturesetContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v FeaturesetContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o FeaturesetContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v FeaturesetContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o FeaturesetContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturesetContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the featureset container.
func (o FeaturesetContainerResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v FeaturesetContainerResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o FeaturesetContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturesetContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Dto object representing the feature set job
type FeaturesetJobResponse struct {
	// Specifies the created date
	CreatedDate *string `pulumi:"createdDate"`
	// Specifies the display name
	DisplayName *string `pulumi:"displayName"`
	// Specifies the duration
	Duration *string `pulumi:"duration"`
	// Specifies the experiment id
	ExperimentId *string `pulumi:"experimentId"`
	// Specifies the backfill feature window to be materialized
	FeatureWindow *FeatureWindowResponse `pulumi:"featureWindow"`
	// Specifies the job id
	JobId *string `pulumi:"jobId"`
	// Specifies the job status
	Status *string `pulumi:"status"`
	// Specifies the tags if any
	Tags map[string]string `pulumi:"tags"`
	// Specifies the feature store job type
	Type *string `pulumi:"type"`
}

// Defaults sets the appropriate defaults for FeaturesetJobResponse
func (val *FeaturesetJobResponse) Defaults() *FeaturesetJobResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Status == nil {
		status_ := "Unknown"
		tmp.Status = &status_
	}
	if tmp.Type == nil {
		type_ := "RecurrentMaterialization"
		tmp.Type = &type_
	}
	return &tmp
}

// Dto object representing the feature set job
type FeaturesetJobResponseOutput struct{ *pulumi.OutputState }

func (FeaturesetJobResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturesetJobResponse)(nil)).Elem()
}

func (o FeaturesetJobResponseOutput) ToFeaturesetJobResponseOutput() FeaturesetJobResponseOutput {
	return o
}

func (o FeaturesetJobResponseOutput) ToFeaturesetJobResponseOutputWithContext(ctx context.Context) FeaturesetJobResponseOutput {
	return o
}

// Specifies the created date
func (o FeaturesetJobResponseOutput) CreatedDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetJobResponse) *string { return v.CreatedDate }).(pulumi.StringPtrOutput)
}

// Specifies the display name
func (o FeaturesetJobResponseOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetJobResponse) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Specifies the duration
func (o FeaturesetJobResponseOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetJobResponse) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// Specifies the experiment id
func (o FeaturesetJobResponseOutput) ExperimentId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetJobResponse) *string { return v.ExperimentId }).(pulumi.StringPtrOutput)
}

// Specifies the backfill feature window to be materialized
func (o FeaturesetJobResponseOutput) FeatureWindow() FeatureWindowResponsePtrOutput {
	return o.ApplyT(func(v FeaturesetJobResponse) *FeatureWindowResponse { return v.FeatureWindow }).(FeatureWindowResponsePtrOutput)
}

// Specifies the job id
func (o FeaturesetJobResponseOutput) JobId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetJobResponse) *string { return v.JobId }).(pulumi.StringPtrOutput)
}

// Specifies the job status
func (o FeaturesetJobResponseOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetJobResponse) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// Specifies the tags if any
func (o FeaturesetJobResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturesetJobResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Specifies the feature store job type
func (o FeaturesetJobResponseOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetJobResponse) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type FeaturesetJobResponseArrayOutput struct{ *pulumi.OutputState }

func (FeaturesetJobResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FeaturesetJobResponse)(nil)).Elem()
}

func (o FeaturesetJobResponseArrayOutput) ToFeaturesetJobResponseArrayOutput() FeaturesetJobResponseArrayOutput {
	return o
}

func (o FeaturesetJobResponseArrayOutput) ToFeaturesetJobResponseArrayOutputWithContext(ctx context.Context) FeaturesetJobResponseArrayOutput {
	return o
}

func (o FeaturesetJobResponseArrayOutput) Index(i pulumi.IntInput) FeaturesetJobResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FeaturesetJobResponse {
		return vs[0].([]FeaturesetJobResponse)[vs[1].(int)]
	}).(FeaturesetJobResponseOutput)
}

// Dto object representing specification
type FeaturesetSpecification struct {
	// Specifies the spec path
	Path *string `pulumi:"path"`
}

// FeaturesetSpecificationInput is an input type that accepts FeaturesetSpecificationArgs and FeaturesetSpecificationOutput values.
// You can construct a concrete instance of `FeaturesetSpecificationInput` via:
//
//	FeaturesetSpecificationArgs{...}
type FeaturesetSpecificationInput interface {
	pulumi.Input

	ToFeaturesetSpecificationOutput() FeaturesetSpecificationOutput
	ToFeaturesetSpecificationOutputWithContext(context.Context) FeaturesetSpecificationOutput
}

// Dto object representing specification
type FeaturesetSpecificationArgs struct {
	// Specifies the spec path
	Path pulumi.StringPtrInput `pulumi:"path"`
}

func (FeaturesetSpecificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturesetSpecification)(nil)).Elem()
}

func (i FeaturesetSpecificationArgs) ToFeaturesetSpecificationOutput() FeaturesetSpecificationOutput {
	return i.ToFeaturesetSpecificationOutputWithContext(context.Background())
}

func (i FeaturesetSpecificationArgs) ToFeaturesetSpecificationOutputWithContext(ctx context.Context) FeaturesetSpecificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeaturesetSpecificationOutput)
}

func (i FeaturesetSpecificationArgs) ToFeaturesetSpecificationPtrOutput() FeaturesetSpecificationPtrOutput {
	return i.ToFeaturesetSpecificationPtrOutputWithContext(context.Background())
}

func (i FeaturesetSpecificationArgs) ToFeaturesetSpecificationPtrOutputWithContext(ctx context.Context) FeaturesetSpecificationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeaturesetSpecificationOutput).ToFeaturesetSpecificationPtrOutputWithContext(ctx)
}

// FeaturesetSpecificationPtrInput is an input type that accepts FeaturesetSpecificationArgs, FeaturesetSpecificationPtr and FeaturesetSpecificationPtrOutput values.
// You can construct a concrete instance of `FeaturesetSpecificationPtrInput` via:
//
//	        FeaturesetSpecificationArgs{...}
//
//	or:
//
//	        nil
type FeaturesetSpecificationPtrInput interface {
	pulumi.Input

	ToFeaturesetSpecificationPtrOutput() FeaturesetSpecificationPtrOutput
	ToFeaturesetSpecificationPtrOutputWithContext(context.Context) FeaturesetSpecificationPtrOutput
}

type featuresetSpecificationPtrType FeaturesetSpecificationArgs

func FeaturesetSpecificationPtr(v *FeaturesetSpecificationArgs) FeaturesetSpecificationPtrInput {
	return (*featuresetSpecificationPtrType)(v)
}

func (*featuresetSpecificationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FeaturesetSpecification)(nil)).Elem()
}

func (i *featuresetSpecificationPtrType) ToFeaturesetSpecificationPtrOutput() FeaturesetSpecificationPtrOutput {
	return i.ToFeaturesetSpecificationPtrOutputWithContext(context.Background())
}

func (i *featuresetSpecificationPtrType) ToFeaturesetSpecificationPtrOutputWithContext(ctx context.Context) FeaturesetSpecificationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeaturesetSpecificationPtrOutput)
}

// Dto object representing specification
type FeaturesetSpecificationOutput struct{ *pulumi.OutputState }

func (FeaturesetSpecificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturesetSpecification)(nil)).Elem()
}

func (o FeaturesetSpecificationOutput) ToFeaturesetSpecificationOutput() FeaturesetSpecificationOutput {
	return o
}

func (o FeaturesetSpecificationOutput) ToFeaturesetSpecificationOutputWithContext(ctx context.Context) FeaturesetSpecificationOutput {
	return o
}

func (o FeaturesetSpecificationOutput) ToFeaturesetSpecificationPtrOutput() FeaturesetSpecificationPtrOutput {
	return o.ToFeaturesetSpecificationPtrOutputWithContext(context.Background())
}

func (o FeaturesetSpecificationOutput) ToFeaturesetSpecificationPtrOutputWithContext(ctx context.Context) FeaturesetSpecificationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FeaturesetSpecification) *FeaturesetSpecification {
		return &v
	}).(FeaturesetSpecificationPtrOutput)
}

// Specifies the spec path
func (o FeaturesetSpecificationOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetSpecification) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type FeaturesetSpecificationPtrOutput struct{ *pulumi.OutputState }

func (FeaturesetSpecificationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FeaturesetSpecification)(nil)).Elem()
}

func (o FeaturesetSpecificationPtrOutput) ToFeaturesetSpecificationPtrOutput() FeaturesetSpecificationPtrOutput {
	return o
}

func (o FeaturesetSpecificationPtrOutput) ToFeaturesetSpecificationPtrOutputWithContext(ctx context.Context) FeaturesetSpecificationPtrOutput {
	return o
}

func (o FeaturesetSpecificationPtrOutput) Elem() FeaturesetSpecificationOutput {
	return o.ApplyT(func(v *FeaturesetSpecification) FeaturesetSpecification {
		if v != nil {
			return *v
		}
		var ret FeaturesetSpecification
		return ret
	}).(FeaturesetSpecificationOutput)
}

// Specifies the spec path
func (o FeaturesetSpecificationPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FeaturesetSpecification) *string {
		if v == nil {
			return nil
		}
		return v.Path
	}).(pulumi.StringPtrOutput)
}

// Dto object representing specification
type FeaturesetSpecificationResponse struct {
	// Specifies the spec path
	Path *string `pulumi:"path"`
}

// Dto object representing specification
type FeaturesetSpecificationResponseOutput struct{ *pulumi.OutputState }

func (FeaturesetSpecificationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturesetSpecificationResponse)(nil)).Elem()
}

func (o FeaturesetSpecificationResponseOutput) ToFeaturesetSpecificationResponseOutput() FeaturesetSpecificationResponseOutput {
	return o
}

func (o FeaturesetSpecificationResponseOutput) ToFeaturesetSpecificationResponseOutputWithContext(ctx context.Context) FeaturesetSpecificationResponseOutput {
	return o
}

// Specifies the spec path
func (o FeaturesetSpecificationResponseOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetSpecificationResponse) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type FeaturesetSpecificationResponsePtrOutput struct{ *pulumi.OutputState }

func (FeaturesetSpecificationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FeaturesetSpecificationResponse)(nil)).Elem()
}

func (o FeaturesetSpecificationResponsePtrOutput) ToFeaturesetSpecificationResponsePtrOutput() FeaturesetSpecificationResponsePtrOutput {
	return o
}

func (o FeaturesetSpecificationResponsePtrOutput) ToFeaturesetSpecificationResponsePtrOutputWithContext(ctx context.Context) FeaturesetSpecificationResponsePtrOutput {
	return o
}

func (o FeaturesetSpecificationResponsePtrOutput) Elem() FeaturesetSpecificationResponseOutput {
	return o.ApplyT(func(v *FeaturesetSpecificationResponse) FeaturesetSpecificationResponse {
		if v != nil {
			return *v
		}
		var ret FeaturesetSpecificationResponse
		return ret
	}).(FeaturesetSpecificationResponseOutput)
}

// Specifies the spec path
func (o FeaturesetSpecificationResponsePtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FeaturesetSpecificationResponse) *string {
		if v == nil {
			return nil
		}
		return v.Path
	}).(pulumi.StringPtrOutput)
}

// Dto object representing feature set version
type FeaturesetVersionType struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSetting `pulumi:"autoDeleteSetting"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Specifies list of entities
	Entities []string `pulumi:"entities"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// Specifies the materialization settings
	MaterializationSettings *MaterializationSettings `pulumi:"materializationSettings"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Specifies the feature spec details
	Specification *FeaturesetSpecification `pulumi:"specification"`
	// Specifies the asset stage
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturesetVersionType
func (val *FeaturesetVersionType) Defaults() *FeaturesetVersionType {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.MaterializationSettings = tmp.MaterializationSettings.Defaults()

	return &tmp
}

// FeaturesetVersionTypeInput is an input type that accepts FeaturesetVersionTypeArgs and FeaturesetVersionTypeOutput values.
// You can construct a concrete instance of `FeaturesetVersionTypeInput` via:
//
//	FeaturesetVersionTypeArgs{...}
type FeaturesetVersionTypeInput interface {
	pulumi.Input

	ToFeaturesetVersionTypeOutput() FeaturesetVersionTypeOutput
	ToFeaturesetVersionTypeOutputWithContext(context.Context) FeaturesetVersionTypeOutput
}

// Dto object representing feature set version
type FeaturesetVersionTypeArgs struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting AutoDeleteSettingPtrInput `pulumi:"autoDeleteSetting"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Specifies list of entities
	Entities pulumi.StringArrayInput `pulumi:"entities"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous pulumi.BoolPtrInput `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// Specifies the materialization settings
	MaterializationSettings MaterializationSettingsPtrInput `pulumi:"materializationSettings"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Specifies the feature spec details
	Specification FeaturesetSpecificationPtrInput `pulumi:"specification"`
	// Specifies the asset stage
	Stage pulumi.StringPtrInput `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturesetVersionTypeArgs
func (val *FeaturesetVersionTypeArgs) Defaults() *FeaturesetVersionTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	if tmp.IsAnonymous == nil {
		tmp.IsAnonymous = pulumi.BoolPtr(false)
	}
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}

	return &tmp
}
func (FeaturesetVersionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturesetVersionType)(nil)).Elem()
}

func (i FeaturesetVersionTypeArgs) ToFeaturesetVersionTypeOutput() FeaturesetVersionTypeOutput {
	return i.ToFeaturesetVersionTypeOutputWithContext(context.Background())
}

func (i FeaturesetVersionTypeArgs) ToFeaturesetVersionTypeOutputWithContext(ctx context.Context) FeaturesetVersionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeaturesetVersionTypeOutput)
}

// Dto object representing feature set version
type FeaturesetVersionTypeOutput struct{ *pulumi.OutputState }

func (FeaturesetVersionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturesetVersionType)(nil)).Elem()
}

func (o FeaturesetVersionTypeOutput) ToFeaturesetVersionTypeOutput() FeaturesetVersionTypeOutput {
	return o
}

func (o FeaturesetVersionTypeOutput) ToFeaturesetVersionTypeOutputWithContext(ctx context.Context) FeaturesetVersionTypeOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o FeaturesetVersionTypeOutput) AutoDeleteSetting() AutoDeleteSettingPtrOutput {
	return o.ApplyT(func(v FeaturesetVersionType) *AutoDeleteSetting { return v.AutoDeleteSetting }).(AutoDeleteSettingPtrOutput)
}

// The asset description text.
func (o FeaturesetVersionTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetVersionType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Specifies list of entities
func (o FeaturesetVersionTypeOutput) Entities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FeaturesetVersionType) []string { return v.Entities }).(pulumi.StringArrayOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o FeaturesetVersionTypeOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturesetVersionType) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o FeaturesetVersionTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturesetVersionType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// Specifies the materialization settings
func (o FeaturesetVersionTypeOutput) MaterializationSettings() MaterializationSettingsPtrOutput {
	return o.ApplyT(func(v FeaturesetVersionType) *MaterializationSettings { return v.MaterializationSettings }).(MaterializationSettingsPtrOutput)
}

// The asset property dictionary.
func (o FeaturesetVersionTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturesetVersionType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Specifies the feature spec details
func (o FeaturesetVersionTypeOutput) Specification() FeaturesetSpecificationPtrOutput {
	return o.ApplyT(func(v FeaturesetVersionType) *FeaturesetSpecification { return v.Specification }).(FeaturesetSpecificationPtrOutput)
}

// Specifies the asset stage
func (o FeaturesetVersionTypeOutput) Stage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetVersionType) *string { return v.Stage }).(pulumi.StringPtrOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o FeaturesetVersionTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturesetVersionType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Dto object representing feature set version
type FeaturesetVersionResponse struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSettingResponse `pulumi:"autoDeleteSetting"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Specifies list of entities
	Entities []string `pulumi:"entities"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// Specifies the materialization settings
	MaterializationSettings *MaterializationSettingsResponse `pulumi:"materializationSettings"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the featureset version container.
	ProvisioningState string `pulumi:"provisioningState"`
	// Specifies the feature spec details
	Specification *FeaturesetSpecificationResponse `pulumi:"specification"`
	// Specifies the asset stage
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturesetVersionResponse
func (val *FeaturesetVersionResponse) Defaults() *FeaturesetVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	tmp.MaterializationSettings = tmp.MaterializationSettings.Defaults()

	return &tmp
}

// Dto object representing feature set version
type FeaturesetVersionResponseOutput struct{ *pulumi.OutputState }

func (FeaturesetVersionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturesetVersionResponse)(nil)).Elem()
}

func (o FeaturesetVersionResponseOutput) ToFeaturesetVersionResponseOutput() FeaturesetVersionResponseOutput {
	return o
}

func (o FeaturesetVersionResponseOutput) ToFeaturesetVersionResponseOutputWithContext(ctx context.Context) FeaturesetVersionResponseOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o FeaturesetVersionResponseOutput) AutoDeleteSetting() AutoDeleteSettingResponsePtrOutput {
	return o.ApplyT(func(v FeaturesetVersionResponse) *AutoDeleteSettingResponse { return v.AutoDeleteSetting }).(AutoDeleteSettingResponsePtrOutput)
}

// The asset description text.
func (o FeaturesetVersionResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetVersionResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Specifies list of entities
func (o FeaturesetVersionResponseOutput) Entities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FeaturesetVersionResponse) []string { return v.Entities }).(pulumi.StringArrayOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o FeaturesetVersionResponseOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturesetVersionResponse) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o FeaturesetVersionResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturesetVersionResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// Specifies the materialization settings
func (o FeaturesetVersionResponseOutput) MaterializationSettings() MaterializationSettingsResponsePtrOutput {
	return o.ApplyT(func(v FeaturesetVersionResponse) *MaterializationSettingsResponse { return v.MaterializationSettings }).(MaterializationSettingsResponsePtrOutput)
}

// The asset property dictionary.
func (o FeaturesetVersionResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturesetVersionResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the featureset version container.
func (o FeaturesetVersionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v FeaturesetVersionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Specifies the feature spec details
func (o FeaturesetVersionResponseOutput) Specification() FeaturesetSpecificationResponsePtrOutput {
	return o.ApplyT(func(v FeaturesetVersionResponse) *FeaturesetSpecificationResponse { return v.Specification }).(FeaturesetSpecificationResponsePtrOutput)
}

// Specifies the asset stage
func (o FeaturesetVersionResponseOutput) Stage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturesetVersionResponse) *string { return v.Stage }).(pulumi.StringPtrOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o FeaturesetVersionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturesetVersionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Dto object representing feature entity
type FeaturestoreEntityContainer struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturestoreEntityContainer
func (val *FeaturestoreEntityContainer) Defaults() *FeaturestoreEntityContainer {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// FeaturestoreEntityContainerInput is an input type that accepts FeaturestoreEntityContainerArgs and FeaturestoreEntityContainerOutput values.
// You can construct a concrete instance of `FeaturestoreEntityContainerInput` via:
//
//	FeaturestoreEntityContainerArgs{...}
type FeaturestoreEntityContainerInput interface {
	pulumi.Input

	ToFeaturestoreEntityContainerOutput() FeaturestoreEntityContainerOutput
	ToFeaturestoreEntityContainerOutputWithContext(context.Context) FeaturestoreEntityContainerOutput
}

// Dto object representing feature entity
type FeaturestoreEntityContainerArgs struct {
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturestoreEntityContainerArgs
func (val *FeaturestoreEntityContainerArgs) Defaults() *FeaturestoreEntityContainerArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (FeaturestoreEntityContainerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturestoreEntityContainer)(nil)).Elem()
}

func (i FeaturestoreEntityContainerArgs) ToFeaturestoreEntityContainerOutput() FeaturestoreEntityContainerOutput {
	return i.ToFeaturestoreEntityContainerOutputWithContext(context.Background())
}

func (i FeaturestoreEntityContainerArgs) ToFeaturestoreEntityContainerOutputWithContext(ctx context.Context) FeaturestoreEntityContainerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeaturestoreEntityContainerOutput)
}

// Dto object representing feature entity
type FeaturestoreEntityContainerOutput struct{ *pulumi.OutputState }

func (FeaturestoreEntityContainerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturestoreEntityContainer)(nil)).Elem()
}

func (o FeaturestoreEntityContainerOutput) ToFeaturestoreEntityContainerOutput() FeaturestoreEntityContainerOutput {
	return o
}

func (o FeaturestoreEntityContainerOutput) ToFeaturestoreEntityContainerOutputWithContext(ctx context.Context) FeaturestoreEntityContainerOutput {
	return o
}

// The asset description text.
func (o FeaturestoreEntityContainerOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityContainer) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o FeaturestoreEntityContainerOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityContainer) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o FeaturestoreEntityContainerOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturestoreEntityContainer) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o FeaturestoreEntityContainerOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturestoreEntityContainer) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Dto object representing feature entity
type FeaturestoreEntityContainerResponse struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the featurestore entity container.
	ProvisioningState string `pulumi:"provisioningState"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturestoreEntityContainerResponse
func (val *FeaturestoreEntityContainerResponse) Defaults() *FeaturestoreEntityContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Dto object representing feature entity
type FeaturestoreEntityContainerResponseOutput struct{ *pulumi.OutputState }

func (FeaturestoreEntityContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturestoreEntityContainerResponse)(nil)).Elem()
}

func (o FeaturestoreEntityContainerResponseOutput) ToFeaturestoreEntityContainerResponseOutput() FeaturestoreEntityContainerResponseOutput {
	return o
}

func (o FeaturestoreEntityContainerResponseOutput) ToFeaturestoreEntityContainerResponseOutputWithContext(ctx context.Context) FeaturestoreEntityContainerResponseOutput {
	return o
}

// The asset description text.
func (o FeaturestoreEntityContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o FeaturestoreEntityContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o FeaturestoreEntityContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v FeaturestoreEntityContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o FeaturestoreEntityContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v FeaturestoreEntityContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o FeaturestoreEntityContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturestoreEntityContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the featurestore entity container.
func (o FeaturestoreEntityContainerResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v FeaturestoreEntityContainerResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o FeaturestoreEntityContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturestoreEntityContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Dto object representing feature entity version
type FeaturestoreEntityVersionType struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSetting `pulumi:"autoDeleteSetting"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Specifies index columns
	IndexColumns []IndexColumn `pulumi:"indexColumns"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Specifies the asset stage
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturestoreEntityVersionType
func (val *FeaturestoreEntityVersionType) Defaults() *FeaturestoreEntityVersionType {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// FeaturestoreEntityVersionTypeInput is an input type that accepts FeaturestoreEntityVersionTypeArgs and FeaturestoreEntityVersionTypeOutput values.
// You can construct a concrete instance of `FeaturestoreEntityVersionTypeInput` via:
//
//	FeaturestoreEntityVersionTypeArgs{...}
type FeaturestoreEntityVersionTypeInput interface {
	pulumi.Input

	ToFeaturestoreEntityVersionTypeOutput() FeaturestoreEntityVersionTypeOutput
	ToFeaturestoreEntityVersionTypeOutputWithContext(context.Context) FeaturestoreEntityVersionTypeOutput
}

// Dto object representing feature entity version
type FeaturestoreEntityVersionTypeArgs struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting AutoDeleteSettingPtrInput `pulumi:"autoDeleteSetting"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Specifies index columns
	IndexColumns IndexColumnArrayInput `pulumi:"indexColumns"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous pulumi.BoolPtrInput `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Specifies the asset stage
	Stage pulumi.StringPtrInput `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturestoreEntityVersionTypeArgs
func (val *FeaturestoreEntityVersionTypeArgs) Defaults() *FeaturestoreEntityVersionTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	if tmp.IsAnonymous == nil {
		tmp.IsAnonymous = pulumi.BoolPtr(false)
	}
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (FeaturestoreEntityVersionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturestoreEntityVersionType)(nil)).Elem()
}

func (i FeaturestoreEntityVersionTypeArgs) ToFeaturestoreEntityVersionTypeOutput() FeaturestoreEntityVersionTypeOutput {
	return i.ToFeaturestoreEntityVersionTypeOutputWithContext(context.Background())
}

func (i FeaturestoreEntityVersionTypeArgs) ToFeaturestoreEntityVersionTypeOutputWithContext(ctx context.Context) FeaturestoreEntityVersionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeaturestoreEntityVersionTypeOutput)
}

// Dto object representing feature entity version
type FeaturestoreEntityVersionTypeOutput struct{ *pulumi.OutputState }

func (FeaturestoreEntityVersionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturestoreEntityVersionType)(nil)).Elem()
}

func (o FeaturestoreEntityVersionTypeOutput) ToFeaturestoreEntityVersionTypeOutput() FeaturestoreEntityVersionTypeOutput {
	return o
}

func (o FeaturestoreEntityVersionTypeOutput) ToFeaturestoreEntityVersionTypeOutputWithContext(ctx context.Context) FeaturestoreEntityVersionTypeOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o FeaturestoreEntityVersionTypeOutput) AutoDeleteSetting() AutoDeleteSettingPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionType) *AutoDeleteSetting { return v.AutoDeleteSetting }).(AutoDeleteSettingPtrOutput)
}

// The asset description text.
func (o FeaturestoreEntityVersionTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Specifies index columns
func (o FeaturestoreEntityVersionTypeOutput) IndexColumns() IndexColumnArrayOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionType) []IndexColumn { return v.IndexColumns }).(IndexColumnArrayOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o FeaturestoreEntityVersionTypeOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionType) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o FeaturestoreEntityVersionTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o FeaturestoreEntityVersionTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Specifies the asset stage
func (o FeaturestoreEntityVersionTypeOutput) Stage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionType) *string { return v.Stage }).(pulumi.StringPtrOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o FeaturestoreEntityVersionTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Dto object representing feature entity version
type FeaturestoreEntityVersionResponse struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSettingResponse `pulumi:"autoDeleteSetting"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Specifies index columns
	IndexColumns []IndexColumnResponse `pulumi:"indexColumns"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the featurestore entity version.
	ProvisioningState string `pulumi:"provisioningState"`
	// Specifies the asset stage
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for FeaturestoreEntityVersionResponse
func (val *FeaturestoreEntityVersionResponse) Defaults() *FeaturestoreEntityVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Dto object representing feature entity version
type FeaturestoreEntityVersionResponseOutput struct{ *pulumi.OutputState }

func (FeaturestoreEntityVersionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FeaturestoreEntityVersionResponse)(nil)).Elem()
}

func (o FeaturestoreEntityVersionResponseOutput) ToFeaturestoreEntityVersionResponseOutput() FeaturestoreEntityVersionResponseOutput {
	return o
}

func (o FeaturestoreEntityVersionResponseOutput) ToFeaturestoreEntityVersionResponseOutputWithContext(ctx context.Context) FeaturestoreEntityVersionResponseOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o FeaturestoreEntityVersionResponseOutput) AutoDeleteSetting() AutoDeleteSettingResponsePtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionResponse) *AutoDeleteSettingResponse { return v.AutoDeleteSetting }).(AutoDeleteSettingResponsePtrOutput)
}

// The asset description text.
func (o FeaturestoreEntityVersionResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Specifies index columns
func (o FeaturestoreEntityVersionResponseOutput) IndexColumns() IndexColumnResponseArrayOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionResponse) []IndexColumnResponse { return v.IndexColumns }).(IndexColumnResponseArrayOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o FeaturestoreEntityVersionResponseOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionResponse) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o FeaturestoreEntityVersionResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o FeaturestoreEntityVersionResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the featurestore entity version.
func (o FeaturestoreEntityVersionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Specifies the asset stage
func (o FeaturestoreEntityVersionResponseOutput) Stage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionResponse) *string { return v.Stage }).(pulumi.StringPtrOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o FeaturestoreEntityVersionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v FeaturestoreEntityVersionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

type FileSystemSource struct {
	// Workspace connection for data import source storage
	Connection *string `pulumi:"connection"`
	// Path on data import FileSystem source
	Path *string `pulumi:"path"`
	// Enum to determine the type of data.
	// Expected value is 'file_system'.
	SourceType string `pulumi:"sourceType"`
}

type FileSystemSourceResponse struct {
	// Workspace connection for data import source storage
	Connection *string `pulumi:"connection"`
	// Path on data import FileSystem source
	Path *string `pulumi:"path"`
	// Enum to determine the type of data.
	// Expected value is 'file_system'.
	SourceType string `pulumi:"sourceType"`
}

// Fixed input data definition.
type FixedInputData struct {
	// Mapping of column names to special uses.
	Columns map[string]string `pulumi:"columns"`
	// The context metadata of the data source.
	DataContext *string `pulumi:"dataContext"`
	// Monitoring input data type enum.
	// Expected value is 'Fixed'.
	InputDataType string `pulumi:"inputDataType"`
	// [Required] Specifies the type of job.
	JobInputType string `pulumi:"jobInputType"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Fixed input data definition.
type FixedInputDataResponse struct {
	// Mapping of column names to special uses.
	Columns map[string]string `pulumi:"columns"`
	// The context metadata of the data source.
	DataContext *string `pulumi:"dataContext"`
	// Monitoring input data type enum.
	// Expected value is 'Fixed'.
	InputDataType string `pulumi:"inputDataType"`
	// [Required] Specifies the type of job.
	JobInputType string `pulumi:"jobInputType"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

type FlavorData struct {
	// Model flavor-specific data.
	Data map[string]string `pulumi:"data"`
}

// FlavorDataInput is an input type that accepts FlavorDataArgs and FlavorDataOutput values.
// You can construct a concrete instance of `FlavorDataInput` via:
//
//	FlavorDataArgs{...}
type FlavorDataInput interface {
	pulumi.Input

	ToFlavorDataOutput() FlavorDataOutput
	ToFlavorDataOutputWithContext(context.Context) FlavorDataOutput
}

type FlavorDataArgs struct {
	// Model flavor-specific data.
	Data pulumi.StringMapInput `pulumi:"data"`
}

func (FlavorDataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FlavorData)(nil)).Elem()
}

func (i FlavorDataArgs) ToFlavorDataOutput() FlavorDataOutput {
	return i.ToFlavorDataOutputWithContext(context.Background())
}

func (i FlavorDataArgs) ToFlavorDataOutputWithContext(ctx context.Context) FlavorDataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlavorDataOutput)
}

// FlavorDataMapInput is an input type that accepts FlavorDataMap and FlavorDataMapOutput values.
// You can construct a concrete instance of `FlavorDataMapInput` via:
//
//	FlavorDataMap{ "key": FlavorDataArgs{...} }
type FlavorDataMapInput interface {
	pulumi.Input

	ToFlavorDataMapOutput() FlavorDataMapOutput
	ToFlavorDataMapOutputWithContext(context.Context) FlavorDataMapOutput
}

type FlavorDataMap map[string]FlavorDataInput

func (FlavorDataMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]FlavorData)(nil)).Elem()
}

func (i FlavorDataMap) ToFlavorDataMapOutput() FlavorDataMapOutput {
	return i.ToFlavorDataMapOutputWithContext(context.Background())
}

func (i FlavorDataMap) ToFlavorDataMapOutputWithContext(ctx context.Context) FlavorDataMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlavorDataMapOutput)
}

type FlavorDataOutput struct{ *pulumi.OutputState }

func (FlavorDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlavorData)(nil)).Elem()
}

func (o FlavorDataOutput) ToFlavorDataOutput() FlavorDataOutput {
	return o
}

func (o FlavorDataOutput) ToFlavorDataOutputWithContext(ctx context.Context) FlavorDataOutput {
	return o
}

// Model flavor-specific data.
func (o FlavorDataOutput) Data() pulumi.StringMapOutput {
	return o.ApplyT(func(v FlavorData) map[string]string { return v.Data }).(pulumi.StringMapOutput)
}

type FlavorDataMapOutput struct{ *pulumi.OutputState }

func (FlavorDataMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]FlavorData)(nil)).Elem()
}

func (o FlavorDataMapOutput) ToFlavorDataMapOutput() FlavorDataMapOutput {
	return o
}

func (o FlavorDataMapOutput) ToFlavorDataMapOutputWithContext(ctx context.Context) FlavorDataMapOutput {
	return o
}

func (o FlavorDataMapOutput) MapIndex(k pulumi.StringInput) FlavorDataOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) FlavorData {
		return vs[0].(map[string]FlavorData)[vs[1].(string)]
	}).(FlavorDataOutput)
}

type FlavorDataResponse struct {
	// Model flavor-specific data.
	Data map[string]string `pulumi:"data"`
}

type FlavorDataResponseOutput struct{ *pulumi.OutputState }

func (FlavorDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FlavorDataResponse)(nil)).Elem()
}

func (o FlavorDataResponseOutput) ToFlavorDataResponseOutput() FlavorDataResponseOutput {
	return o
}

func (o FlavorDataResponseOutput) ToFlavorDataResponseOutputWithContext(ctx context.Context) FlavorDataResponseOutput {
	return o
}

// Model flavor-specific data.
func (o FlavorDataResponseOutput) Data() pulumi.StringMapOutput {
	return o.ApplyT(func(v FlavorDataResponse) map[string]string { return v.Data }).(pulumi.StringMapOutput)
}

type FlavorDataResponseMapOutput struct{ *pulumi.OutputState }

func (FlavorDataResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]FlavorDataResponse)(nil)).Elem()
}

func (o FlavorDataResponseMapOutput) ToFlavorDataResponseMapOutput() FlavorDataResponseMapOutput {
	return o
}

func (o FlavorDataResponseMapOutput) ToFlavorDataResponseMapOutputWithContext(ctx context.Context) FlavorDataResponseMapOutput {
	return o
}

func (o FlavorDataResponseMapOutput) MapIndex(k pulumi.StringInput) FlavorDataResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) FlavorDataResponse {
		return vs[0].(map[string]FlavorDataResponse)[vs[1].(string)]
	}).(FlavorDataResponseOutput)
}

// Forecasting task in AutoML Table vertical.
type Forecasting struct {
	// Columns to use for CVSplit data.
	CvSplitColumnNames []string `pulumi:"cvSplitColumnNames"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettings `pulumi:"featurizationSettings"`
	// Model/training parameters that will remain constant throughout training.
	FixedParameters *TableFixedParameters `pulumi:"fixedParameters"`
	// Forecasting task specific inputs.
	ForecastingSettings *ForecastingSettings `pulumi:"forecastingSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Number of cross validation folds to be applied on training dataset
	// when validation dataset is not provided.
	NCrossValidations interface{} `pulumi:"nCrossValidations"`
	// Primary metric for forecasting task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []TableParameterSubspace `pulumi:"searchSpace"`
	// Settings for model sweeping and hyperparameter tuning.
	SweepSettings *TableSweepSettings `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'Forecasting'.
	TaskType string `pulumi:"taskType"`
	// Test data input.
	TestData *MLTableJobInput `pulumi:"testData"`
	// The fraction of test dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	TestDataSize *float64 `pulumi:"testDataSize"`
	// [Required] Training data input.
	TrainingData MLTableJobInput `pulumi:"trainingData"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *ForecastingTrainingSettings `pulumi:"trainingSettings"`
	// Validation data inputs.
	ValidationData *MLTableJobInput `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
	// The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
	WeightColumnName *string `pulumi:"weightColumnName"`
}

// Defaults sets the appropriate defaults for Forecasting
func (val *Forecasting) Defaults() *Forecasting {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.FixedParameters = tmp.FixedParameters.Defaults()

	tmp.ForecastingSettings = tmp.ForecastingSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "NormalizedRootMeanSquaredError"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Forecasting task in AutoML Table vertical.
type ForecastingResponse struct {
	// Columns to use for CVSplit data.
	CvSplitColumnNames []string `pulumi:"cvSplitColumnNames"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettingsResponse `pulumi:"featurizationSettings"`
	// Model/training parameters that will remain constant throughout training.
	FixedParameters *TableFixedParametersResponse `pulumi:"fixedParameters"`
	// Forecasting task specific inputs.
	ForecastingSettings *ForecastingSettingsResponse `pulumi:"forecastingSettings"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Number of cross validation folds to be applied on training dataset
	// when validation dataset is not provided.
	NCrossValidations interface{} `pulumi:"nCrossValidations"`
	// Primary metric for forecasting task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []TableParameterSubspaceResponse `pulumi:"searchSpace"`
	// Settings for model sweeping and hyperparameter tuning.
	SweepSettings *TableSweepSettingsResponse `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'Forecasting'.
	TaskType string `pulumi:"taskType"`
	// Test data input.
	TestData *MLTableJobInputResponse `pulumi:"testData"`
	// The fraction of test dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	TestDataSize *float64 `pulumi:"testDataSize"`
	// [Required] Training data input.
	TrainingData MLTableJobInputResponse `pulumi:"trainingData"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *ForecastingTrainingSettingsResponse `pulumi:"trainingSettings"`
	// Validation data inputs.
	ValidationData *MLTableJobInputResponse `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
	// The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
	WeightColumnName *string `pulumi:"weightColumnName"`
}

// Defaults sets the appropriate defaults for ForecastingResponse
func (val *ForecastingResponse) Defaults() *ForecastingResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.FixedParameters = tmp.FixedParameters.Defaults()

	tmp.ForecastingSettings = tmp.ForecastingSettings.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "NormalizedRootMeanSquaredError"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Forecasting specific parameters.
type ForecastingSettings struct {
	// Country or region for holidays for forecasting tasks.
	// These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
	CountryOrRegionForHolidays *string `pulumi:"countryOrRegionForHolidays"`
	// Number of periods between the origin time of one CV fold and the next fold. For
	// example, if `CVStepSize` = 3 for daily data, the origin time for each fold will be
	// three days apart.
	CvStepSize *int `pulumi:"cvStepSize"`
	// Flag for generating lags for the numeric features with 'auto' or null.
	FeatureLags *string `pulumi:"featureLags"`
	// The feature columns that are available for training but unknown at the time of forecast/inference.
	// If features_unknown_at_forecast_time is not set, it is assumed that all the feature columns in the dataset are known at inference time.
	FeaturesUnknownAtForecastTime []string `pulumi:"featuresUnknownAtForecastTime"`
	// The desired maximum forecast horizon in units of time-series frequency.
	ForecastHorizon interface{} `pulumi:"forecastHorizon"`
	// When forecasting, this parameter represents the period with which the forecast is desired, for example daily, weekly, yearly, etc. The forecast frequency is dataset frequency by default.
	Frequency *string `pulumi:"frequency"`
	// Set time series seasonality as an integer multiple of the series frequency.
	// If seasonality is set to 'auto', it will be inferred.
	Seasonality interface{} `pulumi:"seasonality"`
	// The parameter defining how if AutoML should handle short time series.
	ShortSeriesHandlingConfig *string `pulumi:"shortSeriesHandlingConfig"`
	// The function to be used to aggregate the time series target column to conform to a user specified frequency.
	// If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised. The possible target aggregation functions are: "sum", "max", "min" and "mean".
	TargetAggregateFunction *string `pulumi:"targetAggregateFunction"`
	// The number of past periods to lag from the target column.
	TargetLags interface{} `pulumi:"targetLags"`
	// The number of past periods used to create a rolling window average of the target column.
	TargetRollingWindowSize interface{} `pulumi:"targetRollingWindowSize"`
	// The name of the time column. This parameter is required when forecasting to specify the datetime column in the input data used for building the time series and inferring its frequency.
	TimeColumnName *string `pulumi:"timeColumnName"`
	// The names of columns used to group a timeseries. It can be used to create multiple series.
	// If grain is not defined, the data set is assumed to be one time-series. This parameter is used with task type forecasting.
	TimeSeriesIdColumnNames []string `pulumi:"timeSeriesIdColumnNames"`
	// Configure STL Decomposition of the time-series target column.
	UseStl *string `pulumi:"useStl"`
}

// Defaults sets the appropriate defaults for ForecastingSettings
func (val *ForecastingSettings) Defaults() *ForecastingSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.FeatureLags == nil {
		featureLags_ := "None"
		tmp.FeatureLags = &featureLags_
	}
	if tmp.ShortSeriesHandlingConfig == nil {
		shortSeriesHandlingConfig_ := "Auto"
		tmp.ShortSeriesHandlingConfig = &shortSeriesHandlingConfig_
	}
	if tmp.TargetAggregateFunction == nil {
		targetAggregateFunction_ := "None"
		tmp.TargetAggregateFunction = &targetAggregateFunction_
	}
	if tmp.UseStl == nil {
		useStl_ := "None"
		tmp.UseStl = &useStl_
	}
	return &tmp
}

// Forecasting specific parameters.
type ForecastingSettingsResponse struct {
	// Country or region for holidays for forecasting tasks.
	// These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
	CountryOrRegionForHolidays *string `pulumi:"countryOrRegionForHolidays"`
	// Number of periods between the origin time of one CV fold and the next fold. For
	// example, if `CVStepSize` = 3 for daily data, the origin time for each fold will be
	// three days apart.
	CvStepSize *int `pulumi:"cvStepSize"`
	// Flag for generating lags for the numeric features with 'auto' or null.
	FeatureLags *string `pulumi:"featureLags"`
	// The feature columns that are available for training but unknown at the time of forecast/inference.
	// If features_unknown_at_forecast_time is not set, it is assumed that all the feature columns in the dataset are known at inference time.
	FeaturesUnknownAtForecastTime []string `pulumi:"featuresUnknownAtForecastTime"`
	// The desired maximum forecast horizon in units of time-series frequency.
	ForecastHorizon interface{} `pulumi:"forecastHorizon"`
	// When forecasting, this parameter represents the period with which the forecast is desired, for example daily, weekly, yearly, etc. The forecast frequency is dataset frequency by default.
	Frequency *string `pulumi:"frequency"`
	// Set time series seasonality as an integer multiple of the series frequency.
	// If seasonality is set to 'auto', it will be inferred.
	Seasonality interface{} `pulumi:"seasonality"`
	// The parameter defining how if AutoML should handle short time series.
	ShortSeriesHandlingConfig *string `pulumi:"shortSeriesHandlingConfig"`
	// The function to be used to aggregate the time series target column to conform to a user specified frequency.
	// If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised. The possible target aggregation functions are: "sum", "max", "min" and "mean".
	TargetAggregateFunction *string `pulumi:"targetAggregateFunction"`
	// The number of past periods to lag from the target column.
	TargetLags interface{} `pulumi:"targetLags"`
	// The number of past periods used to create a rolling window average of the target column.
	TargetRollingWindowSize interface{} `pulumi:"targetRollingWindowSize"`
	// The name of the time column. This parameter is required when forecasting to specify the datetime column in the input data used for building the time series and inferring its frequency.
	TimeColumnName *string `pulumi:"timeColumnName"`
	// The names of columns used to group a timeseries. It can be used to create multiple series.
	// If grain is not defined, the data set is assumed to be one time-series. This parameter is used with task type forecasting.
	TimeSeriesIdColumnNames []string `pulumi:"timeSeriesIdColumnNames"`
	// Configure STL Decomposition of the time-series target column.
	UseStl *string `pulumi:"useStl"`
}

// Defaults sets the appropriate defaults for ForecastingSettingsResponse
func (val *ForecastingSettingsResponse) Defaults() *ForecastingSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.FeatureLags == nil {
		featureLags_ := "None"
		tmp.FeatureLags = &featureLags_
	}
	if tmp.ShortSeriesHandlingConfig == nil {
		shortSeriesHandlingConfig_ := "Auto"
		tmp.ShortSeriesHandlingConfig = &shortSeriesHandlingConfig_
	}
	if tmp.TargetAggregateFunction == nil {
		targetAggregateFunction_ := "None"
		tmp.TargetAggregateFunction = &targetAggregateFunction_
	}
	if tmp.UseStl == nil {
		useStl_ := "None"
		tmp.UseStl = &useStl_
	}
	return &tmp
}

// Forecasting Training related configuration.
type ForecastingTrainingSettings struct {
	// Allowed models for forecasting task.
	AllowedTrainingAlgorithms []string `pulumi:"allowedTrainingAlgorithms"`
	// Blocked models for forecasting task.
	BlockedTrainingAlgorithms []string `pulumi:"blockedTrainingAlgorithms"`
	// Enable recommendation of DNN models.
	EnableDnnTraining *bool `pulumi:"enableDnnTraining"`
	// Flag to turn on explainability on best model.
	EnableModelExplainability *bool `pulumi:"enableModelExplainability"`
	// Flag for enabling onnx compatible models.
	EnableOnnxCompatibleModels *bool `pulumi:"enableOnnxCompatibleModels"`
	// Enable stack ensemble run.
	EnableStackEnsemble *bool `pulumi:"enableStackEnsemble"`
	// Enable voting ensemble run.
	EnableVoteEnsemble *bool `pulumi:"enableVoteEnsemble"`
	// During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
	// Configure this parameter with a higher value than 300 secs, if more time is needed.
	EnsembleModelDownloadTimeout *string `pulumi:"ensembleModelDownloadTimeout"`
	// Stack ensemble settings for stack ensemble run.
	StackEnsembleSettings *StackEnsembleSettings `pulumi:"stackEnsembleSettings"`
	// TrainingMode mode - Setting to 'auto' is same as setting it to 'non-distributed' for now, however in the future may result in mixed mode or heuristics based mode selection. Default is 'auto'.
	// If 'Distributed' then only distributed featurization is used and distributed algorithms are chosen.
	// If 'NonDistributed' then only non distributed algorithms are chosen.
	TrainingMode *string `pulumi:"trainingMode"`
}

// Defaults sets the appropriate defaults for ForecastingTrainingSettings
func (val *ForecastingTrainingSettings) Defaults() *ForecastingTrainingSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.EnableDnnTraining == nil {
		enableDnnTraining_ := false
		tmp.EnableDnnTraining = &enableDnnTraining_
	}
	if tmp.EnableModelExplainability == nil {
		enableModelExplainability_ := true
		tmp.EnableModelExplainability = &enableModelExplainability_
	}
	if tmp.EnableOnnxCompatibleModels == nil {
		enableOnnxCompatibleModels_ := false
		tmp.EnableOnnxCompatibleModels = &enableOnnxCompatibleModels_
	}
	if tmp.EnableStackEnsemble == nil {
		enableStackEnsemble_ := true
		tmp.EnableStackEnsemble = &enableStackEnsemble_
	}
	if tmp.EnableVoteEnsemble == nil {
		enableVoteEnsemble_ := true
		tmp.EnableVoteEnsemble = &enableVoteEnsemble_
	}
	if tmp.EnsembleModelDownloadTimeout == nil {
		ensembleModelDownloadTimeout_ := "PT5M"
		tmp.EnsembleModelDownloadTimeout = &ensembleModelDownloadTimeout_
	}
	tmp.StackEnsembleSettings = tmp.StackEnsembleSettings.Defaults()

	if tmp.TrainingMode == nil {
		trainingMode_ := "Auto"
		tmp.TrainingMode = &trainingMode_
	}
	return &tmp
}

// Forecasting Training related configuration.
type ForecastingTrainingSettingsResponse struct {
	// Allowed models for forecasting task.
	AllowedTrainingAlgorithms []string `pulumi:"allowedTrainingAlgorithms"`
	// Blocked models for forecasting task.
	BlockedTrainingAlgorithms []string `pulumi:"blockedTrainingAlgorithms"`
	// Enable recommendation of DNN models.
	EnableDnnTraining *bool `pulumi:"enableDnnTraining"`
	// Flag to turn on explainability on best model.
	EnableModelExplainability *bool `pulumi:"enableModelExplainability"`
	// Flag for enabling onnx compatible models.
	EnableOnnxCompatibleModels *bool `pulumi:"enableOnnxCompatibleModels"`
	// Enable stack ensemble run.
	EnableStackEnsemble *bool `pulumi:"enableStackEnsemble"`
	// Enable voting ensemble run.
	EnableVoteEnsemble *bool `pulumi:"enableVoteEnsemble"`
	// During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
	// Configure this parameter with a higher value than 300 secs, if more time is needed.
	EnsembleModelDownloadTimeout *string `pulumi:"ensembleModelDownloadTimeout"`
	// Stack ensemble settings for stack ensemble run.
	StackEnsembleSettings *StackEnsembleSettingsResponse `pulumi:"stackEnsembleSettings"`
	// TrainingMode mode - Setting to 'auto' is same as setting it to 'non-distributed' for now, however in the future may result in mixed mode or heuristics based mode selection. Default is 'auto'.
	// If 'Distributed' then only distributed featurization is used and distributed algorithms are chosen.
	// If 'NonDistributed' then only non distributed algorithms are chosen.
	TrainingMode *string `pulumi:"trainingMode"`
}

// Defaults sets the appropriate defaults for ForecastingTrainingSettingsResponse
func (val *ForecastingTrainingSettingsResponse) Defaults() *ForecastingTrainingSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.EnableDnnTraining == nil {
		enableDnnTraining_ := false
		tmp.EnableDnnTraining = &enableDnnTraining_
	}
	if tmp.EnableModelExplainability == nil {
		enableModelExplainability_ := true
		tmp.EnableModelExplainability = &enableModelExplainability_
	}
	if tmp.EnableOnnxCompatibleModels == nil {
		enableOnnxCompatibleModels_ := false
		tmp.EnableOnnxCompatibleModels = &enableOnnxCompatibleModels_
	}
	if tmp.EnableStackEnsemble == nil {
		enableStackEnsemble_ := true
		tmp.EnableStackEnsemble = &enableStackEnsemble_
	}
	if tmp.EnableVoteEnsemble == nil {
		enableVoteEnsemble_ := true
		tmp.EnableVoteEnsemble = &enableVoteEnsemble_
	}
	if tmp.EnsembleModelDownloadTimeout == nil {
		ensembleModelDownloadTimeout_ := "PT5M"
		tmp.EnsembleModelDownloadTimeout = &ensembleModelDownloadTimeout_
	}
	tmp.StackEnsembleSettings = tmp.StackEnsembleSettings.Defaults()

	if tmp.TrainingMode == nil {
		trainingMode_ := "Auto"
		tmp.TrainingMode = &trainingMode_
	}
	return &tmp
}

// FQDN Outbound Rule for the managed network of a machine learning workspace.
type FqdnOutboundRule struct {
	// Category of a managed network Outbound Rule of a machine learning workspace.
	Category    *string `pulumi:"category"`
	Destination *string `pulumi:"destination"`
	// Type of a managed network Outbound Rule of a machine learning workspace.
	Status *string `pulumi:"status"`
	// Type of a managed network Outbound Rule of a machine learning workspace.
	// Expected value is 'FQDN'.
	Type string `pulumi:"type"`
}

// FQDN Outbound Rule for the managed network of a machine learning workspace.
type FqdnOutboundRuleResponse struct {
	// Category of a managed network Outbound Rule of a machine learning workspace.
	Category    *string `pulumi:"category"`
	Destination *string `pulumi:"destination"`
	// Type of a managed network Outbound Rule of a machine learning workspace.
	Status *string `pulumi:"status"`
	// Type of a managed network Outbound Rule of a machine learning workspace.
	// Expected value is 'FQDN'.
	Type string `pulumi:"type"`
}

// Generation safety quality metric threshold definition.
type GenerationSafetyQualityMetricThreshold struct {
	// [Required] Gets or sets the feature attribution metric to calculate.
	Metric string `pulumi:"metric"`
	// Gets or sets the threshold value.
	// If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

// Generation safety quality metric threshold definition.
type GenerationSafetyQualityMetricThresholdResponse struct {
	// [Required] Gets or sets the feature attribution metric to calculate.
	Metric string `pulumi:"metric"`
	// Gets or sets the threshold value.
	// If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

// Generation safety quality monitoring signal definition.
type GenerationSafetyQualityMonitoringSignal struct {
	// [Required] Gets or sets the metrics to calculate and the corresponding thresholds.
	MetricThresholds []GenerationSafetyQualityMetricThreshold `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// Gets or sets the target data for computing metrics.
	ProductionData []interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The sample rate of the target data, should be greater than 0 and at most 1.
	SamplingRate float64 `pulumi:"samplingRate"`
	// Expected value is 'GenerationSafetyQuality'.
	SignalType string `pulumi:"signalType"`
	// Gets or sets the workspace connection ID used to connect to the content generation endpoint.
	WorkspaceConnectionId *string `pulumi:"workspaceConnectionId"`
}

// Defaults sets the appropriate defaults for GenerationSafetyQualityMonitoringSignal
func (val *GenerationSafetyQualityMonitoringSignal) Defaults() *GenerationSafetyQualityMonitoringSignal {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Generation safety quality monitoring signal definition.
type GenerationSafetyQualityMonitoringSignalResponse struct {
	// [Required] Gets or sets the metrics to calculate and the corresponding thresholds.
	MetricThresholds []GenerationSafetyQualityMetricThresholdResponse `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// Gets or sets the target data for computing metrics.
	ProductionData []interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The sample rate of the target data, should be greater than 0 and at most 1.
	SamplingRate float64 `pulumi:"samplingRate"`
	// Expected value is 'GenerationSafetyQuality'.
	SignalType string `pulumi:"signalType"`
	// Gets or sets the workspace connection ID used to connect to the content generation endpoint.
	WorkspaceConnectionId *string `pulumi:"workspaceConnectionId"`
}

// Defaults sets the appropriate defaults for GenerationSafetyQualityMonitoringSignalResponse
func (val *GenerationSafetyQualityMonitoringSignalResponse) Defaults() *GenerationSafetyQualityMonitoringSignalResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Generation token statistics metric threshold definition.
type GenerationTokenStatisticsMetricThreshold struct {
	// [Required] Gets or sets the feature attribution metric to calculate.
	Metric string `pulumi:"metric"`
	// Gets or sets the threshold value.
	// If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

// Generation token statistics metric threshold definition.
type GenerationTokenStatisticsMetricThresholdResponse struct {
	// [Required] Gets or sets the feature attribution metric to calculate.
	Metric string `pulumi:"metric"`
	// Gets or sets the threshold value.
	// If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

// Generation token statistics signal definition.
type GenerationTokenStatisticsSignal struct {
	// [Required] Gets or sets the metrics to calculate and the corresponding thresholds.
	MetricThresholds []GenerationTokenStatisticsMetricThreshold `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// Gets or sets the target data for computing metrics.
	ProductionData interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The sample rate of the target data, should be greater than 0 and at most 1.
	SamplingRate float64 `pulumi:"samplingRate"`
	// Expected value is 'GenerationTokenStatistics'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for GenerationTokenStatisticsSignal
func (val *GenerationTokenStatisticsSignal) Defaults() *GenerationTokenStatisticsSignal {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Generation token statistics signal definition.
type GenerationTokenStatisticsSignalResponse struct {
	// [Required] Gets or sets the metrics to calculate and the corresponding thresholds.
	MetricThresholds []GenerationTokenStatisticsMetricThresholdResponse `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// Gets or sets the target data for computing metrics.
	ProductionData interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The sample rate of the target data, should be greater than 0 and at most 1.
	SamplingRate float64 `pulumi:"samplingRate"`
	// Expected value is 'GenerationTokenStatistics'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for GenerationTokenStatisticsSignalResponse
func (val *GenerationTokenStatisticsSignalResponse) Defaults() *GenerationTokenStatisticsSignalResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Defines a Sampling Algorithm that exhaustively generates every value combination in the space
type GridSamplingAlgorithm struct {
	// Expected value is 'Grid'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
}

// Defines a Sampling Algorithm that exhaustively generates every value combination in the space
type GridSamplingAlgorithmResponse struct {
	// Expected value is 'Grid'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
}

// A HDInsight compute.
type HDInsight struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'HDInsight'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// HDInsight compute properties
	Properties *HDInsightProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// HDInsight compute properties
type HDInsightProperties struct {
	// Public IP address of the master node of the cluster.
	Address *string `pulumi:"address"`
	// Admin credentials for master node of the cluster
	AdministratorAccount *VirtualMachineSshCredentials `pulumi:"administratorAccount"`
	// Port open for ssh connections on the master node of the cluster.
	SshPort *int `pulumi:"sshPort"`
}

// HDInsight compute properties
type HDInsightPropertiesResponse struct {
	// Public IP address of the master node of the cluster.
	Address *string `pulumi:"address"`
	// Admin credentials for master node of the cluster
	AdministratorAccount *VirtualMachineSshCredentialsResponse `pulumi:"administratorAccount"`
	// Port open for ssh connections on the master node of the cluster.
	SshPort *int `pulumi:"sshPort"`
}

// A HDInsight compute.
type HDInsightResponse struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'HDInsight'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// HDInsight compute properties
	Properties *HDInsightPropertiesResponse `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

type HdfsDatastore struct {
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'Hdfs'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// The TLS cert of the HDFS server. Needs to be a base64 encoded string. Required if "Https" protocol is selected.
	HdfsServerCertificate *string `pulumi:"hdfsServerCertificate"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualProperty `pulumi:"intellectualProperty"`
	// [Required] IP Address or DNS HostName.
	NameNodeAddress string `pulumi:"nameNodeAddress"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account (Https/Http).
	Protocol *string `pulumi:"protocol"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for HdfsDatastore
func (val *HdfsDatastore) Defaults() *HdfsDatastore {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.Protocol == nil {
		protocol_ := "http"
		tmp.Protocol = &protocol_
	}
	return &tmp
}

type HdfsDatastoreResponse struct {
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'Hdfs'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// The TLS cert of the HDFS server. Needs to be a base64 encoded string. Required if "Https" protocol is selected.
	HdfsServerCertificate *string `pulumi:"hdfsServerCertificate"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualPropertyResponse `pulumi:"intellectualProperty"`
	// Readonly property to indicate if datastore is the workspace default datastore
	IsDefault bool `pulumi:"isDefault"`
	// [Required] IP Address or DNS HostName.
	NameNodeAddress string `pulumi:"nameNodeAddress"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Protocol used to communicate with the storage account (Https/Http).
	Protocol *string `pulumi:"protocol"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for HdfsDatastoreResponse
func (val *HdfsDatastoreResponse) Defaults() *HdfsDatastoreResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.Protocol == nil {
		protocol_ := "http"
		tmp.Protocol = &protocol_
	}
	return &tmp
}

// Reference to an asset via its ARM resource ID.
type IdAssetReference struct {
	// [Required] ARM resource ID of the asset.
	AssetId string `pulumi:"assetId"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'Id'.
	ReferenceType string `pulumi:"referenceType"`
}

// IdAssetReferenceInput is an input type that accepts IdAssetReferenceArgs and IdAssetReferenceOutput values.
// You can construct a concrete instance of `IdAssetReferenceInput` via:
//
//	IdAssetReferenceArgs{...}
type IdAssetReferenceInput interface {
	pulumi.Input

	ToIdAssetReferenceOutput() IdAssetReferenceOutput
	ToIdAssetReferenceOutputWithContext(context.Context) IdAssetReferenceOutput
}

// Reference to an asset via its ARM resource ID.
type IdAssetReferenceArgs struct {
	// [Required] ARM resource ID of the asset.
	AssetId pulumi.StringInput `pulumi:"assetId"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'Id'.
	ReferenceType pulumi.StringInput `pulumi:"referenceType"`
}

func (IdAssetReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IdAssetReference)(nil)).Elem()
}

func (i IdAssetReferenceArgs) ToIdAssetReferenceOutput() IdAssetReferenceOutput {
	return i.ToIdAssetReferenceOutputWithContext(context.Background())
}

func (i IdAssetReferenceArgs) ToIdAssetReferenceOutputWithContext(ctx context.Context) IdAssetReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IdAssetReferenceOutput)
}

func (i IdAssetReferenceArgs) ToIdAssetReferencePtrOutput() IdAssetReferencePtrOutput {
	return i.ToIdAssetReferencePtrOutputWithContext(context.Background())
}

func (i IdAssetReferenceArgs) ToIdAssetReferencePtrOutputWithContext(ctx context.Context) IdAssetReferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IdAssetReferenceOutput).ToIdAssetReferencePtrOutputWithContext(ctx)
}

// IdAssetReferencePtrInput is an input type that accepts IdAssetReferenceArgs, IdAssetReferencePtr and IdAssetReferencePtrOutput values.
// You can construct a concrete instance of `IdAssetReferencePtrInput` via:
//
//	        IdAssetReferenceArgs{...}
//
//	or:
//
//	        nil
type IdAssetReferencePtrInput interface {
	pulumi.Input

	ToIdAssetReferencePtrOutput() IdAssetReferencePtrOutput
	ToIdAssetReferencePtrOutputWithContext(context.Context) IdAssetReferencePtrOutput
}

type idAssetReferencePtrType IdAssetReferenceArgs

func IdAssetReferencePtr(v *IdAssetReferenceArgs) IdAssetReferencePtrInput {
	return (*idAssetReferencePtrType)(v)
}

func (*idAssetReferencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IdAssetReference)(nil)).Elem()
}

func (i *idAssetReferencePtrType) ToIdAssetReferencePtrOutput() IdAssetReferencePtrOutput {
	return i.ToIdAssetReferencePtrOutputWithContext(context.Background())
}

func (i *idAssetReferencePtrType) ToIdAssetReferencePtrOutputWithContext(ctx context.Context) IdAssetReferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IdAssetReferencePtrOutput)
}

// Reference to an asset via its ARM resource ID.
type IdAssetReferenceOutput struct{ *pulumi.OutputState }

func (IdAssetReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IdAssetReference)(nil)).Elem()
}

func (o IdAssetReferenceOutput) ToIdAssetReferenceOutput() IdAssetReferenceOutput {
	return o
}

func (o IdAssetReferenceOutput) ToIdAssetReferenceOutputWithContext(ctx context.Context) IdAssetReferenceOutput {
	return o
}

func (o IdAssetReferenceOutput) ToIdAssetReferencePtrOutput() IdAssetReferencePtrOutput {
	return o.ToIdAssetReferencePtrOutputWithContext(context.Background())
}

func (o IdAssetReferenceOutput) ToIdAssetReferencePtrOutputWithContext(ctx context.Context) IdAssetReferencePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IdAssetReference) *IdAssetReference {
		return &v
	}).(IdAssetReferencePtrOutput)
}

// [Required] ARM resource ID of the asset.
func (o IdAssetReferenceOutput) AssetId() pulumi.StringOutput {
	return o.ApplyT(func(v IdAssetReference) string { return v.AssetId }).(pulumi.StringOutput)
}

// Enum to determine which reference method to use for an asset.
// Expected value is 'Id'.
func (o IdAssetReferenceOutput) ReferenceType() pulumi.StringOutput {
	return o.ApplyT(func(v IdAssetReference) string { return v.ReferenceType }).(pulumi.StringOutput)
}

type IdAssetReferencePtrOutput struct{ *pulumi.OutputState }

func (IdAssetReferencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IdAssetReference)(nil)).Elem()
}

func (o IdAssetReferencePtrOutput) ToIdAssetReferencePtrOutput() IdAssetReferencePtrOutput {
	return o
}

func (o IdAssetReferencePtrOutput) ToIdAssetReferencePtrOutputWithContext(ctx context.Context) IdAssetReferencePtrOutput {
	return o
}

func (o IdAssetReferencePtrOutput) Elem() IdAssetReferenceOutput {
	return o.ApplyT(func(v *IdAssetReference) IdAssetReference {
		if v != nil {
			return *v
		}
		var ret IdAssetReference
		return ret
	}).(IdAssetReferenceOutput)
}

// [Required] ARM resource ID of the asset.
func (o IdAssetReferencePtrOutput) AssetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IdAssetReference) *string {
		if v == nil {
			return nil
		}
		return &v.AssetId
	}).(pulumi.StringPtrOutput)
}

// Enum to determine which reference method to use for an asset.
// Expected value is 'Id'.
func (o IdAssetReferencePtrOutput) ReferenceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IdAssetReference) *string {
		if v == nil {
			return nil
		}
		return &v.ReferenceType
	}).(pulumi.StringPtrOutput)
}

// Reference to an asset via its ARM resource ID.
type IdAssetReferenceResponse struct {
	// [Required] ARM resource ID of the asset.
	AssetId string `pulumi:"assetId"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'Id'.
	ReferenceType string `pulumi:"referenceType"`
}

// Reference to an asset via its ARM resource ID.
type IdAssetReferenceResponseOutput struct{ *pulumi.OutputState }

func (IdAssetReferenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IdAssetReferenceResponse)(nil)).Elem()
}

func (o IdAssetReferenceResponseOutput) ToIdAssetReferenceResponseOutput() IdAssetReferenceResponseOutput {
	return o
}

func (o IdAssetReferenceResponseOutput) ToIdAssetReferenceResponseOutputWithContext(ctx context.Context) IdAssetReferenceResponseOutput {
	return o
}

// [Required] ARM resource ID of the asset.
func (o IdAssetReferenceResponseOutput) AssetId() pulumi.StringOutput {
	return o.ApplyT(func(v IdAssetReferenceResponse) string { return v.AssetId }).(pulumi.StringOutput)
}

// Enum to determine which reference method to use for an asset.
// Expected value is 'Id'.
func (o IdAssetReferenceResponseOutput) ReferenceType() pulumi.StringOutput {
	return o.ApplyT(func(v IdAssetReferenceResponse) string { return v.ReferenceType }).(pulumi.StringOutput)
}

type IdAssetReferenceResponsePtrOutput struct{ *pulumi.OutputState }

func (IdAssetReferenceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IdAssetReferenceResponse)(nil)).Elem()
}

func (o IdAssetReferenceResponsePtrOutput) ToIdAssetReferenceResponsePtrOutput() IdAssetReferenceResponsePtrOutput {
	return o
}

func (o IdAssetReferenceResponsePtrOutput) ToIdAssetReferenceResponsePtrOutputWithContext(ctx context.Context) IdAssetReferenceResponsePtrOutput {
	return o
}

func (o IdAssetReferenceResponsePtrOutput) Elem() IdAssetReferenceResponseOutput {
	return o.ApplyT(func(v *IdAssetReferenceResponse) IdAssetReferenceResponse {
		if v != nil {
			return *v
		}
		var ret IdAssetReferenceResponse
		return ret
	}).(IdAssetReferenceResponseOutput)
}

// [Required] ARM resource ID of the asset.
func (o IdAssetReferenceResponsePtrOutput) AssetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IdAssetReferenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.AssetId
	}).(pulumi.StringPtrOutput)
}

// Enum to determine which reference method to use for an asset.
// Expected value is 'Id'.
func (o IdAssetReferenceResponsePtrOutput) ReferenceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IdAssetReferenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ReferenceType
	}).(pulumi.StringPtrOutput)
}

// Identity object used for encryption.
type IdentityForCmk struct {
	// UserAssignedIdentity to be used to fetch the encryption key from keyVault
	UserAssignedIdentity *string `pulumi:"userAssignedIdentity"`
}

// IdentityForCmkInput is an input type that accepts IdentityForCmkArgs and IdentityForCmkOutput values.
// You can construct a concrete instance of `IdentityForCmkInput` via:
//
//	IdentityForCmkArgs{...}
type IdentityForCmkInput interface {
	pulumi.Input

	ToIdentityForCmkOutput() IdentityForCmkOutput
	ToIdentityForCmkOutputWithContext(context.Context) IdentityForCmkOutput
}

// Identity object used for encryption.
type IdentityForCmkArgs struct {
	// UserAssignedIdentity to be used to fetch the encryption key from keyVault
	UserAssignedIdentity pulumi.StringPtrInput `pulumi:"userAssignedIdentity"`
}

func (IdentityForCmkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IdentityForCmk)(nil)).Elem()
}

func (i IdentityForCmkArgs) ToIdentityForCmkOutput() IdentityForCmkOutput {
	return i.ToIdentityForCmkOutputWithContext(context.Background())
}

func (i IdentityForCmkArgs) ToIdentityForCmkOutputWithContext(ctx context.Context) IdentityForCmkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IdentityForCmkOutput)
}

func (i IdentityForCmkArgs) ToIdentityForCmkPtrOutput() IdentityForCmkPtrOutput {
	return i.ToIdentityForCmkPtrOutputWithContext(context.Background())
}

func (i IdentityForCmkArgs) ToIdentityForCmkPtrOutputWithContext(ctx context.Context) IdentityForCmkPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IdentityForCmkOutput).ToIdentityForCmkPtrOutputWithContext(ctx)
}

// IdentityForCmkPtrInput is an input type that accepts IdentityForCmkArgs, IdentityForCmkPtr and IdentityForCmkPtrOutput values.
// You can construct a concrete instance of `IdentityForCmkPtrInput` via:
//
//	        IdentityForCmkArgs{...}
//
//	or:
//
//	        nil
type IdentityForCmkPtrInput interface {
	pulumi.Input

	ToIdentityForCmkPtrOutput() IdentityForCmkPtrOutput
	ToIdentityForCmkPtrOutputWithContext(context.Context) IdentityForCmkPtrOutput
}

type identityForCmkPtrType IdentityForCmkArgs

func IdentityForCmkPtr(v *IdentityForCmkArgs) IdentityForCmkPtrInput {
	return (*identityForCmkPtrType)(v)
}

func (*identityForCmkPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IdentityForCmk)(nil)).Elem()
}

func (i *identityForCmkPtrType) ToIdentityForCmkPtrOutput() IdentityForCmkPtrOutput {
	return i.ToIdentityForCmkPtrOutputWithContext(context.Background())
}

func (i *identityForCmkPtrType) ToIdentityForCmkPtrOutputWithContext(ctx context.Context) IdentityForCmkPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IdentityForCmkPtrOutput)
}

// Identity object used for encryption.
type IdentityForCmkOutput struct{ *pulumi.OutputState }

func (IdentityForCmkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IdentityForCmk)(nil)).Elem()
}

func (o IdentityForCmkOutput) ToIdentityForCmkOutput() IdentityForCmkOutput {
	return o
}

func (o IdentityForCmkOutput) ToIdentityForCmkOutputWithContext(ctx context.Context) IdentityForCmkOutput {
	return o
}

func (o IdentityForCmkOutput) ToIdentityForCmkPtrOutput() IdentityForCmkPtrOutput {
	return o.ToIdentityForCmkPtrOutputWithContext(context.Background())
}

func (o IdentityForCmkOutput) ToIdentityForCmkPtrOutputWithContext(ctx context.Context) IdentityForCmkPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IdentityForCmk) *IdentityForCmk {
		return &v
	}).(IdentityForCmkPtrOutput)
}

// UserAssignedIdentity to be used to fetch the encryption key from keyVault
func (o IdentityForCmkOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IdentityForCmk) *string { return v.UserAssignedIdentity }).(pulumi.StringPtrOutput)
}

type IdentityForCmkPtrOutput struct{ *pulumi.OutputState }

func (IdentityForCmkPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IdentityForCmk)(nil)).Elem()
}

func (o IdentityForCmkPtrOutput) ToIdentityForCmkPtrOutput() IdentityForCmkPtrOutput {
	return o
}

func (o IdentityForCmkPtrOutput) ToIdentityForCmkPtrOutputWithContext(ctx context.Context) IdentityForCmkPtrOutput {
	return o
}

func (o IdentityForCmkPtrOutput) Elem() IdentityForCmkOutput {
	return o.ApplyT(func(v *IdentityForCmk) IdentityForCmk {
		if v != nil {
			return *v
		}
		var ret IdentityForCmk
		return ret
	}).(IdentityForCmkOutput)
}

// UserAssignedIdentity to be used to fetch the encryption key from keyVault
func (o IdentityForCmkPtrOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IdentityForCmk) *string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentity
	}).(pulumi.StringPtrOutput)
}

// Identity object used for encryption.
type IdentityForCmkResponse struct {
	// UserAssignedIdentity to be used to fetch the encryption key from keyVault
	UserAssignedIdentity *string `pulumi:"userAssignedIdentity"`
}

// Identity object used for encryption.
type IdentityForCmkResponseOutput struct{ *pulumi.OutputState }

func (IdentityForCmkResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IdentityForCmkResponse)(nil)).Elem()
}

func (o IdentityForCmkResponseOutput) ToIdentityForCmkResponseOutput() IdentityForCmkResponseOutput {
	return o
}

func (o IdentityForCmkResponseOutput) ToIdentityForCmkResponseOutputWithContext(ctx context.Context) IdentityForCmkResponseOutput {
	return o
}

// UserAssignedIdentity to be used to fetch the encryption key from keyVault
func (o IdentityForCmkResponseOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IdentityForCmkResponse) *string { return v.UserAssignedIdentity }).(pulumi.StringPtrOutput)
}

type IdentityForCmkResponsePtrOutput struct{ *pulumi.OutputState }

func (IdentityForCmkResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IdentityForCmkResponse)(nil)).Elem()
}

func (o IdentityForCmkResponsePtrOutput) ToIdentityForCmkResponsePtrOutput() IdentityForCmkResponsePtrOutput {
	return o
}

func (o IdentityForCmkResponsePtrOutput) ToIdentityForCmkResponsePtrOutputWithContext(ctx context.Context) IdentityForCmkResponsePtrOutput {
	return o
}

func (o IdentityForCmkResponsePtrOutput) Elem() IdentityForCmkResponseOutput {
	return o.ApplyT(func(v *IdentityForCmkResponse) IdentityForCmkResponse {
		if v != nil {
			return *v
		}
		var ret IdentityForCmkResponse
		return ret
	}).(IdentityForCmkResponseOutput)
}

// UserAssignedIdentity to be used to fetch the encryption key from keyVault
func (o IdentityForCmkResponsePtrOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IdentityForCmkResponse) *string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentity
	}).(pulumi.StringPtrOutput)
}

type Image struct {
	// Image reference URL
	Reference *string `pulumi:"reference"`
	// Type of the image. Possible values are: docker - For docker images. azureml - For AzureML images
	Type *string `pulumi:"type"`
}

// Defaults sets the appropriate defaults for Image
func (val *Image) Defaults() *Image {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := "docker"
		tmp.Type = &type_
	}
	return &tmp
}

// Image Classification. Multi-class image classification is used when an image is classified with only a single label
// from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
type ImageClassification struct {
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsClassification `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsClassification `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettings `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'ImageClassification'.
	TaskType string `pulumi:"taskType"`
	// [Required] Training data input.
	TrainingData MLTableJobInput `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *MLTableJobInput `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for ImageClassification
func (val *ImageClassification) Defaults() *ImageClassification {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "Accuracy"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
// from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
type ImageClassificationMultilabel struct {
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsClassification `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsClassification `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettings `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'ImageClassificationMultilabel'.
	TaskType string `pulumi:"taskType"`
	// [Required] Training data input.
	TrainingData MLTableJobInput `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *MLTableJobInput `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for ImageClassificationMultilabel
func (val *ImageClassificationMultilabel) Defaults() *ImageClassificationMultilabel {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "IOU"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
// from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
type ImageClassificationMultilabelResponse struct {
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsClassificationResponse `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsClassificationResponse `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettingsResponse `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'ImageClassificationMultilabel'.
	TaskType string `pulumi:"taskType"`
	// [Required] Training data input.
	TrainingData MLTableJobInputResponse `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *MLTableJobInputResponse `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for ImageClassificationMultilabelResponse
func (val *ImageClassificationMultilabelResponse) Defaults() *ImageClassificationMultilabelResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "IOU"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Image Classification. Multi-class image classification is used when an image is classified with only a single label
// from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
type ImageClassificationResponse struct {
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsClassificationResponse `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsClassificationResponse `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettingsResponse `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'ImageClassification'.
	TaskType string `pulumi:"taskType"`
	// [Required] Training data input.
	TrainingData MLTableJobInputResponse `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *MLTableJobInputResponse `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for ImageClassificationResponse
func (val *ImageClassificationResponse) Defaults() *ImageClassificationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "Accuracy"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
// drawing a polygon around each object in the image.
type ImageInstanceSegmentation struct {
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsObjectDetection `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsObjectDetection `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettings `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'ImageInstanceSegmentation'.
	TaskType string `pulumi:"taskType"`
	// [Required] Training data input.
	TrainingData MLTableJobInput `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *MLTableJobInput `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for ImageInstanceSegmentation
func (val *ImageInstanceSegmentation) Defaults() *ImageInstanceSegmentation {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "MeanAveragePrecision"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
// drawing a polygon around each object in the image.
type ImageInstanceSegmentationResponse struct {
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsObjectDetectionResponse `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsObjectDetectionResponse `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettingsResponse `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'ImageInstanceSegmentation'.
	TaskType string `pulumi:"taskType"`
	// [Required] Training data input.
	TrainingData MLTableJobInputResponse `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *MLTableJobInputResponse `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for ImageInstanceSegmentationResponse
func (val *ImageInstanceSegmentationResponse) Defaults() *ImageInstanceSegmentationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "MeanAveragePrecision"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Limit settings for the AutoML job.
type ImageLimitSettings struct {
	// Maximum number of concurrent AutoML iterations.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Maximum number of AutoML iterations.
	MaxTrials *int `pulumi:"maxTrials"`
	// AutoML job timeout.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for ImageLimitSettings
func (val *ImageLimitSettings) Defaults() *ImageLimitSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MaxConcurrentTrials == nil {
		maxConcurrentTrials_ := 1
		tmp.MaxConcurrentTrials = &maxConcurrentTrials_
	}
	if tmp.MaxTrials == nil {
		maxTrials_ := 1
		tmp.MaxTrials = &maxTrials_
	}
	if tmp.Timeout == nil {
		timeout_ := "P7D"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// Limit settings for the AutoML job.
type ImageLimitSettingsResponse struct {
	// Maximum number of concurrent AutoML iterations.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Maximum number of AutoML iterations.
	MaxTrials *int `pulumi:"maxTrials"`
	// AutoML job timeout.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for ImageLimitSettingsResponse
func (val *ImageLimitSettingsResponse) Defaults() *ImageLimitSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MaxConcurrentTrials == nil {
		maxConcurrentTrials_ := 1
		tmp.MaxConcurrentTrials = &maxConcurrentTrials_
	}
	if tmp.MaxTrials == nil {
		maxTrials_ := 1
		tmp.MaxTrials = &maxTrials_
	}
	if tmp.Timeout == nil {
		timeout_ := "P7D"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// Returns metadata about the operating system image for this compute instance.
type ImageMetadataResponse struct {
	// Specifies the current operating system image version this compute instance is running on.
	CurrentImageVersion *string `pulumi:"currentImageVersion"`
	// Specifies whether this compute instance is running on the latest operating system image.
	IsLatestOsImageVersion *bool `pulumi:"isLatestOsImageVersion"`
	// Specifies the latest available operating system image version.
	LatestImageVersion *string `pulumi:"latestImageVersion"`
}

// Distribution expressions to sweep over values of model settings.
// <example>
// Some examples are:
type ImageModelDistributionSettingsClassification struct {
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *string `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *string `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *string `pulumi:"beta2"`
	// Whether to use distributer training.
	Distributed *string `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *string `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *string `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *string `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *string `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *string `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *string `pulumi:"gradientAccumulationStep"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *string `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *string `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *string `pulumi:"momentum"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *string `pulumi:"nesterov"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *string `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *string `pulumi:"numberOfWorkers"`
	// Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *string `pulumi:"randomSeed"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *string `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *string `pulumi:"stepLRStepSize"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *string `pulumi:"trainingBatchSize"`
	// Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
	TrainingCropSize *string `pulumi:"trainingCropSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *string `pulumi:"validationBatchSize"`
	// Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
	ValidationCropSize *string `pulumi:"validationCropSize"`
	// Image size to which to resize before cropping for validation dataset. Must be a positive integer.
	ValidationResizeSize *string `pulumi:"validationResizeSize"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *string `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *string `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *string `pulumi:"weightDecay"`
	// Weighted loss. The accepted values are 0 for no weighted loss.
	// 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
	WeightedLoss *string `pulumi:"weightedLoss"`
}

// Distribution expressions to sweep over values of model settings.
// <example>
// Some examples are:
type ImageModelDistributionSettingsClassificationResponse struct {
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *string `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *string `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *string `pulumi:"beta2"`
	// Whether to use distributer training.
	Distributed *string `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *string `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *string `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *string `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *string `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *string `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *string `pulumi:"gradientAccumulationStep"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *string `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *string `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *string `pulumi:"momentum"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *string `pulumi:"nesterov"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *string `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *string `pulumi:"numberOfWorkers"`
	// Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *string `pulumi:"randomSeed"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *string `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *string `pulumi:"stepLRStepSize"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *string `pulumi:"trainingBatchSize"`
	// Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
	TrainingCropSize *string `pulumi:"trainingCropSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *string `pulumi:"validationBatchSize"`
	// Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
	ValidationCropSize *string `pulumi:"validationCropSize"`
	// Image size to which to resize before cropping for validation dataset. Must be a positive integer.
	ValidationResizeSize *string `pulumi:"validationResizeSize"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *string `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *string `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *string `pulumi:"weightDecay"`
	// Weighted loss. The accepted values are 0 for no weighted loss.
	// 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
	WeightedLoss *string `pulumi:"weightedLoss"`
}

// Distribution expressions to sweep over values of model settings.
// <example>
// Some examples are:
type ImageModelDistributionSettingsObjectDetection struct {
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *string `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *string `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *string `pulumi:"beta2"`
	// Maximum number of detections per image, for all classes. Must be a positive integer.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	BoxDetectionsPerImage *string `pulumi:"boxDetectionsPerImage"`
	// During inference, only return proposals with a classification score greater than
	// BoxScoreThreshold. Must be a float in the range[0, 1].
	BoxScoreThreshold *string `pulumi:"boxScoreThreshold"`
	// Whether to use distributer training.
	Distributed *string `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *string `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *string `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *string `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *string `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *string `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *string `pulumi:"gradientAccumulationStep"`
	// Image size for train and validation. Must be a positive integer.
	// Note: The training run may get into CUDA OOM if the size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ImageSize *string `pulumi:"imageSize"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *string `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *string `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Maximum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MaxSize *string `pulumi:"maxSize"`
	// Minimum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MinSize *string `pulumi:"minSize"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
	// Note: training run may get into CUDA OOM if the model size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ModelSize *string `pulumi:"modelSize"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *string `pulumi:"momentum"`
	// Enable multi-scale image by varying image size by +/- 50%.
	// Note: training run may get into CUDA OOM if no sufficient GPU memory.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	MultiScale *string `pulumi:"multiScale"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *string `pulumi:"nesterov"`
	// IOU threshold used during inference in NMS post processing. Must be float in the range [0, 1].
	NmsIouThreshold *string `pulumi:"nmsIouThreshold"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *string `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *string `pulumi:"numberOfWorkers"`
	// Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *string `pulumi:"randomSeed"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *string `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *string `pulumi:"stepLRStepSize"`
	// The grid size to use for tiling each image. Note: TileGridSize must not be
	// None to enable small object detection logic. A string containing two integers in mxn format.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileGridSize *string `pulumi:"tileGridSize"`
	// Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileOverlapRatio *string `pulumi:"tileOverlapRatio"`
	// The IOU threshold to use to perform NMS while merging predictions from tiles and image.
	// Used in validation/ inference. Must be float in the range [0, 1].
	// Note: This settings is not supported for the 'yolov5' algorithm.
	// NMS: Non-maximum suppression
	TilePredictionsNmsThreshold *string `pulumi:"tilePredictionsNmsThreshold"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *string `pulumi:"trainingBatchSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *string `pulumi:"validationBatchSize"`
	// IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
	ValidationIouThreshold *string `pulumi:"validationIouThreshold"`
	// Metric computation method to use for validation metrics. Must be 'none', 'coco', 'voc', or 'coco_voc'.
	ValidationMetricType *string `pulumi:"validationMetricType"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *string `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *string `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *string `pulumi:"weightDecay"`
}

// Distribution expressions to sweep over values of model settings.
// <example>
// Some examples are:
type ImageModelDistributionSettingsObjectDetectionResponse struct {
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *string `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *string `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *string `pulumi:"beta2"`
	// Maximum number of detections per image, for all classes. Must be a positive integer.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	BoxDetectionsPerImage *string `pulumi:"boxDetectionsPerImage"`
	// During inference, only return proposals with a classification score greater than
	// BoxScoreThreshold. Must be a float in the range[0, 1].
	BoxScoreThreshold *string `pulumi:"boxScoreThreshold"`
	// Whether to use distributer training.
	Distributed *string `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *string `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *string `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *string `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *string `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *string `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *string `pulumi:"gradientAccumulationStep"`
	// Image size for train and validation. Must be a positive integer.
	// Note: The training run may get into CUDA OOM if the size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ImageSize *string `pulumi:"imageSize"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *string `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *string `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Maximum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MaxSize *string `pulumi:"maxSize"`
	// Minimum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MinSize *string `pulumi:"minSize"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
	// Note: training run may get into CUDA OOM if the model size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ModelSize *string `pulumi:"modelSize"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *string `pulumi:"momentum"`
	// Enable multi-scale image by varying image size by +/- 50%.
	// Note: training run may get into CUDA OOM if no sufficient GPU memory.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	MultiScale *string `pulumi:"multiScale"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *string `pulumi:"nesterov"`
	// IOU threshold used during inference in NMS post processing. Must be float in the range [0, 1].
	NmsIouThreshold *string `pulumi:"nmsIouThreshold"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *string `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *string `pulumi:"numberOfWorkers"`
	// Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *string `pulumi:"randomSeed"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *string `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *string `pulumi:"stepLRStepSize"`
	// The grid size to use for tiling each image. Note: TileGridSize must not be
	// None to enable small object detection logic. A string containing two integers in mxn format.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileGridSize *string `pulumi:"tileGridSize"`
	// Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileOverlapRatio *string `pulumi:"tileOverlapRatio"`
	// The IOU threshold to use to perform NMS while merging predictions from tiles and image.
	// Used in validation/ inference. Must be float in the range [0, 1].
	// Note: This settings is not supported for the 'yolov5' algorithm.
	// NMS: Non-maximum suppression
	TilePredictionsNmsThreshold *string `pulumi:"tilePredictionsNmsThreshold"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *string `pulumi:"trainingBatchSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *string `pulumi:"validationBatchSize"`
	// IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
	ValidationIouThreshold *string `pulumi:"validationIouThreshold"`
	// Metric computation method to use for validation metrics. Must be 'none', 'coco', 'voc', or 'coco_voc'.
	ValidationMetricType *string `pulumi:"validationMetricType"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *string `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *string `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *string `pulumi:"weightDecay"`
}

// Settings used for training the model.
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelSettingsClassification struct {
	// Settings for advanced scenarios.
	AdvancedSettings *string `pulumi:"advancedSettings"`
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *bool `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *float64 `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *float64 `pulumi:"beta2"`
	// Frequency to store model checkpoints. Must be a positive integer.
	CheckpointFrequency *int `pulumi:"checkpointFrequency"`
	// The pretrained checkpoint model for incremental training.
	CheckpointModel *MLFlowModelJobInput `pulumi:"checkpointModel"`
	// The id of a previous run that has a pretrained checkpoint for incremental training.
	CheckpointRunId *string `pulumi:"checkpointRunId"`
	// Whether to use distributed training.
	Distributed *bool `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *bool `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *int `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *int `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *bool `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *int `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *int `pulumi:"gradientAccumulationStep"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *int `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *float64 `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *float64 `pulumi:"momentum"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *bool `pulumi:"nesterov"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *int `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *int `pulumi:"numberOfWorkers"`
	// Type of optimizer.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *int `pulumi:"randomSeed"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *float64 `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *int `pulumi:"stepLRStepSize"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *int `pulumi:"trainingBatchSize"`
	// Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
	TrainingCropSize *int `pulumi:"trainingCropSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *int `pulumi:"validationBatchSize"`
	// Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
	ValidationCropSize *int `pulumi:"validationCropSize"`
	// Image size to which to resize before cropping for validation dataset. Must be a positive integer.
	ValidationResizeSize *int `pulumi:"validationResizeSize"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *float64 `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *int `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *float64 `pulumi:"weightDecay"`
	// Weighted loss. The accepted values are 0 for no weighted loss.
	// 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
	WeightedLoss *int `pulumi:"weightedLoss"`
}

// Defaults sets the appropriate defaults for ImageModelSettingsClassification
func (val *ImageModelSettingsClassification) Defaults() *ImageModelSettingsClassification {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.CheckpointModel = tmp.CheckpointModel.Defaults()

	if tmp.LearningRateScheduler == nil {
		learningRateScheduler_ := "None"
		tmp.LearningRateScheduler = &learningRateScheduler_
	}
	if tmp.Optimizer == nil {
		optimizer_ := "None"
		tmp.Optimizer = &optimizer_
	}
	return &tmp
}

// Settings used for training the model.
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelSettingsClassificationResponse struct {
	// Settings for advanced scenarios.
	AdvancedSettings *string `pulumi:"advancedSettings"`
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *bool `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *float64 `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *float64 `pulumi:"beta2"`
	// Frequency to store model checkpoints. Must be a positive integer.
	CheckpointFrequency *int `pulumi:"checkpointFrequency"`
	// The pretrained checkpoint model for incremental training.
	CheckpointModel *MLFlowModelJobInputResponse `pulumi:"checkpointModel"`
	// The id of a previous run that has a pretrained checkpoint for incremental training.
	CheckpointRunId *string `pulumi:"checkpointRunId"`
	// Whether to use distributed training.
	Distributed *bool `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *bool `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *int `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *int `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *bool `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *int `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *int `pulumi:"gradientAccumulationStep"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *int `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *float64 `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *float64 `pulumi:"momentum"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *bool `pulumi:"nesterov"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *int `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *int `pulumi:"numberOfWorkers"`
	// Type of optimizer.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *int `pulumi:"randomSeed"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *float64 `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *int `pulumi:"stepLRStepSize"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *int `pulumi:"trainingBatchSize"`
	// Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
	TrainingCropSize *int `pulumi:"trainingCropSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *int `pulumi:"validationBatchSize"`
	// Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
	ValidationCropSize *int `pulumi:"validationCropSize"`
	// Image size to which to resize before cropping for validation dataset. Must be a positive integer.
	ValidationResizeSize *int `pulumi:"validationResizeSize"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *float64 `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *int `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *float64 `pulumi:"weightDecay"`
	// Weighted loss. The accepted values are 0 for no weighted loss.
	// 1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
	WeightedLoss *int `pulumi:"weightedLoss"`
}

// Defaults sets the appropriate defaults for ImageModelSettingsClassificationResponse
func (val *ImageModelSettingsClassificationResponse) Defaults() *ImageModelSettingsClassificationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.CheckpointModel = tmp.CheckpointModel.Defaults()

	if tmp.LearningRateScheduler == nil {
		learningRateScheduler_ := "None"
		tmp.LearningRateScheduler = &learningRateScheduler_
	}
	if tmp.Optimizer == nil {
		optimizer_ := "None"
		tmp.Optimizer = &optimizer_
	}
	return &tmp
}

// Settings used for training the model.
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelSettingsObjectDetection struct {
	// Settings for advanced scenarios.
	AdvancedSettings *string `pulumi:"advancedSettings"`
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *bool `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *float64 `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *float64 `pulumi:"beta2"`
	// Maximum number of detections per image, for all classes. Must be a positive integer.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	BoxDetectionsPerImage *int `pulumi:"boxDetectionsPerImage"`
	// During inference, only return proposals with a classification score greater than
	// BoxScoreThreshold. Must be a float in the range[0, 1].
	BoxScoreThreshold *float64 `pulumi:"boxScoreThreshold"`
	// Frequency to store model checkpoints. Must be a positive integer.
	CheckpointFrequency *int `pulumi:"checkpointFrequency"`
	// The pretrained checkpoint model for incremental training.
	CheckpointModel *MLFlowModelJobInput `pulumi:"checkpointModel"`
	// The id of a previous run that has a pretrained checkpoint for incremental training.
	CheckpointRunId *string `pulumi:"checkpointRunId"`
	// Whether to use distributed training.
	Distributed *bool `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *bool `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *int `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *int `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *bool `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *int `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *int `pulumi:"gradientAccumulationStep"`
	// Image size for train and validation. Must be a positive integer.
	// Note: The training run may get into CUDA OOM if the size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ImageSize *int `pulumi:"imageSize"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *int `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *float64 `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Enable computing and logging training metrics.
	LogTrainingMetrics *string `pulumi:"logTrainingMetrics"`
	// Enable computing and logging validation loss.
	LogValidationLoss *string `pulumi:"logValidationLoss"`
	// Maximum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MaxSize *int `pulumi:"maxSize"`
	// Minimum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MinSize *int `pulumi:"minSize"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
	// Note: training run may get into CUDA OOM if the model size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ModelSize *string `pulumi:"modelSize"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *float64 `pulumi:"momentum"`
	// Enable multi-scale image by varying image size by +/- 50%.
	// Note: training run may get into CUDA OOM if no sufficient GPU memory.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	MultiScale *bool `pulumi:"multiScale"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *bool `pulumi:"nesterov"`
	// IOU threshold used during inference in NMS post processing. Must be a float in the range [0, 1].
	NmsIouThreshold *float64 `pulumi:"nmsIouThreshold"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *int `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *int `pulumi:"numberOfWorkers"`
	// Type of optimizer.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *int `pulumi:"randomSeed"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *float64 `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *int `pulumi:"stepLRStepSize"`
	// The grid size to use for tiling each image. Note: TileGridSize must not be
	// None to enable small object detection logic. A string containing two integers in mxn format.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileGridSize *string `pulumi:"tileGridSize"`
	// Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileOverlapRatio *float64 `pulumi:"tileOverlapRatio"`
	// The IOU threshold to use to perform NMS while merging predictions from tiles and image.
	// Used in validation/ inference. Must be float in the range [0, 1].
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TilePredictionsNmsThreshold *float64 `pulumi:"tilePredictionsNmsThreshold"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *int `pulumi:"trainingBatchSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *int `pulumi:"validationBatchSize"`
	// IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
	ValidationIouThreshold *float64 `pulumi:"validationIouThreshold"`
	// Metric computation method to use for validation metrics.
	ValidationMetricType *string `pulumi:"validationMetricType"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *float64 `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *int `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *float64 `pulumi:"weightDecay"`
}

// Defaults sets the appropriate defaults for ImageModelSettingsObjectDetection
func (val *ImageModelSettingsObjectDetection) Defaults() *ImageModelSettingsObjectDetection {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.CheckpointModel = tmp.CheckpointModel.Defaults()

	if tmp.LearningRateScheduler == nil {
		learningRateScheduler_ := "None"
		tmp.LearningRateScheduler = &learningRateScheduler_
	}
	if tmp.LogTrainingMetrics == nil {
		logTrainingMetrics_ := "Enable"
		tmp.LogTrainingMetrics = &logTrainingMetrics_
	}
	if tmp.LogValidationLoss == nil {
		logValidationLoss_ := "Disable"
		tmp.LogValidationLoss = &logValidationLoss_
	}
	if tmp.ModelSize == nil {
		modelSize_ := "None"
		tmp.ModelSize = &modelSize_
	}
	if tmp.Optimizer == nil {
		optimizer_ := "None"
		tmp.Optimizer = &optimizer_
	}
	if tmp.ValidationMetricType == nil {
		validationMetricType_ := "None"
		tmp.ValidationMetricType = &validationMetricType_
	}
	return &tmp
}

// Settings used for training the model.
// For more information on the available settings please visit the official documentation:
// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
type ImageModelSettingsObjectDetectionResponse struct {
	// Settings for advanced scenarios.
	AdvancedSettings *string `pulumi:"advancedSettings"`
	// Enable AMSGrad when optimizer is 'adam' or 'adamw'.
	AmsGradient *bool `pulumi:"amsGradient"`
	// Settings for using Augmentations.
	Augmentations *string `pulumi:"augmentations"`
	// Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta1 *float64 `pulumi:"beta1"`
	// Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
	Beta2 *float64 `pulumi:"beta2"`
	// Maximum number of detections per image, for all classes. Must be a positive integer.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	BoxDetectionsPerImage *int `pulumi:"boxDetectionsPerImage"`
	// During inference, only return proposals with a classification score greater than
	// BoxScoreThreshold. Must be a float in the range[0, 1].
	BoxScoreThreshold *float64 `pulumi:"boxScoreThreshold"`
	// Frequency to store model checkpoints. Must be a positive integer.
	CheckpointFrequency *int `pulumi:"checkpointFrequency"`
	// The pretrained checkpoint model for incremental training.
	CheckpointModel *MLFlowModelJobInputResponse `pulumi:"checkpointModel"`
	// The id of a previous run that has a pretrained checkpoint for incremental training.
	CheckpointRunId *string `pulumi:"checkpointRunId"`
	// Whether to use distributed training.
	Distributed *bool `pulumi:"distributed"`
	// Enable early stopping logic during training.
	EarlyStopping *bool `pulumi:"earlyStopping"`
	// Minimum number of epochs or validation evaluations to wait before primary metric improvement
	// is tracked for early stopping. Must be a positive integer.
	EarlyStoppingDelay *int `pulumi:"earlyStoppingDelay"`
	// Minimum number of epochs or validation evaluations with no primary metric improvement before
	// the run is stopped. Must be a positive integer.
	EarlyStoppingPatience *int `pulumi:"earlyStoppingPatience"`
	// Enable normalization when exporting ONNX model.
	EnableOnnxNormalization *bool `pulumi:"enableOnnxNormalization"`
	// Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
	EvaluationFrequency *int `pulumi:"evaluationFrequency"`
	// Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
	// updating the model weights while accumulating the gradients of those steps, and then using
	// the accumulated gradients to compute the weight updates. Must be a positive integer.
	GradientAccumulationStep *int `pulumi:"gradientAccumulationStep"`
	// Image size for train and validation. Must be a positive integer.
	// Note: The training run may get into CUDA OOM if the size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ImageSize *int `pulumi:"imageSize"`
	// Number of layers to freeze for the model. Must be a positive integer.
	// For instance, passing 2 as value for 'seresnext' means
	// freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
	// see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	LayersToFreeze *int `pulumi:"layersToFreeze"`
	// Initial learning rate. Must be a float in the range [0, 1].
	LearningRate *float64 `pulumi:"learningRate"`
	// Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// Enable computing and logging training metrics.
	LogTrainingMetrics *string `pulumi:"logTrainingMetrics"`
	// Enable computing and logging validation loss.
	LogValidationLoss *string `pulumi:"logValidationLoss"`
	// Maximum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MaxSize *int `pulumi:"maxSize"`
	// Minimum size of the image to be rescaled before feeding it to the backbone.
	// Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	MinSize *int `pulumi:"minSize"`
	// Name of the model to use for training.
	// For more information on the available models please visit the official documentation:
	// https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
	ModelName *string `pulumi:"modelName"`
	// Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
	// Note: training run may get into CUDA OOM if the model size is too big.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	ModelSize *string `pulumi:"modelSize"`
	// Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
	Momentum *float64 `pulumi:"momentum"`
	// Enable multi-scale image by varying image size by +/- 50%.
	// Note: training run may get into CUDA OOM if no sufficient GPU memory.
	// Note: This settings is only supported for the 'yolov5' algorithm.
	MultiScale *bool `pulumi:"multiScale"`
	// Enable nesterov when optimizer is 'sgd'.
	Nesterov *bool `pulumi:"nesterov"`
	// IOU threshold used during inference in NMS post processing. Must be a float in the range [0, 1].
	NmsIouThreshold *float64 `pulumi:"nmsIouThreshold"`
	// Number of training epochs. Must be a positive integer.
	NumberOfEpochs *int `pulumi:"numberOfEpochs"`
	// Number of data loader workers. Must be a non-negative integer.
	NumberOfWorkers *int `pulumi:"numberOfWorkers"`
	// Type of optimizer.
	Optimizer *string `pulumi:"optimizer"`
	// Random seed to be used when using deterministic training.
	RandomSeed *int `pulumi:"randomSeed"`
	// Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
	StepLRGamma *float64 `pulumi:"stepLRGamma"`
	// Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
	StepLRStepSize *int `pulumi:"stepLRStepSize"`
	// The grid size to use for tiling each image. Note: TileGridSize must not be
	// None to enable small object detection logic. A string containing two integers in mxn format.
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileGridSize *string `pulumi:"tileGridSize"`
	// Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TileOverlapRatio *float64 `pulumi:"tileOverlapRatio"`
	// The IOU threshold to use to perform NMS while merging predictions from tiles and image.
	// Used in validation/ inference. Must be float in the range [0, 1].
	// Note: This settings is not supported for the 'yolov5' algorithm.
	TilePredictionsNmsThreshold *float64 `pulumi:"tilePredictionsNmsThreshold"`
	// Training batch size. Must be a positive integer.
	TrainingBatchSize *int `pulumi:"trainingBatchSize"`
	// Validation batch size. Must be a positive integer.
	ValidationBatchSize *int `pulumi:"validationBatchSize"`
	// IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
	ValidationIouThreshold *float64 `pulumi:"validationIouThreshold"`
	// Metric computation method to use for validation metrics.
	ValidationMetricType *string `pulumi:"validationMetricType"`
	// Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
	WarmupCosineLRCycles *float64 `pulumi:"warmupCosineLRCycles"`
	// Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
	WarmupCosineLRWarmupEpochs *int `pulumi:"warmupCosineLRWarmupEpochs"`
	// Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
	WeightDecay *float64 `pulumi:"weightDecay"`
}

// Defaults sets the appropriate defaults for ImageModelSettingsObjectDetectionResponse
func (val *ImageModelSettingsObjectDetectionResponse) Defaults() *ImageModelSettingsObjectDetectionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.CheckpointModel = tmp.CheckpointModel.Defaults()

	if tmp.LearningRateScheduler == nil {
		learningRateScheduler_ := "None"
		tmp.LearningRateScheduler = &learningRateScheduler_
	}
	if tmp.LogTrainingMetrics == nil {
		logTrainingMetrics_ := "Enable"
		tmp.LogTrainingMetrics = &logTrainingMetrics_
	}
	if tmp.LogValidationLoss == nil {
		logValidationLoss_ := "Disable"
		tmp.LogValidationLoss = &logValidationLoss_
	}
	if tmp.ModelSize == nil {
		modelSize_ := "None"
		tmp.ModelSize = &modelSize_
	}
	if tmp.Optimizer == nil {
		optimizer_ := "None"
		tmp.Optimizer = &optimizer_
	}
	if tmp.ValidationMetricType == nil {
		validationMetricType_ := "None"
		tmp.ValidationMetricType = &validationMetricType_
	}
	return &tmp
}

// Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
// bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
type ImageObjectDetection struct {
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsObjectDetection `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsObjectDetection `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettings `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'ImageObjectDetection'.
	TaskType string `pulumi:"taskType"`
	// [Required] Training data input.
	TrainingData MLTableJobInput `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *MLTableJobInput `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for ImageObjectDetection
func (val *ImageObjectDetection) Defaults() *ImageObjectDetection {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "MeanAveragePrecision"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
// bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
type ImageObjectDetectionResponse struct {
	// [Required] Limit settings for the AutoML job.
	LimitSettings ImageLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Settings used for training the model.
	ModelSettings *ImageModelSettingsObjectDetectionResponse `pulumi:"modelSettings"`
	// Primary metric to optimize for this task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []ImageModelDistributionSettingsObjectDetectionResponse `pulumi:"searchSpace"`
	// Model sweeping and hyperparameter sweeping related settings.
	SweepSettings *ImageSweepSettingsResponse `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'ImageObjectDetection'.
	TaskType string `pulumi:"taskType"`
	// [Required] Training data input.
	TrainingData MLTableJobInputResponse `pulumi:"trainingData"`
	// Validation data inputs.
	ValidationData *MLTableJobInputResponse `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
}

// Defaults sets the appropriate defaults for ImageObjectDetectionResponse
func (val *ImageObjectDetectionResponse) Defaults() *ImageObjectDetectionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.LimitSettings = *tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	tmp.ModelSettings = tmp.ModelSettings.Defaults()

	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "MeanAveragePrecision"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

type ImageResponse struct {
	// Image reference URL
	Reference *string `pulumi:"reference"`
	// Type of the image. Possible values are: docker - For docker images. azureml - For AzureML images
	Type *string `pulumi:"type"`
}

// Defaults sets the appropriate defaults for ImageResponse
func (val *ImageResponse) Defaults() *ImageResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := "docker"
		tmp.Type = &type_
	}
	return &tmp
}

// Model sweeping and hyperparameter sweeping related settings.
type ImageSweepSettings struct {
	// Type of early termination policy.
	EarlyTermination interface{} `pulumi:"earlyTermination"`
	// [Required] Type of the hyperparameter sampling algorithms.
	SamplingAlgorithm string `pulumi:"samplingAlgorithm"`
}

// Model sweeping and hyperparameter sweeping related settings.
type ImageSweepSettingsResponse struct {
	// Type of early termination policy.
	EarlyTermination interface{} `pulumi:"earlyTermination"`
	// [Required] Type of the hyperparameter sampling algorithms.
	SamplingAlgorithm string `pulumi:"samplingAlgorithm"`
}

type ImportDataAction struct {
	// Expected value is 'ImportData'.
	ActionType string `pulumi:"actionType"`
	// [Required] Defines Schedule action definition details.
	DataImportDefinition DataImport `pulumi:"dataImportDefinition"`
}

// Defaults sets the appropriate defaults for ImportDataAction
func (val *ImportDataAction) Defaults() *ImportDataAction {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataImportDefinition = *tmp.DataImportDefinition.Defaults()

	return &tmp
}

type ImportDataActionResponse struct {
	// Expected value is 'ImportData'.
	ActionType string `pulumi:"actionType"`
	// [Required] Defines Schedule action definition details.
	DataImportDefinition DataImportResponse `pulumi:"dataImportDefinition"`
}

// Defaults sets the appropriate defaults for ImportDataActionResponse
func (val *ImportDataActionResponse) Defaults() *ImportDataActionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataImportDefinition = *tmp.DataImportDefinition.Defaults()

	return &tmp
}

// Dto object representing index column
type IndexColumn struct {
	// Specifies the column name
	ColumnName *string `pulumi:"columnName"`
	// Specifies the data type
	DataType *string `pulumi:"dataType"`
}

// Defaults sets the appropriate defaults for IndexColumn
func (val *IndexColumn) Defaults() *IndexColumn {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DataType == nil {
		dataType_ := "String"
		tmp.DataType = &dataType_
	}
	return &tmp
}

// IndexColumnInput is an input type that accepts IndexColumnArgs and IndexColumnOutput values.
// You can construct a concrete instance of `IndexColumnInput` via:
//
//	IndexColumnArgs{...}
type IndexColumnInput interface {
	pulumi.Input

	ToIndexColumnOutput() IndexColumnOutput
	ToIndexColumnOutputWithContext(context.Context) IndexColumnOutput
}

// Dto object representing index column
type IndexColumnArgs struct {
	// Specifies the column name
	ColumnName pulumi.StringPtrInput `pulumi:"columnName"`
	// Specifies the data type
	DataType pulumi.StringPtrInput `pulumi:"dataType"`
}

// Defaults sets the appropriate defaults for IndexColumnArgs
func (val *IndexColumnArgs) Defaults() *IndexColumnArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DataType == nil {
		tmp.DataType = pulumi.StringPtr("String")
	}
	return &tmp
}
func (IndexColumnArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexColumn)(nil)).Elem()
}

func (i IndexColumnArgs) ToIndexColumnOutput() IndexColumnOutput {
	return i.ToIndexColumnOutputWithContext(context.Background())
}

func (i IndexColumnArgs) ToIndexColumnOutputWithContext(ctx context.Context) IndexColumnOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexColumnOutput)
}

// IndexColumnArrayInput is an input type that accepts IndexColumnArray and IndexColumnArrayOutput values.
// You can construct a concrete instance of `IndexColumnArrayInput` via:
//
//	IndexColumnArray{ IndexColumnArgs{...} }
type IndexColumnArrayInput interface {
	pulumi.Input

	ToIndexColumnArrayOutput() IndexColumnArrayOutput
	ToIndexColumnArrayOutputWithContext(context.Context) IndexColumnArrayOutput
}

type IndexColumnArray []IndexColumnInput

func (IndexColumnArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexColumn)(nil)).Elem()
}

func (i IndexColumnArray) ToIndexColumnArrayOutput() IndexColumnArrayOutput {
	return i.ToIndexColumnArrayOutputWithContext(context.Background())
}

func (i IndexColumnArray) ToIndexColumnArrayOutputWithContext(ctx context.Context) IndexColumnArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexColumnArrayOutput)
}

// Dto object representing index column
type IndexColumnOutput struct{ *pulumi.OutputState }

func (IndexColumnOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexColumn)(nil)).Elem()
}

func (o IndexColumnOutput) ToIndexColumnOutput() IndexColumnOutput {
	return o
}

func (o IndexColumnOutput) ToIndexColumnOutputWithContext(ctx context.Context) IndexColumnOutput {
	return o
}

// Specifies the column name
func (o IndexColumnOutput) ColumnName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexColumn) *string { return v.ColumnName }).(pulumi.StringPtrOutput)
}

// Specifies the data type
func (o IndexColumnOutput) DataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexColumn) *string { return v.DataType }).(pulumi.StringPtrOutput)
}

type IndexColumnArrayOutput struct{ *pulumi.OutputState }

func (IndexColumnArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexColumn)(nil)).Elem()
}

func (o IndexColumnArrayOutput) ToIndexColumnArrayOutput() IndexColumnArrayOutput {
	return o
}

func (o IndexColumnArrayOutput) ToIndexColumnArrayOutputWithContext(ctx context.Context) IndexColumnArrayOutput {
	return o
}

func (o IndexColumnArrayOutput) Index(i pulumi.IntInput) IndexColumnOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexColumn {
		return vs[0].([]IndexColumn)[vs[1].(int)]
	}).(IndexColumnOutput)
}

// Dto object representing index column
type IndexColumnResponse struct {
	// Specifies the column name
	ColumnName *string `pulumi:"columnName"`
	// Specifies the data type
	DataType *string `pulumi:"dataType"`
}

// Defaults sets the appropriate defaults for IndexColumnResponse
func (val *IndexColumnResponse) Defaults() *IndexColumnResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DataType == nil {
		dataType_ := "String"
		tmp.DataType = &dataType_
	}
	return &tmp
}

// Dto object representing index column
type IndexColumnResponseOutput struct{ *pulumi.OutputState }

func (IndexColumnResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexColumnResponse)(nil)).Elem()
}

func (o IndexColumnResponseOutput) ToIndexColumnResponseOutput() IndexColumnResponseOutput {
	return o
}

func (o IndexColumnResponseOutput) ToIndexColumnResponseOutputWithContext(ctx context.Context) IndexColumnResponseOutput {
	return o
}

// Specifies the column name
func (o IndexColumnResponseOutput) ColumnName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexColumnResponse) *string { return v.ColumnName }).(pulumi.StringPtrOutput)
}

// Specifies the data type
func (o IndexColumnResponseOutput) DataType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexColumnResponse) *string { return v.DataType }).(pulumi.StringPtrOutput)
}

type IndexColumnResponseArrayOutput struct{ *pulumi.OutputState }

func (IndexColumnResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexColumnResponse)(nil)).Elem()
}

func (o IndexColumnResponseArrayOutput) ToIndexColumnResponseArrayOutput() IndexColumnResponseArrayOutput {
	return o
}

func (o IndexColumnResponseArrayOutput) ToIndexColumnResponseArrayOutputWithContext(ctx context.Context) IndexColumnResponseArrayOutput {
	return o
}

func (o IndexColumnResponseArrayOutput) Index(i pulumi.IntInput) IndexColumnResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexColumnResponse {
		return vs[0].([]IndexColumnResponse)[vs[1].(int)]
	}).(IndexColumnResponseOutput)
}

type InferenceContainerProperties struct {
	// The route to check the liveness of the inference server container.
	LivenessRoute *Route `pulumi:"livenessRoute"`
	// The route to check the readiness of the inference server container.
	ReadinessRoute *Route `pulumi:"readinessRoute"`
	// The port to send the scoring requests to, within the inference server container.
	ScoringRoute *Route `pulumi:"scoringRoute"`
}

// InferenceContainerPropertiesInput is an input type that accepts InferenceContainerPropertiesArgs and InferenceContainerPropertiesOutput values.
// You can construct a concrete instance of `InferenceContainerPropertiesInput` via:
//
//	InferenceContainerPropertiesArgs{...}
type InferenceContainerPropertiesInput interface {
	pulumi.Input

	ToInferenceContainerPropertiesOutput() InferenceContainerPropertiesOutput
	ToInferenceContainerPropertiesOutputWithContext(context.Context) InferenceContainerPropertiesOutput
}

type InferenceContainerPropertiesArgs struct {
	// The route to check the liveness of the inference server container.
	LivenessRoute RoutePtrInput `pulumi:"livenessRoute"`
	// The route to check the readiness of the inference server container.
	ReadinessRoute RoutePtrInput `pulumi:"readinessRoute"`
	// The port to send the scoring requests to, within the inference server container.
	ScoringRoute RoutePtrInput `pulumi:"scoringRoute"`
}

func (InferenceContainerPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InferenceContainerProperties)(nil)).Elem()
}

func (i InferenceContainerPropertiesArgs) ToInferenceContainerPropertiesOutput() InferenceContainerPropertiesOutput {
	return i.ToInferenceContainerPropertiesOutputWithContext(context.Background())
}

func (i InferenceContainerPropertiesArgs) ToInferenceContainerPropertiesOutputWithContext(ctx context.Context) InferenceContainerPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InferenceContainerPropertiesOutput)
}

func (i InferenceContainerPropertiesArgs) ToInferenceContainerPropertiesPtrOutput() InferenceContainerPropertiesPtrOutput {
	return i.ToInferenceContainerPropertiesPtrOutputWithContext(context.Background())
}

func (i InferenceContainerPropertiesArgs) ToInferenceContainerPropertiesPtrOutputWithContext(ctx context.Context) InferenceContainerPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InferenceContainerPropertiesOutput).ToInferenceContainerPropertiesPtrOutputWithContext(ctx)
}

// InferenceContainerPropertiesPtrInput is an input type that accepts InferenceContainerPropertiesArgs, InferenceContainerPropertiesPtr and InferenceContainerPropertiesPtrOutput values.
// You can construct a concrete instance of `InferenceContainerPropertiesPtrInput` via:
//
//	        InferenceContainerPropertiesArgs{...}
//
//	or:
//
//	        nil
type InferenceContainerPropertiesPtrInput interface {
	pulumi.Input

	ToInferenceContainerPropertiesPtrOutput() InferenceContainerPropertiesPtrOutput
	ToInferenceContainerPropertiesPtrOutputWithContext(context.Context) InferenceContainerPropertiesPtrOutput
}

type inferenceContainerPropertiesPtrType InferenceContainerPropertiesArgs

func InferenceContainerPropertiesPtr(v *InferenceContainerPropertiesArgs) InferenceContainerPropertiesPtrInput {
	return (*inferenceContainerPropertiesPtrType)(v)
}

func (*inferenceContainerPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InferenceContainerProperties)(nil)).Elem()
}

func (i *inferenceContainerPropertiesPtrType) ToInferenceContainerPropertiesPtrOutput() InferenceContainerPropertiesPtrOutput {
	return i.ToInferenceContainerPropertiesPtrOutputWithContext(context.Background())
}

func (i *inferenceContainerPropertiesPtrType) ToInferenceContainerPropertiesPtrOutputWithContext(ctx context.Context) InferenceContainerPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InferenceContainerPropertiesPtrOutput)
}

type InferenceContainerPropertiesOutput struct{ *pulumi.OutputState }

func (InferenceContainerPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InferenceContainerProperties)(nil)).Elem()
}

func (o InferenceContainerPropertiesOutput) ToInferenceContainerPropertiesOutput() InferenceContainerPropertiesOutput {
	return o
}

func (o InferenceContainerPropertiesOutput) ToInferenceContainerPropertiesOutputWithContext(ctx context.Context) InferenceContainerPropertiesOutput {
	return o
}

func (o InferenceContainerPropertiesOutput) ToInferenceContainerPropertiesPtrOutput() InferenceContainerPropertiesPtrOutput {
	return o.ToInferenceContainerPropertiesPtrOutputWithContext(context.Background())
}

func (o InferenceContainerPropertiesOutput) ToInferenceContainerPropertiesPtrOutputWithContext(ctx context.Context) InferenceContainerPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v InferenceContainerProperties) *InferenceContainerProperties {
		return &v
	}).(InferenceContainerPropertiesPtrOutput)
}

// The route to check the liveness of the inference server container.
func (o InferenceContainerPropertiesOutput) LivenessRoute() RoutePtrOutput {
	return o.ApplyT(func(v InferenceContainerProperties) *Route { return v.LivenessRoute }).(RoutePtrOutput)
}

// The route to check the readiness of the inference server container.
func (o InferenceContainerPropertiesOutput) ReadinessRoute() RoutePtrOutput {
	return o.ApplyT(func(v InferenceContainerProperties) *Route { return v.ReadinessRoute }).(RoutePtrOutput)
}

// The port to send the scoring requests to, within the inference server container.
func (o InferenceContainerPropertiesOutput) ScoringRoute() RoutePtrOutput {
	return o.ApplyT(func(v InferenceContainerProperties) *Route { return v.ScoringRoute }).(RoutePtrOutput)
}

type InferenceContainerPropertiesPtrOutput struct{ *pulumi.OutputState }

func (InferenceContainerPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InferenceContainerProperties)(nil)).Elem()
}

func (o InferenceContainerPropertiesPtrOutput) ToInferenceContainerPropertiesPtrOutput() InferenceContainerPropertiesPtrOutput {
	return o
}

func (o InferenceContainerPropertiesPtrOutput) ToInferenceContainerPropertiesPtrOutputWithContext(ctx context.Context) InferenceContainerPropertiesPtrOutput {
	return o
}

func (o InferenceContainerPropertiesPtrOutput) Elem() InferenceContainerPropertiesOutput {
	return o.ApplyT(func(v *InferenceContainerProperties) InferenceContainerProperties {
		if v != nil {
			return *v
		}
		var ret InferenceContainerProperties
		return ret
	}).(InferenceContainerPropertiesOutput)
}

// The route to check the liveness of the inference server container.
func (o InferenceContainerPropertiesPtrOutput) LivenessRoute() RoutePtrOutput {
	return o.ApplyT(func(v *InferenceContainerProperties) *Route {
		if v == nil {
			return nil
		}
		return v.LivenessRoute
	}).(RoutePtrOutput)
}

// The route to check the readiness of the inference server container.
func (o InferenceContainerPropertiesPtrOutput) ReadinessRoute() RoutePtrOutput {
	return o.ApplyT(func(v *InferenceContainerProperties) *Route {
		if v == nil {
			return nil
		}
		return v.ReadinessRoute
	}).(RoutePtrOutput)
}

// The port to send the scoring requests to, within the inference server container.
func (o InferenceContainerPropertiesPtrOutput) ScoringRoute() RoutePtrOutput {
	return o.ApplyT(func(v *InferenceContainerProperties) *Route {
		if v == nil {
			return nil
		}
		return v.ScoringRoute
	}).(RoutePtrOutput)
}

type InferenceContainerPropertiesResponse struct {
	// The route to check the liveness of the inference server container.
	LivenessRoute *RouteResponse `pulumi:"livenessRoute"`
	// The route to check the readiness of the inference server container.
	ReadinessRoute *RouteResponse `pulumi:"readinessRoute"`
	// The port to send the scoring requests to, within the inference server container.
	ScoringRoute *RouteResponse `pulumi:"scoringRoute"`
}

type InferenceContainerPropertiesResponseOutput struct{ *pulumi.OutputState }

func (InferenceContainerPropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InferenceContainerPropertiesResponse)(nil)).Elem()
}

func (o InferenceContainerPropertiesResponseOutput) ToInferenceContainerPropertiesResponseOutput() InferenceContainerPropertiesResponseOutput {
	return o
}

func (o InferenceContainerPropertiesResponseOutput) ToInferenceContainerPropertiesResponseOutputWithContext(ctx context.Context) InferenceContainerPropertiesResponseOutput {
	return o
}

// The route to check the liveness of the inference server container.
func (o InferenceContainerPropertiesResponseOutput) LivenessRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v InferenceContainerPropertiesResponse) *RouteResponse { return v.LivenessRoute }).(RouteResponsePtrOutput)
}

// The route to check the readiness of the inference server container.
func (o InferenceContainerPropertiesResponseOutput) ReadinessRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v InferenceContainerPropertiesResponse) *RouteResponse { return v.ReadinessRoute }).(RouteResponsePtrOutput)
}

// The port to send the scoring requests to, within the inference server container.
func (o InferenceContainerPropertiesResponseOutput) ScoringRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v InferenceContainerPropertiesResponse) *RouteResponse { return v.ScoringRoute }).(RouteResponsePtrOutput)
}

type InferenceContainerPropertiesResponsePtrOutput struct{ *pulumi.OutputState }

func (InferenceContainerPropertiesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InferenceContainerPropertiesResponse)(nil)).Elem()
}

func (o InferenceContainerPropertiesResponsePtrOutput) ToInferenceContainerPropertiesResponsePtrOutput() InferenceContainerPropertiesResponsePtrOutput {
	return o
}

func (o InferenceContainerPropertiesResponsePtrOutput) ToInferenceContainerPropertiesResponsePtrOutputWithContext(ctx context.Context) InferenceContainerPropertiesResponsePtrOutput {
	return o
}

func (o InferenceContainerPropertiesResponsePtrOutput) Elem() InferenceContainerPropertiesResponseOutput {
	return o.ApplyT(func(v *InferenceContainerPropertiesResponse) InferenceContainerPropertiesResponse {
		if v != nil {
			return *v
		}
		var ret InferenceContainerPropertiesResponse
		return ret
	}).(InferenceContainerPropertiesResponseOutput)
}

// The route to check the liveness of the inference server container.
func (o InferenceContainerPropertiesResponsePtrOutput) LivenessRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v *InferenceContainerPropertiesResponse) *RouteResponse {
		if v == nil {
			return nil
		}
		return v.LivenessRoute
	}).(RouteResponsePtrOutput)
}

// The route to check the readiness of the inference server container.
func (o InferenceContainerPropertiesResponsePtrOutput) ReadinessRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v *InferenceContainerPropertiesResponse) *RouteResponse {
		if v == nil {
			return nil
		}
		return v.ReadinessRoute
	}).(RouteResponsePtrOutput)
}

// The port to send the scoring requests to, within the inference server container.
func (o InferenceContainerPropertiesResponsePtrOutput) ScoringRoute() RouteResponsePtrOutput {
	return o.ApplyT(func(v *InferenceContainerPropertiesResponse) *RouteResponse {
		if v == nil {
			return nil
		}
		return v.ScoringRoute
	}).(RouteResponsePtrOutput)
}

// Instance type schema.
type InstanceTypeSchema struct {
	// Node Selector
	NodeSelector map[string]string `pulumi:"nodeSelector"`
	// Resource requests/limits for this instance type
	Resources *InstanceTypeSchemaResources `pulumi:"resources"`
}

// Resource requests/limits for this instance type
type InstanceTypeSchemaResources struct {
	// Resource limits for this instance type
	Limits map[string]string `pulumi:"limits"`
	// Resource requests for this instance type
	Requests map[string]string `pulumi:"requests"`
}

// Instance type schema.
type InstanceTypeSchemaResponse struct {
	// Node Selector
	NodeSelector map[string]string `pulumi:"nodeSelector"`
	// Resource requests/limits for this instance type
	Resources *InstanceTypeSchemaResponseResources `pulumi:"resources"`
}

// Resource requests/limits for this instance type
type InstanceTypeSchemaResponseResources struct {
	// Resource limits for this instance type
	Limits map[string]string `pulumi:"limits"`
	// Resource requests for this instance type
	Requests map[string]string `pulumi:"requests"`
}

// Intellectual Property details for a resource.
type IntellectualProperty struct {
	// Protection level of the Intellectual Property.
	ProtectionLevel *string `pulumi:"protectionLevel"`
	// [Required] Publisher of the Intellectual Property. Must be the same as Registry publisher name.
	Publisher string `pulumi:"publisher"`
}

// Defaults sets the appropriate defaults for IntellectualProperty
func (val *IntellectualProperty) Defaults() *IntellectualProperty {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ProtectionLevel == nil {
		protectionLevel_ := "All"
		tmp.ProtectionLevel = &protectionLevel_
	}
	return &tmp
}

// IntellectualPropertyInput is an input type that accepts IntellectualPropertyArgs and IntellectualPropertyOutput values.
// You can construct a concrete instance of `IntellectualPropertyInput` via:
//
//	IntellectualPropertyArgs{...}
type IntellectualPropertyInput interface {
	pulumi.Input

	ToIntellectualPropertyOutput() IntellectualPropertyOutput
	ToIntellectualPropertyOutputWithContext(context.Context) IntellectualPropertyOutput
}

// Intellectual Property details for a resource.
type IntellectualPropertyArgs struct {
	// Protection level of the Intellectual Property.
	ProtectionLevel pulumi.StringPtrInput `pulumi:"protectionLevel"`
	// [Required] Publisher of the Intellectual Property. Must be the same as Registry publisher name.
	Publisher pulumi.StringInput `pulumi:"publisher"`
}

// Defaults sets the appropriate defaults for IntellectualPropertyArgs
func (val *IntellectualPropertyArgs) Defaults() *IntellectualPropertyArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ProtectionLevel == nil {
		tmp.ProtectionLevel = pulumi.StringPtr("All")
	}
	return &tmp
}
func (IntellectualPropertyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IntellectualProperty)(nil)).Elem()
}

func (i IntellectualPropertyArgs) ToIntellectualPropertyOutput() IntellectualPropertyOutput {
	return i.ToIntellectualPropertyOutputWithContext(context.Background())
}

func (i IntellectualPropertyArgs) ToIntellectualPropertyOutputWithContext(ctx context.Context) IntellectualPropertyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntellectualPropertyOutput)
}

func (i IntellectualPropertyArgs) ToIntellectualPropertyPtrOutput() IntellectualPropertyPtrOutput {
	return i.ToIntellectualPropertyPtrOutputWithContext(context.Background())
}

func (i IntellectualPropertyArgs) ToIntellectualPropertyPtrOutputWithContext(ctx context.Context) IntellectualPropertyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntellectualPropertyOutput).ToIntellectualPropertyPtrOutputWithContext(ctx)
}

// IntellectualPropertyPtrInput is an input type that accepts IntellectualPropertyArgs, IntellectualPropertyPtr and IntellectualPropertyPtrOutput values.
// You can construct a concrete instance of `IntellectualPropertyPtrInput` via:
//
//	        IntellectualPropertyArgs{...}
//
//	or:
//
//	        nil
type IntellectualPropertyPtrInput interface {
	pulumi.Input

	ToIntellectualPropertyPtrOutput() IntellectualPropertyPtrOutput
	ToIntellectualPropertyPtrOutputWithContext(context.Context) IntellectualPropertyPtrOutput
}

type intellectualPropertyPtrType IntellectualPropertyArgs

func IntellectualPropertyPtr(v *IntellectualPropertyArgs) IntellectualPropertyPtrInput {
	return (*intellectualPropertyPtrType)(v)
}

func (*intellectualPropertyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IntellectualProperty)(nil)).Elem()
}

func (i *intellectualPropertyPtrType) ToIntellectualPropertyPtrOutput() IntellectualPropertyPtrOutput {
	return i.ToIntellectualPropertyPtrOutputWithContext(context.Background())
}

func (i *intellectualPropertyPtrType) ToIntellectualPropertyPtrOutputWithContext(ctx context.Context) IntellectualPropertyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntellectualPropertyPtrOutput)
}

// Intellectual Property details for a resource.
type IntellectualPropertyOutput struct{ *pulumi.OutputState }

func (IntellectualPropertyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IntellectualProperty)(nil)).Elem()
}

func (o IntellectualPropertyOutput) ToIntellectualPropertyOutput() IntellectualPropertyOutput {
	return o
}

func (o IntellectualPropertyOutput) ToIntellectualPropertyOutputWithContext(ctx context.Context) IntellectualPropertyOutput {
	return o
}

func (o IntellectualPropertyOutput) ToIntellectualPropertyPtrOutput() IntellectualPropertyPtrOutput {
	return o.ToIntellectualPropertyPtrOutputWithContext(context.Background())
}

func (o IntellectualPropertyOutput) ToIntellectualPropertyPtrOutputWithContext(ctx context.Context) IntellectualPropertyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IntellectualProperty) *IntellectualProperty {
		return &v
	}).(IntellectualPropertyPtrOutput)
}

// Protection level of the Intellectual Property.
func (o IntellectualPropertyOutput) ProtectionLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IntellectualProperty) *string { return v.ProtectionLevel }).(pulumi.StringPtrOutput)
}

// [Required] Publisher of the Intellectual Property. Must be the same as Registry publisher name.
func (o IntellectualPropertyOutput) Publisher() pulumi.StringOutput {
	return o.ApplyT(func(v IntellectualProperty) string { return v.Publisher }).(pulumi.StringOutput)
}

type IntellectualPropertyPtrOutput struct{ *pulumi.OutputState }

func (IntellectualPropertyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IntellectualProperty)(nil)).Elem()
}

func (o IntellectualPropertyPtrOutput) ToIntellectualPropertyPtrOutput() IntellectualPropertyPtrOutput {
	return o
}

func (o IntellectualPropertyPtrOutput) ToIntellectualPropertyPtrOutputWithContext(ctx context.Context) IntellectualPropertyPtrOutput {
	return o
}

func (o IntellectualPropertyPtrOutput) Elem() IntellectualPropertyOutput {
	return o.ApplyT(func(v *IntellectualProperty) IntellectualProperty {
		if v != nil {
			return *v
		}
		var ret IntellectualProperty
		return ret
	}).(IntellectualPropertyOutput)
}

// Protection level of the Intellectual Property.
func (o IntellectualPropertyPtrOutput) ProtectionLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IntellectualProperty) *string {
		if v == nil {
			return nil
		}
		return v.ProtectionLevel
	}).(pulumi.StringPtrOutput)
}

// [Required] Publisher of the Intellectual Property. Must be the same as Registry publisher name.
func (o IntellectualPropertyPtrOutput) Publisher() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IntellectualProperty) *string {
		if v == nil {
			return nil
		}
		return &v.Publisher
	}).(pulumi.StringPtrOutput)
}

// Intellectual Property details for a resource.
type IntellectualPropertyResponse struct {
	// Protection level of the Intellectual Property.
	ProtectionLevel *string `pulumi:"protectionLevel"`
	// [Required] Publisher of the Intellectual Property. Must be the same as Registry publisher name.
	Publisher string `pulumi:"publisher"`
}

// Defaults sets the appropriate defaults for IntellectualPropertyResponse
func (val *IntellectualPropertyResponse) Defaults() *IntellectualPropertyResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ProtectionLevel == nil {
		protectionLevel_ := "All"
		tmp.ProtectionLevel = &protectionLevel_
	}
	return &tmp
}

// Intellectual Property details for a resource.
type IntellectualPropertyResponseOutput struct{ *pulumi.OutputState }

func (IntellectualPropertyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IntellectualPropertyResponse)(nil)).Elem()
}

func (o IntellectualPropertyResponseOutput) ToIntellectualPropertyResponseOutput() IntellectualPropertyResponseOutput {
	return o
}

func (o IntellectualPropertyResponseOutput) ToIntellectualPropertyResponseOutputWithContext(ctx context.Context) IntellectualPropertyResponseOutput {
	return o
}

// Protection level of the Intellectual Property.
func (o IntellectualPropertyResponseOutput) ProtectionLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IntellectualPropertyResponse) *string { return v.ProtectionLevel }).(pulumi.StringPtrOutput)
}

// [Required] Publisher of the Intellectual Property. Must be the same as Registry publisher name.
func (o IntellectualPropertyResponseOutput) Publisher() pulumi.StringOutput {
	return o.ApplyT(func(v IntellectualPropertyResponse) string { return v.Publisher }).(pulumi.StringOutput)
}

type IntellectualPropertyResponsePtrOutput struct{ *pulumi.OutputState }

func (IntellectualPropertyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IntellectualPropertyResponse)(nil)).Elem()
}

func (o IntellectualPropertyResponsePtrOutput) ToIntellectualPropertyResponsePtrOutput() IntellectualPropertyResponsePtrOutput {
	return o
}

func (o IntellectualPropertyResponsePtrOutput) ToIntellectualPropertyResponsePtrOutputWithContext(ctx context.Context) IntellectualPropertyResponsePtrOutput {
	return o
}

func (o IntellectualPropertyResponsePtrOutput) Elem() IntellectualPropertyResponseOutput {
	return o.ApplyT(func(v *IntellectualPropertyResponse) IntellectualPropertyResponse {
		if v != nil {
			return *v
		}
		var ret IntellectualPropertyResponse
		return ret
	}).(IntellectualPropertyResponseOutput)
}

// Protection level of the Intellectual Property.
func (o IntellectualPropertyResponsePtrOutput) ProtectionLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IntellectualPropertyResponse) *string {
		if v == nil {
			return nil
		}
		return v.ProtectionLevel
	}).(pulumi.StringPtrOutput)
}

// [Required] Publisher of the Intellectual Property. Must be the same as Registry publisher name.
func (o IntellectualPropertyResponsePtrOutput) Publisher() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IntellectualPropertyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Publisher
	}).(pulumi.StringPtrOutput)
}

type JobResourceConfiguration struct {
	// Extra arguments to pass to the Docker run command. This would override any parameters that have already been set by the system, or in this section. This parameter is only supported for Azure ML compute types.
	DockerArgs *string `pulumi:"dockerArgs"`
	// Optional number of instances or nodes used by the compute target.
	InstanceCount *int `pulumi:"instanceCount"`
	// Optional type of VM used as supported by the compute target.
	InstanceType *string `pulumi:"instanceType"`
	// Locations where the job can run.
	Locations []string `pulumi:"locations"`
	// Optional max allowed number of instances or nodes to be used by the compute target.
	// For use with elastic training, currently supported by PyTorch distribution type only.
	MaxInstanceCount *int `pulumi:"maxInstanceCount"`
	// Additional properties bag.
	Properties map[string]interface{} `pulumi:"properties"`
	// Size of the docker container's shared memory block. This should be in the format of (number)(unit) where number as to be greater than 0 and the unit can be one of b(bytes), k(kilobytes), m(megabytes), or g(gigabytes).
	ShmSize *string `pulumi:"shmSize"`
}

// Defaults sets the appropriate defaults for JobResourceConfiguration
func (val *JobResourceConfiguration) Defaults() *JobResourceConfiguration {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.InstanceCount == nil {
		instanceCount_ := 1
		tmp.InstanceCount = &instanceCount_
	}
	if tmp.ShmSize == nil {
		shmSize_ := "2g"
		tmp.ShmSize = &shmSize_
	}
	return &tmp
}

type JobResourceConfigurationResponse struct {
	// Extra arguments to pass to the Docker run command. This would override any parameters that have already been set by the system, or in this section. This parameter is only supported for Azure ML compute types.
	DockerArgs *string `pulumi:"dockerArgs"`
	// Optional number of instances or nodes used by the compute target.
	InstanceCount *int `pulumi:"instanceCount"`
	// Optional type of VM used as supported by the compute target.
	InstanceType *string `pulumi:"instanceType"`
	// Locations where the job can run.
	Locations []string `pulumi:"locations"`
	// Optional max allowed number of instances or nodes to be used by the compute target.
	// For use with elastic training, currently supported by PyTorch distribution type only.
	MaxInstanceCount *int `pulumi:"maxInstanceCount"`
	// Additional properties bag.
	Properties map[string]interface{} `pulumi:"properties"`
	// Size of the docker container's shared memory block. This should be in the format of (number)(unit) where number as to be greater than 0 and the unit can be one of b(bytes), k(kilobytes), m(megabytes), or g(gigabytes).
	ShmSize *string `pulumi:"shmSize"`
}

// Defaults sets the appropriate defaults for JobResourceConfigurationResponse
func (val *JobResourceConfigurationResponse) Defaults() *JobResourceConfigurationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.InstanceCount == nil {
		instanceCount_ := 1
		tmp.InstanceCount = &instanceCount_
	}
	if tmp.ShmSize == nil {
		shmSize_ := "2g"
		tmp.ShmSize = &shmSize_
	}
	return &tmp
}

type JobScheduleAction struct {
	// Expected value is 'CreateJob'.
	ActionType string `pulumi:"actionType"`
	// [Required] Defines Schedule action definition details.
	JobBaseProperties interface{} `pulumi:"jobBaseProperties"`
}

type JobScheduleActionResponse struct {
	// Expected value is 'CreateJob'.
	ActionType string `pulumi:"actionType"`
	// [Required] Defines Schedule action definition details.
	JobBaseProperties interface{} `pulumi:"jobBaseProperties"`
}

// Job endpoint definition
type JobService struct {
	// Url for endpoint.
	Endpoint *string `pulumi:"endpoint"`
	// Endpoint type.
	JobServiceType *string `pulumi:"jobServiceType"`
	// Nodes that user would like to start the service on.
	// If Nodes is not set or set to null, the service will only be started on leader node.
	Nodes *AllNodes `pulumi:"nodes"`
	// Port for endpoint set by user.
	Port *int `pulumi:"port"`
	// Additional properties to set on the endpoint.
	Properties map[string]string `pulumi:"properties"`
}

// JobServiceInput is an input type that accepts JobServiceArgs and JobServiceOutput values.
// You can construct a concrete instance of `JobServiceInput` via:
//
//	JobServiceArgs{...}
type JobServiceInput interface {
	pulumi.Input

	ToJobServiceOutput() JobServiceOutput
	ToJobServiceOutputWithContext(context.Context) JobServiceOutput
}

// Job endpoint definition
type JobServiceArgs struct {
	// Url for endpoint.
	Endpoint pulumi.StringPtrInput `pulumi:"endpoint"`
	// Endpoint type.
	JobServiceType pulumi.StringPtrInput `pulumi:"jobServiceType"`
	// Nodes that user would like to start the service on.
	// If Nodes is not set or set to null, the service will only be started on leader node.
	Nodes AllNodesPtrInput `pulumi:"nodes"`
	// Port for endpoint set by user.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Additional properties to set on the endpoint.
	Properties pulumi.StringMapInput `pulumi:"properties"`
}

func (JobServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobService)(nil)).Elem()
}

func (i JobServiceArgs) ToJobServiceOutput() JobServiceOutput {
	return i.ToJobServiceOutputWithContext(context.Background())
}

func (i JobServiceArgs) ToJobServiceOutputWithContext(ctx context.Context) JobServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobServiceOutput)
}

// JobServiceMapInput is an input type that accepts JobServiceMap and JobServiceMapOutput values.
// You can construct a concrete instance of `JobServiceMapInput` via:
//
//	JobServiceMap{ "key": JobServiceArgs{...} }
type JobServiceMapInput interface {
	pulumi.Input

	ToJobServiceMapOutput() JobServiceMapOutput
	ToJobServiceMapOutputWithContext(context.Context) JobServiceMapOutput
}

type JobServiceMap map[string]JobServiceInput

func (JobServiceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]JobService)(nil)).Elem()
}

func (i JobServiceMap) ToJobServiceMapOutput() JobServiceMapOutput {
	return i.ToJobServiceMapOutputWithContext(context.Background())
}

func (i JobServiceMap) ToJobServiceMapOutputWithContext(ctx context.Context) JobServiceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobServiceMapOutput)
}

// Job endpoint definition
type JobServiceOutput struct{ *pulumi.OutputState }

func (JobServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobService)(nil)).Elem()
}

func (o JobServiceOutput) ToJobServiceOutput() JobServiceOutput {
	return o
}

func (o JobServiceOutput) ToJobServiceOutputWithContext(ctx context.Context) JobServiceOutput {
	return o
}

// Url for endpoint.
func (o JobServiceOutput) Endpoint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobService) *string { return v.Endpoint }).(pulumi.StringPtrOutput)
}

// Endpoint type.
func (o JobServiceOutput) JobServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobService) *string { return v.JobServiceType }).(pulumi.StringPtrOutput)
}

// Nodes that user would like to start the service on.
// If Nodes is not set or set to null, the service will only be started on leader node.
func (o JobServiceOutput) Nodes() AllNodesPtrOutput {
	return o.ApplyT(func(v JobService) *AllNodes { return v.Nodes }).(AllNodesPtrOutput)
}

// Port for endpoint set by user.
func (o JobServiceOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JobService) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Additional properties to set on the endpoint.
func (o JobServiceOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v JobService) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

type JobServiceMapOutput struct{ *pulumi.OutputState }

func (JobServiceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]JobService)(nil)).Elem()
}

func (o JobServiceMapOutput) ToJobServiceMapOutput() JobServiceMapOutput {
	return o
}

func (o JobServiceMapOutput) ToJobServiceMapOutputWithContext(ctx context.Context) JobServiceMapOutput {
	return o
}

func (o JobServiceMapOutput) MapIndex(k pulumi.StringInput) JobServiceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) JobService {
		return vs[0].(map[string]JobService)[vs[1].(string)]
	}).(JobServiceOutput)
}

// Job endpoint definition
type JobServiceResponse struct {
	// Url for endpoint.
	Endpoint *string `pulumi:"endpoint"`
	// Any error in the service.
	ErrorMessage string `pulumi:"errorMessage"`
	// Endpoint type.
	JobServiceType *string `pulumi:"jobServiceType"`
	// Nodes that user would like to start the service on.
	// If Nodes is not set or set to null, the service will only be started on leader node.
	Nodes *AllNodesResponse `pulumi:"nodes"`
	// Port for endpoint set by user.
	Port *int `pulumi:"port"`
	// Additional properties to set on the endpoint.
	Properties map[string]string `pulumi:"properties"`
	// Status of endpoint.
	Status string `pulumi:"status"`
}

// Job endpoint definition
type JobServiceResponseOutput struct{ *pulumi.OutputState }

func (JobServiceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobServiceResponse)(nil)).Elem()
}

func (o JobServiceResponseOutput) ToJobServiceResponseOutput() JobServiceResponseOutput {
	return o
}

func (o JobServiceResponseOutput) ToJobServiceResponseOutputWithContext(ctx context.Context) JobServiceResponseOutput {
	return o
}

// Url for endpoint.
func (o JobServiceResponseOutput) Endpoint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobServiceResponse) *string { return v.Endpoint }).(pulumi.StringPtrOutput)
}

// Any error in the service.
func (o JobServiceResponseOutput) ErrorMessage() pulumi.StringOutput {
	return o.ApplyT(func(v JobServiceResponse) string { return v.ErrorMessage }).(pulumi.StringOutput)
}

// Endpoint type.
func (o JobServiceResponseOutput) JobServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobServiceResponse) *string { return v.JobServiceType }).(pulumi.StringPtrOutput)
}

// Nodes that user would like to start the service on.
// If Nodes is not set or set to null, the service will only be started on leader node.
func (o JobServiceResponseOutput) Nodes() AllNodesResponsePtrOutput {
	return o.ApplyT(func(v JobServiceResponse) *AllNodesResponse { return v.Nodes }).(AllNodesResponsePtrOutput)
}

// Port for endpoint set by user.
func (o JobServiceResponseOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JobServiceResponse) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Additional properties to set on the endpoint.
func (o JobServiceResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v JobServiceResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Status of endpoint.
func (o JobServiceResponseOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v JobServiceResponse) string { return v.Status }).(pulumi.StringOutput)
}

type JobServiceResponseMapOutput struct{ *pulumi.OutputState }

func (JobServiceResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]JobServiceResponse)(nil)).Elem()
}

func (o JobServiceResponseMapOutput) ToJobServiceResponseMapOutput() JobServiceResponseMapOutput {
	return o
}

func (o JobServiceResponseMapOutput) ToJobServiceResponseMapOutputWithContext(ctx context.Context) JobServiceResponseMapOutput {
	return o
}

func (o JobServiceResponseMapOutput) MapIndex(k pulumi.StringInput) JobServiceResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) JobServiceResponse {
		return vs[0].(map[string]JobServiceResponse)[vs[1].(string)]
	}).(JobServiceResponseOutput)
}

type KerberosKeytabCredentials struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'KerberosKeytab'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] IP Address or DNS HostName.
	KerberosKdcAddress string `pulumi:"kerberosKdcAddress"`
	// [Required] Kerberos Username
	KerberosPrincipal string `pulumi:"kerberosPrincipal"`
	// [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
	KerberosRealm string `pulumi:"kerberosRealm"`
	// [Required] Keytab secrets.
	Secrets KerberosKeytabSecrets `pulumi:"secrets"`
}

type KerberosKeytabCredentialsResponse struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'KerberosKeytab'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] IP Address or DNS HostName.
	KerberosKdcAddress string `pulumi:"kerberosKdcAddress"`
	// [Required] Kerberos Username
	KerberosPrincipal string `pulumi:"kerberosPrincipal"`
	// [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
	KerberosRealm string `pulumi:"kerberosRealm"`
}

type KerberosKeytabSecrets struct {
	// Kerberos keytab secret.
	KerberosKeytab *string `pulumi:"kerberosKeytab"`
	// Enum to determine the datastore secrets type.
	// Expected value is 'KerberosKeytab'.
	SecretsType string `pulumi:"secretsType"`
}

type KerberosPasswordCredentials struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'KerberosPassword'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] IP Address or DNS HostName.
	KerberosKdcAddress string `pulumi:"kerberosKdcAddress"`
	// [Required] Kerberos Username
	KerberosPrincipal string `pulumi:"kerberosPrincipal"`
	// [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
	KerberosRealm string `pulumi:"kerberosRealm"`
	// [Required] Kerberos password secrets.
	Secrets KerberosPasswordSecrets `pulumi:"secrets"`
}

type KerberosPasswordCredentialsResponse struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'KerberosPassword'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] IP Address or DNS HostName.
	KerberosKdcAddress string `pulumi:"kerberosKdcAddress"`
	// [Required] Kerberos Username
	KerberosPrincipal string `pulumi:"kerberosPrincipal"`
	// [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
	KerberosRealm string `pulumi:"kerberosRealm"`
}

type KerberosPasswordSecrets struct {
	// Kerberos password secret.
	KerberosPassword *string `pulumi:"kerberosPassword"`
	// Enum to determine the datastore secrets type.
	// Expected value is 'KerberosPassword'.
	SecretsType string `pulumi:"secretsType"`
}

// Customer Key vault properties.
type KeyVaultProperties struct {
	// Currently, we support only SystemAssigned MSI.
	// We need this when we support UserAssignedIdentities
	IdentityClientId *string `pulumi:"identityClientId"`
	// KeyVault key identifier to encrypt the data
	KeyIdentifier string `pulumi:"keyIdentifier"`
	// KeyVault Arm Id that contains the data encryption key
	KeyVaultArmId string `pulumi:"keyVaultArmId"`
}

// KeyVaultPropertiesInput is an input type that accepts KeyVaultPropertiesArgs and KeyVaultPropertiesOutput values.
// You can construct a concrete instance of `KeyVaultPropertiesInput` via:
//
//	KeyVaultPropertiesArgs{...}
type KeyVaultPropertiesInput interface {
	pulumi.Input

	ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput
	ToKeyVaultPropertiesOutputWithContext(context.Context) KeyVaultPropertiesOutput
}

// Customer Key vault properties.
type KeyVaultPropertiesArgs struct {
	// Currently, we support only SystemAssigned MSI.
	// We need this when we support UserAssignedIdentities
	IdentityClientId pulumi.StringPtrInput `pulumi:"identityClientId"`
	// KeyVault key identifier to encrypt the data
	KeyIdentifier pulumi.StringInput `pulumi:"keyIdentifier"`
	// KeyVault Arm Id that contains the data encryption key
	KeyVaultArmId pulumi.StringInput `pulumi:"keyVaultArmId"`
}

func (KeyVaultPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultProperties)(nil)).Elem()
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput {
	return i.ToKeyVaultPropertiesOutputWithContext(context.Background())
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesOutputWithContext(ctx context.Context) KeyVaultPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesOutput)
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return i.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesOutput).ToKeyVaultPropertiesPtrOutputWithContext(ctx)
}

// KeyVaultPropertiesPtrInput is an input type that accepts KeyVaultPropertiesArgs, KeyVaultPropertiesPtr and KeyVaultPropertiesPtrOutput values.
// You can construct a concrete instance of `KeyVaultPropertiesPtrInput` via:
//
//	        KeyVaultPropertiesArgs{...}
//
//	or:
//
//	        nil
type KeyVaultPropertiesPtrInput interface {
	pulumi.Input

	ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput
	ToKeyVaultPropertiesPtrOutputWithContext(context.Context) KeyVaultPropertiesPtrOutput
}

type keyVaultPropertiesPtrType KeyVaultPropertiesArgs

func KeyVaultPropertiesPtr(v *KeyVaultPropertiesArgs) KeyVaultPropertiesPtrInput {
	return (*keyVaultPropertiesPtrType)(v)
}

func (*keyVaultPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultProperties)(nil)).Elem()
}

func (i *keyVaultPropertiesPtrType) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return i.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (i *keyVaultPropertiesPtrType) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesPtrOutput)
}

// Customer Key vault properties.
type KeyVaultPropertiesOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultProperties)(nil)).Elem()
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput {
	return o
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesOutputWithContext(ctx context.Context) KeyVaultPropertiesOutput {
	return o
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return o.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KeyVaultProperties) *KeyVaultProperties {
		return &v
	}).(KeyVaultPropertiesPtrOutput)
}

// Currently, we support only SystemAssigned MSI.
// We need this when we support UserAssignedIdentities
func (o KeyVaultPropertiesOutput) IdentityClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyVaultProperties) *string { return v.IdentityClientId }).(pulumi.StringPtrOutput)
}

// KeyVault key identifier to encrypt the data
func (o KeyVaultPropertiesOutput) KeyIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v KeyVaultProperties) string { return v.KeyIdentifier }).(pulumi.StringOutput)
}

// KeyVault Arm Id that contains the data encryption key
func (o KeyVaultPropertiesOutput) KeyVaultArmId() pulumi.StringOutput {
	return o.ApplyT(func(v KeyVaultProperties) string { return v.KeyVaultArmId }).(pulumi.StringOutput)
}

type KeyVaultPropertiesPtrOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultProperties)(nil)).Elem()
}

func (o KeyVaultPropertiesPtrOutput) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return o
}

func (o KeyVaultPropertiesPtrOutput) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return o
}

func (o KeyVaultPropertiesPtrOutput) Elem() KeyVaultPropertiesOutput {
	return o.ApplyT(func(v *KeyVaultProperties) KeyVaultProperties {
		if v != nil {
			return *v
		}
		var ret KeyVaultProperties
		return ret
	}).(KeyVaultPropertiesOutput)
}

// Currently, we support only SystemAssigned MSI.
// We need this when we support UserAssignedIdentities
func (o KeyVaultPropertiesPtrOutput) IdentityClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultProperties) *string {
		if v == nil {
			return nil
		}
		return v.IdentityClientId
	}).(pulumi.StringPtrOutput)
}

// KeyVault key identifier to encrypt the data
func (o KeyVaultPropertiesPtrOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultProperties) *string {
		if v == nil {
			return nil
		}
		return &v.KeyIdentifier
	}).(pulumi.StringPtrOutput)
}

// KeyVault Arm Id that contains the data encryption key
func (o KeyVaultPropertiesPtrOutput) KeyVaultArmId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultProperties) *string {
		if v == nil {
			return nil
		}
		return &v.KeyVaultArmId
	}).(pulumi.StringPtrOutput)
}

// Customer Key vault properties.
type KeyVaultPropertiesResponse struct {
	// Currently, we support only SystemAssigned MSI.
	// We need this when we support UserAssignedIdentities
	IdentityClientId *string `pulumi:"identityClientId"`
	// KeyVault key identifier to encrypt the data
	KeyIdentifier string `pulumi:"keyIdentifier"`
	// KeyVault Arm Id that contains the data encryption key
	KeyVaultArmId string `pulumi:"keyVaultArmId"`
}

// Customer Key vault properties.
type KeyVaultPropertiesResponseOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultPropertiesResponse)(nil)).Elem()
}

func (o KeyVaultPropertiesResponseOutput) ToKeyVaultPropertiesResponseOutput() KeyVaultPropertiesResponseOutput {
	return o
}

func (o KeyVaultPropertiesResponseOutput) ToKeyVaultPropertiesResponseOutputWithContext(ctx context.Context) KeyVaultPropertiesResponseOutput {
	return o
}

// Currently, we support only SystemAssigned MSI.
// We need this when we support UserAssignedIdentities
func (o KeyVaultPropertiesResponseOutput) IdentityClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyVaultPropertiesResponse) *string { return v.IdentityClientId }).(pulumi.StringPtrOutput)
}

// KeyVault key identifier to encrypt the data
func (o KeyVaultPropertiesResponseOutput) KeyIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v KeyVaultPropertiesResponse) string { return v.KeyIdentifier }).(pulumi.StringOutput)
}

// KeyVault Arm Id that contains the data encryption key
func (o KeyVaultPropertiesResponseOutput) KeyVaultArmId() pulumi.StringOutput {
	return o.ApplyT(func(v KeyVaultPropertiesResponse) string { return v.KeyVaultArmId }).(pulumi.StringOutput)
}

type KeyVaultPropertiesResponsePtrOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultPropertiesResponse)(nil)).Elem()
}

func (o KeyVaultPropertiesResponsePtrOutput) ToKeyVaultPropertiesResponsePtrOutput() KeyVaultPropertiesResponsePtrOutput {
	return o
}

func (o KeyVaultPropertiesResponsePtrOutput) ToKeyVaultPropertiesResponsePtrOutputWithContext(ctx context.Context) KeyVaultPropertiesResponsePtrOutput {
	return o
}

func (o KeyVaultPropertiesResponsePtrOutput) Elem() KeyVaultPropertiesResponseOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) KeyVaultPropertiesResponse {
		if v != nil {
			return *v
		}
		var ret KeyVaultPropertiesResponse
		return ret
	}).(KeyVaultPropertiesResponseOutput)
}

// Currently, we support only SystemAssigned MSI.
// We need this when we support UserAssignedIdentities
func (o KeyVaultPropertiesResponsePtrOutput) IdentityClientId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return v.IdentityClientId
	}).(pulumi.StringPtrOutput)
}

// KeyVault key identifier to encrypt the data
func (o KeyVaultPropertiesResponsePtrOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return &v.KeyIdentifier
	}).(pulumi.StringPtrOutput)
}

// KeyVault Arm Id that contains the data encryption key
func (o KeyVaultPropertiesResponsePtrOutput) KeyVaultArmId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return &v.KeyVaultArmId
	}).(pulumi.StringPtrOutput)
}

// A Machine Learning compute based on Kubernetes Compute.
type Kubernetes struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'Kubernetes'.
	ComputeType string `pulumi:"computeType"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Properties of Kubernetes
	Properties *KubernetesProperties `pulumi:"properties"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for Kubernetes
func (val *Kubernetes) Defaults() *Kubernetes {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// Properties specific to a KubernetesOnlineDeployment.
type KubernetesOnlineDeployment struct {
	// If true, enables Application Insights logging.
	AppInsightsEnabled *bool `pulumi:"appInsightsEnabled"`
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfiguration `pulumi:"codeConfiguration"`
	// The resource requirements for the container (cpu and memory).
	ContainerResourceRequirements *ContainerResourceRequirements `pulumi:"containerResourceRequirements"`
	// The mdc configuration, we disable mdc when it's null.
	DataCollector *DataCollector `pulumi:"dataCollector"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
	EgressPublicNetworkAccess *string `pulumi:"egressPublicNetworkAccess"`
	// Enum to determine endpoint compute type.
	// Expected value is 'Kubernetes'.
	EndpointComputeType string `pulumi:"endpointComputeType"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Compute instance type.
	InstanceType *string `pulumi:"instanceType"`
	// Liveness probe monitors the health of the container regularly.
	LivenessProbe *ProbeSettings `pulumi:"livenessProbe"`
	// The URI path to the model.
	Model *string `pulumi:"model"`
	// The path to mount the model in custom container.
	ModelMountPath *string `pulumi:"modelMountPath"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
	ReadinessProbe *ProbeSettings `pulumi:"readinessProbe"`
	// Request settings for the deployment.
	RequestSettings *OnlineRequestSettings `pulumi:"requestSettings"`
	// Scale settings for the deployment.
	// If it is null or not provided,
	// it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
	// and to DefaultScaleSettings for ManagedOnlineDeployment.
	ScaleSettings interface{} `pulumi:"scaleSettings"`
}

// Defaults sets the appropriate defaults for KubernetesOnlineDeployment
func (val *KubernetesOnlineDeployment) Defaults() *KubernetesOnlineDeployment {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AppInsightsEnabled == nil {
		appInsightsEnabled_ := false
		tmp.AppInsightsEnabled = &appInsightsEnabled_
	}
	tmp.DataCollector = tmp.DataCollector.Defaults()

	if tmp.EgressPublicNetworkAccess == nil {
		egressPublicNetworkAccess_ := "Enabled"
		tmp.EgressPublicNetworkAccess = &egressPublicNetworkAccess_
	}
	tmp.LivenessProbe = tmp.LivenessProbe.Defaults()

	tmp.ReadinessProbe = tmp.ReadinessProbe.Defaults()

	tmp.RequestSettings = tmp.RequestSettings.Defaults()

	return &tmp
}

// Properties specific to a KubernetesOnlineDeployment.
type KubernetesOnlineDeploymentResponse struct {
	// If true, enables Application Insights logging.
	AppInsightsEnabled *bool `pulumi:"appInsightsEnabled"`
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfigurationResponse `pulumi:"codeConfiguration"`
	// The resource requirements for the container (cpu and memory).
	ContainerResourceRequirements *ContainerResourceRequirementsResponse `pulumi:"containerResourceRequirements"`
	// The mdc configuration, we disable mdc when it's null.
	DataCollector *DataCollectorResponse `pulumi:"dataCollector"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
	EgressPublicNetworkAccess *string `pulumi:"egressPublicNetworkAccess"`
	// Enum to determine endpoint compute type.
	// Expected value is 'Kubernetes'.
	EndpointComputeType string `pulumi:"endpointComputeType"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Compute instance type.
	InstanceType *string `pulumi:"instanceType"`
	// Liveness probe monitors the health of the container regularly.
	LivenessProbe *ProbeSettingsResponse `pulumi:"livenessProbe"`
	// The URI path to the model.
	Model *string `pulumi:"model"`
	// The path to mount the model in custom container.
	ModelMountPath *string `pulumi:"modelMountPath"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the endpoint deployment.
	ProvisioningState string `pulumi:"provisioningState"`
	// Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
	ReadinessProbe *ProbeSettingsResponse `pulumi:"readinessProbe"`
	// Request settings for the deployment.
	RequestSettings *OnlineRequestSettingsResponse `pulumi:"requestSettings"`
	// Scale settings for the deployment.
	// If it is null or not provided,
	// it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
	// and to DefaultScaleSettings for ManagedOnlineDeployment.
	ScaleSettings interface{} `pulumi:"scaleSettings"`
}

// Defaults sets the appropriate defaults for KubernetesOnlineDeploymentResponse
func (val *KubernetesOnlineDeploymentResponse) Defaults() *KubernetesOnlineDeploymentResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AppInsightsEnabled == nil {
		appInsightsEnabled_ := false
		tmp.AppInsightsEnabled = &appInsightsEnabled_
	}
	tmp.DataCollector = tmp.DataCollector.Defaults()

	if tmp.EgressPublicNetworkAccess == nil {
		egressPublicNetworkAccess_ := "Enabled"
		tmp.EgressPublicNetworkAccess = &egressPublicNetworkAccess_
	}
	tmp.LivenessProbe = tmp.LivenessProbe.Defaults()

	tmp.ReadinessProbe = tmp.ReadinessProbe.Defaults()

	tmp.RequestSettings = tmp.RequestSettings.Defaults()

	return &tmp
}

// Kubernetes properties
type KubernetesProperties struct {
	// Default instance type
	DefaultInstanceType *string `pulumi:"defaultInstanceType"`
	// Extension instance release train.
	ExtensionInstanceReleaseTrain *string `pulumi:"extensionInstanceReleaseTrain"`
	// Extension principal-id.
	ExtensionPrincipalId *string `pulumi:"extensionPrincipalId"`
	// Instance Type Schema
	InstanceTypes map[string]InstanceTypeSchema `pulumi:"instanceTypes"`
	// Compute namespace
	Namespace *string `pulumi:"namespace"`
	// Relay connection string.
	RelayConnectionString *string `pulumi:"relayConnectionString"`
	// ServiceBus connection string.
	ServiceBusConnectionString *string `pulumi:"serviceBusConnectionString"`
	// VC name.
	VcName *string `pulumi:"vcName"`
}

// Defaults sets the appropriate defaults for KubernetesProperties
func (val *KubernetesProperties) Defaults() *KubernetesProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Namespace == nil {
		namespace_ := "default"
		tmp.Namespace = &namespace_
	}
	return &tmp
}

// Kubernetes properties
type KubernetesPropertiesResponse struct {
	// Default instance type
	DefaultInstanceType *string `pulumi:"defaultInstanceType"`
	// Extension instance release train.
	ExtensionInstanceReleaseTrain *string `pulumi:"extensionInstanceReleaseTrain"`
	// Extension principal-id.
	ExtensionPrincipalId *string `pulumi:"extensionPrincipalId"`
	// Instance Type Schema
	InstanceTypes map[string]InstanceTypeSchemaResponse `pulumi:"instanceTypes"`
	// Compute namespace
	Namespace *string `pulumi:"namespace"`
	// Relay connection string.
	RelayConnectionString *string `pulumi:"relayConnectionString"`
	// ServiceBus connection string.
	ServiceBusConnectionString *string `pulumi:"serviceBusConnectionString"`
	// VC name.
	VcName *string `pulumi:"vcName"`
}

// Defaults sets the appropriate defaults for KubernetesPropertiesResponse
func (val *KubernetesPropertiesResponse) Defaults() *KubernetesPropertiesResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Namespace == nil {
		namespace_ := "default"
		tmp.Namespace = &namespace_
	}
	return &tmp
}

// A Machine Learning compute based on Kubernetes Compute.
type KubernetesResponse struct {
	// Location for the underlying compute
	ComputeLocation *string `pulumi:"computeLocation"`
	// The type of compute
	// Expected value is 'Kubernetes'.
	ComputeType string `pulumi:"computeType"`
	// The time at which the compute was created.
	CreatedOn string `pulumi:"createdOn"`
	// The description of the Machine Learning compute.
	Description *string `pulumi:"description"`
	// Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `pulumi:"disableLocalAuth"`
	// Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute bool `pulumi:"isAttachedCompute"`
	// The time at which the compute was last modified.
	ModifiedOn string `pulumi:"modifiedOn"`
	// Properties of Kubernetes
	Properties *KubernetesPropertiesResponse `pulumi:"properties"`
	// Errors during provisioning
	ProvisioningErrors []ErrorResponseResponse `pulumi:"provisioningErrors"`
	// The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
	ProvisioningState string `pulumi:"provisioningState"`
	// ARM resource id of the underlying compute
	ResourceId *string `pulumi:"resourceId"`
}

// Defaults sets the appropriate defaults for KubernetesResponse
func (val *KubernetesResponse) Defaults() *KubernetesResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Properties = tmp.Properties.Defaults()

	return &tmp
}

// Label category definition
type LabelCategory struct {
	// Dictionary of label classes in this category.
	Classes map[string]LabelClass `pulumi:"classes"`
	// Display name of the label category.
	DisplayName *string `pulumi:"displayName"`
	// Indicates whether it is allowed to select multiple classes in this category.
	MultiSelect *string `pulumi:"multiSelect"`
}

// Defaults sets the appropriate defaults for LabelCategory
func (val *LabelCategory) Defaults() *LabelCategory {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MultiSelect == nil {
		multiSelect_ := "Disabled"
		tmp.MultiSelect = &multiSelect_
	}
	return &tmp
}

// LabelCategoryInput is an input type that accepts LabelCategoryArgs and LabelCategoryOutput values.
// You can construct a concrete instance of `LabelCategoryInput` via:
//
//	LabelCategoryArgs{...}
type LabelCategoryInput interface {
	pulumi.Input

	ToLabelCategoryOutput() LabelCategoryOutput
	ToLabelCategoryOutputWithContext(context.Context) LabelCategoryOutput
}

// Label category definition
type LabelCategoryArgs struct {
	// Dictionary of label classes in this category.
	Classes LabelClassMapInput `pulumi:"classes"`
	// Display name of the label category.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// Indicates whether it is allowed to select multiple classes in this category.
	MultiSelect pulumi.StringPtrInput `pulumi:"multiSelect"`
}

// Defaults sets the appropriate defaults for LabelCategoryArgs
func (val *LabelCategoryArgs) Defaults() *LabelCategoryArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MultiSelect == nil {
		tmp.MultiSelect = pulumi.StringPtr("Disabled")
	}
	return &tmp
}
func (LabelCategoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelCategory)(nil)).Elem()
}

func (i LabelCategoryArgs) ToLabelCategoryOutput() LabelCategoryOutput {
	return i.ToLabelCategoryOutputWithContext(context.Background())
}

func (i LabelCategoryArgs) ToLabelCategoryOutputWithContext(ctx context.Context) LabelCategoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelCategoryOutput)
}

// LabelCategoryMapInput is an input type that accepts LabelCategoryMap and LabelCategoryMapOutput values.
// You can construct a concrete instance of `LabelCategoryMapInput` via:
//
//	LabelCategoryMap{ "key": LabelCategoryArgs{...} }
type LabelCategoryMapInput interface {
	pulumi.Input

	ToLabelCategoryMapOutput() LabelCategoryMapOutput
	ToLabelCategoryMapOutputWithContext(context.Context) LabelCategoryMapOutput
}

type LabelCategoryMap map[string]LabelCategoryInput

func (LabelCategoryMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]LabelCategory)(nil)).Elem()
}

func (i LabelCategoryMap) ToLabelCategoryMapOutput() LabelCategoryMapOutput {
	return i.ToLabelCategoryMapOutputWithContext(context.Background())
}

func (i LabelCategoryMap) ToLabelCategoryMapOutputWithContext(ctx context.Context) LabelCategoryMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelCategoryMapOutput)
}

// Label category definition
type LabelCategoryOutput struct{ *pulumi.OutputState }

func (LabelCategoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelCategory)(nil)).Elem()
}

func (o LabelCategoryOutput) ToLabelCategoryOutput() LabelCategoryOutput {
	return o
}

func (o LabelCategoryOutput) ToLabelCategoryOutputWithContext(ctx context.Context) LabelCategoryOutput {
	return o
}

// Dictionary of label classes in this category.
func (o LabelCategoryOutput) Classes() LabelClassMapOutput {
	return o.ApplyT(func(v LabelCategory) map[string]LabelClass { return v.Classes }).(LabelClassMapOutput)
}

// Display name of the label category.
func (o LabelCategoryOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelCategory) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Indicates whether it is allowed to select multiple classes in this category.
func (o LabelCategoryOutput) MultiSelect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelCategory) *string { return v.MultiSelect }).(pulumi.StringPtrOutput)
}

type LabelCategoryMapOutput struct{ *pulumi.OutputState }

func (LabelCategoryMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]LabelCategory)(nil)).Elem()
}

func (o LabelCategoryMapOutput) ToLabelCategoryMapOutput() LabelCategoryMapOutput {
	return o
}

func (o LabelCategoryMapOutput) ToLabelCategoryMapOutputWithContext(ctx context.Context) LabelCategoryMapOutput {
	return o
}

func (o LabelCategoryMapOutput) MapIndex(k pulumi.StringInput) LabelCategoryOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) LabelCategory {
		return vs[0].(map[string]LabelCategory)[vs[1].(string)]
	}).(LabelCategoryOutput)
}

// Label category definition
type LabelCategoryResponse struct {
	// Dictionary of label classes in this category.
	Classes map[string]LabelClassResponse `pulumi:"classes"`
	// Display name of the label category.
	DisplayName *string `pulumi:"displayName"`
	// Indicates whether it is allowed to select multiple classes in this category.
	MultiSelect *string `pulumi:"multiSelect"`
}

// Defaults sets the appropriate defaults for LabelCategoryResponse
func (val *LabelCategoryResponse) Defaults() *LabelCategoryResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MultiSelect == nil {
		multiSelect_ := "Disabled"
		tmp.MultiSelect = &multiSelect_
	}
	return &tmp
}

// Label category definition
type LabelCategoryResponseOutput struct{ *pulumi.OutputState }

func (LabelCategoryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelCategoryResponse)(nil)).Elem()
}

func (o LabelCategoryResponseOutput) ToLabelCategoryResponseOutput() LabelCategoryResponseOutput {
	return o
}

func (o LabelCategoryResponseOutput) ToLabelCategoryResponseOutputWithContext(ctx context.Context) LabelCategoryResponseOutput {
	return o
}

// Dictionary of label classes in this category.
func (o LabelCategoryResponseOutput) Classes() LabelClassResponseMapOutput {
	return o.ApplyT(func(v LabelCategoryResponse) map[string]LabelClassResponse { return v.Classes }).(LabelClassResponseMapOutput)
}

// Display name of the label category.
func (o LabelCategoryResponseOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelCategoryResponse) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Indicates whether it is allowed to select multiple classes in this category.
func (o LabelCategoryResponseOutput) MultiSelect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelCategoryResponse) *string { return v.MultiSelect }).(pulumi.StringPtrOutput)
}

type LabelCategoryResponseMapOutput struct{ *pulumi.OutputState }

func (LabelCategoryResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]LabelCategoryResponse)(nil)).Elem()
}

func (o LabelCategoryResponseMapOutput) ToLabelCategoryResponseMapOutput() LabelCategoryResponseMapOutput {
	return o
}

func (o LabelCategoryResponseMapOutput) ToLabelCategoryResponseMapOutputWithContext(ctx context.Context) LabelCategoryResponseMapOutput {
	return o
}

func (o LabelCategoryResponseMapOutput) MapIndex(k pulumi.StringInput) LabelCategoryResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) LabelCategoryResponse {
		return vs[0].(map[string]LabelCategoryResponse)[vs[1].(string)]
	}).(LabelCategoryResponseOutput)
}

// Label class definition
type LabelClass struct {
	// Display name of the label class.
	DisplayName *string `pulumi:"displayName"`
	// Dictionary of subclasses of the label class.
	Subclasses map[string]LabelClass `pulumi:"subclasses"`
}

// LabelClassInput is an input type that accepts LabelClassArgs and LabelClassOutput values.
// You can construct a concrete instance of `LabelClassInput` via:
//
//	LabelClassArgs{...}
type LabelClassInput interface {
	pulumi.Input

	ToLabelClassOutput() LabelClassOutput
	ToLabelClassOutputWithContext(context.Context) LabelClassOutput
}

// Label class definition
type LabelClassArgs struct {
	// Display name of the label class.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// Dictionary of subclasses of the label class.
	Subclasses LabelClassMapInput `pulumi:"subclasses"`
}

func (LabelClassArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelClass)(nil)).Elem()
}

func (i LabelClassArgs) ToLabelClassOutput() LabelClassOutput {
	return i.ToLabelClassOutputWithContext(context.Background())
}

func (i LabelClassArgs) ToLabelClassOutputWithContext(ctx context.Context) LabelClassOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelClassOutput)
}

// LabelClassMapInput is an input type that accepts LabelClassMap and LabelClassMapOutput values.
// You can construct a concrete instance of `LabelClassMapInput` via:
//
//	LabelClassMap{ "key": LabelClassArgs{...} }
type LabelClassMapInput interface {
	pulumi.Input

	ToLabelClassMapOutput() LabelClassMapOutput
	ToLabelClassMapOutputWithContext(context.Context) LabelClassMapOutput
}

type LabelClassMap map[string]LabelClassInput

func (LabelClassMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]LabelClass)(nil)).Elem()
}

func (i LabelClassMap) ToLabelClassMapOutput() LabelClassMapOutput {
	return i.ToLabelClassMapOutputWithContext(context.Background())
}

func (i LabelClassMap) ToLabelClassMapOutputWithContext(ctx context.Context) LabelClassMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelClassMapOutput)
}

// Label class definition
type LabelClassOutput struct{ *pulumi.OutputState }

func (LabelClassOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelClass)(nil)).Elem()
}

func (o LabelClassOutput) ToLabelClassOutput() LabelClassOutput {
	return o
}

func (o LabelClassOutput) ToLabelClassOutputWithContext(ctx context.Context) LabelClassOutput {
	return o
}

// Display name of the label class.
func (o LabelClassOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelClass) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Dictionary of subclasses of the label class.
func (o LabelClassOutput) Subclasses() LabelClassMapOutput {
	return o.ApplyT(func(v LabelClass) map[string]LabelClass { return v.Subclasses }).(LabelClassMapOutput)
}

type LabelClassMapOutput struct{ *pulumi.OutputState }

func (LabelClassMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]LabelClass)(nil)).Elem()
}

func (o LabelClassMapOutput) ToLabelClassMapOutput() LabelClassMapOutput {
	return o
}

func (o LabelClassMapOutput) ToLabelClassMapOutputWithContext(ctx context.Context) LabelClassMapOutput {
	return o
}

func (o LabelClassMapOutput) MapIndex(k pulumi.StringInput) LabelClassOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) LabelClass {
		return vs[0].(map[string]LabelClass)[vs[1].(string)]
	}).(LabelClassOutput)
}

// Label class definition
type LabelClassResponse struct {
	// Display name of the label class.
	DisplayName *string `pulumi:"displayName"`
	// Dictionary of subclasses of the label class.
	Subclasses map[string]LabelClassResponse `pulumi:"subclasses"`
}

// Label class definition
type LabelClassResponseOutput struct{ *pulumi.OutputState }

func (LabelClassResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelClassResponse)(nil)).Elem()
}

func (o LabelClassResponseOutput) ToLabelClassResponseOutput() LabelClassResponseOutput {
	return o
}

func (o LabelClassResponseOutput) ToLabelClassResponseOutputWithContext(ctx context.Context) LabelClassResponseOutput {
	return o
}

// Display name of the label class.
func (o LabelClassResponseOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelClassResponse) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Dictionary of subclasses of the label class.
func (o LabelClassResponseOutput) Subclasses() LabelClassResponseMapOutput {
	return o.ApplyT(func(v LabelClassResponse) map[string]LabelClassResponse { return v.Subclasses }).(LabelClassResponseMapOutput)
}

type LabelClassResponseMapOutput struct{ *pulumi.OutputState }

func (LabelClassResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]LabelClassResponse)(nil)).Elem()
}

func (o LabelClassResponseMapOutput) ToLabelClassResponseMapOutput() LabelClassResponseMapOutput {
	return o
}

func (o LabelClassResponseMapOutput) ToLabelClassResponseMapOutputWithContext(ctx context.Context) LabelClassResponseMapOutput {
	return o
}

func (o LabelClassResponseMapOutput) MapIndex(k pulumi.StringInput) LabelClassResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) LabelClassResponse {
		return vs[0].(map[string]LabelClassResponse)[vs[1].(string)]
	}).(LabelClassResponseOutput)
}

// Labeling data configuration definition
type LabelingDataConfiguration struct {
	// Resource Id of the data asset to perform labeling.
	DataId *string `pulumi:"dataId"`
	// Indicates whether to enable incremental data refresh.
	IncrementalDataRefresh *string `pulumi:"incrementalDataRefresh"`
}

// Defaults sets the appropriate defaults for LabelingDataConfiguration
func (val *LabelingDataConfiguration) Defaults() *LabelingDataConfiguration {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IncrementalDataRefresh == nil {
		incrementalDataRefresh_ := "Disabled"
		tmp.IncrementalDataRefresh = &incrementalDataRefresh_
	}
	return &tmp
}

// LabelingDataConfigurationInput is an input type that accepts LabelingDataConfigurationArgs and LabelingDataConfigurationOutput values.
// You can construct a concrete instance of `LabelingDataConfigurationInput` via:
//
//	LabelingDataConfigurationArgs{...}
type LabelingDataConfigurationInput interface {
	pulumi.Input

	ToLabelingDataConfigurationOutput() LabelingDataConfigurationOutput
	ToLabelingDataConfigurationOutputWithContext(context.Context) LabelingDataConfigurationOutput
}

// Labeling data configuration definition
type LabelingDataConfigurationArgs struct {
	// Resource Id of the data asset to perform labeling.
	DataId pulumi.StringPtrInput `pulumi:"dataId"`
	// Indicates whether to enable incremental data refresh.
	IncrementalDataRefresh pulumi.StringPtrInput `pulumi:"incrementalDataRefresh"`
}

// Defaults sets the appropriate defaults for LabelingDataConfigurationArgs
func (val *LabelingDataConfigurationArgs) Defaults() *LabelingDataConfigurationArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IncrementalDataRefresh == nil {
		tmp.IncrementalDataRefresh = pulumi.StringPtr("Disabled")
	}
	return &tmp
}
func (LabelingDataConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelingDataConfiguration)(nil)).Elem()
}

func (i LabelingDataConfigurationArgs) ToLabelingDataConfigurationOutput() LabelingDataConfigurationOutput {
	return i.ToLabelingDataConfigurationOutputWithContext(context.Background())
}

func (i LabelingDataConfigurationArgs) ToLabelingDataConfigurationOutputWithContext(ctx context.Context) LabelingDataConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelingDataConfigurationOutput)
}

func (i LabelingDataConfigurationArgs) ToLabelingDataConfigurationPtrOutput() LabelingDataConfigurationPtrOutput {
	return i.ToLabelingDataConfigurationPtrOutputWithContext(context.Background())
}

func (i LabelingDataConfigurationArgs) ToLabelingDataConfigurationPtrOutputWithContext(ctx context.Context) LabelingDataConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelingDataConfigurationOutput).ToLabelingDataConfigurationPtrOutputWithContext(ctx)
}

// LabelingDataConfigurationPtrInput is an input type that accepts LabelingDataConfigurationArgs, LabelingDataConfigurationPtr and LabelingDataConfigurationPtrOutput values.
// You can construct a concrete instance of `LabelingDataConfigurationPtrInput` via:
//
//	        LabelingDataConfigurationArgs{...}
//
//	or:
//
//	        nil
type LabelingDataConfigurationPtrInput interface {
	pulumi.Input

	ToLabelingDataConfigurationPtrOutput() LabelingDataConfigurationPtrOutput
	ToLabelingDataConfigurationPtrOutputWithContext(context.Context) LabelingDataConfigurationPtrOutput
}

type labelingDataConfigurationPtrType LabelingDataConfigurationArgs

func LabelingDataConfigurationPtr(v *LabelingDataConfigurationArgs) LabelingDataConfigurationPtrInput {
	return (*labelingDataConfigurationPtrType)(v)
}

func (*labelingDataConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LabelingDataConfiguration)(nil)).Elem()
}

func (i *labelingDataConfigurationPtrType) ToLabelingDataConfigurationPtrOutput() LabelingDataConfigurationPtrOutput {
	return i.ToLabelingDataConfigurationPtrOutputWithContext(context.Background())
}

func (i *labelingDataConfigurationPtrType) ToLabelingDataConfigurationPtrOutputWithContext(ctx context.Context) LabelingDataConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelingDataConfigurationPtrOutput)
}

// Labeling data configuration definition
type LabelingDataConfigurationOutput struct{ *pulumi.OutputState }

func (LabelingDataConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelingDataConfiguration)(nil)).Elem()
}

func (o LabelingDataConfigurationOutput) ToLabelingDataConfigurationOutput() LabelingDataConfigurationOutput {
	return o
}

func (o LabelingDataConfigurationOutput) ToLabelingDataConfigurationOutputWithContext(ctx context.Context) LabelingDataConfigurationOutput {
	return o
}

func (o LabelingDataConfigurationOutput) ToLabelingDataConfigurationPtrOutput() LabelingDataConfigurationPtrOutput {
	return o.ToLabelingDataConfigurationPtrOutputWithContext(context.Background())
}

func (o LabelingDataConfigurationOutput) ToLabelingDataConfigurationPtrOutputWithContext(ctx context.Context) LabelingDataConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LabelingDataConfiguration) *LabelingDataConfiguration {
		return &v
	}).(LabelingDataConfigurationPtrOutput)
}

// Resource Id of the data asset to perform labeling.
func (o LabelingDataConfigurationOutput) DataId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingDataConfiguration) *string { return v.DataId }).(pulumi.StringPtrOutput)
}

// Indicates whether to enable incremental data refresh.
func (o LabelingDataConfigurationOutput) IncrementalDataRefresh() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingDataConfiguration) *string { return v.IncrementalDataRefresh }).(pulumi.StringPtrOutput)
}

type LabelingDataConfigurationPtrOutput struct{ *pulumi.OutputState }

func (LabelingDataConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LabelingDataConfiguration)(nil)).Elem()
}

func (o LabelingDataConfigurationPtrOutput) ToLabelingDataConfigurationPtrOutput() LabelingDataConfigurationPtrOutput {
	return o
}

func (o LabelingDataConfigurationPtrOutput) ToLabelingDataConfigurationPtrOutputWithContext(ctx context.Context) LabelingDataConfigurationPtrOutput {
	return o
}

func (o LabelingDataConfigurationPtrOutput) Elem() LabelingDataConfigurationOutput {
	return o.ApplyT(func(v *LabelingDataConfiguration) LabelingDataConfiguration {
		if v != nil {
			return *v
		}
		var ret LabelingDataConfiguration
		return ret
	}).(LabelingDataConfigurationOutput)
}

// Resource Id of the data asset to perform labeling.
func (o LabelingDataConfigurationPtrOutput) DataId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LabelingDataConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.DataId
	}).(pulumi.StringPtrOutput)
}

// Indicates whether to enable incremental data refresh.
func (o LabelingDataConfigurationPtrOutput) IncrementalDataRefresh() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LabelingDataConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.IncrementalDataRefresh
	}).(pulumi.StringPtrOutput)
}

// Labeling data configuration definition
type LabelingDataConfigurationResponse struct {
	// Resource Id of the data asset to perform labeling.
	DataId *string `pulumi:"dataId"`
	// Indicates whether to enable incremental data refresh.
	IncrementalDataRefresh *string `pulumi:"incrementalDataRefresh"`
}

// Defaults sets the appropriate defaults for LabelingDataConfigurationResponse
func (val *LabelingDataConfigurationResponse) Defaults() *LabelingDataConfigurationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IncrementalDataRefresh == nil {
		incrementalDataRefresh_ := "Disabled"
		tmp.IncrementalDataRefresh = &incrementalDataRefresh_
	}
	return &tmp
}

// Labeling data configuration definition
type LabelingDataConfigurationResponseOutput struct{ *pulumi.OutputState }

func (LabelingDataConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelingDataConfigurationResponse)(nil)).Elem()
}

func (o LabelingDataConfigurationResponseOutput) ToLabelingDataConfigurationResponseOutput() LabelingDataConfigurationResponseOutput {
	return o
}

func (o LabelingDataConfigurationResponseOutput) ToLabelingDataConfigurationResponseOutputWithContext(ctx context.Context) LabelingDataConfigurationResponseOutput {
	return o
}

// Resource Id of the data asset to perform labeling.
func (o LabelingDataConfigurationResponseOutput) DataId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingDataConfigurationResponse) *string { return v.DataId }).(pulumi.StringPtrOutput)
}

// Indicates whether to enable incremental data refresh.
func (o LabelingDataConfigurationResponseOutput) IncrementalDataRefresh() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingDataConfigurationResponse) *string { return v.IncrementalDataRefresh }).(pulumi.StringPtrOutput)
}

type LabelingDataConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (LabelingDataConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LabelingDataConfigurationResponse)(nil)).Elem()
}

func (o LabelingDataConfigurationResponsePtrOutput) ToLabelingDataConfigurationResponsePtrOutput() LabelingDataConfigurationResponsePtrOutput {
	return o
}

func (o LabelingDataConfigurationResponsePtrOutput) ToLabelingDataConfigurationResponsePtrOutputWithContext(ctx context.Context) LabelingDataConfigurationResponsePtrOutput {
	return o
}

func (o LabelingDataConfigurationResponsePtrOutput) Elem() LabelingDataConfigurationResponseOutput {
	return o.ApplyT(func(v *LabelingDataConfigurationResponse) LabelingDataConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret LabelingDataConfigurationResponse
		return ret
	}).(LabelingDataConfigurationResponseOutput)
}

// Resource Id of the data asset to perform labeling.
func (o LabelingDataConfigurationResponsePtrOutput) DataId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LabelingDataConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.DataId
	}).(pulumi.StringPtrOutput)
}

// Indicates whether to enable incremental data refresh.
func (o LabelingDataConfigurationResponsePtrOutput) IncrementalDataRefresh() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LabelingDataConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.IncrementalDataRefresh
	}).(pulumi.StringPtrOutput)
}

// Labeling job definition
type LabelingJobType struct {
	// ARM resource ID of the component resource.
	ComponentId *string `pulumi:"componentId"`
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// Configuration of data used in the job.
	DataConfiguration *LabelingDataConfiguration `pulumi:"dataConfiguration"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Labeling instructions of the job.
	JobInstructions *LabelingJobInstructions `pulumi:"jobInstructions"`
	// Enum to determine the type of job.
	// Expected value is 'Labeling'.
	JobType string `pulumi:"jobType"`
	// Label categories of the job.
	LabelCategories map[string]LabelCategory `pulumi:"labelCategories"`
	// Media type specific properties in the job.
	LabelingJobMediaProperties interface{} `pulumi:"labelingJobMediaProperties"`
	// Configuration of MLAssist feature in the job.
	MlAssistConfiguration interface{} `pulumi:"mlAssistConfiguration"`
	// Notification setting for the job
	NotificationSetting *NotificationSetting `pulumi:"notificationSetting"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Configuration for secrets to be made available during runtime.
	SecretsConfiguration map[string]SecretConfiguration `pulumi:"secretsConfiguration"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobService `pulumi:"services"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for LabelingJobType
func (val *LabelingJobType) Defaults() *LabelingJobType {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataConfiguration = tmp.DataConfiguration.Defaults()

	if tmp.ExperimentName == nil {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// LabelingJobTypeInput is an input type that accepts LabelingJobTypeArgs and LabelingJobTypeOutput values.
// You can construct a concrete instance of `LabelingJobTypeInput` via:
//
//	LabelingJobTypeArgs{...}
type LabelingJobTypeInput interface {
	pulumi.Input

	ToLabelingJobTypeOutput() LabelingJobTypeOutput
	ToLabelingJobTypeOutputWithContext(context.Context) LabelingJobTypeOutput
}

// Labeling job definition
type LabelingJobTypeArgs struct {
	// ARM resource ID of the component resource.
	ComponentId pulumi.StringPtrInput `pulumi:"componentId"`
	// ARM resource ID of the compute resource.
	ComputeId pulumi.StringPtrInput `pulumi:"computeId"`
	// Configuration of data used in the job.
	DataConfiguration LabelingDataConfigurationPtrInput `pulumi:"dataConfiguration"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Display name of job.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName pulumi.StringPtrInput `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity pulumi.Input `pulumi:"identity"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// Labeling instructions of the job.
	JobInstructions LabelingJobInstructionsPtrInput `pulumi:"jobInstructions"`
	// Enum to determine the type of job.
	// Expected value is 'Labeling'.
	JobType pulumi.StringInput `pulumi:"jobType"`
	// Label categories of the job.
	LabelCategories LabelCategoryMapInput `pulumi:"labelCategories"`
	// Media type specific properties in the job.
	LabelingJobMediaProperties pulumi.Input `pulumi:"labelingJobMediaProperties"`
	// Configuration of MLAssist feature in the job.
	MlAssistConfiguration pulumi.Input `pulumi:"mlAssistConfiguration"`
	// Notification setting for the job
	NotificationSetting NotificationSettingPtrInput `pulumi:"notificationSetting"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Configuration for secrets to be made available during runtime.
	SecretsConfiguration SecretConfigurationMapInput `pulumi:"secretsConfiguration"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services JobServiceMapInput `pulumi:"services"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for LabelingJobTypeArgs
func (val *LabelingJobTypeArgs) Defaults() *LabelingJobTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	if tmp.ExperimentName == nil {
		tmp.ExperimentName = pulumi.StringPtr("Default")
	}
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (LabelingJobTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelingJobType)(nil)).Elem()
}

func (i LabelingJobTypeArgs) ToLabelingJobTypeOutput() LabelingJobTypeOutput {
	return i.ToLabelingJobTypeOutputWithContext(context.Background())
}

func (i LabelingJobTypeArgs) ToLabelingJobTypeOutputWithContext(ctx context.Context) LabelingJobTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelingJobTypeOutput)
}

// Labeling job definition
type LabelingJobTypeOutput struct{ *pulumi.OutputState }

func (LabelingJobTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelingJobType)(nil)).Elem()
}

func (o LabelingJobTypeOutput) ToLabelingJobTypeOutput() LabelingJobTypeOutput {
	return o
}

func (o LabelingJobTypeOutput) ToLabelingJobTypeOutputWithContext(ctx context.Context) LabelingJobTypeOutput {
	return o
}

// ARM resource ID of the component resource.
func (o LabelingJobTypeOutput) ComponentId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobType) *string { return v.ComponentId }).(pulumi.StringPtrOutput)
}

// ARM resource ID of the compute resource.
func (o LabelingJobTypeOutput) ComputeId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobType) *string { return v.ComputeId }).(pulumi.StringPtrOutput)
}

// Configuration of data used in the job.
func (o LabelingJobTypeOutput) DataConfiguration() LabelingDataConfigurationPtrOutput {
	return o.ApplyT(func(v LabelingJobType) *LabelingDataConfiguration { return v.DataConfiguration }).(LabelingDataConfigurationPtrOutput)
}

// The asset description text.
func (o LabelingJobTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Display name of job.
func (o LabelingJobTypeOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobType) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
func (o LabelingJobTypeOutput) ExperimentName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobType) *string { return v.ExperimentName }).(pulumi.StringPtrOutput)
}

// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
// Defaults to AmlToken if null.
func (o LabelingJobTypeOutput) Identity() pulumi.AnyOutput {
	return o.ApplyT(func(v LabelingJobType) interface{} { return v.Identity }).(pulumi.AnyOutput)
}

// Is the asset archived?
func (o LabelingJobTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LabelingJobType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// Labeling instructions of the job.
func (o LabelingJobTypeOutput) JobInstructions() LabelingJobInstructionsPtrOutput {
	return o.ApplyT(func(v LabelingJobType) *LabelingJobInstructions { return v.JobInstructions }).(LabelingJobInstructionsPtrOutput)
}

// Enum to determine the type of job.
// Expected value is 'Labeling'.
func (o LabelingJobTypeOutput) JobType() pulumi.StringOutput {
	return o.ApplyT(func(v LabelingJobType) string { return v.JobType }).(pulumi.StringOutput)
}

// Label categories of the job.
func (o LabelingJobTypeOutput) LabelCategories() LabelCategoryMapOutput {
	return o.ApplyT(func(v LabelingJobType) map[string]LabelCategory { return v.LabelCategories }).(LabelCategoryMapOutput)
}

// Media type specific properties in the job.
func (o LabelingJobTypeOutput) LabelingJobMediaProperties() pulumi.AnyOutput {
	return o.ApplyT(func(v LabelingJobType) interface{} { return v.LabelingJobMediaProperties }).(pulumi.AnyOutput)
}

// Configuration of MLAssist feature in the job.
func (o LabelingJobTypeOutput) MlAssistConfiguration() pulumi.AnyOutput {
	return o.ApplyT(func(v LabelingJobType) interface{} { return v.MlAssistConfiguration }).(pulumi.AnyOutput)
}

// Notification setting for the job
func (o LabelingJobTypeOutput) NotificationSetting() NotificationSettingPtrOutput {
	return o.ApplyT(func(v LabelingJobType) *NotificationSetting { return v.NotificationSetting }).(NotificationSettingPtrOutput)
}

// The asset property dictionary.
func (o LabelingJobTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v LabelingJobType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Configuration for secrets to be made available during runtime.
func (o LabelingJobTypeOutput) SecretsConfiguration() SecretConfigurationMapOutput {
	return o.ApplyT(func(v LabelingJobType) map[string]SecretConfiguration { return v.SecretsConfiguration }).(SecretConfigurationMapOutput)
}

// List of JobEndpoints.
// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
func (o LabelingJobTypeOutput) Services() JobServiceMapOutput {
	return o.ApplyT(func(v LabelingJobType) map[string]JobService { return v.Services }).(JobServiceMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o LabelingJobTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v LabelingJobType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Properties of a labeling job for image data
type LabelingJobImageProperties struct {
	// Annotation type of image labeling job.
	AnnotationType *string `pulumi:"annotationType"`
	// Media type of data asset.
	// Expected value is 'Image'.
	MediaType string `pulumi:"mediaType"`
}

// Defaults sets the appropriate defaults for LabelingJobImageProperties
func (val *LabelingJobImageProperties) Defaults() *LabelingJobImageProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AnnotationType == nil {
		annotationType_ := "Classification"
		tmp.AnnotationType = &annotationType_
	}
	return &tmp
}

// Properties of a labeling job for image data
type LabelingJobImagePropertiesResponse struct {
	// Annotation type of image labeling job.
	AnnotationType *string `pulumi:"annotationType"`
	// Media type of data asset.
	// Expected value is 'Image'.
	MediaType string `pulumi:"mediaType"`
}

// Defaults sets the appropriate defaults for LabelingJobImagePropertiesResponse
func (val *LabelingJobImagePropertiesResponse) Defaults() *LabelingJobImagePropertiesResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AnnotationType == nil {
		annotationType_ := "Classification"
		tmp.AnnotationType = &annotationType_
	}
	return &tmp
}

// Instructions for labeling job
type LabelingJobInstructions struct {
	// The link to a page with detailed labeling instructions for labelers.
	Uri *string `pulumi:"uri"`
}

// LabelingJobInstructionsInput is an input type that accepts LabelingJobInstructionsArgs and LabelingJobInstructionsOutput values.
// You can construct a concrete instance of `LabelingJobInstructionsInput` via:
//
//	LabelingJobInstructionsArgs{...}
type LabelingJobInstructionsInput interface {
	pulumi.Input

	ToLabelingJobInstructionsOutput() LabelingJobInstructionsOutput
	ToLabelingJobInstructionsOutputWithContext(context.Context) LabelingJobInstructionsOutput
}

// Instructions for labeling job
type LabelingJobInstructionsArgs struct {
	// The link to a page with detailed labeling instructions for labelers.
	Uri pulumi.StringPtrInput `pulumi:"uri"`
}

func (LabelingJobInstructionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelingJobInstructions)(nil)).Elem()
}

func (i LabelingJobInstructionsArgs) ToLabelingJobInstructionsOutput() LabelingJobInstructionsOutput {
	return i.ToLabelingJobInstructionsOutputWithContext(context.Background())
}

func (i LabelingJobInstructionsArgs) ToLabelingJobInstructionsOutputWithContext(ctx context.Context) LabelingJobInstructionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelingJobInstructionsOutput)
}

func (i LabelingJobInstructionsArgs) ToLabelingJobInstructionsPtrOutput() LabelingJobInstructionsPtrOutput {
	return i.ToLabelingJobInstructionsPtrOutputWithContext(context.Background())
}

func (i LabelingJobInstructionsArgs) ToLabelingJobInstructionsPtrOutputWithContext(ctx context.Context) LabelingJobInstructionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelingJobInstructionsOutput).ToLabelingJobInstructionsPtrOutputWithContext(ctx)
}

// LabelingJobInstructionsPtrInput is an input type that accepts LabelingJobInstructionsArgs, LabelingJobInstructionsPtr and LabelingJobInstructionsPtrOutput values.
// You can construct a concrete instance of `LabelingJobInstructionsPtrInput` via:
//
//	        LabelingJobInstructionsArgs{...}
//
//	or:
//
//	        nil
type LabelingJobInstructionsPtrInput interface {
	pulumi.Input

	ToLabelingJobInstructionsPtrOutput() LabelingJobInstructionsPtrOutput
	ToLabelingJobInstructionsPtrOutputWithContext(context.Context) LabelingJobInstructionsPtrOutput
}

type labelingJobInstructionsPtrType LabelingJobInstructionsArgs

func LabelingJobInstructionsPtr(v *LabelingJobInstructionsArgs) LabelingJobInstructionsPtrInput {
	return (*labelingJobInstructionsPtrType)(v)
}

func (*labelingJobInstructionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LabelingJobInstructions)(nil)).Elem()
}

func (i *labelingJobInstructionsPtrType) ToLabelingJobInstructionsPtrOutput() LabelingJobInstructionsPtrOutput {
	return i.ToLabelingJobInstructionsPtrOutputWithContext(context.Background())
}

func (i *labelingJobInstructionsPtrType) ToLabelingJobInstructionsPtrOutputWithContext(ctx context.Context) LabelingJobInstructionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelingJobInstructionsPtrOutput)
}

// Instructions for labeling job
type LabelingJobInstructionsOutput struct{ *pulumi.OutputState }

func (LabelingJobInstructionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelingJobInstructions)(nil)).Elem()
}

func (o LabelingJobInstructionsOutput) ToLabelingJobInstructionsOutput() LabelingJobInstructionsOutput {
	return o
}

func (o LabelingJobInstructionsOutput) ToLabelingJobInstructionsOutputWithContext(ctx context.Context) LabelingJobInstructionsOutput {
	return o
}

func (o LabelingJobInstructionsOutput) ToLabelingJobInstructionsPtrOutput() LabelingJobInstructionsPtrOutput {
	return o.ToLabelingJobInstructionsPtrOutputWithContext(context.Background())
}

func (o LabelingJobInstructionsOutput) ToLabelingJobInstructionsPtrOutputWithContext(ctx context.Context) LabelingJobInstructionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LabelingJobInstructions) *LabelingJobInstructions {
		return &v
	}).(LabelingJobInstructionsPtrOutput)
}

// The link to a page with detailed labeling instructions for labelers.
func (o LabelingJobInstructionsOutput) Uri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobInstructions) *string { return v.Uri }).(pulumi.StringPtrOutput)
}

type LabelingJobInstructionsPtrOutput struct{ *pulumi.OutputState }

func (LabelingJobInstructionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LabelingJobInstructions)(nil)).Elem()
}

func (o LabelingJobInstructionsPtrOutput) ToLabelingJobInstructionsPtrOutput() LabelingJobInstructionsPtrOutput {
	return o
}

func (o LabelingJobInstructionsPtrOutput) ToLabelingJobInstructionsPtrOutputWithContext(ctx context.Context) LabelingJobInstructionsPtrOutput {
	return o
}

func (o LabelingJobInstructionsPtrOutput) Elem() LabelingJobInstructionsOutput {
	return o.ApplyT(func(v *LabelingJobInstructions) LabelingJobInstructions {
		if v != nil {
			return *v
		}
		var ret LabelingJobInstructions
		return ret
	}).(LabelingJobInstructionsOutput)
}

// The link to a page with detailed labeling instructions for labelers.
func (o LabelingJobInstructionsPtrOutput) Uri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LabelingJobInstructions) *string {
		if v == nil {
			return nil
		}
		return v.Uri
	}).(pulumi.StringPtrOutput)
}

// Instructions for labeling job
type LabelingJobInstructionsResponse struct {
	// The link to a page with detailed labeling instructions for labelers.
	Uri *string `pulumi:"uri"`
}

// Instructions for labeling job
type LabelingJobInstructionsResponseOutput struct{ *pulumi.OutputState }

func (LabelingJobInstructionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelingJobInstructionsResponse)(nil)).Elem()
}

func (o LabelingJobInstructionsResponseOutput) ToLabelingJobInstructionsResponseOutput() LabelingJobInstructionsResponseOutput {
	return o
}

func (o LabelingJobInstructionsResponseOutput) ToLabelingJobInstructionsResponseOutputWithContext(ctx context.Context) LabelingJobInstructionsResponseOutput {
	return o
}

// The link to a page with detailed labeling instructions for labelers.
func (o LabelingJobInstructionsResponseOutput) Uri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobInstructionsResponse) *string { return v.Uri }).(pulumi.StringPtrOutput)
}

type LabelingJobInstructionsResponsePtrOutput struct{ *pulumi.OutputState }

func (LabelingJobInstructionsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LabelingJobInstructionsResponse)(nil)).Elem()
}

func (o LabelingJobInstructionsResponsePtrOutput) ToLabelingJobInstructionsResponsePtrOutput() LabelingJobInstructionsResponsePtrOutput {
	return o
}

func (o LabelingJobInstructionsResponsePtrOutput) ToLabelingJobInstructionsResponsePtrOutputWithContext(ctx context.Context) LabelingJobInstructionsResponsePtrOutput {
	return o
}

func (o LabelingJobInstructionsResponsePtrOutput) Elem() LabelingJobInstructionsResponseOutput {
	return o.ApplyT(func(v *LabelingJobInstructionsResponse) LabelingJobInstructionsResponse {
		if v != nil {
			return *v
		}
		var ret LabelingJobInstructionsResponse
		return ret
	}).(LabelingJobInstructionsResponseOutput)
}

// The link to a page with detailed labeling instructions for labelers.
func (o LabelingJobInstructionsResponsePtrOutput) Uri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LabelingJobInstructionsResponse) *string {
		if v == nil {
			return nil
		}
		return v.Uri
	}).(pulumi.StringPtrOutput)
}

// Labeling job definition
type LabelingJobResponse struct {
	// ARM resource ID of the component resource.
	ComponentId *string `pulumi:"componentId"`
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// Created time of the job in UTC timezone.
	CreatedDateTime string `pulumi:"createdDateTime"`
	// Configuration of data used in the job.
	DataConfiguration *LabelingDataConfigurationResponse `pulumi:"dataConfiguration"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Labeling instructions of the job.
	JobInstructions *LabelingJobInstructionsResponse `pulumi:"jobInstructions"`
	// Enum to determine the type of job.
	// Expected value is 'Labeling'.
	JobType string `pulumi:"jobType"`
	// Label categories of the job.
	LabelCategories map[string]LabelCategoryResponse `pulumi:"labelCategories"`
	// Media type specific properties in the job.
	LabelingJobMediaProperties interface{} `pulumi:"labelingJobMediaProperties"`
	// Configuration of MLAssist feature in the job.
	MlAssistConfiguration interface{} `pulumi:"mlAssistConfiguration"`
	// Notification setting for the job
	NotificationSetting *NotificationSettingResponse `pulumi:"notificationSetting"`
	// Progress metrics of the job.
	ProgressMetrics ProgressMetricsResponse `pulumi:"progressMetrics"`
	// Internal id of the job(Previously called project).
	ProjectId string `pulumi:"projectId"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Specifies the labeling job provisioning state.
	ProvisioningState string `pulumi:"provisioningState"`
	// Configuration for secrets to be made available during runtime.
	SecretsConfiguration map[string]SecretConfigurationResponse `pulumi:"secretsConfiguration"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobServiceResponse `pulumi:"services"`
	// Status of the job.
	Status string `pulumi:"status"`
	// Status messages of the job.
	StatusMessages []StatusMessageResponse `pulumi:"statusMessages"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for LabelingJobResponse
func (val *LabelingJobResponse) Defaults() *LabelingJobResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.DataConfiguration = tmp.DataConfiguration.Defaults()

	if tmp.ExperimentName == nil {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Labeling job definition
type LabelingJobResponseOutput struct{ *pulumi.OutputState }

func (LabelingJobResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelingJobResponse)(nil)).Elem()
}

func (o LabelingJobResponseOutput) ToLabelingJobResponseOutput() LabelingJobResponseOutput {
	return o
}

func (o LabelingJobResponseOutput) ToLabelingJobResponseOutputWithContext(ctx context.Context) LabelingJobResponseOutput {
	return o
}

// ARM resource ID of the component resource.
func (o LabelingJobResponseOutput) ComponentId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobResponse) *string { return v.ComponentId }).(pulumi.StringPtrOutput)
}

// ARM resource ID of the compute resource.
func (o LabelingJobResponseOutput) ComputeId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobResponse) *string { return v.ComputeId }).(pulumi.StringPtrOutput)
}

// Created time of the job in UTC timezone.
func (o LabelingJobResponseOutput) CreatedDateTime() pulumi.StringOutput {
	return o.ApplyT(func(v LabelingJobResponse) string { return v.CreatedDateTime }).(pulumi.StringOutput)
}

// Configuration of data used in the job.
func (o LabelingJobResponseOutput) DataConfiguration() LabelingDataConfigurationResponsePtrOutput {
	return o.ApplyT(func(v LabelingJobResponse) *LabelingDataConfigurationResponse { return v.DataConfiguration }).(LabelingDataConfigurationResponsePtrOutput)
}

// The asset description text.
func (o LabelingJobResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Display name of job.
func (o LabelingJobResponseOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobResponse) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
func (o LabelingJobResponseOutput) ExperimentName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelingJobResponse) *string { return v.ExperimentName }).(pulumi.StringPtrOutput)
}

// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
// Defaults to AmlToken if null.
func (o LabelingJobResponseOutput) Identity() pulumi.AnyOutput {
	return o.ApplyT(func(v LabelingJobResponse) interface{} { return v.Identity }).(pulumi.AnyOutput)
}

// Is the asset archived?
func (o LabelingJobResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v LabelingJobResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// Labeling instructions of the job.
func (o LabelingJobResponseOutput) JobInstructions() LabelingJobInstructionsResponsePtrOutput {
	return o.ApplyT(func(v LabelingJobResponse) *LabelingJobInstructionsResponse { return v.JobInstructions }).(LabelingJobInstructionsResponsePtrOutput)
}

// Enum to determine the type of job.
// Expected value is 'Labeling'.
func (o LabelingJobResponseOutput) JobType() pulumi.StringOutput {
	return o.ApplyT(func(v LabelingJobResponse) string { return v.JobType }).(pulumi.StringOutput)
}

// Label categories of the job.
func (o LabelingJobResponseOutput) LabelCategories() LabelCategoryResponseMapOutput {
	return o.ApplyT(func(v LabelingJobResponse) map[string]LabelCategoryResponse { return v.LabelCategories }).(LabelCategoryResponseMapOutput)
}

// Media type specific properties in the job.
func (o LabelingJobResponseOutput) LabelingJobMediaProperties() pulumi.AnyOutput {
	return o.ApplyT(func(v LabelingJobResponse) interface{} { return v.LabelingJobMediaProperties }).(pulumi.AnyOutput)
}

// Configuration of MLAssist feature in the job.
func (o LabelingJobResponseOutput) MlAssistConfiguration() pulumi.AnyOutput {
	return o.ApplyT(func(v LabelingJobResponse) interface{} { return v.MlAssistConfiguration }).(pulumi.AnyOutput)
}

// Notification setting for the job
func (o LabelingJobResponseOutput) NotificationSetting() NotificationSettingResponsePtrOutput {
	return o.ApplyT(func(v LabelingJobResponse) *NotificationSettingResponse { return v.NotificationSetting }).(NotificationSettingResponsePtrOutput)
}

// Progress metrics of the job.
func (o LabelingJobResponseOutput) ProgressMetrics() ProgressMetricsResponseOutput {
	return o.ApplyT(func(v LabelingJobResponse) ProgressMetricsResponse { return v.ProgressMetrics }).(ProgressMetricsResponseOutput)
}

// Internal id of the job(Previously called project).
func (o LabelingJobResponseOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v LabelingJobResponse) string { return v.ProjectId }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o LabelingJobResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v LabelingJobResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Specifies the labeling job provisioning state.
func (o LabelingJobResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v LabelingJobResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Configuration for secrets to be made available during runtime.
func (o LabelingJobResponseOutput) SecretsConfiguration() SecretConfigurationResponseMapOutput {
	return o.ApplyT(func(v LabelingJobResponse) map[string]SecretConfigurationResponse { return v.SecretsConfiguration }).(SecretConfigurationResponseMapOutput)
}

// List of JobEndpoints.
// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
func (o LabelingJobResponseOutput) Services() JobServiceResponseMapOutput {
	return o.ApplyT(func(v LabelingJobResponse) map[string]JobServiceResponse { return v.Services }).(JobServiceResponseMapOutput)
}

// Status of the job.
func (o LabelingJobResponseOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v LabelingJobResponse) string { return v.Status }).(pulumi.StringOutput)
}

// Status messages of the job.
func (o LabelingJobResponseOutput) StatusMessages() StatusMessageResponseArrayOutput {
	return o.ApplyT(func(v LabelingJobResponse) []StatusMessageResponse { return v.StatusMessages }).(StatusMessageResponseArrayOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o LabelingJobResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v LabelingJobResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Properties of a labeling job for text data
type LabelingJobTextProperties struct {
	// Annotation type of text labeling job.
	AnnotationType *string `pulumi:"annotationType"`
	// Media type of data asset.
	// Expected value is 'Text'.
	MediaType string `pulumi:"mediaType"`
}

// Defaults sets the appropriate defaults for LabelingJobTextProperties
func (val *LabelingJobTextProperties) Defaults() *LabelingJobTextProperties {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AnnotationType == nil {
		annotationType_ := "Classification"
		tmp.AnnotationType = &annotationType_
	}
	return &tmp
}

// Properties of a labeling job for text data
type LabelingJobTextPropertiesResponse struct {
	// Annotation type of text labeling job.
	AnnotationType *string `pulumi:"annotationType"`
	// Media type of data asset.
	// Expected value is 'Text'.
	MediaType string `pulumi:"mediaType"`
}

// Defaults sets the appropriate defaults for LabelingJobTextPropertiesResponse
func (val *LabelingJobTextPropertiesResponse) Defaults() *LabelingJobTextPropertiesResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AnnotationType == nil {
		annotationType_ := "Classification"
		tmp.AnnotationType = &annotationType_
	}
	return &tmp
}

type LakeHouseArtifact struct {
	// [Required] OneLake artifact name
	ArtifactName string `pulumi:"artifactName"`
	// Enum to determine OneLake artifact type.
	// Expected value is 'LakeHouse'.
	ArtifactType string `pulumi:"artifactType"`
}

type LakeHouseArtifactResponse struct {
	// [Required] OneLake artifact name
	ArtifactName string `pulumi:"artifactName"`
	// Enum to determine OneLake artifact type.
	// Expected value is 'LakeHouse'.
	ArtifactType string `pulumi:"artifactType"`
}

type ListNotebookKeysResultResponse struct {
	// The primary access key of the Notebook
	PrimaryAccessKey string `pulumi:"primaryAccessKey"`
	// The secondary access key of the Notebook
	SecondaryAccessKey string `pulumi:"secondaryAccessKey"`
}

type ListNotebookKeysResultResponseOutput struct{ *pulumi.OutputState }

func (ListNotebookKeysResultResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ListNotebookKeysResultResponse)(nil)).Elem()
}

func (o ListNotebookKeysResultResponseOutput) ToListNotebookKeysResultResponseOutput() ListNotebookKeysResultResponseOutput {
	return o
}

func (o ListNotebookKeysResultResponseOutput) ToListNotebookKeysResultResponseOutputWithContext(ctx context.Context) ListNotebookKeysResultResponseOutput {
	return o
}

// The primary access key of the Notebook
func (o ListNotebookKeysResultResponseOutput) PrimaryAccessKey() pulumi.StringOutput {
	return o.ApplyT(func(v ListNotebookKeysResultResponse) string { return v.PrimaryAccessKey }).(pulumi.StringOutput)
}

// The secondary access key of the Notebook
func (o ListNotebookKeysResultResponseOutput) SecondaryAccessKey() pulumi.StringOutput {
	return o.ApplyT(func(v ListNotebookKeysResultResponse) string { return v.SecondaryAccessKey }).(pulumi.StringOutput)
}

type ListNotebookKeysResultResponsePtrOutput struct{ *pulumi.OutputState }

func (ListNotebookKeysResultResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ListNotebookKeysResultResponse)(nil)).Elem()
}

func (o ListNotebookKeysResultResponsePtrOutput) ToListNotebookKeysResultResponsePtrOutput() ListNotebookKeysResultResponsePtrOutput {
	return o
}

func (o ListNotebookKeysResultResponsePtrOutput) ToListNotebookKeysResultResponsePtrOutputWithContext(ctx context.Context) ListNotebookKeysResultResponsePtrOutput {
	return o
}

func (o ListNotebookKeysResultResponsePtrOutput) Elem() ListNotebookKeysResultResponseOutput {
	return o.ApplyT(func(v *ListNotebookKeysResultResponse) ListNotebookKeysResultResponse {
		if v != nil {
			return *v
		}
		var ret ListNotebookKeysResultResponse
		return ret
	}).(ListNotebookKeysResultResponseOutput)
}

// The primary access key of the Notebook
func (o ListNotebookKeysResultResponsePtrOutput) PrimaryAccessKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ListNotebookKeysResultResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PrimaryAccessKey
	}).(pulumi.StringPtrOutput)
}

// The secondary access key of the Notebook
func (o ListNotebookKeysResultResponsePtrOutput) SecondaryAccessKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ListNotebookKeysResultResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SecondaryAccessKey
	}).(pulumi.StringPtrOutput)
}

// Literal input type.
type LiteralJobInput struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'literal'.
	JobInputType string `pulumi:"jobInputType"`
	// [Required] Literal value for the input.
	Value string `pulumi:"value"`
}

// Literal input type.
type LiteralJobInputResponse struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'literal'.
	JobInputType string `pulumi:"jobInputType"`
	// [Required] Literal value for the input.
	Value string `pulumi:"value"`
}

// Labeling MLAssist configuration definition when MLAssist is disabled
type MLAssistConfigurationDisabled struct {
	// Expected value is 'Disabled'.
	MlAssist string `pulumi:"mlAssist"`
}

// Labeling MLAssist configuration definition when MLAssist is disabled
type MLAssistConfigurationDisabledResponse struct {
	// Expected value is 'Disabled'.
	MlAssist string `pulumi:"mlAssist"`
}

// Labeling MLAssist configuration definition when MLAssist is enabled
type MLAssistConfigurationEnabled struct {
	// [Required] AML compute binding used in inferencing.
	InferencingComputeBinding string `pulumi:"inferencingComputeBinding"`
	// Expected value is 'Enabled'.
	MlAssist string `pulumi:"mlAssist"`
	// [Required] AML compute binding used in training.
	TrainingComputeBinding string `pulumi:"trainingComputeBinding"`
}

// Labeling MLAssist configuration definition when MLAssist is enabled
type MLAssistConfigurationEnabledResponse struct {
	// [Required] AML compute binding used in inferencing.
	InferencingComputeBinding string `pulumi:"inferencingComputeBinding"`
	// Expected value is 'Enabled'.
	MlAssist string `pulumi:"mlAssist"`
	// [Required] AML compute binding used in training.
	TrainingComputeBinding string `pulumi:"trainingComputeBinding"`
}

type MLFlowModelJobInput struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'mlflow_model'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLFlowModelJobInput
func (val *MLFlowModelJobInput) Defaults() *MLFlowModelJobInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLFlowModelJobInputResponse struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'mlflow_model'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLFlowModelJobInputResponse
func (val *MLFlowModelJobInputResponse) Defaults() *MLFlowModelJobInputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLFlowModelJobOutput struct {
	// Output Asset Name.
	AssetName *string `pulumi:"assetName"`
	// Output Asset Version.
	AssetVersion *string `pulumi:"assetVersion"`
	// Auto delete setting of output data asset.
	AutoDeleteSetting *AutoDeleteSetting `pulumi:"autoDeleteSetting"`
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'mlflow_model'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLFlowModelJobOutput
func (val *MLFlowModelJobOutput) Defaults() *MLFlowModelJobOutput {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.Mode == nil {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLFlowModelJobOutputResponse struct {
	// Output Asset Name.
	AssetName *string `pulumi:"assetName"`
	// Output Asset Version.
	AssetVersion *string `pulumi:"assetVersion"`
	// Auto delete setting of output data asset.
	AutoDeleteSetting *AutoDeleteSettingResponse `pulumi:"autoDeleteSetting"`
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'mlflow_model'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLFlowModelJobOutputResponse
func (val *MLFlowModelJobOutputResponse) Defaults() *MLFlowModelJobOutputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.Mode == nil {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

// MLTable data definition
type MLTableData struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSetting `pulumi:"autoDeleteSetting"`
	// Enum to determine the type of data.
	// Expected value is 'mltable'.
	DataType string `pulumi:"dataType"`
	// [Required] Uri of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330
	DataUri string `pulumi:"dataUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Intellectual Property details. Used if data is an Intellectual Property.
	IntellectualProperty *IntellectualProperty `pulumi:"intellectualProperty"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Uris referenced in the MLTable definition (required for lineage)
	ReferencedUris []string `pulumi:"referencedUris"`
	// Stage in the data lifecycle assigned to this data asset
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for MLTableData
func (val *MLTableData) Defaults() *MLTableData {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// MLTable data definition
type MLTableDataResponse struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSettingResponse `pulumi:"autoDeleteSetting"`
	// Enum to determine the type of data.
	// Expected value is 'mltable'.
	DataType string `pulumi:"dataType"`
	// [Required] Uri of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330
	DataUri string `pulumi:"dataUri"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Intellectual Property details. Used if data is an Intellectual Property.
	IntellectualProperty *IntellectualPropertyResponse `pulumi:"intellectualProperty"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Uris referenced in the MLTable definition (required for lineage)
	ReferencedUris []string `pulumi:"referencedUris"`
	// Stage in the data lifecycle assigned to this data asset
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for MLTableDataResponse
func (val *MLTableDataResponse) Defaults() *MLTableDataResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

type MLTableJobInput struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'mltable'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLTableJobInput
func (val *MLTableJobInput) Defaults() *MLTableJobInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLTableJobInputResponse struct {
	// Description for the input.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Input Type.
	// Expected value is 'mltable'.
	JobInputType string `pulumi:"jobInputType"`
	// Input Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// [Required] Input Asset URI.
	Uri string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLTableJobInputResponse
func (val *MLTableJobInputResponse) Defaults() *MLTableJobInputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "ReadOnlyMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLTableJobOutput struct {
	// Output Asset Name.
	AssetName *string `pulumi:"assetName"`
	// Output Asset Version.
	AssetVersion *string `pulumi:"assetVersion"`
	// Auto delete setting of output data asset.
	AutoDeleteSetting *AutoDeleteSetting `pulumi:"autoDeleteSetting"`
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'mltable'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLTableJobOutput
func (val *MLTableJobOutput) Defaults() *MLTableJobOutput {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.Mode == nil {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

type MLTableJobOutputResponse struct {
	// Output Asset Name.
	AssetName *string `pulumi:"assetName"`
	// Output Asset Version.
	AssetVersion *string `pulumi:"assetVersion"`
	// Auto delete setting of output data asset.
	AutoDeleteSetting *AutoDeleteSettingResponse `pulumi:"autoDeleteSetting"`
	// Description for the output.
	Description *string `pulumi:"description"`
	// Enum to determine the Job Output Type.
	// Expected value is 'mltable'.
	JobOutputType string `pulumi:"jobOutputType"`
	// Output Asset Delivery Mode.
	Mode *string `pulumi:"mode"`
	// Output Asset URI.
	Uri *string `pulumi:"uri"`
}

// Defaults sets the appropriate defaults for MLTableJobOutputResponse
func (val *MLTableJobOutputResponse) Defaults() *MLTableJobOutputResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	if tmp.Mode == nil {
		mode_ := "ReadWriteMount"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Managed compute identity definition.
type ManagedComputeIdentity struct {
	// Monitor compute identity type enum.
	// Expected value is 'ManagedIdentity'.
	ComputeIdentityType string `pulumi:"computeIdentityType"`
	// Managed service identity (system assigned and/or user assigned identities)
	Identity *ManagedServiceIdentity `pulumi:"identity"`
}

// Managed compute identity definition.
type ManagedComputeIdentityResponse struct {
	// Monitor compute identity type enum.
	// Expected value is 'ManagedIdentity'.
	ComputeIdentityType string `pulumi:"computeIdentityType"`
	// Managed service identity (system assigned and/or user assigned identities)
	Identity *ManagedServiceIdentityResponse `pulumi:"identity"`
}

// Managed identity configuration.
type ManagedIdentity struct {
	// Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
	ClientId *string `pulumi:"clientId"`
	// Enum to determine identity framework.
	// Expected value is 'Managed'.
	IdentityType string `pulumi:"identityType"`
	// Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
	ObjectId *string `pulumi:"objectId"`
	// Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
	ResourceId *string `pulumi:"resourceId"`
}

type ManagedIdentityAuthTypeWorkspaceConnectionProperties struct {
	// Authentication type of the connection target
	// Expected value is 'ManagedIdentity'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category    *string                             `pulumi:"category"`
	Credentials *WorkspaceConnectionManagedIdentity `pulumi:"credentials"`
	ExpiryTime  *string                             `pulumi:"expiryTime"`
	Metadata    interface{}                         `pulumi:"metadata"`
	Target      *string                             `pulumi:"target"`
}

type ManagedIdentityAuthTypeWorkspaceConnectionPropertiesResponse struct {
	// Authentication type of the connection target
	// Expected value is 'ManagedIdentity'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category    *string                                     `pulumi:"category"`
	Credentials *WorkspaceConnectionManagedIdentityResponse `pulumi:"credentials"`
	ExpiryTime  *string                                     `pulumi:"expiryTime"`
	Metadata    interface{}                                 `pulumi:"metadata"`
	Target      *string                                     `pulumi:"target"`
}

// Managed identity configuration.
type ManagedIdentityResponse struct {
	// Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
	ClientId *string `pulumi:"clientId"`
	// Enum to determine identity framework.
	// Expected value is 'Managed'.
	IdentityType string `pulumi:"identityType"`
	// Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
	ObjectId *string `pulumi:"objectId"`
	// Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
	ResourceId *string `pulumi:"resourceId"`
}

// Status of the Provisioning for the managed network of a machine learning workspace.
type ManagedNetworkProvisionStatus struct {
	SparkReady *bool `pulumi:"sparkReady"`
	// Status for the managed network of a machine learning workspace.
	Status *string `pulumi:"status"`
}

// ManagedNetworkProvisionStatusInput is an input type that accepts ManagedNetworkProvisionStatusArgs and ManagedNetworkProvisionStatusOutput values.
// You can construct a concrete instance of `ManagedNetworkProvisionStatusInput` via:
//
//	ManagedNetworkProvisionStatusArgs{...}
type ManagedNetworkProvisionStatusInput interface {
	pulumi.Input

	ToManagedNetworkProvisionStatusOutput() ManagedNetworkProvisionStatusOutput
	ToManagedNetworkProvisionStatusOutputWithContext(context.Context) ManagedNetworkProvisionStatusOutput
}

// Status of the Provisioning for the managed network of a machine learning workspace.
type ManagedNetworkProvisionStatusArgs struct {
	SparkReady pulumi.BoolPtrInput `pulumi:"sparkReady"`
	// Status for the managed network of a machine learning workspace.
	Status pulumi.StringPtrInput `pulumi:"status"`
}

func (ManagedNetworkProvisionStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedNetworkProvisionStatus)(nil)).Elem()
}

func (i ManagedNetworkProvisionStatusArgs) ToManagedNetworkProvisionStatusOutput() ManagedNetworkProvisionStatusOutput {
	return i.ToManagedNetworkProvisionStatusOutputWithContext(context.Background())
}

func (i ManagedNetworkProvisionStatusArgs) ToManagedNetworkProvisionStatusOutputWithContext(ctx context.Context) ManagedNetworkProvisionStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedNetworkProvisionStatusOutput)
}

func (i ManagedNetworkProvisionStatusArgs) ToManagedNetworkProvisionStatusPtrOutput() ManagedNetworkProvisionStatusPtrOutput {
	return i.ToManagedNetworkProvisionStatusPtrOutputWithContext(context.Background())
}

func (i ManagedNetworkProvisionStatusArgs) ToManagedNetworkProvisionStatusPtrOutputWithContext(ctx context.Context) ManagedNetworkProvisionStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedNetworkProvisionStatusOutput).ToManagedNetworkProvisionStatusPtrOutputWithContext(ctx)
}

// ManagedNetworkProvisionStatusPtrInput is an input type that accepts ManagedNetworkProvisionStatusArgs, ManagedNetworkProvisionStatusPtr and ManagedNetworkProvisionStatusPtrOutput values.
// You can construct a concrete instance of `ManagedNetworkProvisionStatusPtrInput` via:
//
//	        ManagedNetworkProvisionStatusArgs{...}
//
//	or:
//
//	        nil
type ManagedNetworkProvisionStatusPtrInput interface {
	pulumi.Input

	ToManagedNetworkProvisionStatusPtrOutput() ManagedNetworkProvisionStatusPtrOutput
	ToManagedNetworkProvisionStatusPtrOutputWithContext(context.Context) ManagedNetworkProvisionStatusPtrOutput
}

type managedNetworkProvisionStatusPtrType ManagedNetworkProvisionStatusArgs

func ManagedNetworkProvisionStatusPtr(v *ManagedNetworkProvisionStatusArgs) ManagedNetworkProvisionStatusPtrInput {
	return (*managedNetworkProvisionStatusPtrType)(v)
}

func (*managedNetworkProvisionStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedNetworkProvisionStatus)(nil)).Elem()
}

func (i *managedNetworkProvisionStatusPtrType) ToManagedNetworkProvisionStatusPtrOutput() ManagedNetworkProvisionStatusPtrOutput {
	return i.ToManagedNetworkProvisionStatusPtrOutputWithContext(context.Background())
}

func (i *managedNetworkProvisionStatusPtrType) ToManagedNetworkProvisionStatusPtrOutputWithContext(ctx context.Context) ManagedNetworkProvisionStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedNetworkProvisionStatusPtrOutput)
}

// Status of the Provisioning for the managed network of a machine learning workspace.
type ManagedNetworkProvisionStatusOutput struct{ *pulumi.OutputState }

func (ManagedNetworkProvisionStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedNetworkProvisionStatus)(nil)).Elem()
}

func (o ManagedNetworkProvisionStatusOutput) ToManagedNetworkProvisionStatusOutput() ManagedNetworkProvisionStatusOutput {
	return o
}

func (o ManagedNetworkProvisionStatusOutput) ToManagedNetworkProvisionStatusOutputWithContext(ctx context.Context) ManagedNetworkProvisionStatusOutput {
	return o
}

func (o ManagedNetworkProvisionStatusOutput) ToManagedNetworkProvisionStatusPtrOutput() ManagedNetworkProvisionStatusPtrOutput {
	return o.ToManagedNetworkProvisionStatusPtrOutputWithContext(context.Background())
}

func (o ManagedNetworkProvisionStatusOutput) ToManagedNetworkProvisionStatusPtrOutputWithContext(ctx context.Context) ManagedNetworkProvisionStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ManagedNetworkProvisionStatus) *ManagedNetworkProvisionStatus {
		return &v
	}).(ManagedNetworkProvisionStatusPtrOutput)
}

func (o ManagedNetworkProvisionStatusOutput) SparkReady() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ManagedNetworkProvisionStatus) *bool { return v.SparkReady }).(pulumi.BoolPtrOutput)
}

// Status for the managed network of a machine learning workspace.
func (o ManagedNetworkProvisionStatusOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ManagedNetworkProvisionStatus) *string { return v.Status }).(pulumi.StringPtrOutput)
}

type ManagedNetworkProvisionStatusPtrOutput struct{ *pulumi.OutputState }

func (ManagedNetworkProvisionStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedNetworkProvisionStatus)(nil)).Elem()
}

func (o ManagedNetworkProvisionStatusPtrOutput) ToManagedNetworkProvisionStatusPtrOutput() ManagedNetworkProvisionStatusPtrOutput {
	return o
}

func (o ManagedNetworkProvisionStatusPtrOutput) ToManagedNetworkProvisionStatusPtrOutputWithContext(ctx context.Context) ManagedNetworkProvisionStatusPtrOutput {
	return o
}

func (o ManagedNetworkProvisionStatusPtrOutput) Elem() ManagedNetworkProvisionStatusOutput {
	return o.ApplyT(func(v *ManagedNetworkProvisionStatus) ManagedNetworkProvisionStatus {
		if v != nil {
			return *v
		}
		var ret ManagedNetworkProvisionStatus
		return ret
	}).(ManagedNetworkProvisionStatusOutput)
}

func (o ManagedNetworkProvisionStatusPtrOutput) SparkReady() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedNetworkProvisionStatus) *bool {
		if v == nil {
			return nil
		}
		return v.SparkReady
	}).(pulumi.BoolPtrOutput)
}

// Status for the managed network of a machine learning workspace.
func (o ManagedNetworkProvisionStatusPtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedNetworkProvisionStatus) *string {
		if v == nil {
			return nil
		}
		return v.Status
	}).(pulumi.StringPtrOutput)
}

// Status of the Provisioning for the managed network of a machine learning workspace.
type ManagedNetworkProvisionStatusResponse struct {
	SparkReady *bool `pulumi:"sparkReady"`
	// Status for the managed network of a machine learning workspace.
	Status *string `pulumi:"status"`
}

// Status of the Provisioning for the managed network of a machine learning workspace.
type ManagedNetworkProvisionStatusResponseOutput struct{ *pulumi.OutputState }

func (ManagedNetworkProvisionStatusResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedNetworkProvisionStatusResponse)(nil)).Elem()
}

func (o ManagedNetworkProvisionStatusResponseOutput) ToManagedNetworkProvisionStatusResponseOutput() ManagedNetworkProvisionStatusResponseOutput {
	return o
}

func (o ManagedNetworkProvisionStatusResponseOutput) ToManagedNetworkProvisionStatusResponseOutputWithContext(ctx context.Context) ManagedNetworkProvisionStatusResponseOutput {
	return o
}

func (o ManagedNetworkProvisionStatusResponseOutput) SparkReady() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ManagedNetworkProvisionStatusResponse) *bool { return v.SparkReady }).(pulumi.BoolPtrOutput)
}

// Status for the managed network of a machine learning workspace.
func (o ManagedNetworkProvisionStatusResponseOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ManagedNetworkProvisionStatusResponse) *string { return v.Status }).(pulumi.StringPtrOutput)
}

type ManagedNetworkProvisionStatusResponsePtrOutput struct{ *pulumi.OutputState }

func (ManagedNetworkProvisionStatusResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedNetworkProvisionStatusResponse)(nil)).Elem()
}

func (o ManagedNetworkProvisionStatusResponsePtrOutput) ToManagedNetworkProvisionStatusResponsePtrOutput() ManagedNetworkProvisionStatusResponsePtrOutput {
	return o
}

func (o ManagedNetworkProvisionStatusResponsePtrOutput) ToManagedNetworkProvisionStatusResponsePtrOutputWithContext(ctx context.Context) ManagedNetworkProvisionStatusResponsePtrOutput {
	return o
}

func (o ManagedNetworkProvisionStatusResponsePtrOutput) Elem() ManagedNetworkProvisionStatusResponseOutput {
	return o.ApplyT(func(v *ManagedNetworkProvisionStatusResponse) ManagedNetworkProvisionStatusResponse {
		if v != nil {
			return *v
		}
		var ret ManagedNetworkProvisionStatusResponse
		return ret
	}).(ManagedNetworkProvisionStatusResponseOutput)
}

func (o ManagedNetworkProvisionStatusResponsePtrOutput) SparkReady() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedNetworkProvisionStatusResponse) *bool {
		if v == nil {
			return nil
		}
		return v.SparkReady
	}).(pulumi.BoolPtrOutput)
}

// Status for the managed network of a machine learning workspace.
func (o ManagedNetworkProvisionStatusResponsePtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedNetworkProvisionStatusResponse) *string {
		if v == nil {
			return nil
		}
		return v.Status
	}).(pulumi.StringPtrOutput)
}

// Managed Network settings for a machine learning workspace.
type ManagedNetworkSettings struct {
	// Isolation mode for the managed network of a machine learning workspace.
	IsolationMode *string                `pulumi:"isolationMode"`
	OutboundRules map[string]interface{} `pulumi:"outboundRules"`
	// Status of the Provisioning for the managed network of a machine learning workspace.
	Status *ManagedNetworkProvisionStatus `pulumi:"status"`
}

// ManagedNetworkSettingsInput is an input type that accepts ManagedNetworkSettingsArgs and ManagedNetworkSettingsOutput values.
// You can construct a concrete instance of `ManagedNetworkSettingsInput` via:
//
//	ManagedNetworkSettingsArgs{...}
type ManagedNetworkSettingsInput interface {
	pulumi.Input

	ToManagedNetworkSettingsOutput() ManagedNetworkSettingsOutput
	ToManagedNetworkSettingsOutputWithContext(context.Context) ManagedNetworkSettingsOutput
}

// Managed Network settings for a machine learning workspace.
type ManagedNetworkSettingsArgs struct {
	// Isolation mode for the managed network of a machine learning workspace.
	IsolationMode pulumi.StringPtrInput `pulumi:"isolationMode"`
	OutboundRules pulumi.MapInput       `pulumi:"outboundRules"`
	// Status of the Provisioning for the managed network of a machine learning workspace.
	Status ManagedNetworkProvisionStatusPtrInput `pulumi:"status"`
}

func (ManagedNetworkSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedNetworkSettings)(nil)).Elem()
}

func (i ManagedNetworkSettingsArgs) ToManagedNetworkSettingsOutput() ManagedNetworkSettingsOutput {
	return i.ToManagedNetworkSettingsOutputWithContext(context.Background())
}

func (i ManagedNetworkSettingsArgs) ToManagedNetworkSettingsOutputWithContext(ctx context.Context) ManagedNetworkSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedNetworkSettingsOutput)
}

func (i ManagedNetworkSettingsArgs) ToManagedNetworkSettingsPtrOutput() ManagedNetworkSettingsPtrOutput {
	return i.ToManagedNetworkSettingsPtrOutputWithContext(context.Background())
}

func (i ManagedNetworkSettingsArgs) ToManagedNetworkSettingsPtrOutputWithContext(ctx context.Context) ManagedNetworkSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedNetworkSettingsOutput).ToManagedNetworkSettingsPtrOutputWithContext(ctx)
}

// ManagedNetworkSettingsPtrInput is an input type that accepts ManagedNetworkSettingsArgs, ManagedNetworkSettingsPtr and ManagedNetworkSettingsPtrOutput values.
// You can construct a concrete instance of `ManagedNetworkSettingsPtrInput` via:
//
//	        ManagedNetworkSettingsArgs{...}
//
//	or:
//
//	        nil
type ManagedNetworkSettingsPtrInput interface {
	pulumi.Input

	ToManagedNetworkSettingsPtrOutput() ManagedNetworkSettingsPtrOutput
	ToManagedNetworkSettingsPtrOutputWithContext(context.Context) ManagedNetworkSettingsPtrOutput
}

type managedNetworkSettingsPtrType ManagedNetworkSettingsArgs

func ManagedNetworkSettingsPtr(v *ManagedNetworkSettingsArgs) ManagedNetworkSettingsPtrInput {
	return (*managedNetworkSettingsPtrType)(v)
}

func (*managedNetworkSettingsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedNetworkSettings)(nil)).Elem()
}

func (i *managedNetworkSettingsPtrType) ToManagedNetworkSettingsPtrOutput() ManagedNetworkSettingsPtrOutput {
	return i.ToManagedNetworkSettingsPtrOutputWithContext(context.Background())
}

func (i *managedNetworkSettingsPtrType) ToManagedNetworkSettingsPtrOutputWithContext(ctx context.Context) ManagedNetworkSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedNetworkSettingsPtrOutput)
}

// Managed Network settings for a machine learning workspace.
type ManagedNetworkSettingsOutput struct{ *pulumi.OutputState }

func (ManagedNetworkSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedNetworkSettings)(nil)).Elem()
}

func (o ManagedNetworkSettingsOutput) ToManagedNetworkSettingsOutput() ManagedNetworkSettingsOutput {
	return o
}

func (o ManagedNetworkSettingsOutput) ToManagedNetworkSettingsOutputWithContext(ctx context.Context) ManagedNetworkSettingsOutput {
	return o
}

func (o ManagedNetworkSettingsOutput) ToManagedNetworkSettingsPtrOutput() ManagedNetworkSettingsPtrOutput {
	return o.ToManagedNetworkSettingsPtrOutputWithContext(context.Background())
}

func (o ManagedNetworkSettingsOutput) ToManagedNetworkSettingsPtrOutputWithContext(ctx context.Context) ManagedNetworkSettingsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ManagedNetworkSettings) *ManagedNetworkSettings {
		return &v
	}).(ManagedNetworkSettingsPtrOutput)
}

// Isolation mode for the managed network of a machine learning workspace.
func (o ManagedNetworkSettingsOutput) IsolationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ManagedNetworkSettings) *string { return v.IsolationMode }).(pulumi.StringPtrOutput)
}

func (o ManagedNetworkSettingsOutput) OutboundRules() pulumi.MapOutput {
	return o.ApplyT(func(v ManagedNetworkSettings) map[string]interface{} { return v.OutboundRules }).(pulumi.MapOutput)
}

// Status of the Provisioning for the managed network of a machine learning workspace.
func (o ManagedNetworkSettingsOutput) Status() ManagedNetworkProvisionStatusPtrOutput {
	return o.ApplyT(func(v ManagedNetworkSettings) *ManagedNetworkProvisionStatus { return v.Status }).(ManagedNetworkProvisionStatusPtrOutput)
}

type ManagedNetworkSettingsPtrOutput struct{ *pulumi.OutputState }

func (ManagedNetworkSettingsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedNetworkSettings)(nil)).Elem()
}

func (o ManagedNetworkSettingsPtrOutput) ToManagedNetworkSettingsPtrOutput() ManagedNetworkSettingsPtrOutput {
	return o
}

func (o ManagedNetworkSettingsPtrOutput) ToManagedNetworkSettingsPtrOutputWithContext(ctx context.Context) ManagedNetworkSettingsPtrOutput {
	return o
}

func (o ManagedNetworkSettingsPtrOutput) Elem() ManagedNetworkSettingsOutput {
	return o.ApplyT(func(v *ManagedNetworkSettings) ManagedNetworkSettings {
		if v != nil {
			return *v
		}
		var ret ManagedNetworkSettings
		return ret
	}).(ManagedNetworkSettingsOutput)
}

// Isolation mode for the managed network of a machine learning workspace.
func (o ManagedNetworkSettingsPtrOutput) IsolationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedNetworkSettings) *string {
		if v == nil {
			return nil
		}
		return v.IsolationMode
	}).(pulumi.StringPtrOutput)
}

func (o ManagedNetworkSettingsPtrOutput) OutboundRules() pulumi.MapOutput {
	return o.ApplyT(func(v *ManagedNetworkSettings) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.OutboundRules
	}).(pulumi.MapOutput)
}

// Status of the Provisioning for the managed network of a machine learning workspace.
func (o ManagedNetworkSettingsPtrOutput) Status() ManagedNetworkProvisionStatusPtrOutput {
	return o.ApplyT(func(v *ManagedNetworkSettings) *ManagedNetworkProvisionStatus {
		if v == nil {
			return nil
		}
		return v.Status
	}).(ManagedNetworkProvisionStatusPtrOutput)
}

// Managed Network settings for a machine learning workspace.
type ManagedNetworkSettingsResponse struct {
	// Isolation mode for the managed network of a machine learning workspace.
	IsolationMode *string                `pulumi:"isolationMode"`
	NetworkId     string                 `pulumi:"networkId"`
	OutboundRules map[string]interface{} `pulumi:"outboundRules"`
	// Status of the Provisioning for the managed network of a machine learning workspace.
	Status *ManagedNetworkProvisionStatusResponse `pulumi:"status"`
}

// Managed Network settings for a machine learning workspace.
type ManagedNetworkSettingsResponseOutput struct{ *pulumi.OutputState }

func (ManagedNetworkSettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedNetworkSettingsResponse)(nil)).Elem()
}

func (o ManagedNetworkSettingsResponseOutput) ToManagedNetworkSettingsResponseOutput() ManagedNetworkSettingsResponseOutput {
	return o
}

func (o ManagedNetworkSettingsResponseOutput) ToManagedNetworkSettingsResponseOutputWithContext(ctx context.Context) ManagedNetworkSettingsResponseOutput {
	return o
}

// Isolation mode for the managed network of a machine learning workspace.
func (o ManagedNetworkSettingsResponseOutput) IsolationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ManagedNetworkSettingsResponse) *string { return v.IsolationMode }).(pulumi.StringPtrOutput)
}

func (o ManagedNetworkSettingsResponseOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedNetworkSettingsResponse) string { return v.NetworkId }).(pulumi.StringOutput)
}

func (o ManagedNetworkSettingsResponseOutput) OutboundRules() pulumi.MapOutput {
	return o.ApplyT(func(v ManagedNetworkSettingsResponse) map[string]interface{} { return v.OutboundRules }).(pulumi.MapOutput)
}

// Status of the Provisioning for the managed network of a machine learning workspace.
func (o ManagedNetworkSettingsResponseOutput) Status() ManagedNetworkProvisionStatusResponsePtrOutput {
	return o.ApplyT(func(v ManagedNetworkSettingsResponse) *ManagedNetworkProvisionStatusResponse { return v.Status }).(ManagedNetworkProvisionStatusResponsePtrOutput)
}

type ManagedNetworkSettingsResponsePtrOutput struct{ *pulumi.OutputState }

func (ManagedNetworkSettingsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedNetworkSettingsResponse)(nil)).Elem()
}

func (o ManagedNetworkSettingsResponsePtrOutput) ToManagedNetworkSettingsResponsePtrOutput() ManagedNetworkSettingsResponsePtrOutput {
	return o
}

func (o ManagedNetworkSettingsResponsePtrOutput) ToManagedNetworkSettingsResponsePtrOutputWithContext(ctx context.Context) ManagedNetworkSettingsResponsePtrOutput {
	return o
}

func (o ManagedNetworkSettingsResponsePtrOutput) Elem() ManagedNetworkSettingsResponseOutput {
	return o.ApplyT(func(v *ManagedNetworkSettingsResponse) ManagedNetworkSettingsResponse {
		if v != nil {
			return *v
		}
		var ret ManagedNetworkSettingsResponse
		return ret
	}).(ManagedNetworkSettingsResponseOutput)
}

// Isolation mode for the managed network of a machine learning workspace.
func (o ManagedNetworkSettingsResponsePtrOutput) IsolationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedNetworkSettingsResponse) *string {
		if v == nil {
			return nil
		}
		return v.IsolationMode
	}).(pulumi.StringPtrOutput)
}

func (o ManagedNetworkSettingsResponsePtrOutput) NetworkId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedNetworkSettingsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.NetworkId
	}).(pulumi.StringPtrOutput)
}

func (o ManagedNetworkSettingsResponsePtrOutput) OutboundRules() pulumi.MapOutput {
	return o.ApplyT(func(v *ManagedNetworkSettingsResponse) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.OutboundRules
	}).(pulumi.MapOutput)
}

// Status of the Provisioning for the managed network of a machine learning workspace.
func (o ManagedNetworkSettingsResponsePtrOutput) Status() ManagedNetworkProvisionStatusResponsePtrOutput {
	return o.ApplyT(func(v *ManagedNetworkSettingsResponse) *ManagedNetworkProvisionStatusResponse {
		if v == nil {
			return nil
		}
		return v.Status
	}).(ManagedNetworkProvisionStatusResponsePtrOutput)
}

// Properties specific to a ManagedOnlineDeployment.
type ManagedOnlineDeployment struct {
	// If true, enables Application Insights logging.
	AppInsightsEnabled *bool `pulumi:"appInsightsEnabled"`
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfiguration `pulumi:"codeConfiguration"`
	// The mdc configuration, we disable mdc when it's null.
	DataCollector *DataCollector `pulumi:"dataCollector"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
	EgressPublicNetworkAccess *string `pulumi:"egressPublicNetworkAccess"`
	// Enum to determine endpoint compute type.
	// Expected value is 'Managed'.
	EndpointComputeType string `pulumi:"endpointComputeType"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Compute instance type.
	InstanceType *string `pulumi:"instanceType"`
	// Liveness probe monitors the health of the container regularly.
	LivenessProbe *ProbeSettings `pulumi:"livenessProbe"`
	// The URI path to the model.
	Model *string `pulumi:"model"`
	// The path to mount the model in custom container.
	ModelMountPath *string `pulumi:"modelMountPath"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
	ReadinessProbe *ProbeSettings `pulumi:"readinessProbe"`
	// Request settings for the deployment.
	RequestSettings *OnlineRequestSettings `pulumi:"requestSettings"`
	// Scale settings for the deployment.
	// If it is null or not provided,
	// it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
	// and to DefaultScaleSettings for ManagedOnlineDeployment.
	ScaleSettings interface{} `pulumi:"scaleSettings"`
}

// Defaults sets the appropriate defaults for ManagedOnlineDeployment
func (val *ManagedOnlineDeployment) Defaults() *ManagedOnlineDeployment {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AppInsightsEnabled == nil {
		appInsightsEnabled_ := false
		tmp.AppInsightsEnabled = &appInsightsEnabled_
	}
	tmp.DataCollector = tmp.DataCollector.Defaults()

	if tmp.EgressPublicNetworkAccess == nil {
		egressPublicNetworkAccess_ := "Enabled"
		tmp.EgressPublicNetworkAccess = &egressPublicNetworkAccess_
	}
	tmp.LivenessProbe = tmp.LivenessProbe.Defaults()

	tmp.ReadinessProbe = tmp.ReadinessProbe.Defaults()

	tmp.RequestSettings = tmp.RequestSettings.Defaults()

	return &tmp
}

// Properties specific to a ManagedOnlineDeployment.
type ManagedOnlineDeploymentResponse struct {
	// If true, enables Application Insights logging.
	AppInsightsEnabled *bool `pulumi:"appInsightsEnabled"`
	// Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfigurationResponse `pulumi:"codeConfiguration"`
	// The mdc configuration, we disable mdc when it's null.
	DataCollector *DataCollectorResponse `pulumi:"dataCollector"`
	// Description of the endpoint deployment.
	Description *string `pulumi:"description"`
	// If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
	EgressPublicNetworkAccess *string `pulumi:"egressPublicNetworkAccess"`
	// Enum to determine endpoint compute type.
	// Expected value is 'Managed'.
	EndpointComputeType string `pulumi:"endpointComputeType"`
	// ARM resource ID of the environment specification for the endpoint deployment.
	EnvironmentId *string `pulumi:"environmentId"`
	// Environment variables configuration for the deployment.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Compute instance type.
	InstanceType *string `pulumi:"instanceType"`
	// Liveness probe monitors the health of the container regularly.
	LivenessProbe *ProbeSettingsResponse `pulumi:"livenessProbe"`
	// The URI path to the model.
	Model *string `pulumi:"model"`
	// The path to mount the model in custom container.
	ModelMountPath *string `pulumi:"modelMountPath"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the endpoint deployment.
	ProvisioningState string `pulumi:"provisioningState"`
	// Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
	ReadinessProbe *ProbeSettingsResponse `pulumi:"readinessProbe"`
	// Request settings for the deployment.
	RequestSettings *OnlineRequestSettingsResponse `pulumi:"requestSettings"`
	// Scale settings for the deployment.
	// If it is null or not provided,
	// it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
	// and to DefaultScaleSettings for ManagedOnlineDeployment.
	ScaleSettings interface{} `pulumi:"scaleSettings"`
}

// Defaults sets the appropriate defaults for ManagedOnlineDeploymentResponse
func (val *ManagedOnlineDeploymentResponse) Defaults() *ManagedOnlineDeploymentResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.AppInsightsEnabled == nil {
		appInsightsEnabled_ := false
		tmp.AppInsightsEnabled = &appInsightsEnabled_
	}
	tmp.DataCollector = tmp.DataCollector.Defaults()

	if tmp.EgressPublicNetworkAccess == nil {
		egressPublicNetworkAccess_ := "Enabled"
		tmp.EgressPublicNetworkAccess = &egressPublicNetworkAccess_
	}
	tmp.LivenessProbe = tmp.LivenessProbe.Defaults()

	tmp.ReadinessProbe = tmp.ReadinessProbe.Defaults()

	tmp.RequestSettings = tmp.RequestSettings.Defaults()

	return &tmp
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type string `pulumi:"type"`
	// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
	UserAssignedIdentities []string `pulumi:"userAssignedIdentities"`
}

// ManagedServiceIdentityInput is an input type that accepts ManagedServiceIdentityArgs and ManagedServiceIdentityOutput values.
// You can construct a concrete instance of `ManagedServiceIdentityInput` via:
//
//	ManagedServiceIdentityArgs{...}
type ManagedServiceIdentityInput interface {
	pulumi.Input

	ToManagedServiceIdentityOutput() ManagedServiceIdentityOutput
	ToManagedServiceIdentityOutputWithContext(context.Context) ManagedServiceIdentityOutput
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentityArgs struct {
	// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type pulumi.StringInput `pulumi:"type"`
	// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
	UserAssignedIdentities pulumi.StringArrayInput `pulumi:"userAssignedIdentities"`
}

func (ManagedServiceIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedServiceIdentity)(nil)).Elem()
}

func (i ManagedServiceIdentityArgs) ToManagedServiceIdentityOutput() ManagedServiceIdentityOutput {
	return i.ToManagedServiceIdentityOutputWithContext(context.Background())
}

func (i ManagedServiceIdentityArgs) ToManagedServiceIdentityOutputWithContext(ctx context.Context) ManagedServiceIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedServiceIdentityOutput)
}

func (i ManagedServiceIdentityArgs) ToManagedServiceIdentityPtrOutput() ManagedServiceIdentityPtrOutput {
	return i.ToManagedServiceIdentityPtrOutputWithContext(context.Background())
}

func (i ManagedServiceIdentityArgs) ToManagedServiceIdentityPtrOutputWithContext(ctx context.Context) ManagedServiceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedServiceIdentityOutput).ToManagedServiceIdentityPtrOutputWithContext(ctx)
}

// ManagedServiceIdentityPtrInput is an input type that accepts ManagedServiceIdentityArgs, ManagedServiceIdentityPtr and ManagedServiceIdentityPtrOutput values.
// You can construct a concrete instance of `ManagedServiceIdentityPtrInput` via:
//
//	        ManagedServiceIdentityArgs{...}
//
//	or:
//
//	        nil
type ManagedServiceIdentityPtrInput interface {
	pulumi.Input

	ToManagedServiceIdentityPtrOutput() ManagedServiceIdentityPtrOutput
	ToManagedServiceIdentityPtrOutputWithContext(context.Context) ManagedServiceIdentityPtrOutput
}

type managedServiceIdentityPtrType ManagedServiceIdentityArgs

func ManagedServiceIdentityPtr(v *ManagedServiceIdentityArgs) ManagedServiceIdentityPtrInput {
	return (*managedServiceIdentityPtrType)(v)
}

func (*managedServiceIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedServiceIdentity)(nil)).Elem()
}

func (i *managedServiceIdentityPtrType) ToManagedServiceIdentityPtrOutput() ManagedServiceIdentityPtrOutput {
	return i.ToManagedServiceIdentityPtrOutputWithContext(context.Background())
}

func (i *managedServiceIdentityPtrType) ToManagedServiceIdentityPtrOutputWithContext(ctx context.Context) ManagedServiceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedServiceIdentityPtrOutput)
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentityOutput struct{ *pulumi.OutputState }

func (ManagedServiceIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedServiceIdentity)(nil)).Elem()
}

func (o ManagedServiceIdentityOutput) ToManagedServiceIdentityOutput() ManagedServiceIdentityOutput {
	return o
}

func (o ManagedServiceIdentityOutput) ToManagedServiceIdentityOutputWithContext(ctx context.Context) ManagedServiceIdentityOutput {
	return o
}

func (o ManagedServiceIdentityOutput) ToManagedServiceIdentityPtrOutput() ManagedServiceIdentityPtrOutput {
	return o.ToManagedServiceIdentityPtrOutputWithContext(context.Background())
}

func (o ManagedServiceIdentityOutput) ToManagedServiceIdentityPtrOutputWithContext(ctx context.Context) ManagedServiceIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ManagedServiceIdentity) *ManagedServiceIdentity {
		return &v
	}).(ManagedServiceIdentityPtrOutput)
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
func (o ManagedServiceIdentityOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedServiceIdentity) string { return v.Type }).(pulumi.StringOutput)
}

// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
func (o ManagedServiceIdentityOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ManagedServiceIdentity) []string { return v.UserAssignedIdentities }).(pulumi.StringArrayOutput)
}

type ManagedServiceIdentityPtrOutput struct{ *pulumi.OutputState }

func (ManagedServiceIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedServiceIdentity)(nil)).Elem()
}

func (o ManagedServiceIdentityPtrOutput) ToManagedServiceIdentityPtrOutput() ManagedServiceIdentityPtrOutput {
	return o
}

func (o ManagedServiceIdentityPtrOutput) ToManagedServiceIdentityPtrOutputWithContext(ctx context.Context) ManagedServiceIdentityPtrOutput {
	return o
}

func (o ManagedServiceIdentityPtrOutput) Elem() ManagedServiceIdentityOutput {
	return o.ApplyT(func(v *ManagedServiceIdentity) ManagedServiceIdentity {
		if v != nil {
			return *v
		}
		var ret ManagedServiceIdentity
		return ret
	}).(ManagedServiceIdentityOutput)
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
func (o ManagedServiceIdentityPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedServiceIdentity) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
func (o ManagedServiceIdentityPtrOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ManagedServiceIdentity) []string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.StringArrayOutput)
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentityResponse struct {
	// The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
	PrincipalId string `pulumi:"principalId"`
	// The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
	TenantId string `pulumi:"tenantId"`
	// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type string `pulumi:"type"`
	// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
	UserAssignedIdentities map[string]UserAssignedIdentityResponse `pulumi:"userAssignedIdentities"`
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentityResponseOutput struct{ *pulumi.OutputState }

func (ManagedServiceIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedServiceIdentityResponse)(nil)).Elem()
}

func (o ManagedServiceIdentityResponseOutput) ToManagedServiceIdentityResponseOutput() ManagedServiceIdentityResponseOutput {
	return o
}

func (o ManagedServiceIdentityResponseOutput) ToManagedServiceIdentityResponseOutputWithContext(ctx context.Context) ManagedServiceIdentityResponseOutput {
	return o
}

// The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
func (o ManagedServiceIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedServiceIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

// The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
func (o ManagedServiceIdentityResponseOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedServiceIdentityResponse) string { return v.TenantId }).(pulumi.StringOutput)
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
func (o ManagedServiceIdentityResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedServiceIdentityResponse) string { return v.Type }).(pulumi.StringOutput)
}

// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
func (o ManagedServiceIdentityResponseOutput) UserAssignedIdentities() UserAssignedIdentityResponseMapOutput {
	return o.ApplyT(func(v ManagedServiceIdentityResponse) map[string]UserAssignedIdentityResponse {
		return v.UserAssignedIdentities
	}).(UserAssignedIdentityResponseMapOutput)
}

type ManagedServiceIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (ManagedServiceIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedServiceIdentityResponse)(nil)).Elem()
}

func (o ManagedServiceIdentityResponsePtrOutput) ToManagedServiceIdentityResponsePtrOutput() ManagedServiceIdentityResponsePtrOutput {
	return o
}

func (o ManagedServiceIdentityResponsePtrOutput) ToManagedServiceIdentityResponsePtrOutputWithContext(ctx context.Context) ManagedServiceIdentityResponsePtrOutput {
	return o
}

func (o ManagedServiceIdentityResponsePtrOutput) Elem() ManagedServiceIdentityResponseOutput {
	return o.ApplyT(func(v *ManagedServiceIdentityResponse) ManagedServiceIdentityResponse {
		if v != nil {
			return *v
		}
		var ret ManagedServiceIdentityResponse
		return ret
	}).(ManagedServiceIdentityResponseOutput)
}

// The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
func (o ManagedServiceIdentityResponsePtrOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PrincipalId
	}).(pulumi.StringPtrOutput)
}

// The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
func (o ManagedServiceIdentityResponsePtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TenantId
	}).(pulumi.StringPtrOutput)
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
func (o ManagedServiceIdentityResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
func (o ManagedServiceIdentityResponsePtrOutput) UserAssignedIdentities() UserAssignedIdentityResponseMapOutput {
	return o.ApplyT(func(v *ManagedServiceIdentityResponse) map[string]UserAssignedIdentityResponse {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(UserAssignedIdentityResponseMapOutput)
}

// Dto object representing compute resource
type MaterializationComputeResource struct {
	// Specifies the instance type
	InstanceType *string `pulumi:"instanceType"`
}

// MaterializationComputeResourceInput is an input type that accepts MaterializationComputeResourceArgs and MaterializationComputeResourceOutput values.
// You can construct a concrete instance of `MaterializationComputeResourceInput` via:
//
//	MaterializationComputeResourceArgs{...}
type MaterializationComputeResourceInput interface {
	pulumi.Input

	ToMaterializationComputeResourceOutput() MaterializationComputeResourceOutput
	ToMaterializationComputeResourceOutputWithContext(context.Context) MaterializationComputeResourceOutput
}

// Dto object representing compute resource
type MaterializationComputeResourceArgs struct {
	// Specifies the instance type
	InstanceType pulumi.StringPtrInput `pulumi:"instanceType"`
}

func (MaterializationComputeResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MaterializationComputeResource)(nil)).Elem()
}

func (i MaterializationComputeResourceArgs) ToMaterializationComputeResourceOutput() MaterializationComputeResourceOutput {
	return i.ToMaterializationComputeResourceOutputWithContext(context.Background())
}

func (i MaterializationComputeResourceArgs) ToMaterializationComputeResourceOutputWithContext(ctx context.Context) MaterializationComputeResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MaterializationComputeResourceOutput)
}

func (i MaterializationComputeResourceArgs) ToMaterializationComputeResourcePtrOutput() MaterializationComputeResourcePtrOutput {
	return i.ToMaterializationComputeResourcePtrOutputWithContext(context.Background())
}

func (i MaterializationComputeResourceArgs) ToMaterializationComputeResourcePtrOutputWithContext(ctx context.Context) MaterializationComputeResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MaterializationComputeResourceOutput).ToMaterializationComputeResourcePtrOutputWithContext(ctx)
}

// MaterializationComputeResourcePtrInput is an input type that accepts MaterializationComputeResourceArgs, MaterializationComputeResourcePtr and MaterializationComputeResourcePtrOutput values.
// You can construct a concrete instance of `MaterializationComputeResourcePtrInput` via:
//
//	        MaterializationComputeResourceArgs{...}
//
//	or:
//
//	        nil
type MaterializationComputeResourcePtrInput interface {
	pulumi.Input

	ToMaterializationComputeResourcePtrOutput() MaterializationComputeResourcePtrOutput
	ToMaterializationComputeResourcePtrOutputWithContext(context.Context) MaterializationComputeResourcePtrOutput
}

type materializationComputeResourcePtrType MaterializationComputeResourceArgs

func MaterializationComputeResourcePtr(v *MaterializationComputeResourceArgs) MaterializationComputeResourcePtrInput {
	return (*materializationComputeResourcePtrType)(v)
}

func (*materializationComputeResourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MaterializationComputeResource)(nil)).Elem()
}

func (i *materializationComputeResourcePtrType) ToMaterializationComputeResourcePtrOutput() MaterializationComputeResourcePtrOutput {
	return i.ToMaterializationComputeResourcePtrOutputWithContext(context.Background())
}

func (i *materializationComputeResourcePtrType) ToMaterializationComputeResourcePtrOutputWithContext(ctx context.Context) MaterializationComputeResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MaterializationComputeResourcePtrOutput)
}

// Dto object representing compute resource
type MaterializationComputeResourceOutput struct{ *pulumi.OutputState }

func (MaterializationComputeResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MaterializationComputeResource)(nil)).Elem()
}

func (o MaterializationComputeResourceOutput) ToMaterializationComputeResourceOutput() MaterializationComputeResourceOutput {
	return o
}

func (o MaterializationComputeResourceOutput) ToMaterializationComputeResourceOutputWithContext(ctx context.Context) MaterializationComputeResourceOutput {
	return o
}

func (o MaterializationComputeResourceOutput) ToMaterializationComputeResourcePtrOutput() MaterializationComputeResourcePtrOutput {
	return o.ToMaterializationComputeResourcePtrOutputWithContext(context.Background())
}

func (o MaterializationComputeResourceOutput) ToMaterializationComputeResourcePtrOutputWithContext(ctx context.Context) MaterializationComputeResourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MaterializationComputeResource) *MaterializationComputeResource {
		return &v
	}).(MaterializationComputeResourcePtrOutput)
}

// Specifies the instance type
func (o MaterializationComputeResourceOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MaterializationComputeResource) *string { return v.InstanceType }).(pulumi.StringPtrOutput)
}

type MaterializationComputeResourcePtrOutput struct{ *pulumi.OutputState }

func (MaterializationComputeResourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MaterializationComputeResource)(nil)).Elem()
}

func (o MaterializationComputeResourcePtrOutput) ToMaterializationComputeResourcePtrOutput() MaterializationComputeResourcePtrOutput {
	return o
}

func (o MaterializationComputeResourcePtrOutput) ToMaterializationComputeResourcePtrOutputWithContext(ctx context.Context) MaterializationComputeResourcePtrOutput {
	return o
}

func (o MaterializationComputeResourcePtrOutput) Elem() MaterializationComputeResourceOutput {
	return o.ApplyT(func(v *MaterializationComputeResource) MaterializationComputeResource {
		if v != nil {
			return *v
		}
		var ret MaterializationComputeResource
		return ret
	}).(MaterializationComputeResourceOutput)
}

// Specifies the instance type
func (o MaterializationComputeResourcePtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MaterializationComputeResource) *string {
		if v == nil {
			return nil
		}
		return v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// Dto object representing compute resource
type MaterializationComputeResourceResponse struct {
	// Specifies the instance type
	InstanceType *string `pulumi:"instanceType"`
}

// Dto object representing compute resource
type MaterializationComputeResourceResponseOutput struct{ *pulumi.OutputState }

func (MaterializationComputeResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MaterializationComputeResourceResponse)(nil)).Elem()
}

func (o MaterializationComputeResourceResponseOutput) ToMaterializationComputeResourceResponseOutput() MaterializationComputeResourceResponseOutput {
	return o
}

func (o MaterializationComputeResourceResponseOutput) ToMaterializationComputeResourceResponseOutputWithContext(ctx context.Context) MaterializationComputeResourceResponseOutput {
	return o
}

// Specifies the instance type
func (o MaterializationComputeResourceResponseOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MaterializationComputeResourceResponse) *string { return v.InstanceType }).(pulumi.StringPtrOutput)
}

type MaterializationComputeResourceResponsePtrOutput struct{ *pulumi.OutputState }

func (MaterializationComputeResourceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MaterializationComputeResourceResponse)(nil)).Elem()
}

func (o MaterializationComputeResourceResponsePtrOutput) ToMaterializationComputeResourceResponsePtrOutput() MaterializationComputeResourceResponsePtrOutput {
	return o
}

func (o MaterializationComputeResourceResponsePtrOutput) ToMaterializationComputeResourceResponsePtrOutputWithContext(ctx context.Context) MaterializationComputeResourceResponsePtrOutput {
	return o
}

func (o MaterializationComputeResourceResponsePtrOutput) Elem() MaterializationComputeResourceResponseOutput {
	return o.ApplyT(func(v *MaterializationComputeResourceResponse) MaterializationComputeResourceResponse {
		if v != nil {
			return *v
		}
		var ret MaterializationComputeResourceResponse
		return ret
	}).(MaterializationComputeResourceResponseOutput)
}

// Specifies the instance type
func (o MaterializationComputeResourceResponsePtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MaterializationComputeResourceResponse) *string {
		if v == nil {
			return nil
		}
		return v.InstanceType
	}).(pulumi.StringPtrOutput)
}

type MaterializationSettings struct {
	// Specifies the notification details
	Notification *NotificationSetting `pulumi:"notification"`
	// Specifies the compute resource settings
	Resource *MaterializationComputeResource `pulumi:"resource"`
	// Specifies the schedule details
	Schedule *RecurrenceTrigger `pulumi:"schedule"`
	// Specifies the spark compute settings
	SparkConfiguration map[string]string `pulumi:"sparkConfiguration"`
	// Specifies the stores to which materialization should happen
	StoreType *string `pulumi:"storeType"`
}

// Defaults sets the appropriate defaults for MaterializationSettings
func (val *MaterializationSettings) Defaults() *MaterializationSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Schedule = tmp.Schedule.Defaults()

	if tmp.StoreType == nil {
		storeType_ := "None"
		tmp.StoreType = &storeType_
	}
	return &tmp
}

// MaterializationSettingsInput is an input type that accepts MaterializationSettingsArgs and MaterializationSettingsOutput values.
// You can construct a concrete instance of `MaterializationSettingsInput` via:
//
//	MaterializationSettingsArgs{...}
type MaterializationSettingsInput interface {
	pulumi.Input

	ToMaterializationSettingsOutput() MaterializationSettingsOutput
	ToMaterializationSettingsOutputWithContext(context.Context) MaterializationSettingsOutput
}

type MaterializationSettingsArgs struct {
	// Specifies the notification details
	Notification NotificationSettingPtrInput `pulumi:"notification"`
	// Specifies the compute resource settings
	Resource MaterializationComputeResourcePtrInput `pulumi:"resource"`
	// Specifies the schedule details
	Schedule RecurrenceTriggerPtrInput `pulumi:"schedule"`
	// Specifies the spark compute settings
	SparkConfiguration pulumi.StringMapInput `pulumi:"sparkConfiguration"`
	// Specifies the stores to which materialization should happen
	StoreType pulumi.StringPtrInput `pulumi:"storeType"`
}

// Defaults sets the appropriate defaults for MaterializationSettingsArgs
func (val *MaterializationSettingsArgs) Defaults() *MaterializationSettingsArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	if tmp.StoreType == nil {
		tmp.StoreType = pulumi.StringPtr("None")
	}
	return &tmp
}
func (MaterializationSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MaterializationSettings)(nil)).Elem()
}

func (i MaterializationSettingsArgs) ToMaterializationSettingsOutput() MaterializationSettingsOutput {
	return i.ToMaterializationSettingsOutputWithContext(context.Background())
}

func (i MaterializationSettingsArgs) ToMaterializationSettingsOutputWithContext(ctx context.Context) MaterializationSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MaterializationSettingsOutput)
}

func (i MaterializationSettingsArgs) ToMaterializationSettingsPtrOutput() MaterializationSettingsPtrOutput {
	return i.ToMaterializationSettingsPtrOutputWithContext(context.Background())
}

func (i MaterializationSettingsArgs) ToMaterializationSettingsPtrOutputWithContext(ctx context.Context) MaterializationSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MaterializationSettingsOutput).ToMaterializationSettingsPtrOutputWithContext(ctx)
}

// MaterializationSettingsPtrInput is an input type that accepts MaterializationSettingsArgs, MaterializationSettingsPtr and MaterializationSettingsPtrOutput values.
// You can construct a concrete instance of `MaterializationSettingsPtrInput` via:
//
//	        MaterializationSettingsArgs{...}
//
//	or:
//
//	        nil
type MaterializationSettingsPtrInput interface {
	pulumi.Input

	ToMaterializationSettingsPtrOutput() MaterializationSettingsPtrOutput
	ToMaterializationSettingsPtrOutputWithContext(context.Context) MaterializationSettingsPtrOutput
}

type materializationSettingsPtrType MaterializationSettingsArgs

func MaterializationSettingsPtr(v *MaterializationSettingsArgs) MaterializationSettingsPtrInput {
	return (*materializationSettingsPtrType)(v)
}

func (*materializationSettingsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MaterializationSettings)(nil)).Elem()
}

func (i *materializationSettingsPtrType) ToMaterializationSettingsPtrOutput() MaterializationSettingsPtrOutput {
	return i.ToMaterializationSettingsPtrOutputWithContext(context.Background())
}

func (i *materializationSettingsPtrType) ToMaterializationSettingsPtrOutputWithContext(ctx context.Context) MaterializationSettingsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MaterializationSettingsPtrOutput)
}

type MaterializationSettingsOutput struct{ *pulumi.OutputState }

func (MaterializationSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MaterializationSettings)(nil)).Elem()
}

func (o MaterializationSettingsOutput) ToMaterializationSettingsOutput() MaterializationSettingsOutput {
	return o
}

func (o MaterializationSettingsOutput) ToMaterializationSettingsOutputWithContext(ctx context.Context) MaterializationSettingsOutput {
	return o
}

func (o MaterializationSettingsOutput) ToMaterializationSettingsPtrOutput() MaterializationSettingsPtrOutput {
	return o.ToMaterializationSettingsPtrOutputWithContext(context.Background())
}

func (o MaterializationSettingsOutput) ToMaterializationSettingsPtrOutputWithContext(ctx context.Context) MaterializationSettingsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MaterializationSettings) *MaterializationSettings {
		return &v
	}).(MaterializationSettingsPtrOutput)
}

// Specifies the notification details
func (o MaterializationSettingsOutput) Notification() NotificationSettingPtrOutput {
	return o.ApplyT(func(v MaterializationSettings) *NotificationSetting { return v.Notification }).(NotificationSettingPtrOutput)
}

// Specifies the compute resource settings
func (o MaterializationSettingsOutput) Resource() MaterializationComputeResourcePtrOutput {
	return o.ApplyT(func(v MaterializationSettings) *MaterializationComputeResource { return v.Resource }).(MaterializationComputeResourcePtrOutput)
}

// Specifies the schedule details
func (o MaterializationSettingsOutput) Schedule() RecurrenceTriggerPtrOutput {
	return o.ApplyT(func(v MaterializationSettings) *RecurrenceTrigger { return v.Schedule }).(RecurrenceTriggerPtrOutput)
}

// Specifies the spark compute settings
func (o MaterializationSettingsOutput) SparkConfiguration() pulumi.StringMapOutput {
	return o.ApplyT(func(v MaterializationSettings) map[string]string { return v.SparkConfiguration }).(pulumi.StringMapOutput)
}

// Specifies the stores to which materialization should happen
func (o MaterializationSettingsOutput) StoreType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MaterializationSettings) *string { return v.StoreType }).(pulumi.StringPtrOutput)
}

type MaterializationSettingsPtrOutput struct{ *pulumi.OutputState }

func (MaterializationSettingsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MaterializationSettings)(nil)).Elem()
}

func (o MaterializationSettingsPtrOutput) ToMaterializationSettingsPtrOutput() MaterializationSettingsPtrOutput {
	return o
}

func (o MaterializationSettingsPtrOutput) ToMaterializationSettingsPtrOutputWithContext(ctx context.Context) MaterializationSettingsPtrOutput {
	return o
}

func (o MaterializationSettingsPtrOutput) Elem() MaterializationSettingsOutput {
	return o.ApplyT(func(v *MaterializationSettings) MaterializationSettings {
		if v != nil {
			return *v
		}
		var ret MaterializationSettings
		return ret
	}).(MaterializationSettingsOutput)
}

// Specifies the notification details
func (o MaterializationSettingsPtrOutput) Notification() NotificationSettingPtrOutput {
	return o.ApplyT(func(v *MaterializationSettings) *NotificationSetting {
		if v == nil {
			return nil
		}
		return v.Notification
	}).(NotificationSettingPtrOutput)
}

// Specifies the compute resource settings
func (o MaterializationSettingsPtrOutput) Resource() MaterializationComputeResourcePtrOutput {
	return o.ApplyT(func(v *MaterializationSettings) *MaterializationComputeResource {
		if v == nil {
			return nil
		}
		return v.Resource
	}).(MaterializationComputeResourcePtrOutput)
}

// Specifies the schedule details
func (o MaterializationSettingsPtrOutput) Schedule() RecurrenceTriggerPtrOutput {
	return o.ApplyT(func(v *MaterializationSettings) *RecurrenceTrigger {
		if v == nil {
			return nil
		}
		return v.Schedule
	}).(RecurrenceTriggerPtrOutput)
}

// Specifies the spark compute settings
func (o MaterializationSettingsPtrOutput) SparkConfiguration() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MaterializationSettings) map[string]string {
		if v == nil {
			return nil
		}
		return v.SparkConfiguration
	}).(pulumi.StringMapOutput)
}

// Specifies the stores to which materialization should happen
func (o MaterializationSettingsPtrOutput) StoreType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MaterializationSettings) *string {
		if v == nil {
			return nil
		}
		return v.StoreType
	}).(pulumi.StringPtrOutput)
}

type MaterializationSettingsResponse struct {
	// Specifies the notification details
	Notification *NotificationSettingResponse `pulumi:"notification"`
	// Specifies the compute resource settings
	Resource *MaterializationComputeResourceResponse `pulumi:"resource"`
	// Specifies the schedule details
	Schedule *RecurrenceTriggerResponse `pulumi:"schedule"`
	// Specifies the spark compute settings
	SparkConfiguration map[string]string `pulumi:"sparkConfiguration"`
	// Specifies the stores to which materialization should happen
	StoreType *string `pulumi:"storeType"`
}

// Defaults sets the appropriate defaults for MaterializationSettingsResponse
func (val *MaterializationSettingsResponse) Defaults() *MaterializationSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Schedule = tmp.Schedule.Defaults()

	if tmp.StoreType == nil {
		storeType_ := "None"
		tmp.StoreType = &storeType_
	}
	return &tmp
}

type MaterializationSettingsResponseOutput struct{ *pulumi.OutputState }

func (MaterializationSettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MaterializationSettingsResponse)(nil)).Elem()
}

func (o MaterializationSettingsResponseOutput) ToMaterializationSettingsResponseOutput() MaterializationSettingsResponseOutput {
	return o
}

func (o MaterializationSettingsResponseOutput) ToMaterializationSettingsResponseOutputWithContext(ctx context.Context) MaterializationSettingsResponseOutput {
	return o
}

// Specifies the notification details
func (o MaterializationSettingsResponseOutput) Notification() NotificationSettingResponsePtrOutput {
	return o.ApplyT(func(v MaterializationSettingsResponse) *NotificationSettingResponse { return v.Notification }).(NotificationSettingResponsePtrOutput)
}

// Specifies the compute resource settings
func (o MaterializationSettingsResponseOutput) Resource() MaterializationComputeResourceResponsePtrOutput {
	return o.ApplyT(func(v MaterializationSettingsResponse) *MaterializationComputeResourceResponse { return v.Resource }).(MaterializationComputeResourceResponsePtrOutput)
}

// Specifies the schedule details
func (o MaterializationSettingsResponseOutput) Schedule() RecurrenceTriggerResponsePtrOutput {
	return o.ApplyT(func(v MaterializationSettingsResponse) *RecurrenceTriggerResponse { return v.Schedule }).(RecurrenceTriggerResponsePtrOutput)
}

// Specifies the spark compute settings
func (o MaterializationSettingsResponseOutput) SparkConfiguration() pulumi.StringMapOutput {
	return o.ApplyT(func(v MaterializationSettingsResponse) map[string]string { return v.SparkConfiguration }).(pulumi.StringMapOutput)
}

// Specifies the stores to which materialization should happen
func (o MaterializationSettingsResponseOutput) StoreType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MaterializationSettingsResponse) *string { return v.StoreType }).(pulumi.StringPtrOutput)
}

type MaterializationSettingsResponsePtrOutput struct{ *pulumi.OutputState }

func (MaterializationSettingsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MaterializationSettingsResponse)(nil)).Elem()
}

func (o MaterializationSettingsResponsePtrOutput) ToMaterializationSettingsResponsePtrOutput() MaterializationSettingsResponsePtrOutput {
	return o
}

func (o MaterializationSettingsResponsePtrOutput) ToMaterializationSettingsResponsePtrOutputWithContext(ctx context.Context) MaterializationSettingsResponsePtrOutput {
	return o
}

func (o MaterializationSettingsResponsePtrOutput) Elem() MaterializationSettingsResponseOutput {
	return o.ApplyT(func(v *MaterializationSettingsResponse) MaterializationSettingsResponse {
		if v != nil {
			return *v
		}
		var ret MaterializationSettingsResponse
		return ret
	}).(MaterializationSettingsResponseOutput)
}

// Specifies the notification details
func (o MaterializationSettingsResponsePtrOutput) Notification() NotificationSettingResponsePtrOutput {
	return o.ApplyT(func(v *MaterializationSettingsResponse) *NotificationSettingResponse {
		if v == nil {
			return nil
		}
		return v.Notification
	}).(NotificationSettingResponsePtrOutput)
}

// Specifies the compute resource settings
func (o MaterializationSettingsResponsePtrOutput) Resource() MaterializationComputeResourceResponsePtrOutput {
	return o.ApplyT(func(v *MaterializationSettingsResponse) *MaterializationComputeResourceResponse {
		if v == nil {
			return nil
		}
		return v.Resource
	}).(MaterializationComputeResourceResponsePtrOutput)
}

// Specifies the schedule details
func (o MaterializationSettingsResponsePtrOutput) Schedule() RecurrenceTriggerResponsePtrOutput {
	return o.ApplyT(func(v *MaterializationSettingsResponse) *RecurrenceTriggerResponse {
		if v == nil {
			return nil
		}
		return v.Schedule
	}).(RecurrenceTriggerResponsePtrOutput)
}

// Specifies the spark compute settings
func (o MaterializationSettingsResponsePtrOutput) SparkConfiguration() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MaterializationSettingsResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.SparkConfiguration
	}).(pulumi.StringMapOutput)
}

// Specifies the stores to which materialization should happen
func (o MaterializationSettingsResponsePtrOutput) StoreType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MaterializationSettingsResponse) *string {
		if v == nil {
			return nil
		}
		return v.StoreType
	}).(pulumi.StringPtrOutput)
}

// Defines an early termination policy based on running averages of the primary metric of all runs
type MedianStoppingPolicy struct {
	// Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int `pulumi:"delayEvaluation"`
	// Interval (number of runs) between policy evaluations.
	EvaluationInterval *int `pulumi:"evaluationInterval"`
	// Expected value is 'MedianStopping'.
	PolicyType string `pulumi:"policyType"`
}

// Defaults sets the appropriate defaults for MedianStoppingPolicy
func (val *MedianStoppingPolicy) Defaults() *MedianStoppingPolicy {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DelayEvaluation == nil {
		delayEvaluation_ := 0
		tmp.DelayEvaluation = &delayEvaluation_
	}
	if tmp.EvaluationInterval == nil {
		evaluationInterval_ := 0
		tmp.EvaluationInterval = &evaluationInterval_
	}
	return &tmp
}

// Defines an early termination policy based on running averages of the primary metric of all runs
type MedianStoppingPolicyResponse struct {
	// Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int `pulumi:"delayEvaluation"`
	// Interval (number of runs) between policy evaluations.
	EvaluationInterval *int `pulumi:"evaluationInterval"`
	// Expected value is 'MedianStopping'.
	PolicyType string `pulumi:"policyType"`
}

// Defaults sets the appropriate defaults for MedianStoppingPolicyResponse
func (val *MedianStoppingPolicyResponse) Defaults() *MedianStoppingPolicyResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.DelayEvaluation == nil {
		delayEvaluation_ := 0
		tmp.DelayEvaluation = &delayEvaluation_
	}
	if tmp.EvaluationInterval == nil {
		evaluationInterval_ := 0
		tmp.EvaluationInterval = &evaluationInterval_
	}
	return &tmp
}

type ModelContainerType struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelContainerType
func (val *ModelContainerType) Defaults() *ModelContainerType {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// ModelContainerTypeInput is an input type that accepts ModelContainerTypeArgs and ModelContainerTypeOutput values.
// You can construct a concrete instance of `ModelContainerTypeInput` via:
//
//	ModelContainerTypeArgs{...}
type ModelContainerTypeInput interface {
	pulumi.Input

	ToModelContainerTypeOutput() ModelContainerTypeOutput
	ToModelContainerTypeOutputWithContext(context.Context) ModelContainerTypeOutput
}

type ModelContainerTypeArgs struct {
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Is the asset archived?
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelContainerTypeArgs
func (val *ModelContainerTypeArgs) Defaults() *ModelContainerTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (ModelContainerTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelContainerType)(nil)).Elem()
}

func (i ModelContainerTypeArgs) ToModelContainerTypeOutput() ModelContainerTypeOutput {
	return i.ToModelContainerTypeOutputWithContext(context.Background())
}

func (i ModelContainerTypeArgs) ToModelContainerTypeOutputWithContext(ctx context.Context) ModelContainerTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ModelContainerTypeOutput)
}

type ModelContainerTypeOutput struct{ *pulumi.OutputState }

func (ModelContainerTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelContainerType)(nil)).Elem()
}

func (o ModelContainerTypeOutput) ToModelContainerTypeOutput() ModelContainerTypeOutput {
	return o
}

func (o ModelContainerTypeOutput) ToModelContainerTypeOutputWithContext(ctx context.Context) ModelContainerTypeOutput {
	return o
}

// The asset description text.
func (o ModelContainerTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelContainerType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o ModelContainerTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelContainerType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The asset property dictionary.
func (o ModelContainerTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelContainerType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ModelContainerTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelContainerType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

type ModelContainerResponse struct {
	// The asset description text.
	Description *string `pulumi:"description"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// The latest version inside this container.
	LatestVersion string `pulumi:"latestVersion"`
	// The next auto incremental version
	NextVersion string `pulumi:"nextVersion"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the model container.
	ProvisioningState string `pulumi:"provisioningState"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelContainerResponse
func (val *ModelContainerResponse) Defaults() *ModelContainerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

type ModelContainerResponseOutput struct{ *pulumi.OutputState }

func (ModelContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelContainerResponse)(nil)).Elem()
}

func (o ModelContainerResponseOutput) ToModelContainerResponseOutput() ModelContainerResponseOutput {
	return o
}

func (o ModelContainerResponseOutput) ToModelContainerResponseOutputWithContext(ctx context.Context) ModelContainerResponseOutput {
	return o
}

// The asset description text.
func (o ModelContainerResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelContainerResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Is the asset archived?
func (o ModelContainerResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelContainerResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// The latest version inside this container.
func (o ModelContainerResponseOutput) LatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v ModelContainerResponse) string { return v.LatestVersion }).(pulumi.StringOutput)
}

// The next auto incremental version
func (o ModelContainerResponseOutput) NextVersion() pulumi.StringOutput {
	return o.ApplyT(func(v ModelContainerResponse) string { return v.NextVersion }).(pulumi.StringOutput)
}

// The asset property dictionary.
func (o ModelContainerResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelContainerResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the model container.
func (o ModelContainerResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v ModelContainerResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ModelContainerResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelContainerResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Model performance signal definition.
type ModelPerformanceSignal struct {
	// The data segment.
	DataSegment *MonitoringDataSegment `pulumi:"dataSegment"`
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThreshold interface{} `pulumi:"metricThreshold"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// [Required] The data produced by the production service which drift will be calculated for.
	ProductionData []interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The data to calculate drift against.
	ReferenceData interface{} `pulumi:"referenceData"`
	// Expected value is 'ModelPerformance'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for ModelPerformanceSignal
func (val *ModelPerformanceSignal) Defaults() *ModelPerformanceSignal {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Model performance signal definition.
type ModelPerformanceSignalResponse struct {
	// The data segment.
	DataSegment *MonitoringDataSegmentResponse `pulumi:"dataSegment"`
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThreshold interface{} `pulumi:"metricThreshold"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// [Required] The data produced by the production service which drift will be calculated for.
	ProductionData []interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The data to calculate drift against.
	ReferenceData interface{} `pulumi:"referenceData"`
	// Expected value is 'ModelPerformance'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for ModelPerformanceSignalResponse
func (val *ModelPerformanceSignalResponse) Defaults() *ModelPerformanceSignalResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

// Model asset version details.
type ModelVersionType struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSetting `pulumi:"autoDeleteSetting"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Mapping of model flavors to their properties.
	Flavors map[string]FlavorData `pulumi:"flavors"`
	// Intellectual Property details. Used if model is an Intellectual Property.
	IntellectualProperty *IntellectualProperty `pulumi:"intellectualProperty"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// Name of the training job which produced this model
	JobName *string `pulumi:"jobName"`
	// The storage format for this entity. Used for NCD.
	ModelType *string `pulumi:"modelType"`
	// The URI path to the model contents.
	ModelUri *string `pulumi:"modelUri"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Stage in the model lifecycle assigned to this model
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelVersionType
func (val *ModelVersionType) Defaults() *ModelVersionType {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// ModelVersionTypeInput is an input type that accepts ModelVersionTypeArgs and ModelVersionTypeOutput values.
// You can construct a concrete instance of `ModelVersionTypeInput` via:
//
//	ModelVersionTypeArgs{...}
type ModelVersionTypeInput interface {
	pulumi.Input

	ToModelVersionTypeOutput() ModelVersionTypeOutput
	ToModelVersionTypeOutputWithContext(context.Context) ModelVersionTypeOutput
}

// Model asset version details.
type ModelVersionTypeArgs struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting AutoDeleteSettingPtrInput `pulumi:"autoDeleteSetting"`
	// The asset description text.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Mapping of model flavors to their properties.
	Flavors FlavorDataMapInput `pulumi:"flavors"`
	// Intellectual Property details. Used if model is an Intellectual Property.
	IntellectualProperty IntellectualPropertyPtrInput `pulumi:"intellectualProperty"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous pulumi.BoolPtrInput `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived pulumi.BoolPtrInput `pulumi:"isArchived"`
	// Name of the training job which produced this model
	JobName pulumi.StringPtrInput `pulumi:"jobName"`
	// The storage format for this entity. Used for NCD.
	ModelType pulumi.StringPtrInput `pulumi:"modelType"`
	// The URI path to the model contents.
	ModelUri pulumi.StringPtrInput `pulumi:"modelUri"`
	// The asset property dictionary.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Stage in the model lifecycle assigned to this model
	Stage pulumi.StringPtrInput `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags pulumi.StringMapInput `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelVersionTypeArgs
func (val *ModelVersionTypeArgs) Defaults() *ModelVersionTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	if tmp.IsAnonymous == nil {
		tmp.IsAnonymous = pulumi.BoolPtr(false)
	}
	if tmp.IsArchived == nil {
		tmp.IsArchived = pulumi.BoolPtr(false)
	}
	return &tmp
}
func (ModelVersionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelVersionType)(nil)).Elem()
}

func (i ModelVersionTypeArgs) ToModelVersionTypeOutput() ModelVersionTypeOutput {
	return i.ToModelVersionTypeOutputWithContext(context.Background())
}

func (i ModelVersionTypeArgs) ToModelVersionTypeOutputWithContext(ctx context.Context) ModelVersionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ModelVersionTypeOutput)
}

// Model asset version details.
type ModelVersionTypeOutput struct{ *pulumi.OutputState }

func (ModelVersionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelVersionType)(nil)).Elem()
}

func (o ModelVersionTypeOutput) ToModelVersionTypeOutput() ModelVersionTypeOutput {
	return o
}

func (o ModelVersionTypeOutput) ToModelVersionTypeOutputWithContext(ctx context.Context) ModelVersionTypeOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o ModelVersionTypeOutput) AutoDeleteSetting() AutoDeleteSettingPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *AutoDeleteSetting { return v.AutoDeleteSetting }).(AutoDeleteSettingPtrOutput)
}

// The asset description text.
func (o ModelVersionTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Mapping of model flavors to their properties.
func (o ModelVersionTypeOutput) Flavors() FlavorDataMapOutput {
	return o.ApplyT(func(v ModelVersionType) map[string]FlavorData { return v.Flavors }).(FlavorDataMapOutput)
}

// Intellectual Property details. Used if model is an Intellectual Property.
func (o ModelVersionTypeOutput) IntellectualProperty() IntellectualPropertyPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *IntellectualProperty { return v.IntellectualProperty }).(IntellectualPropertyPtrOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o ModelVersionTypeOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o ModelVersionTypeOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// Name of the training job which produced this model
func (o ModelVersionTypeOutput) JobName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *string { return v.JobName }).(pulumi.StringPtrOutput)
}

// The storage format for this entity. Used for NCD.
func (o ModelVersionTypeOutput) ModelType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *string { return v.ModelType }).(pulumi.StringPtrOutput)
}

// The URI path to the model contents.
func (o ModelVersionTypeOutput) ModelUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *string { return v.ModelUri }).(pulumi.StringPtrOutput)
}

// The asset property dictionary.
func (o ModelVersionTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelVersionType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Stage in the model lifecycle assigned to this model
func (o ModelVersionTypeOutput) Stage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionType) *string { return v.Stage }).(pulumi.StringPtrOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ModelVersionTypeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelVersionType) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// Model asset version details.
type ModelVersionResponse struct {
	// Specifies the lifecycle setting of managed data asset.
	AutoDeleteSetting *AutoDeleteSettingResponse `pulumi:"autoDeleteSetting"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Mapping of model flavors to their properties.
	Flavors map[string]FlavorDataResponse `pulumi:"flavors"`
	// Intellectual Property details. Used if model is an Intellectual Property.
	IntellectualProperty *IntellectualPropertyResponse `pulumi:"intellectualProperty"`
	// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
	IsAnonymous *bool `pulumi:"isAnonymous"`
	// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
	IsArchived *bool `pulumi:"isArchived"`
	// Name of the training job which produced this model
	JobName *string `pulumi:"jobName"`
	// The storage format for this entity. Used for NCD.
	ModelType *string `pulumi:"modelType"`
	// The URI path to the model contents.
	ModelUri *string `pulumi:"modelUri"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the model version.
	ProvisioningState string `pulumi:"provisioningState"`
	// Stage in the model lifecycle assigned to this model
	Stage *string `pulumi:"stage"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for ModelVersionResponse
func (val *ModelVersionResponse) Defaults() *ModelVersionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AutoDeleteSetting = tmp.AutoDeleteSetting.Defaults()

	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.IsAnonymous == nil {
		isAnonymous_ := false
		tmp.IsAnonymous = &isAnonymous_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Model asset version details.
type ModelVersionResponseOutput struct{ *pulumi.OutputState }

func (ModelVersionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ModelVersionResponse)(nil)).Elem()
}

func (o ModelVersionResponseOutput) ToModelVersionResponseOutput() ModelVersionResponseOutput {
	return o
}

func (o ModelVersionResponseOutput) ToModelVersionResponseOutputWithContext(ctx context.Context) ModelVersionResponseOutput {
	return o
}

// Specifies the lifecycle setting of managed data asset.
func (o ModelVersionResponseOutput) AutoDeleteSetting() AutoDeleteSettingResponsePtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *AutoDeleteSettingResponse { return v.AutoDeleteSetting }).(AutoDeleteSettingResponsePtrOutput)
}

// The asset description text.
func (o ModelVersionResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Mapping of model flavors to their properties.
func (o ModelVersionResponseOutput) Flavors() FlavorDataResponseMapOutput {
	return o.ApplyT(func(v ModelVersionResponse) map[string]FlavorDataResponse { return v.Flavors }).(FlavorDataResponseMapOutput)
}

// Intellectual Property details. Used if model is an Intellectual Property.
func (o ModelVersionResponseOutput) IntellectualProperty() IntellectualPropertyResponsePtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *IntellectualPropertyResponse { return v.IntellectualProperty }).(IntellectualPropertyResponsePtrOutput)
}

// If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
func (o ModelVersionResponseOutput) IsAnonymous() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *bool { return v.IsAnonymous }).(pulumi.BoolPtrOutput)
}

// Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
func (o ModelVersionResponseOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *bool { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// Name of the training job which produced this model
func (o ModelVersionResponseOutput) JobName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *string { return v.JobName }).(pulumi.StringPtrOutput)
}

// The storage format for this entity. Used for NCD.
func (o ModelVersionResponseOutput) ModelType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *string { return v.ModelType }).(pulumi.StringPtrOutput)
}

// The URI path to the model contents.
func (o ModelVersionResponseOutput) ModelUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *string { return v.ModelUri }).(pulumi.StringPtrOutput)
}

// The asset property dictionary.
func (o ModelVersionResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelVersionResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the model version.
func (o ModelVersionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v ModelVersionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Stage in the model lifecycle assigned to this model
func (o ModelVersionResponseOutput) Stage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ModelVersionResponse) *string { return v.Stage }).(pulumi.StringPtrOutput)
}

// Tag dictionary. Tags can be added, removed, and updated.
func (o ModelVersionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ModelVersionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

type MonitorDefinition struct {
	// The monitor's notification settings.
	AlertNotificationSetting interface{} `pulumi:"alertNotificationSetting"`
	// [Required] The ARM resource ID of the compute resource to run the monitoring job on.
	ComputeConfiguration MonitorServerlessSparkCompute `pulumi:"computeConfiguration"`
	// The ARM resource ID of either the model or deployment targeted by this monitor.
	MonitoringTarget *MonitoringTarget `pulumi:"monitoringTarget"`
	// [Required] The signals to monitor.
	Signals map[string]interface{} `pulumi:"signals"`
}

type MonitorDefinitionResponse struct {
	// The monitor's notification settings.
	AlertNotificationSetting interface{} `pulumi:"alertNotificationSetting"`
	// [Required] The ARM resource ID of the compute resource to run the monitoring job on.
	ComputeConfiguration MonitorServerlessSparkComputeResponse `pulumi:"computeConfiguration"`
	// The ARM resource ID of either the model or deployment targeted by this monitor.
	MonitoringTarget *MonitoringTargetResponse `pulumi:"monitoringTarget"`
	// [Required] The signals to monitor.
	Signals map[string]interface{} `pulumi:"signals"`
}

// Monitor serverless spark compute definition.
type MonitorServerlessSparkCompute struct {
	// [Required] The identity scheme leveraged to by the spark jobs running on serverless Spark.
	ComputeIdentity interface{} `pulumi:"computeIdentity"`
	// Monitor compute type enum.
	// Expected value is 'ServerlessSpark'.
	ComputeType string `pulumi:"computeType"`
	// [Required] The instance type running the Spark job.
	InstanceType string `pulumi:"instanceType"`
	// [Required] The Spark runtime version.
	RuntimeVersion string `pulumi:"runtimeVersion"`
}

// Monitor serverless spark compute definition.
type MonitorServerlessSparkComputeResponse struct {
	// [Required] The identity scheme leveraged to by the spark jobs running on serverless Spark.
	ComputeIdentity interface{} `pulumi:"computeIdentity"`
	// Monitor compute type enum.
	// Expected value is 'ServerlessSpark'.
	ComputeType string `pulumi:"computeType"`
	// [Required] The instance type running the Spark job.
	InstanceType string `pulumi:"instanceType"`
	// [Required] The Spark runtime version.
	RuntimeVersion string `pulumi:"runtimeVersion"`
}

type MonitoringDataSegment struct {
	// The feature to segment the data on.
	Feature *string `pulumi:"feature"`
	// Filters for only the specified values of the given segmented feature.
	Values []string `pulumi:"values"`
}

type MonitoringDataSegmentResponse struct {
	// The feature to segment the data on.
	Feature *string `pulumi:"feature"`
	// Filters for only the specified values of the given segmented feature.
	Values []string `pulumi:"values"`
}

// Monitoring target definition.
type MonitoringTarget struct {
	// The ARM resource ID of either the deployment targeted by this monitor.
	DeploymentId *string `pulumi:"deploymentId"`
	// The ARM resource ID of either the model targeted by this monitor.
	ModelId *string `pulumi:"modelId"`
	// [Required] The machine learning task type of the model.
	TaskType string `pulumi:"taskType"`
}

// Monitoring target definition.
type MonitoringTargetResponse struct {
	// The ARM resource ID of either the deployment targeted by this monitor.
	DeploymentId *string `pulumi:"deploymentId"`
	// The ARM resource ID of either the model targeted by this monitor.
	ModelId *string `pulumi:"modelId"`
	// [Required] The machine learning task type of the model.
	TaskType string `pulumi:"taskType"`
}

type MonitoringThreshold struct {
	// The threshold value. If null, the set default is dependent on the metric type.
	Value *float64 `pulumi:"value"`
}

type MonitoringThresholdResponse struct {
	// The threshold value. If null, the set default is dependent on the metric type.
	Value *float64 `pulumi:"value"`
}

// Monitoring workspace connection definition.
type MonitoringWorkspaceConnection struct {
	// The properties of a workspace service connection to store as environment variables in the submitted jobs.
	// Key is workspace connection property path, name is environment variable key.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// The properties of a workspace service connection to store as secrets in the submitted jobs.
	// Key is workspace connection property path, name is secret key.
	Secrets map[string]string `pulumi:"secrets"`
}

// Monitoring workspace connection definition.
type MonitoringWorkspaceConnectionResponse struct {
	// The properties of a workspace service connection to store as environment variables in the submitted jobs.
	// Key is workspace connection property path, name is environment variable key.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// The properties of a workspace service connection to store as secrets in the submitted jobs.
	// Key is workspace connection property path, name is secret key.
	Secrets map[string]string `pulumi:"secrets"`
}

// MPI distribution configuration.
type Mpi struct {
	// Enum to determine the job distribution type.
	// Expected value is 'Mpi'.
	DistributionType string `pulumi:"distributionType"`
	// Number of processes per MPI node.
	ProcessCountPerInstance *int `pulumi:"processCountPerInstance"`
}

// MPI distribution configuration.
type MpiResponse struct {
	// Enum to determine the job distribution type.
	// Expected value is 'Mpi'.
	DistributionType string `pulumi:"distributionType"`
	// Number of processes per MPI node.
	ProcessCountPerInstance *int `pulumi:"processCountPerInstance"`
}

// Fixed training parameters that won't be swept over during AutoML NLP training.
type NlpFixedParameters struct {
	// Number of steps to accumulate gradients over before running a backward pass.
	GradientAccumulationSteps *int `pulumi:"gradientAccumulationSteps"`
	// The learning rate for the training procedure.
	LearningRate *float64 `pulumi:"learningRate"`
	// The type of learning rate schedule to use during the training procedure.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// The name of the model to train.
	ModelName *string `pulumi:"modelName"`
	// Number of training epochs.
	NumberOfEpochs *int `pulumi:"numberOfEpochs"`
	// The batch size for the training procedure.
	TrainingBatchSize *int `pulumi:"trainingBatchSize"`
	// The batch size to be used during evaluation.
	ValidationBatchSize *int `pulumi:"validationBatchSize"`
	// The warmup ratio, used alongside LrSchedulerType.
	WarmupRatio *float64 `pulumi:"warmupRatio"`
	// The weight decay for the training procedure.
	WeightDecay *float64 `pulumi:"weightDecay"`
}

// Defaults sets the appropriate defaults for NlpFixedParameters
func (val *NlpFixedParameters) Defaults() *NlpFixedParameters {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.LearningRateScheduler == nil {
		learningRateScheduler_ := "None"
		tmp.LearningRateScheduler = &learningRateScheduler_
	}
	return &tmp
}

// Fixed training parameters that won't be swept over during AutoML NLP training.
type NlpFixedParametersResponse struct {
	// Number of steps to accumulate gradients over before running a backward pass.
	GradientAccumulationSteps *int `pulumi:"gradientAccumulationSteps"`
	// The learning rate for the training procedure.
	LearningRate *float64 `pulumi:"learningRate"`
	// The type of learning rate schedule to use during the training procedure.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// The name of the model to train.
	ModelName *string `pulumi:"modelName"`
	// Number of training epochs.
	NumberOfEpochs *int `pulumi:"numberOfEpochs"`
	// The batch size for the training procedure.
	TrainingBatchSize *int `pulumi:"trainingBatchSize"`
	// The batch size to be used during evaluation.
	ValidationBatchSize *int `pulumi:"validationBatchSize"`
	// The warmup ratio, used alongside LrSchedulerType.
	WarmupRatio *float64 `pulumi:"warmupRatio"`
	// The weight decay for the training procedure.
	WeightDecay *float64 `pulumi:"weightDecay"`
}

// Defaults sets the appropriate defaults for NlpFixedParametersResponse
func (val *NlpFixedParametersResponse) Defaults() *NlpFixedParametersResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.LearningRateScheduler == nil {
		learningRateScheduler_ := "None"
		tmp.LearningRateScheduler = &learningRateScheduler_
	}
	return &tmp
}

// Stringified search spaces for each parameter. See below examples.
type NlpParameterSubspace struct {
	// Number of steps to accumulate gradients over before running a backward pass.
	GradientAccumulationSteps *string `pulumi:"gradientAccumulationSteps"`
	// The learning rate for the training procedure.
	LearningRate *string `pulumi:"learningRate"`
	// The type of learning rate schedule to use during the training procedure.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// The name of the model to train.
	ModelName *string `pulumi:"modelName"`
	// Number of training epochs.
	NumberOfEpochs *string `pulumi:"numberOfEpochs"`
	// The batch size for the training procedure.
	TrainingBatchSize *string `pulumi:"trainingBatchSize"`
	// The batch size to be used during evaluation.
	ValidationBatchSize *string `pulumi:"validationBatchSize"`
	// The warmup ratio, used alongside LrSchedulerType.
	WarmupRatio *string `pulumi:"warmupRatio"`
	// The weight decay for the training procedure.
	WeightDecay *string `pulumi:"weightDecay"`
}

// Stringified search spaces for each parameter. See below examples.
type NlpParameterSubspaceResponse struct {
	// Number of steps to accumulate gradients over before running a backward pass.
	GradientAccumulationSteps *string `pulumi:"gradientAccumulationSteps"`
	// The learning rate for the training procedure.
	LearningRate *string `pulumi:"learningRate"`
	// The type of learning rate schedule to use during the training procedure.
	LearningRateScheduler *string `pulumi:"learningRateScheduler"`
	// The name of the model to train.
	ModelName *string `pulumi:"modelName"`
	// Number of training epochs.
	NumberOfEpochs *string `pulumi:"numberOfEpochs"`
	// The batch size for the training procedure.
	TrainingBatchSize *string `pulumi:"trainingBatchSize"`
	// The batch size to be used during evaluation.
	ValidationBatchSize *string `pulumi:"validationBatchSize"`
	// The warmup ratio, used alongside LrSchedulerType.
	WarmupRatio *string `pulumi:"warmupRatio"`
	// The weight decay for the training procedure.
	WeightDecay *string `pulumi:"weightDecay"`
}

// Model sweeping and hyperparameter tuning related settings.
type NlpSweepSettings struct {
	// Type of early termination policy for the sweeping job.
	EarlyTermination interface{} `pulumi:"earlyTermination"`
	// [Required] Type of sampling algorithm.
	SamplingAlgorithm string `pulumi:"samplingAlgorithm"`
}

// Model sweeping and hyperparameter tuning related settings.
type NlpSweepSettingsResponse struct {
	// Type of early termination policy for the sweeping job.
	EarlyTermination interface{} `pulumi:"earlyTermination"`
	// [Required] Type of sampling algorithm.
	SamplingAlgorithm string `pulumi:"samplingAlgorithm"`
}

type NlpVerticalFeaturizationSettings struct {
	// Dataset language, useful for the text data.
	DatasetLanguage *string `pulumi:"datasetLanguage"`
}

type NlpVerticalFeaturizationSettingsResponse struct {
	// Dataset language, useful for the text data.
	DatasetLanguage *string `pulumi:"datasetLanguage"`
}

// Job execution constraints.
type NlpVerticalLimitSettings struct {
	// Maximum Concurrent AutoML iterations.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Maximum nodes to use for the experiment.
	MaxNodes *int `pulumi:"maxNodes"`
	// Number of AutoML iterations.
	MaxTrials *int `pulumi:"maxTrials"`
	// AutoML job timeout.
	Timeout *string `pulumi:"timeout"`
	// Timeout for individual HD trials.
	TrialTimeout *string `pulumi:"trialTimeout"`
}

// Defaults sets the appropriate defaults for NlpVerticalLimitSettings
func (val *NlpVerticalLimitSettings) Defaults() *NlpVerticalLimitSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MaxConcurrentTrials == nil {
		maxConcurrentTrials_ := 1
		tmp.MaxConcurrentTrials = &maxConcurrentTrials_
	}
	if tmp.MaxNodes == nil {
		maxNodes_ := 1
		tmp.MaxNodes = &maxNodes_
	}
	if tmp.MaxTrials == nil {
		maxTrials_ := 1
		tmp.MaxTrials = &maxTrials_
	}
	if tmp.Timeout == nil {
		timeout_ := "P7D"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// Job execution constraints.
type NlpVerticalLimitSettingsResponse struct {
	// Maximum Concurrent AutoML iterations.
	MaxConcurrentTrials *int `pulumi:"maxConcurrentTrials"`
	// Maximum nodes to use for the experiment.
	MaxNodes *int `pulumi:"maxNodes"`
	// Number of AutoML iterations.
	MaxTrials *int `pulumi:"maxTrials"`
	// AutoML job timeout.
	Timeout *string `pulumi:"timeout"`
	// Timeout for individual HD trials.
	TrialTimeout *string `pulumi:"trialTimeout"`
}

// Defaults sets the appropriate defaults for NlpVerticalLimitSettingsResponse
func (val *NlpVerticalLimitSettingsResponse) Defaults() *NlpVerticalLimitSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MaxConcurrentTrials == nil {
		maxConcurrentTrials_ := 1
		tmp.MaxConcurrentTrials = &maxConcurrentTrials_
	}
	if tmp.MaxNodes == nil {
		maxNodes_ := 1
		tmp.MaxNodes = &maxNodes_
	}
	if tmp.MaxTrials == nil {
		maxTrials_ := 1
		tmp.MaxTrials = &maxTrials_
	}
	if tmp.Timeout == nil {
		timeout_ := "P7D"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// Counts of various compute node states on the amlCompute.
type NodeStateCountsResponse struct {
	// Number of compute nodes in idle state.
	IdleNodeCount int `pulumi:"idleNodeCount"`
	// Number of compute nodes which are leaving the amlCompute.
	LeavingNodeCount int `pulumi:"leavingNodeCount"`
	// Number of compute nodes which are in preempted state.
	PreemptedNodeCount int `pulumi:"preemptedNodeCount"`
	// Number of compute nodes which are being prepared.
	PreparingNodeCount int `pulumi:"preparingNodeCount"`
	// Number of compute nodes which are running jobs.
	RunningNodeCount int `pulumi:"runningNodeCount"`
	// Number of compute nodes which are in unusable state.
	UnusableNodeCount int `pulumi:"unusableNodeCount"`
}

type NoneAuthTypeWorkspaceConnectionProperties struct {
	// Authentication type of the connection target
	// Expected value is 'None'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category   *string     `pulumi:"category"`
	ExpiryTime *string     `pulumi:"expiryTime"`
	Metadata   interface{} `pulumi:"metadata"`
	Target     *string     `pulumi:"target"`
}

type NoneAuthTypeWorkspaceConnectionPropertiesResponse struct {
	// Authentication type of the connection target
	// Expected value is 'None'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category   *string     `pulumi:"category"`
	ExpiryTime *string     `pulumi:"expiryTime"`
	Metadata   interface{} `pulumi:"metadata"`
	Target     *string     `pulumi:"target"`
}

// Empty/none datastore credentials.
type NoneDatastoreCredentials struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'None'.
	CredentialsType string `pulumi:"credentialsType"`
}

// Empty/none datastore credentials.
type NoneDatastoreCredentialsResponse struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'None'.
	CredentialsType string `pulumi:"credentialsType"`
}

type NotebookPreparationErrorResponse struct {
	ErrorMessage *string `pulumi:"errorMessage"`
	StatusCode   *int    `pulumi:"statusCode"`
}

type NotebookPreparationErrorResponseOutput struct{ *pulumi.OutputState }

func (NotebookPreparationErrorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotebookPreparationErrorResponse)(nil)).Elem()
}

func (o NotebookPreparationErrorResponseOutput) ToNotebookPreparationErrorResponseOutput() NotebookPreparationErrorResponseOutput {
	return o
}

func (o NotebookPreparationErrorResponseOutput) ToNotebookPreparationErrorResponseOutputWithContext(ctx context.Context) NotebookPreparationErrorResponseOutput {
	return o
}

func (o NotebookPreparationErrorResponseOutput) ErrorMessage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotebookPreparationErrorResponse) *string { return v.ErrorMessage }).(pulumi.StringPtrOutput)
}

func (o NotebookPreparationErrorResponseOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v NotebookPreparationErrorResponse) *int { return v.StatusCode }).(pulumi.IntPtrOutput)
}

type NotebookPreparationErrorResponsePtrOutput struct{ *pulumi.OutputState }

func (NotebookPreparationErrorResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotebookPreparationErrorResponse)(nil)).Elem()
}

func (o NotebookPreparationErrorResponsePtrOutput) ToNotebookPreparationErrorResponsePtrOutput() NotebookPreparationErrorResponsePtrOutput {
	return o
}

func (o NotebookPreparationErrorResponsePtrOutput) ToNotebookPreparationErrorResponsePtrOutputWithContext(ctx context.Context) NotebookPreparationErrorResponsePtrOutput {
	return o
}

func (o NotebookPreparationErrorResponsePtrOutput) Elem() NotebookPreparationErrorResponseOutput {
	return o.ApplyT(func(v *NotebookPreparationErrorResponse) NotebookPreparationErrorResponse {
		if v != nil {
			return *v
		}
		var ret NotebookPreparationErrorResponse
		return ret
	}).(NotebookPreparationErrorResponseOutput)
}

func (o NotebookPreparationErrorResponsePtrOutput) ErrorMessage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NotebookPreparationErrorResponse) *string {
		if v == nil {
			return nil
		}
		return v.ErrorMessage
	}).(pulumi.StringPtrOutput)
}

func (o NotebookPreparationErrorResponsePtrOutput) StatusCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NotebookPreparationErrorResponse) *int {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(pulumi.IntPtrOutput)
}

type NotebookResourceInfoResponse struct {
	Fqdn                 *string `pulumi:"fqdn"`
	IsPrivateLinkEnabled *bool   `pulumi:"isPrivateLinkEnabled"`
	// The error that occurs when preparing notebook.
	NotebookPreparationError *NotebookPreparationErrorResponse `pulumi:"notebookPreparationError"`
	// the data plane resourceId that used to initialize notebook component
	ResourceId *string `pulumi:"resourceId"`
}

type NotebookResourceInfoResponseOutput struct{ *pulumi.OutputState }

func (NotebookResourceInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotebookResourceInfoResponse)(nil)).Elem()
}

func (o NotebookResourceInfoResponseOutput) ToNotebookResourceInfoResponseOutput() NotebookResourceInfoResponseOutput {
	return o
}

func (o NotebookResourceInfoResponseOutput) ToNotebookResourceInfoResponseOutputWithContext(ctx context.Context) NotebookResourceInfoResponseOutput {
	return o
}

func (o NotebookResourceInfoResponseOutput) Fqdn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotebookResourceInfoResponse) *string { return v.Fqdn }).(pulumi.StringPtrOutput)
}

func (o NotebookResourceInfoResponseOutput) IsPrivateLinkEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NotebookResourceInfoResponse) *bool { return v.IsPrivateLinkEnabled }).(pulumi.BoolPtrOutput)
}

// The error that occurs when preparing notebook.
func (o NotebookResourceInfoResponseOutput) NotebookPreparationError() NotebookPreparationErrorResponsePtrOutput {
	return o.ApplyT(func(v NotebookResourceInfoResponse) *NotebookPreparationErrorResponse {
		return v.NotebookPreparationError
	}).(NotebookPreparationErrorResponsePtrOutput)
}

// the data plane resourceId that used to initialize notebook component
func (o NotebookResourceInfoResponseOutput) ResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotebookResourceInfoResponse) *string { return v.ResourceId }).(pulumi.StringPtrOutput)
}

// Configuration for notification.
type NotificationSetting struct {
	// Send email notification to user on specified notification type
	EmailOn []string `pulumi:"emailOn"`
	// This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
	Emails []string `pulumi:"emails"`
	// Send webhook callback to a service. Key is a user-provided name for the webhook.
	Webhooks map[string]AzureDevOpsWebhook `pulumi:"webhooks"`
}

// NotificationSettingInput is an input type that accepts NotificationSettingArgs and NotificationSettingOutput values.
// You can construct a concrete instance of `NotificationSettingInput` via:
//
//	NotificationSettingArgs{...}
type NotificationSettingInput interface {
	pulumi.Input

	ToNotificationSettingOutput() NotificationSettingOutput
	ToNotificationSettingOutputWithContext(context.Context) NotificationSettingOutput
}

// Configuration for notification.
type NotificationSettingArgs struct {
	// Send email notification to user on specified notification type
	EmailOn pulumi.StringArrayInput `pulumi:"emailOn"`
	// This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
	Emails pulumi.StringArrayInput `pulumi:"emails"`
	// Send webhook callback to a service. Key is a user-provided name for the webhook.
	Webhooks AzureDevOpsWebhookMapInput `pulumi:"webhooks"`
}

func (NotificationSettingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationSetting)(nil)).Elem()
}

func (i NotificationSettingArgs) ToNotificationSettingOutput() NotificationSettingOutput {
	return i.ToNotificationSettingOutputWithContext(context.Background())
}

func (i NotificationSettingArgs) ToNotificationSettingOutputWithContext(ctx context.Context) NotificationSettingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationSettingOutput)
}

func (i NotificationSettingArgs) ToNotificationSettingPtrOutput() NotificationSettingPtrOutput {
	return i.ToNotificationSettingPtrOutputWithContext(context.Background())
}

func (i NotificationSettingArgs) ToNotificationSettingPtrOutputWithContext(ctx context.Context) NotificationSettingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationSettingOutput).ToNotificationSettingPtrOutputWithContext(ctx)
}

// NotificationSettingPtrInput is an input type that accepts NotificationSettingArgs, NotificationSettingPtr and NotificationSettingPtrOutput values.
// You can construct a concrete instance of `NotificationSettingPtrInput` via:
//
//	        NotificationSettingArgs{...}
//
//	or:
//
//	        nil
type NotificationSettingPtrInput interface {
	pulumi.Input

	ToNotificationSettingPtrOutput() NotificationSettingPtrOutput
	ToNotificationSettingPtrOutputWithContext(context.Context) NotificationSettingPtrOutput
}

type notificationSettingPtrType NotificationSettingArgs

func NotificationSettingPtr(v *NotificationSettingArgs) NotificationSettingPtrInput {
	return (*notificationSettingPtrType)(v)
}

func (*notificationSettingPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationSetting)(nil)).Elem()
}

func (i *notificationSettingPtrType) ToNotificationSettingPtrOutput() NotificationSettingPtrOutput {
	return i.ToNotificationSettingPtrOutputWithContext(context.Background())
}

func (i *notificationSettingPtrType) ToNotificationSettingPtrOutputWithContext(ctx context.Context) NotificationSettingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationSettingPtrOutput)
}

// Configuration for notification.
type NotificationSettingOutput struct{ *pulumi.OutputState }

func (NotificationSettingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationSetting)(nil)).Elem()
}

func (o NotificationSettingOutput) ToNotificationSettingOutput() NotificationSettingOutput {
	return o
}

func (o NotificationSettingOutput) ToNotificationSettingOutputWithContext(ctx context.Context) NotificationSettingOutput {
	return o
}

func (o NotificationSettingOutput) ToNotificationSettingPtrOutput() NotificationSettingPtrOutput {
	return o.ToNotificationSettingPtrOutputWithContext(context.Background())
}

func (o NotificationSettingOutput) ToNotificationSettingPtrOutputWithContext(ctx context.Context) NotificationSettingPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NotificationSetting) *NotificationSetting {
		return &v
	}).(NotificationSettingPtrOutput)
}

// Send email notification to user on specified notification type
func (o NotificationSettingOutput) EmailOn() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NotificationSetting) []string { return v.EmailOn }).(pulumi.StringArrayOutput)
}

// This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
func (o NotificationSettingOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NotificationSetting) []string { return v.Emails }).(pulumi.StringArrayOutput)
}

// Send webhook callback to a service. Key is a user-provided name for the webhook.
func (o NotificationSettingOutput) Webhooks() AzureDevOpsWebhookMapOutput {
	return o.ApplyT(func(v NotificationSetting) map[string]AzureDevOpsWebhook { return v.Webhooks }).(AzureDevOpsWebhookMapOutput)
}

type NotificationSettingPtrOutput struct{ *pulumi.OutputState }

func (NotificationSettingPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationSetting)(nil)).Elem()
}

func (o NotificationSettingPtrOutput) ToNotificationSettingPtrOutput() NotificationSettingPtrOutput {
	return o
}

func (o NotificationSettingPtrOutput) ToNotificationSettingPtrOutputWithContext(ctx context.Context) NotificationSettingPtrOutput {
	return o
}

func (o NotificationSettingPtrOutput) Elem() NotificationSettingOutput {
	return o.ApplyT(func(v *NotificationSetting) NotificationSetting {
		if v != nil {
			return *v
		}
		var ret NotificationSetting
		return ret
	}).(NotificationSettingOutput)
}

// Send email notification to user on specified notification type
func (o NotificationSettingPtrOutput) EmailOn() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NotificationSetting) []string {
		if v == nil {
			return nil
		}
		return v.EmailOn
	}).(pulumi.StringArrayOutput)
}

// This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
func (o NotificationSettingPtrOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NotificationSetting) []string {
		if v == nil {
			return nil
		}
		return v.Emails
	}).(pulumi.StringArrayOutput)
}

// Send webhook callback to a service. Key is a user-provided name for the webhook.
func (o NotificationSettingPtrOutput) Webhooks() AzureDevOpsWebhookMapOutput {
	return o.ApplyT(func(v *NotificationSetting) map[string]AzureDevOpsWebhook {
		if v == nil {
			return nil
		}
		return v.Webhooks
	}).(AzureDevOpsWebhookMapOutput)
}

// Configuration for notification.
type NotificationSettingResponse struct {
	// Send email notification to user on specified notification type
	EmailOn []string `pulumi:"emailOn"`
	// This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
	Emails []string `pulumi:"emails"`
	// Send webhook callback to a service. Key is a user-provided name for the webhook.
	Webhooks map[string]AzureDevOpsWebhookResponse `pulumi:"webhooks"`
}

// Configuration for notification.
type NotificationSettingResponseOutput struct{ *pulumi.OutputState }

func (NotificationSettingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationSettingResponse)(nil)).Elem()
}

func (o NotificationSettingResponseOutput) ToNotificationSettingResponseOutput() NotificationSettingResponseOutput {
	return o
}

func (o NotificationSettingResponseOutput) ToNotificationSettingResponseOutputWithContext(ctx context.Context) NotificationSettingResponseOutput {
	return o
}

// Send email notification to user on specified notification type
func (o NotificationSettingResponseOutput) EmailOn() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NotificationSettingResponse) []string { return v.EmailOn }).(pulumi.StringArrayOutput)
}

// This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
func (o NotificationSettingResponseOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NotificationSettingResponse) []string { return v.Emails }).(pulumi.StringArrayOutput)
}

// Send webhook callback to a service. Key is a user-provided name for the webhook.
func (o NotificationSettingResponseOutput) Webhooks() AzureDevOpsWebhookResponseMapOutput {
	return o.ApplyT(func(v NotificationSettingResponse) map[string]AzureDevOpsWebhookResponse { return v.Webhooks }).(AzureDevOpsWebhookResponseMapOutput)
}

type NotificationSettingResponsePtrOutput struct{ *pulumi.OutputState }

func (NotificationSettingResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationSettingResponse)(nil)).Elem()
}

func (o NotificationSettingResponsePtrOutput) ToNotificationSettingResponsePtrOutput() NotificationSettingResponsePtrOutput {
	return o
}

func (o NotificationSettingResponsePtrOutput) ToNotificationSettingResponsePtrOutputWithContext(ctx context.Context) NotificationSettingResponsePtrOutput {
	return o
}

func (o NotificationSettingResponsePtrOutput) Elem() NotificationSettingResponseOutput {
	return o.ApplyT(func(v *NotificationSettingResponse) NotificationSettingResponse {
		if v != nil {
			return *v
		}
		var ret NotificationSettingResponse
		return ret
	}).(NotificationSettingResponseOutput)
}

// Send email notification to user on specified notification type
func (o NotificationSettingResponsePtrOutput) EmailOn() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NotificationSettingResponse) []string {
		if v == nil {
			return nil
		}
		return v.EmailOn
	}).(pulumi.StringArrayOutput)
}

// This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
func (o NotificationSettingResponsePtrOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NotificationSettingResponse) []string {
		if v == nil {
			return nil
		}
		return v.Emails
	}).(pulumi.StringArrayOutput)
}

// Send webhook callback to a service. Key is a user-provided name for the webhook.
func (o NotificationSettingResponsePtrOutput) Webhooks() AzureDevOpsWebhookResponseMapOutput {
	return o.ApplyT(func(v *NotificationSettingResponse) map[string]AzureDevOpsWebhookResponse {
		if v == nil {
			return nil
		}
		return v.Webhooks
	}).(AzureDevOpsWebhookResponseMapOutput)
}

type NumericalDataDriftMetricThreshold struct {
	// Expected value is 'Numerical'.
	DataType string `pulumi:"dataType"`
	// [Required] The numerical data drift metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

type NumericalDataDriftMetricThresholdResponse struct {
	// Expected value is 'Numerical'.
	DataType string `pulumi:"dataType"`
	// [Required] The numerical data drift metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

type NumericalDataQualityMetricThreshold struct {
	// Expected value is 'Numerical'.
	DataType string `pulumi:"dataType"`
	// [Required] The numerical data quality metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

type NumericalDataQualityMetricThresholdResponse struct {
	// Expected value is 'Numerical'.
	DataType string `pulumi:"dataType"`
	// [Required] The numerical data quality metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

type NumericalPredictionDriftMetricThreshold struct {
	// Expected value is 'Numerical'.
	DataType string `pulumi:"dataType"`
	// [Required] The numerical prediction drift metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

type NumericalPredictionDriftMetricThresholdResponse struct {
	// Expected value is 'Numerical'.
	DataType string `pulumi:"dataType"`
	// [Required] The numerical prediction drift metric to calculate.
	Metric string `pulumi:"metric"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

// Optimization objective.
type Objective struct {
	// [Required] Defines supported metric goals for hyperparameter tuning
	Goal string `pulumi:"goal"`
	// [Required] Name of the metric to optimize.
	PrimaryMetric string `pulumi:"primaryMetric"`
}

// Optimization objective.
type ObjectiveResponse struct {
	// [Required] Defines supported metric goals for hyperparameter tuning
	Goal string `pulumi:"goal"`
	// [Required] Name of the metric to optimize.
	PrimaryMetric string `pulumi:"primaryMetric"`
}

// OneLake (Trident) datastore configuration.
type OneLakeDatastore struct {
	// [Required] OneLake artifact backing the datastore.
	Artifact LakeHouseArtifact `pulumi:"artifact"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'OneLake'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// OneLake endpoint to use for the datastore.
	Endpoint *string `pulumi:"endpoint"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualProperty `pulumi:"intellectualProperty"`
	// [Required] OneLake workspace name.
	OneLakeWorkspaceName string `pulumi:"oneLakeWorkspaceName"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for OneLakeDatastore
func (val *OneLakeDatastore) Defaults() *OneLakeDatastore {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.ServiceDataAccessAuthIdentity == nil {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// OneLake (Trident) datastore configuration.
type OneLakeDatastoreResponse struct {
	// [Required] OneLake artifact backing the datastore.
	Artifact LakeHouseArtifactResponse `pulumi:"artifact"`
	// [Required] Account credentials.
	Credentials interface{} `pulumi:"credentials"`
	// Enum to determine the datastore contents type.
	// Expected value is 'OneLake'.
	DatastoreType string `pulumi:"datastoreType"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// OneLake endpoint to use for the datastore.
	Endpoint *string `pulumi:"endpoint"`
	// Intellectual Property details.
	IntellectualProperty *IntellectualPropertyResponse `pulumi:"intellectualProperty"`
	// Readonly property to indicate if datastore is the workspace default datastore
	IsDefault bool `pulumi:"isDefault"`
	// [Required] OneLake workspace name.
	OneLakeWorkspaceName string `pulumi:"oneLakeWorkspaceName"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Indicates which identity to use to authenticate service data access to customer's storage.
	ServiceDataAccessAuthIdentity *string `pulumi:"serviceDataAccessAuthIdentity"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for OneLakeDatastoreResponse
func (val *OneLakeDatastoreResponse) Defaults() *OneLakeDatastoreResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.IntellectualProperty = tmp.IntellectualProperty.Defaults()

	if tmp.ServiceDataAccessAuthIdentity == nil {
		serviceDataAccessAuthIdentity_ := "None"
		tmp.ServiceDataAccessAuthIdentity = &serviceDataAccessAuthIdentity_
	}
	return &tmp
}

// Online endpoint configuration
type OnlineEndpointType struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode string `pulumi:"authMode"`
	// ARM resource ID of the compute if it exists.
	// optional
	Compute *string `pulumi:"compute"`
	// Description of the inference endpoint.
	Description *string `pulumi:"description"`
	// EndpointAuthKeys to set initially on an Endpoint.
	// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
	Keys *EndpointAuthKeys `pulumi:"keys"`
	// Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
	MirrorTraffic map[string]int `pulumi:"mirrorTraffic"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
	PublicNetworkAccess *string `pulumi:"publicNetworkAccess"`
	// Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
	Traffic map[string]int `pulumi:"traffic"`
}

// Defaults sets the appropriate defaults for OnlineEndpointType
func (val *OnlineEndpointType) Defaults() *OnlineEndpointType {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.PublicNetworkAccess == nil {
		publicNetworkAccess_ := "Enabled"
		tmp.PublicNetworkAccess = &publicNetworkAccess_
	}
	return &tmp
}

// OnlineEndpointTypeInput is an input type that accepts OnlineEndpointTypeArgs and OnlineEndpointTypeOutput values.
// You can construct a concrete instance of `OnlineEndpointTypeInput` via:
//
//	OnlineEndpointTypeArgs{...}
type OnlineEndpointTypeInput interface {
	pulumi.Input

	ToOnlineEndpointTypeOutput() OnlineEndpointTypeOutput
	ToOnlineEndpointTypeOutputWithContext(context.Context) OnlineEndpointTypeOutput
}

// Online endpoint configuration
type OnlineEndpointTypeArgs struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode pulumi.StringInput `pulumi:"authMode"`
	// ARM resource ID of the compute if it exists.
	// optional
	Compute pulumi.StringPtrInput `pulumi:"compute"`
	// Description of the inference endpoint.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// EndpointAuthKeys to set initially on an Endpoint.
	// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
	Keys EndpointAuthKeysPtrInput `pulumi:"keys"`
	// Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
	MirrorTraffic pulumi.IntMapInput `pulumi:"mirrorTraffic"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
	PublicNetworkAccess pulumi.StringPtrInput `pulumi:"publicNetworkAccess"`
	// Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
	Traffic pulumi.IntMapInput `pulumi:"traffic"`
}

// Defaults sets the appropriate defaults for OnlineEndpointTypeArgs
func (val *OnlineEndpointTypeArgs) Defaults() *OnlineEndpointTypeArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.PublicNetworkAccess == nil {
		tmp.PublicNetworkAccess = pulumi.StringPtr("Enabled")
	}
	return &tmp
}
func (OnlineEndpointTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OnlineEndpointType)(nil)).Elem()
}

func (i OnlineEndpointTypeArgs) ToOnlineEndpointTypeOutput() OnlineEndpointTypeOutput {
	return i.ToOnlineEndpointTypeOutputWithContext(context.Background())
}

func (i OnlineEndpointTypeArgs) ToOnlineEndpointTypeOutputWithContext(ctx context.Context) OnlineEndpointTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OnlineEndpointTypeOutput)
}

// Online endpoint configuration
type OnlineEndpointTypeOutput struct{ *pulumi.OutputState }

func (OnlineEndpointTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OnlineEndpointType)(nil)).Elem()
}

func (o OnlineEndpointTypeOutput) ToOnlineEndpointTypeOutput() OnlineEndpointTypeOutput {
	return o
}

func (o OnlineEndpointTypeOutput) ToOnlineEndpointTypeOutputWithContext(ctx context.Context) OnlineEndpointTypeOutput {
	return o
}

// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
func (o OnlineEndpointTypeOutput) AuthMode() pulumi.StringOutput {
	return o.ApplyT(func(v OnlineEndpointType) string { return v.AuthMode }).(pulumi.StringOutput)
}

// ARM resource ID of the compute if it exists.
// optional
func (o OnlineEndpointTypeOutput) Compute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointType) *string { return v.Compute }).(pulumi.StringPtrOutput)
}

// Description of the inference endpoint.
func (o OnlineEndpointTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// EndpointAuthKeys to set initially on an Endpoint.
// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
func (o OnlineEndpointTypeOutput) Keys() EndpointAuthKeysPtrOutput {
	return o.ApplyT(func(v OnlineEndpointType) *EndpointAuthKeys { return v.Keys }).(EndpointAuthKeysPtrOutput)
}

// Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
func (o OnlineEndpointTypeOutput) MirrorTraffic() pulumi.IntMapOutput {
	return o.ApplyT(func(v OnlineEndpointType) map[string]int { return v.MirrorTraffic }).(pulumi.IntMapOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o OnlineEndpointTypeOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v OnlineEndpointType) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
func (o OnlineEndpointTypeOutput) PublicNetworkAccess() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointType) *string { return v.PublicNetworkAccess }).(pulumi.StringPtrOutput)
}

// Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
func (o OnlineEndpointTypeOutput) Traffic() pulumi.IntMapOutput {
	return o.ApplyT(func(v OnlineEndpointType) map[string]int { return v.Traffic }).(pulumi.IntMapOutput)
}

// Online endpoint configuration
type OnlineEndpointResponse struct {
	// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
	AuthMode string `pulumi:"authMode"`
	// ARM resource ID of the compute if it exists.
	// optional
	Compute *string `pulumi:"compute"`
	// Description of the inference endpoint.
	Description *string `pulumi:"description"`
	// Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
	MirrorTraffic map[string]int `pulumi:"mirrorTraffic"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// Provisioning state for the endpoint.
	ProvisioningState string `pulumi:"provisioningState"`
	// Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
	PublicNetworkAccess *string `pulumi:"publicNetworkAccess"`
	// Endpoint URI.
	ScoringUri string `pulumi:"scoringUri"`
	// Endpoint Swagger URI.
	SwaggerUri string `pulumi:"swaggerUri"`
	// Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
	Traffic map[string]int `pulumi:"traffic"`
}

// Defaults sets the appropriate defaults for OnlineEndpointResponse
func (val *OnlineEndpointResponse) Defaults() *OnlineEndpointResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.PublicNetworkAccess == nil {
		publicNetworkAccess_ := "Enabled"
		tmp.PublicNetworkAccess = &publicNetworkAccess_
	}
	return &tmp
}

// Online endpoint configuration
type OnlineEndpointResponseOutput struct{ *pulumi.OutputState }

func (OnlineEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OnlineEndpointResponse)(nil)).Elem()
}

func (o OnlineEndpointResponseOutput) ToOnlineEndpointResponseOutput() OnlineEndpointResponseOutput {
	return o
}

func (o OnlineEndpointResponseOutput) ToOnlineEndpointResponseOutputWithContext(ctx context.Context) OnlineEndpointResponseOutput {
	return o
}

// [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
func (o OnlineEndpointResponseOutput) AuthMode() pulumi.StringOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) string { return v.AuthMode }).(pulumi.StringOutput)
}

// ARM resource ID of the compute if it exists.
// optional
func (o OnlineEndpointResponseOutput) Compute() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) *string { return v.Compute }).(pulumi.StringPtrOutput)
}

// Description of the inference endpoint.
func (o OnlineEndpointResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
func (o OnlineEndpointResponseOutput) MirrorTraffic() pulumi.IntMapOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) map[string]int { return v.MirrorTraffic }).(pulumi.IntMapOutput)
}

// Property dictionary. Properties can be added, but not removed or altered.
func (o OnlineEndpointResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// Provisioning state for the endpoint.
func (o OnlineEndpointResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
func (o OnlineEndpointResponseOutput) PublicNetworkAccess() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) *string { return v.PublicNetworkAccess }).(pulumi.StringPtrOutput)
}

// Endpoint URI.
func (o OnlineEndpointResponseOutput) ScoringUri() pulumi.StringOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) string { return v.ScoringUri }).(pulumi.StringOutput)
}

// Endpoint Swagger URI.
func (o OnlineEndpointResponseOutput) SwaggerUri() pulumi.StringOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) string { return v.SwaggerUri }).(pulumi.StringOutput)
}

// Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
func (o OnlineEndpointResponseOutput) Traffic() pulumi.IntMapOutput {
	return o.ApplyT(func(v OnlineEndpointResponse) map[string]int { return v.Traffic }).(pulumi.IntMapOutput)
}

// Online deployment scoring requests configuration.
type OnlineRequestSettings struct {
	// The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
	MaxConcurrentRequestsPerInstance *int `pulumi:"maxConcurrentRequestsPerInstance"`
	// The maximum amount of time a request will stay in the queue in ISO 8601 format.
	// Defaults to 500ms.
	MaxQueueWait *string `pulumi:"maxQueueWait"`
	// The scoring timeout in ISO 8601 format.
	// Defaults to 5000ms.
	RequestTimeout *string `pulumi:"requestTimeout"`
}

// Defaults sets the appropriate defaults for OnlineRequestSettings
func (val *OnlineRequestSettings) Defaults() *OnlineRequestSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MaxConcurrentRequestsPerInstance == nil {
		maxConcurrentRequestsPerInstance_ := 1
		tmp.MaxConcurrentRequestsPerInstance = &maxConcurrentRequestsPerInstance_
	}
	if tmp.MaxQueueWait == nil {
		maxQueueWait_ := "PT0.5S"
		tmp.MaxQueueWait = &maxQueueWait_
	}
	if tmp.RequestTimeout == nil {
		requestTimeout_ := "PT5S"
		tmp.RequestTimeout = &requestTimeout_
	}
	return &tmp
}

// Online deployment scoring requests configuration.
type OnlineRequestSettingsResponse struct {
	// The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
	MaxConcurrentRequestsPerInstance *int `pulumi:"maxConcurrentRequestsPerInstance"`
	// The maximum amount of time a request will stay in the queue in ISO 8601 format.
	// Defaults to 500ms.
	MaxQueueWait *string `pulumi:"maxQueueWait"`
	// The scoring timeout in ISO 8601 format.
	// Defaults to 5000ms.
	RequestTimeout *string `pulumi:"requestTimeout"`
}

// Defaults sets the appropriate defaults for OnlineRequestSettingsResponse
func (val *OnlineRequestSettingsResponse) Defaults() *OnlineRequestSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MaxConcurrentRequestsPerInstance == nil {
		maxConcurrentRequestsPerInstance_ := 1
		tmp.MaxConcurrentRequestsPerInstance = &maxConcurrentRequestsPerInstance_
	}
	if tmp.MaxQueueWait == nil {
		maxQueueWait_ := "PT0.5S"
		tmp.MaxQueueWait = &maxQueueWait_
	}
	if tmp.RequestTimeout == nil {
		requestTimeout_ := "PT5S"
		tmp.RequestTimeout = &requestTimeout_
	}
	return &tmp
}

// Reference to an asset via its path in a job output.
type OutputPathAssetReference struct {
	// ARM resource ID of the job.
	JobId *string `pulumi:"jobId"`
	// The path of the file/directory in the job output.
	Path *string `pulumi:"path"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'OutputPath'.
	ReferenceType string `pulumi:"referenceType"`
}

// Reference to an asset via its path in a job output.
type OutputPathAssetReferenceResponse struct {
	// ARM resource ID of the job.
	JobId *string `pulumi:"jobId"`
	// The path of the file/directory in the job output.
	Path *string `pulumi:"path"`
	// Enum to determine which reference method to use for an asset.
	// Expected value is 'OutputPath'.
	ReferenceType string `pulumi:"referenceType"`
}

type PATAuthTypeWorkspaceConnectionProperties struct {
	// Authentication type of the connection target
	// Expected value is 'PAT'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category    *string                                 `pulumi:"category"`
	Credentials *WorkspaceConnectionPersonalAccessToken `pulumi:"credentials"`
	ExpiryTime  *string                                 `pulumi:"expiryTime"`
	Metadata    interface{}                             `pulumi:"metadata"`
	Target      *string                                 `pulumi:"target"`
}

type PATAuthTypeWorkspaceConnectionPropertiesResponse struct {
	// Authentication type of the connection target
	// Expected value is 'PAT'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category    *string                                         `pulumi:"category"`
	Credentials *WorkspaceConnectionPersonalAccessTokenResponse `pulumi:"credentials"`
	ExpiryTime  *string                                         `pulumi:"expiryTime"`
	Metadata    interface{}                                     `pulumi:"metadata"`
	Target      *string                                         `pulumi:"target"`
}

type PasswordResponse struct {
	Name  string `pulumi:"name"`
	Value string `pulumi:"value"`
}

type PasswordResponseOutput struct{ *pulumi.OutputState }

func (PasswordResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PasswordResponse)(nil)).Elem()
}

func (o PasswordResponseOutput) ToPasswordResponseOutput() PasswordResponseOutput {
	return o
}

func (o PasswordResponseOutput) ToPasswordResponseOutputWithContext(ctx context.Context) PasswordResponseOutput {
	return o
}

func (o PasswordResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v PasswordResponse) string { return v.Name }).(pulumi.StringOutput)
}

func (o PasswordResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v PasswordResponse) string { return v.Value }).(pulumi.StringOutput)
}

type PasswordResponseArrayOutput struct{ *pulumi.OutputState }

func (PasswordResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PasswordResponse)(nil)).Elem()
}

func (o PasswordResponseArrayOutput) ToPasswordResponseArrayOutput() PasswordResponseArrayOutput {
	return o
}

func (o PasswordResponseArrayOutput) ToPasswordResponseArrayOutputWithContext(ctx context.Context) PasswordResponseArrayOutput {
	return o
}

func (o PasswordResponseArrayOutput) Index(i pulumi.IntInput) PasswordResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PasswordResponse {
		return vs[0].([]PasswordResponse)[vs[1].(int)]
	}).(PasswordResponseOutput)
}

// Settings for a personal compute instance.
type PersonalComputeInstanceSettings struct {
	// A user explicitly assigned to a personal compute instance.
	AssignedUser *AssignedUser `pulumi:"assignedUser"`
}

// Settings for a personal compute instance.
type PersonalComputeInstanceSettingsResponse struct {
	// A user explicitly assigned to a personal compute instance.
	AssignedUser *AssignedUserResponse `pulumi:"assignedUser"`
}

// Pipeline Job definition: defines generic to MFE attributes.
type PipelineJob struct {
	// ARM resource ID of the component resource.
	ComponentId *string `pulumi:"componentId"`
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Inputs for the pipeline job.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'Pipeline'.
	JobType string `pulumi:"jobType"`
	// Jobs construct the Pipeline Job.
	Jobs map[string]interface{} `pulumi:"jobs"`
	// Notification setting for the job
	NotificationSetting *NotificationSetting `pulumi:"notificationSetting"`
	// Outputs for the pipeline job
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Configuration for secrets to be made available during runtime.
	SecretsConfiguration map[string]SecretConfiguration `pulumi:"secretsConfiguration"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobService `pulumi:"services"`
	// Pipeline settings, for things like ContinueRunOnStepFailure etc.
	Settings interface{} `pulumi:"settings"`
	// ARM resource ID of source job.
	SourceJobId *string `pulumi:"sourceJobId"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for PipelineJob
func (val *PipelineJob) Defaults() *PipelineJob {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ExperimentName == nil {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

// Pipeline Job definition: defines generic to MFE attributes.
type PipelineJobResponse struct {
	// ARM resource ID of the component resource.
	ComponentId *string `pulumi:"componentId"`
	// ARM resource ID of the compute resource.
	ComputeId *string `pulumi:"computeId"`
	// The asset description text.
	Description *string `pulumi:"description"`
	// Display name of job.
	DisplayName *string `pulumi:"displayName"`
	// The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `pulumi:"experimentName"`
	// Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity interface{} `pulumi:"identity"`
	// Inputs for the pipeline job.
	Inputs map[string]interface{} `pulumi:"inputs"`
	// Is the asset archived?
	IsArchived *bool `pulumi:"isArchived"`
	// Enum to determine the type of job.
	// Expected value is 'Pipeline'.
	JobType string `pulumi:"jobType"`
	// Jobs construct the Pipeline Job.
	Jobs map[string]interface{} `pulumi:"jobs"`
	// Notification setting for the job
	NotificationSetting *NotificationSettingResponse `pulumi:"notificationSetting"`
	// Outputs for the pipeline job
	Outputs map[string]interface{} `pulumi:"outputs"`
	// The asset property dictionary.
	Properties map[string]string `pulumi:"properties"`
	// Configuration for secrets to be made available during runtime.
	SecretsConfiguration map[string]SecretConfigurationResponse `pulumi:"secretsConfiguration"`
	// List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]JobServiceResponse `pulumi:"services"`
	// Pipeline settings, for things like ContinueRunOnStepFailure etc.
	Settings interface{} `pulumi:"settings"`
	// ARM resource ID of source job.
	SourceJobId *string `pulumi:"sourceJobId"`
	// Status of the job.
	Status string `pulumi:"status"`
	// Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]string `pulumi:"tags"`
}

// Defaults sets the appropriate defaults for PipelineJobResponse
func (val *PipelineJobResponse) Defaults() *PipelineJobResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.ExperimentName == nil {
		experimentName_ := "Default"
		tmp.ExperimentName = &experimentName_
	}
	if tmp.IsArchived == nil {
		isArchived_ := false
		tmp.IsArchived = &isArchived_
	}
	return &tmp
}

type PredictionDriftMonitoringSignal struct {
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThresholds []interface{} `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// [Required] The type of the model monitored.
	ModelType string `pulumi:"modelType"`
	// [Required] The data which drift will be calculated for.
	ProductionData interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The data to calculate drift against.
	ReferenceData interface{} `pulumi:"referenceData"`
	// Expected value is 'PredictionDrift'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for PredictionDriftMonitoringSignal
func (val *PredictionDriftMonitoringSignal) Defaults() *PredictionDriftMonitoringSignal {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

type PredictionDriftMonitoringSignalResponse struct {
	// [Required] A list of metrics to calculate and their associated thresholds.
	MetricThresholds []interface{} `pulumi:"metricThresholds"`
	// The current notification mode for this signal.
	Mode *string `pulumi:"mode"`
	// [Required] The type of the model monitored.
	ModelType string `pulumi:"modelType"`
	// [Required] The data which drift will be calculated for.
	ProductionData interface{} `pulumi:"productionData"`
	// Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]string `pulumi:"properties"`
	// [Required] The data to calculate drift against.
	ReferenceData interface{} `pulumi:"referenceData"`
	// Expected value is 'PredictionDrift'.
	SignalType string `pulumi:"signalType"`
}

// Defaults sets the appropriate defaults for PredictionDriftMonitoringSignalResponse
func (val *PredictionDriftMonitoringSignalResponse) Defaults() *PredictionDriftMonitoringSignalResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		mode_ := "Disabled"
		tmp.Mode = &mode_
	}
	return &tmp
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnectionResponse struct {
	// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id string `pulumi:"id"`
	// Managed service identity (system assigned and/or user assigned identities)
	Identity *ManagedServiceIdentityResponse `pulumi:"identity"`
	// Same as workspace location.
	Location *string `pulumi:"location"`
	// The name of the resource
	Name string `pulumi:"name"`
	// The Private Endpoint resource.
	PrivateEndpoint *WorkspacePrivateEndpointResourceResponse `pulumi:"privateEndpoint"`
	// The connection state.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionStateResponse `pulumi:"privateLinkServiceConnectionState"`
	// The current provisioning state.
	ProvisioningState string `pulumi:"provisioningState"`
	// Optional. This field is required to be implemented by the RP because AML is supporting more than one tier
	Sku *SkuResponse `pulumi:"sku"`
	// Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData SystemDataResponse `pulumi:"systemData"`
	Tags       map[string]string  `pulumi:"tags"`
	// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type string `pulumi:"type"`
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnectionResponseOutput struct{ *pulumi.OutputState }

func (PrivateEndpointConnectionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateEndpointConnectionResponse)(nil)).Elem()
}

func (o PrivateEndpointConnectionResponseOutput) ToPrivateEndpointConnectionResponseOutput() PrivateEndpointConnectionResponseOutput {
	return o
}

func (o PrivateEndpointConnectionResponseOutput) ToPrivateEndpointConnectionResponseOutputWithContext(ctx context.Context) PrivateEndpointConnectionResponseOutput {
	return o
}

// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
func (o PrivateEndpointConnectionResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Id }).(pulumi.StringOutput)
}

// Managed service identity (system assigned and/or user assigned identities)
func (o PrivateEndpointConnectionResponseOutput) Identity() ManagedServiceIdentityResponsePtrOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) *ManagedServiceIdentityResponse { return v.Identity }).(ManagedServiceIdentityResponsePtrOutput)
}

// Same as workspace location.
func (o PrivateEndpointConnectionResponseOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// The name of the resource
func (o PrivateEndpointConnectionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The Private Endpoint resource.
func (o PrivateEndpointConnectionResponseOutput) PrivateEndpoint() WorkspacePrivateEndpointResourceResponsePtrOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) *WorkspacePrivateEndpointResourceResponse {
		return v.PrivateEndpoint
	}).(WorkspacePrivateEndpointResourceResponsePtrOutput)
}

// The connection state.
func (o PrivateEndpointConnectionResponseOutput) PrivateLinkServiceConnectionState() PrivateLinkServiceConnectionStateResponsePtrOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) *PrivateLinkServiceConnectionStateResponse {
		return v.PrivateLinkServiceConnectionState
	}).(PrivateLinkServiceConnectionStateResponsePtrOutput)
}

// The current provisioning state.
func (o PrivateEndpointConnectionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Optional. This field is required to be implemented by the RP because AML is supporting more than one tier
func (o PrivateEndpointConnectionResponseOutput) Sku() SkuResponsePtrOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) *SkuResponse { return v.Sku }).(SkuResponsePtrOutput)
}

// Azure Resource Manager metadata containing createdBy and modifiedBy information.
func (o PrivateEndpointConnectionResponseOutput) SystemData() SystemDataResponseOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) SystemDataResponse { return v.SystemData }).(SystemDataResponseOutput)
}

func (o PrivateEndpointConnectionResponseOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
func (o PrivateEndpointConnectionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Type }).(pulumi.StringOutput)
}

type PrivateEndpointConnectionResponseArrayOutput struct{ *pulumi.OutputState }

func (PrivateEndpointConnectionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PrivateEndpointConnectionResponse)(nil)).Elem()
}

func (o PrivateEndpointConnectionResponseArrayOutput) ToPrivateEndpointConnectionResponseArrayOutput() PrivateEndpointConnectionResponseArrayOutput {
	return o
}

func (o PrivateEndpointConnectionResponseArrayOutput) ToPrivateEndpointConnectionResponseArrayOutputWithContext(ctx context.Context) PrivateEndpointConnectionResponseArrayOutput {
	return o
}

func (o PrivateEndpointConnectionResponseArrayOutput) Index(i pulumi.IntInput) PrivateEndpointConnectionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PrivateEndpointConnectionResponse {
		return vs[0].([]PrivateEndpointConnectionResponse)[vs[1].(int)]
	}).(PrivateEndpointConnectionResponseOutput)
}

// Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
type PrivateEndpointDestination struct {
	ServiceResourceId *string `pulumi:"serviceResourceId"`
	SparkEnabled      *bool   `pulumi:"sparkEnabled"`
	// Type of a managed network Outbound Rule of a machine learning workspace.
	SparkStatus       *string `pulumi:"sparkStatus"`
	SubresourceTarget *string `pulumi:"subresourceTarget"`
}

// Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
type PrivateEndpointDestinationResponse struct {
	ServiceResourceId *string `pulumi:"serviceResourceId"`
	SparkEnabled      *bool   `pulumi:"sparkEnabled"`
	// Type of a managed network Outbound Rule of a machine learning workspace.
	SparkStatus       *string `pulumi:"sparkStatus"`
	SubresourceTarget *string `pulumi:"subresourceTarget"`
}

// Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
type PrivateEndpointOutboundRule struct {
	// Category of a managed network Outbound Rule of a machine learning workspace.
	Category *string `pulumi:"category"`
	// Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
	Destination *PrivateEndpointDestination `pulumi:"destination"`
	// Type of a managed network Outbound Rule of a machine learning workspace.
	Status *string `pulumi:"status"`
	// Type of a managed network Outbound Rule of a machine learning workspace.
	// Expected value is 'PrivateEndpoint'.
	Type string `pulumi:"type"`
}

// Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
type PrivateEndpointOutboundRuleResponse struct {
	// Category of a managed network Outbound Rule of a machine learning workspace.
	Category *string `pulumi:"category"`
	// Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
	Destination *PrivateEndpointDestinationResponse `pulumi:"destination"`
	// Type of a managed network Outbound Rule of a machine learning workspace.
	Status *string `pulumi:"status"`
	// Type of a managed network Outbound Rule of a machine learning workspace.
	// Expected value is 'PrivateEndpoint'.
	Type string `pulumi:"type"`
}

// The PE network resource that is linked to this PE connection.
type PrivateEndpointResource struct {
	// The subnetId that the private endpoint is connected to.
	SubnetArmId *string `pulumi:"subnetArmId"`
}

// PrivateEndpointResourceInput is an input type that accepts PrivateEndpointResourceArgs and PrivateEndpointResourceOutput values.
// You can construct a concrete instance of `PrivateEndpointResourceInput` via:
//
//	PrivateEndpointResourceArgs{...}
type PrivateEndpointResourceInput interface {
	pulumi.Input

	ToPrivateEndpointResourceOutput() PrivateEndpointResourceOutput
	ToPrivateEndpointResourceOutputWithContext(context.Context) PrivateEndpointResourceOutput
}

// The PE network resource that is linked to this PE connection.
type PrivateEndpointResourceArgs struct {
	// The subnetId that the private endpoint is connected to.
	SubnetArmId pulumi.StringPtrInput `pulumi:"subnetArmId"`
}

func (PrivateEndpointResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateEndpointResource)(nil)).Elem()
}

func (i PrivateEndpointResourceArgs) ToPrivateEndpointResourceOutput() PrivateEndpointResourceOutput {
	return i.ToPrivateEndpointResourceOutputWithContext(context.Background())
}

func (i PrivateEndpointResourceArgs) ToPrivateEndpointResourceOutputWithContext(ctx context.Context) PrivateEndpointResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateEndpointResourceOutput)
}

func (i PrivateEndpointResourceArgs) ToPrivateEndpointResourcePtrOutput() PrivateEndpointResourcePtrOutput {
	return i.ToPrivateEndpointResourcePtrOutputWithContext(context.Background())
}

func (i PrivateEndpointResourceArgs) ToPrivateEndpointResourcePtrOutputWithContext(ctx context.Context) PrivateEndpointResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateEndpointResourceOutput).ToPrivateEndpointResourcePtrOutputWithContext(ctx)
}

// PrivateEndpointResourcePtrInput is an input type that accepts PrivateEndpointResourceArgs, PrivateEndpointResourcePtr and PrivateEndpointResourcePtrOutput values.
// You can construct a concrete instance of `PrivateEndpointResourcePtrInput` via:
//
//	        PrivateEndpointResourceArgs{...}
//
//	or:
//
//	        nil
type PrivateEndpointResourcePtrInput interface {
	pulumi.Input

	ToPrivateEndpointResourcePtrOutput() PrivateEndpointResourcePtrOutput
	ToPrivateEndpointResourcePtrOutputWithContext(context.Context) PrivateEndpointResourcePtrOutput
}

type privateEndpointResourcePtrType PrivateEndpointResourceArgs

func PrivateEndpointResourcePtr(v *PrivateEndpointResourceArgs) PrivateEndpointResourcePtrInput {
	return (*privateEndpointResourcePtrType)(v)
}

func (*privateEndpointResourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateEndpointResource)(nil)).Elem()
}

func (i *privateEndpointResourcePtrType) ToPrivateEndpointResourcePtrOutput() PrivateEndpointResourcePtrOutput {
	return i.ToPrivateEndpointResourcePtrOutputWithContext(context.Background())
}

func (i *privateEndpointResourcePtrType) ToPrivateEndpointResourcePtrOutputWithContext(ctx context.Context) PrivateEndpointResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateEndpointResourcePtrOutput)
}

// The PE network resource that is linked to this PE connection.
type PrivateEndpointResourceOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateEndpointResource)(nil)).Elem()
}

func (o PrivateEndpointResourceOutput) ToPrivateEndpointResourceOutput() PrivateEndpointResourceOutput {
	return o
}

func (o PrivateEndpointResourceOutput) ToPrivateEndpointResourceOutputWithContext(ctx context.Context) PrivateEndpointResourceOutput {
	return o
}

func (o PrivateEndpointResourceOutput) ToPrivateEndpointResourcePtrOutput() PrivateEndpointResourcePtrOutput {
	return o.ToPrivateEndpointResourcePtrOutputWithContext(context.Background())
}

func (o PrivateEndpointResourceOutput) ToPrivateEndpointResourcePtrOutputWithContext(ctx context.Context) PrivateEndpointResourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PrivateEndpointResource) *PrivateEndpointResource {
		return &v
	}).(PrivateEndpointResourcePtrOutput)
}

// The subnetId that the private endpoint is connected to.
func (o PrivateEndpointResourceOutput) SubnetArmId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateEndpointResource) *string { return v.SubnetArmId }).(pulumi.StringPtrOutput)
}

type PrivateEndpointResourcePtrOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateEndpointResource)(nil)).Elem()
}

func (o PrivateEndpointResourcePtrOutput) ToPrivateEndpointResourcePtrOutput() PrivateEndpointResourcePtrOutput {
	return o
}

func (o PrivateEndpointResourcePtrOutput) ToPrivateEndpointResourcePtrOutputWithContext(ctx context.Context) PrivateEndpointResourcePtrOutput {
	return o
}

func (o PrivateEndpointResourcePtrOutput) Elem() PrivateEndpointResourceOutput {
	return o.ApplyT(func(v *PrivateEndpointResource) PrivateEndpointResource {
		if v != nil {
			return *v
		}
		var ret PrivateEndpointResource
		return ret
	}).(PrivateEndpointResourceOutput)
}

// The subnetId that the private endpoint is connected to.
func (o PrivateEndpointResourcePtrOutput) SubnetArmId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateEndpointResource) *string {
		if v == nil {
			return nil
		}
		return v.SubnetArmId
	}).(pulumi.StringPtrOutput)
}

// The PE network resource that is linked to this PE connection.
type PrivateEndpointResourceResponse struct {
	// The ARM identifier for Private Endpoint
	Id string `pulumi:"id"`
	// The subnetId that the private endpoint is connected to.
	SubnetArmId *string `pulumi:"subnetArmId"`
}

// The PE network resource that is linked to this PE connection.
type PrivateEndpointResourceResponseOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateEndpointResourceResponse)(nil)).Elem()
}

func (o PrivateEndpointResourceResponseOutput) ToPrivateEndpointResourceResponseOutput() PrivateEndpointResourceResponseOutput {
	return o
}

func (o PrivateEndpointResourceResponseOutput) ToPrivateEndpointResourceResponseOutputWithContext(ctx context.Context) PrivateEndpointResourceResponseOutput {
	return o
}

// The ARM identifier for Private Endpoint
func (o PrivateEndpointResourceResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointResourceResponse) string { return v.Id }).(pulumi.StringOutput)
}

// The subnetId that the private endpoint is connected to.
func (o PrivateEndpointResourceResponseOutput) SubnetArmId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateEndpointResourceResponse) *string { return v.SubnetArmId }).(pulumi.StringPtrOutput)
}

type PrivateEndpointResourceResponsePtrOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResourceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateEndpointResourceResponse)(nil)).Elem()
}

func (o PrivateEndpointResourceResponsePtrOutput) ToPrivateEndpointResourceResponsePtrOutput() PrivateEndpointResourceResponsePtrOutput {
	return o
}

func (o PrivateEndpointResourceResponsePtrOutput) ToPrivateEndpointResourceResponsePtrOutputWithContext(ctx context.Context) PrivateEndpointResourceResponsePtrOutput {
	return o
}

func (o PrivateEndpointResourceResponsePtrOutput) Elem() PrivateEndpointResourceResponseOutput {
	return o.ApplyT(func(v *PrivateEndpointResourceResponse) PrivateEndpointResourceResponse {
		if v != nil {
			return *v
		}
		var ret PrivateEndpointResourceResponse
		return ret
	}).(PrivateEndpointResourceResponseOutput)
}

// The ARM identifier for Private Endpoint
func (o PrivateEndpointResourceResponsePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateEndpointResourceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Id
	}).(pulumi.StringPtrOutput)
}

// The subnetId that the private endpoint is connected to.
func (o PrivateEndpointResourceResponsePtrOutput) SubnetArmId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateEndpointResourceResponse) *string {
		if v == nil {
			return nil
		}
		return v.SubnetArmId
	}).(pulumi.StringPtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionState struct {
	// Some RP chose "None". Other RPs use this for region expansion.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// User-defined message that, per NRP doc, may be used for approval-related message.
	Description *string `pulumi:"description"`
	// Connection status of the service consumer with the service provider
	// Possible state transitions
	// Pending -> Approved (Service provider approves the connection request)
	// Pending -> Rejected (Service provider rejects the connection request)
	// Pending -> Disconnected (Service provider deletes the connection)
	// Approved -> Rejected (Service provider rejects the approved connection)
	// Approved -> Disconnected (Service provider deletes the connection)
	// Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
	// Rejected -> Disconnected (Service provider deletes the connection)
	Status *string `pulumi:"status"`
}

// PrivateLinkServiceConnectionStateInput is an input type that accepts PrivateLinkServiceConnectionStateArgs and PrivateLinkServiceConnectionStateOutput values.
// You can construct a concrete instance of `PrivateLinkServiceConnectionStateInput` via:
//
//	PrivateLinkServiceConnectionStateArgs{...}
type PrivateLinkServiceConnectionStateInput interface {
	pulumi.Input

	ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput
	ToPrivateLinkServiceConnectionStateOutputWithContext(context.Context) PrivateLinkServiceConnectionStateOutput
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateArgs struct {
	// Some RP chose "None". Other RPs use this for region expansion.
	ActionsRequired pulumi.StringPtrInput `pulumi:"actionsRequired"`
	// User-defined message that, per NRP doc, may be used for approval-related message.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Connection status of the service consumer with the service provider
	// Possible state transitions
	// Pending -> Approved (Service provider approves the connection request)
	// Pending -> Rejected (Service provider rejects the connection request)
	// Pending -> Disconnected (Service provider deletes the connection)
	// Approved -> Rejected (Service provider rejects the approved connection)
	// Approved -> Disconnected (Service provider deletes the connection)
	// Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
	// Rejected -> Disconnected (Service provider deletes the connection)
	Status pulumi.StringPtrInput `pulumi:"status"`
}

func (PrivateLinkServiceConnectionStateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput {
	return i.ToPrivateLinkServiceConnectionStateOutputWithContext(context.Background())
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateLinkServiceConnectionStateOutput)
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStatePtrOutput() PrivateLinkServiceConnectionStatePtrOutput {
	return i.ToPrivateLinkServiceConnectionStatePtrOutputWithContext(context.Background())
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStatePtrOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateLinkServiceConnectionStateOutput).ToPrivateLinkServiceConnectionStatePtrOutputWithContext(ctx)
}

// PrivateLinkServiceConnectionStatePtrInput is an input type that accepts PrivateLinkServiceConnectionStateArgs, PrivateLinkServiceConnectionStatePtr and PrivateLinkServiceConnectionStatePtrOutput values.
// You can construct a concrete instance of `PrivateLinkServiceConnectionStatePtrInput` via:
//
//	        PrivateLinkServiceConnectionStateArgs{...}
//
//	or:
//
//	        nil
type PrivateLinkServiceConnectionStatePtrInput interface {
	pulumi.Input

	ToPrivateLinkServiceConnectionStatePtrOutput() PrivateLinkServiceConnectionStatePtrOutput
	ToPrivateLinkServiceConnectionStatePtrOutputWithContext(context.Context) PrivateLinkServiceConnectionStatePtrOutput
}

type privateLinkServiceConnectionStatePtrType PrivateLinkServiceConnectionStateArgs

func PrivateLinkServiceConnectionStatePtr(v *PrivateLinkServiceConnectionStateArgs) PrivateLinkServiceConnectionStatePtrInput {
	return (*privateLinkServiceConnectionStatePtrType)(v)
}

func (*privateLinkServiceConnectionStatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (i *privateLinkServiceConnectionStatePtrType) ToPrivateLinkServiceConnectionStatePtrOutput() PrivateLinkServiceConnectionStatePtrOutput {
	return i.ToPrivateLinkServiceConnectionStatePtrOutputWithContext(context.Background())
}

func (i *privateLinkServiceConnectionStatePtrType) ToPrivateLinkServiceConnectionStatePtrOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateLinkServiceConnectionStatePtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStatePtrOutput() PrivateLinkServiceConnectionStatePtrOutput {
	return o.ToPrivateLinkServiceConnectionStatePtrOutputWithContext(context.Background())
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStatePtrOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PrivateLinkServiceConnectionState) *PrivateLinkServiceConnectionState {
		return &v
	}).(PrivateLinkServiceConnectionStatePtrOutput)
}

// Some RP chose "None". Other RPs use this for region expansion.
func (o PrivateLinkServiceConnectionStateOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// User-defined message that, per NRP doc, may be used for approval-related message.
func (o PrivateLinkServiceConnectionStateOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Connection status of the service consumer with the service provider
// Possible state transitions
// Pending -> Approved (Service provider approves the connection request)
// Pending -> Rejected (Service provider rejects the connection request)
// Pending -> Disconnected (Service provider deletes the connection)
// Approved -> Rejected (Service provider rejects the approved connection)
// Approved -> Disconnected (Service provider deletes the connection)
// Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
// Rejected -> Disconnected (Service provider deletes the connection)
func (o PrivateLinkServiceConnectionStateOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.Status }).(pulumi.StringPtrOutput)
}

type PrivateLinkServiceConnectionStatePtrOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStatePtrOutput) ToPrivateLinkServiceConnectionStatePtrOutput() PrivateLinkServiceConnectionStatePtrOutput {
	return o
}

func (o PrivateLinkServiceConnectionStatePtrOutput) ToPrivateLinkServiceConnectionStatePtrOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStatePtrOutput {
	return o
}

func (o PrivateLinkServiceConnectionStatePtrOutput) Elem() PrivateLinkServiceConnectionStateOutput {
	return o.ApplyT(func(v *PrivateLinkServiceConnectionState) PrivateLinkServiceConnectionState {
		if v != nil {
			return *v
		}
		var ret PrivateLinkServiceConnectionState
		return ret
	}).(PrivateLinkServiceConnectionStateOutput)
}

// Some RP chose "None". Other RPs use this for region expansion.
func (o PrivateLinkServiceConnectionStatePtrOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateLinkServiceConnectionState) *string {
		if v == nil {
			return nil
		}
		return v.ActionsRequired
	}).(pulumi.StringPtrOutput)
}

// User-defined message that, per NRP doc, may be used for approval-related message.
func (o PrivateLinkServiceConnectionStatePtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateLinkServiceConnectionState) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Connection status of the service consumer with the service provider
// Possible state transitions
// Pending -> Approved (Service provider approves the connection request)
// Pending -> Rejected (Service provider rejects the connection request)
// Pending -> Disconnected (Service provider deletes the connection)
// Approved -> Rejected (Service provider rejects the approved connection)
// Approved -> Disconnected (Service provider deletes the connection)
// Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
// Rejected -> Disconnected (Service provider deletes the connection)
func (o PrivateLinkServiceConnectionStatePtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateLinkServiceConnectionState) *string {
		if v == nil {
			return nil
		}
		return v.Status
	}).(pulumi.StringPtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateResponse struct {
	// Some RP chose "None". Other RPs use this for region expansion.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// User-defined message that, per NRP doc, may be used for approval-related message.
	Description *string `pulumi:"description"`
	// Connection status of the service consumer with the service provider
	// Possible state transitions
	// Pending -> Approved (Service provider approves the connection request)
	// Pending -> Rejected (Service provider rejects the connection request)
	// Pending -> Disconnected (Service provider deletes the connection)
	// Approved -> Rejected (Service provider rejects the approved connection)
	// Approved -> Disconnected (Service provider deletes the connection)
	// Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
	// Rejected -> Disconnected (Service provider deletes the connection)
	Status *string `pulumi:"status"`
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateResponseOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionStateResponse)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStateResponseOutput) ToPrivateLinkServiceConnectionStateResponseOutput() PrivateLinkServiceConnectionStateResponseOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateResponseOutput) ToPrivateLinkServiceConnectionStateResponseOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateResponseOutput {
	return o
}

// Some RP chose "None". Other RPs use this for region expansion.
func (o PrivateLinkServiceConnectionStateResponseOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// User-defined message that, per NRP doc, may be used for approval-related message.
func (o PrivateLinkServiceConnectionStateResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Connection status of the service consumer with the service provider
// Possible state transitions
// Pending -> Approved (Service provider approves the connection request)
// Pending -> Rejected (Service provider rejects the connection request)
// Pending -> Disconnected (Service provider deletes the connection)
// Approved -> Rejected (Service provider rejects the approved connection)
// Approved -> Disconnected (Service provider deletes the connection)
// Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
// Rejected -> Disconnected (Service provider deletes the connection)
func (o PrivateLinkServiceConnectionStateResponseOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.Status }).(pulumi.StringPtrOutput)
}

type PrivateLinkServiceConnectionStateResponsePtrOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStateResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateLinkServiceConnectionStateResponse)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStateResponsePtrOutput) ToPrivateLinkServiceConnectionStateResponsePtrOutput() PrivateLinkServiceConnectionStateResponsePtrOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateResponsePtrOutput) ToPrivateLinkServiceConnectionStateResponsePtrOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateResponsePtrOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateResponsePtrOutput) Elem() PrivateLinkServiceConnectionStateResponseOutput {
	return o.ApplyT(func(v *PrivateLinkServiceConnectionStateResponse) PrivateLinkServiceConnectionStateResponse {
		if v != nil {
			return *v
		}
		var ret PrivateLinkServiceConnectionStateResponse
		return ret
	}).(PrivateLinkServiceConnectionStateResponseOutput)
}

// Some RP chose "None". Other RPs use this for region expansion.
func (o PrivateLinkServiceConnectionStateResponsePtrOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateLinkServiceConnectionStateResponse) *string {
		if v == nil {
			return nil
		}
		return v.ActionsRequired
	}).(pulumi.StringPtrOutput)
}

// User-defined message that, per NRP doc, may be used for approval-related message.
func (o PrivateLinkServiceConnectionStateResponsePtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateLinkServiceConnectionStateResponse) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Connection status of the service consumer with the service provider
// Possible state transitions
// Pending -> Approved (Service provider approves the connection request)
// Pending -> Rejected (Service provider rejects the connection request)
// Pending -> Disconnected (Service provider deletes the connection)
// Approved -> Rejected (Service provider rejects the approved connection)
// Approved -> Disconnected (Service provider deletes the connection)
// Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
// Rejected -> Disconnected (Service provider deletes the connection)
func (o PrivateLinkServiceConnectionStateResponsePtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateLinkServiceConnectionStateResponse) *string {
		if v == nil {
			return nil
		}
		return v.Status
	}).(pulumi.StringPtrOutput)
}

// Deployment container liveness/readiness probe configuration.
type ProbeSettings struct {
	// The number of failures to allow before returning an unhealthy status.
	FailureThreshold *int `pulumi:"failureThreshold"`
	// The delay before the first probe in ISO 8601 format.
	InitialDelay *string `pulumi:"initialDelay"`
	// The length of time between probes in ISO 8601 format.
	Period *string `pulumi:"period"`
	// The number of successful probes before returning a healthy status.
	SuccessThreshold *int `pulumi:"successThreshold"`
	// The probe timeout in ISO 8601 format.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for ProbeSettings
func (val *ProbeSettings) Defaults() *ProbeSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.FailureThreshold == nil {
		failureThreshold_ := 30
		tmp.FailureThreshold = &failureThreshold_
	}
	if tmp.Period == nil {
		period_ := "PT10S"
		tmp.Period = &period_
	}
	if tmp.SuccessThreshold == nil {
		successThreshold_ := 1
		tmp.SuccessThreshold = &successThreshold_
	}
	if tmp.Timeout == nil {
		timeout_ := "PT2S"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// Deployment container liveness/readiness probe configuration.
type ProbeSettingsResponse struct {
	// The number of failures to allow before returning an unhealthy status.
	FailureThreshold *int `pulumi:"failureThreshold"`
	// The delay before the first probe in ISO 8601 format.
	InitialDelay *string `pulumi:"initialDelay"`
	// The length of time between probes in ISO 8601 format.
	Period *string `pulumi:"period"`
	// The number of successful probes before returning a healthy status.
	SuccessThreshold *int `pulumi:"successThreshold"`
	// The probe timeout in ISO 8601 format.
	Timeout *string `pulumi:"timeout"`
}

// Defaults sets the appropriate defaults for ProbeSettingsResponse
func (val *ProbeSettingsResponse) Defaults() *ProbeSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.FailureThreshold == nil {
		failureThreshold_ := 30
		tmp.FailureThreshold = &failureThreshold_
	}
	if tmp.Period == nil {
		period_ := "PT10S"
		tmp.Period = &period_
	}
	if tmp.SuccessThreshold == nil {
		successThreshold_ := 1
		tmp.SuccessThreshold = &successThreshold_
	}
	if tmp.Timeout == nil {
		timeout_ := "PT2S"
		tmp.Timeout = &timeout_
	}
	return &tmp
}

// Progress metrics definition
type ProgressMetricsResponse struct {
	// The completed datapoint count.
	CompletedDatapointCount float64 `pulumi:"completedDatapointCount"`
	// The time of last successful incremental data refresh in UTC.
	IncrementalDataLastRefreshDateTime string `pulumi:"incrementalDataLastRefreshDateTime"`
	// The skipped datapoint count.
	SkippedDatapointCount float64 `pulumi:"skippedDatapointCount"`
	// The total datapoint count.
	TotalDatapointCount float64 `pulumi:"totalDatapointCount"`
}

// Progress metrics definition
type ProgressMetricsResponseOutput struct{ *pulumi.OutputState }

func (ProgressMetricsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProgressMetricsResponse)(nil)).Elem()
}

func (o ProgressMetricsResponseOutput) ToProgressMetricsResponseOutput() ProgressMetricsResponseOutput {
	return o
}

func (o ProgressMetricsResponseOutput) ToProgressMetricsResponseOutputWithContext(ctx context.Context) ProgressMetricsResponseOutput {
	return o
}

// The completed datapoint count.
func (o ProgressMetricsResponseOutput) CompletedDatapointCount() pulumi.Float64Output {
	return o.ApplyT(func(v ProgressMetricsResponse) float64 { return v.CompletedDatapointCount }).(pulumi.Float64Output)
}

// The time of last successful incremental data refresh in UTC.
func (o ProgressMetricsResponseOutput) IncrementalDataLastRefreshDateTime() pulumi.StringOutput {
	return o.ApplyT(func(v ProgressMetricsResponse) string { return v.IncrementalDataLastRefreshDateTime }).(pulumi.StringOutput)
}

// The skipped datapoint count.
func (o ProgressMetricsResponseOutput) SkippedDatapointCount() pulumi.Float64Output {
	return o.ApplyT(func(v ProgressMetricsResponse) float64 { return v.SkippedDatapointCount }).(pulumi.Float64Output)
}

// The total datapoint count.
func (o ProgressMetricsResponseOutput) TotalDatapointCount() pulumi.Float64Output {
	return o.ApplyT(func(v ProgressMetricsResponse) float64 { return v.TotalDatapointCount }).(pulumi.Float64Output)
}

// PyTorch distribution configuration.
type PyTorch struct {
	// Enum to determine the job distribution type.
	// Expected value is 'PyTorch'.
	DistributionType string `pulumi:"distributionType"`
	// Number of processes per node.
	ProcessCountPerInstance *int `pulumi:"processCountPerInstance"`
}

// PyTorch distribution configuration.
type PyTorchResponse struct {
	// Enum to determine the job distribution type.
	// Expected value is 'PyTorch'.
	DistributionType string `pulumi:"distributionType"`
	// Number of processes per node.
	ProcessCountPerInstance *int `pulumi:"processCountPerInstance"`
}

type QueueSettings struct {
	// Controls the compute job tier
	JobTier *string `pulumi:"jobTier"`
	// Controls the priority of the job on a compute.
	Priority *int `pulumi:"priority"`
}

// Defaults sets the appropriate defaults for QueueSettings
func (val *QueueSettings) Defaults() *QueueSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.JobTier == nil {
		jobTier_ := "Null"
		tmp.JobTier = &jobTier_
	}
	return &tmp
}

type QueueSettingsResponse struct {
	// Controls the compute job tier
	JobTier *string `pulumi:"jobTier"`
	// Controls the priority of the job on a compute.
	Priority *int `pulumi:"priority"`
}

// Defaults sets the appropriate defaults for QueueSettingsResponse
func (val *QueueSettingsResponse) Defaults() *QueueSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.JobTier == nil {
		jobTier_ := "Null"
		tmp.JobTier = &jobTier_
	}
	return &tmp
}

// Defines a Sampling Algorithm that generates values randomly
type RandomSamplingAlgorithm struct {
	// An optional positive number or e in string format to be used as base for log based random sampling
	Logbase *string `pulumi:"logbase"`
	// The specific type of random algorithm
	Rule *string `pulumi:"rule"`
	// Expected value is 'Random'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
	// An optional integer to use as the seed for random number generation
	Seed *int `pulumi:"seed"`
}

// Defaults sets the appropriate defaults for RandomSamplingAlgorithm
func (val *RandomSamplingAlgorithm) Defaults() *RandomSamplingAlgorithm {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Rule == nil {
		rule_ := "Random"
		tmp.Rule = &rule_
	}
	return &tmp
}

// Defines a Sampling Algorithm that generates values randomly
type RandomSamplingAlgorithmResponse struct {
	// An optional positive number or e in string format to be used as base for log based random sampling
	Logbase *string `pulumi:"logbase"`
	// The specific type of random algorithm
	Rule *string `pulumi:"rule"`
	// Expected value is 'Random'.
	SamplingAlgorithmType string `pulumi:"samplingAlgorithmType"`
	// An optional integer to use as the seed for random number generation
	Seed *int `pulumi:"seed"`
}

// Defaults sets the appropriate defaults for RandomSamplingAlgorithmResponse
func (val *RandomSamplingAlgorithmResponse) Defaults() *RandomSamplingAlgorithmResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Rule == nil {
		rule_ := "Random"
		tmp.Rule = &rule_
	}
	return &tmp
}

// Ray distribution configuration.
type Ray struct {
	// The address of Ray head node.
	Address *string `pulumi:"address"`
	// The port to bind the dashboard server to.
	DashboardPort *int `pulumi:"dashboardPort"`
	// Enum to determine the job distribution type.
	// Expected value is 'Ray'.
	DistributionType string `pulumi:"distributionType"`
	// Additional arguments passed to ray start in head node.
	HeadNodeAdditionalArgs *string `pulumi:"headNodeAdditionalArgs"`
	// Provide this argument to start the Ray dashboard GUI.
	IncludeDashboard *bool `pulumi:"includeDashboard"`
	// The port of the head ray process.
	Port *int `pulumi:"port"`
	// Additional arguments passed to ray start in worker node.
	WorkerNodeAdditionalArgs *string `pulumi:"workerNodeAdditionalArgs"`
}

// Ray distribution configuration.
type RayResponse struct {
	// The address of Ray head node.
	Address *string `pulumi:"address"`
	// The port to bind the dashboard server to.
	DashboardPort *int `pulumi:"dashboardPort"`
	// Enum to determine the job distribution type.
	// Expected value is 'Ray'.
	DistributionType string `pulumi:"distributionType"`
	// Additional arguments passed to ray start in head node.
	HeadNodeAdditionalArgs *string `pulumi:"headNodeAdditionalArgs"`
	// Provide this argument to start the Ray dashboard GUI.
	IncludeDashboard *bool `pulumi:"includeDashboard"`
	// The port of the head ray process.
	Port *int `pulumi:"port"`
	// Additional arguments passed to ray start in worker node.
	WorkerNodeAdditionalArgs *string `pulumi:"workerNodeAdditionalArgs"`
}

// The workflow trigger recurrence for ComputeStartStop schedule type.
type Recurrence struct {
	// [Required] The frequency to trigger schedule.
	Frequency *string `pulumi:"frequency"`
	// [Required] Specifies schedule interval in conjunction with frequency
	Interval *int `pulumi:"interval"`
	// [Required] The recurrence schedule.
	Schedule *RecurrenceSchedule `pulumi:"schedule"`
	// The start time in yyyy-MM-ddTHH:mm:ss format.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `pulumi:"timeZone"`
}

// Defaults sets the appropriate defaults for Recurrence
func (val *Recurrence) Defaults() *Recurrence {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.TimeZone == nil {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

// The workflow trigger recurrence for ComputeStartStop schedule type.
type RecurrenceResponse struct {
	// [Required] The frequency to trigger schedule.
	Frequency *string `pulumi:"frequency"`
	// [Required] Specifies schedule interval in conjunction with frequency
	Interval *int `pulumi:"interval"`
	// [Required] The recurrence schedule.
	Schedule *RecurrenceScheduleResponse `pulumi:"schedule"`
	// The start time in yyyy-MM-ddTHH:mm:ss format.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `pulumi:"timeZone"`
}

// Defaults sets the appropriate defaults for RecurrenceResponse
func (val *RecurrenceResponse) Defaults() *RecurrenceResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.TimeZone == nil {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

type RecurrenceSchedule struct {
	// [Required] List of hours for the schedule.
	Hours []int `pulumi:"hours"`
	// [Required] List of minutes for the schedule.
	Minutes []int `pulumi:"minutes"`
	// List of month days for the schedule
	MonthDays []int `pulumi:"monthDays"`
	// List of days for the schedule.
	WeekDays []string `pulumi:"weekDays"`
}

// RecurrenceScheduleInput is an input type that accepts RecurrenceScheduleArgs and RecurrenceScheduleOutput values.
// You can construct a concrete instance of `RecurrenceScheduleInput` via:
//
//	RecurrenceScheduleArgs{...}
type RecurrenceScheduleInput interface {
	pulumi.Input

	ToRecurrenceScheduleOutput() RecurrenceScheduleOutput
	ToRecurrenceScheduleOutputWithContext(context.Context) RecurrenceScheduleOutput
}

type RecurrenceScheduleArgs struct {
	// [Required] List of hours for the schedule.
	Hours pulumi.IntArrayInput `pulumi:"hours"`
	// [Required] List of minutes for the schedule.
	Minutes pulumi.IntArrayInput `pulumi:"minutes"`
	// List of month days for the schedule
	MonthDays pulumi.IntArrayInput `pulumi:"monthDays"`
	// List of days for the schedule.
	WeekDays pulumi.StringArrayInput `pulumi:"weekDays"`
}

func (RecurrenceScheduleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrenceSchedule)(nil)).Elem()
}

func (i RecurrenceScheduleArgs) ToRecurrenceScheduleOutput() RecurrenceScheduleOutput {
	return i.ToRecurrenceScheduleOutputWithContext(context.Background())
}

func (i RecurrenceScheduleArgs) ToRecurrenceScheduleOutputWithContext(ctx context.Context) RecurrenceScheduleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrenceScheduleOutput)
}

func (i RecurrenceScheduleArgs) ToRecurrenceSchedulePtrOutput() RecurrenceSchedulePtrOutput {
	return i.ToRecurrenceSchedulePtrOutputWithContext(context.Background())
}

func (i RecurrenceScheduleArgs) ToRecurrenceSchedulePtrOutputWithContext(ctx context.Context) RecurrenceSchedulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrenceScheduleOutput).ToRecurrenceSchedulePtrOutputWithContext(ctx)
}

// RecurrenceSchedulePtrInput is an input type that accepts RecurrenceScheduleArgs, RecurrenceSchedulePtr and RecurrenceSchedulePtrOutput values.
// You can construct a concrete instance of `RecurrenceSchedulePtrInput` via:
//
//	        RecurrenceScheduleArgs{...}
//
//	or:
//
//	        nil
type RecurrenceSchedulePtrInput interface {
	pulumi.Input

	ToRecurrenceSchedulePtrOutput() RecurrenceSchedulePtrOutput
	ToRecurrenceSchedulePtrOutputWithContext(context.Context) RecurrenceSchedulePtrOutput
}

type recurrenceSchedulePtrType RecurrenceScheduleArgs

func RecurrenceSchedulePtr(v *RecurrenceScheduleArgs) RecurrenceSchedulePtrInput {
	return (*recurrenceSchedulePtrType)(v)
}

func (*recurrenceSchedulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrenceSchedule)(nil)).Elem()
}

func (i *recurrenceSchedulePtrType) ToRecurrenceSchedulePtrOutput() RecurrenceSchedulePtrOutput {
	return i.ToRecurrenceSchedulePtrOutputWithContext(context.Background())
}

func (i *recurrenceSchedulePtrType) ToRecurrenceSchedulePtrOutputWithContext(ctx context.Context) RecurrenceSchedulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrenceSchedulePtrOutput)
}

type RecurrenceScheduleOutput struct{ *pulumi.OutputState }

func (RecurrenceScheduleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrenceSchedule)(nil)).Elem()
}

func (o RecurrenceScheduleOutput) ToRecurrenceScheduleOutput() RecurrenceScheduleOutput {
	return o
}

func (o RecurrenceScheduleOutput) ToRecurrenceScheduleOutputWithContext(ctx context.Context) RecurrenceScheduleOutput {
	return o
}

func (o RecurrenceScheduleOutput) ToRecurrenceSchedulePtrOutput() RecurrenceSchedulePtrOutput {
	return o.ToRecurrenceSchedulePtrOutputWithContext(context.Background())
}

func (o RecurrenceScheduleOutput) ToRecurrenceSchedulePtrOutputWithContext(ctx context.Context) RecurrenceSchedulePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RecurrenceSchedule) *RecurrenceSchedule {
		return &v
	}).(RecurrenceSchedulePtrOutput)
}

// [Required] List of hours for the schedule.
func (o RecurrenceScheduleOutput) Hours() pulumi.IntArrayOutput {
	return o.ApplyT(func(v RecurrenceSchedule) []int { return v.Hours }).(pulumi.IntArrayOutput)
}

// [Required] List of minutes for the schedule.
func (o RecurrenceScheduleOutput) Minutes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v RecurrenceSchedule) []int { return v.Minutes }).(pulumi.IntArrayOutput)
}

// List of month days for the schedule
func (o RecurrenceScheduleOutput) MonthDays() pulumi.IntArrayOutput {
	return o.ApplyT(func(v RecurrenceSchedule) []int { return v.MonthDays }).(pulumi.IntArrayOutput)
}

// List of days for the schedule.
func (o RecurrenceScheduleOutput) WeekDays() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RecurrenceSchedule) []string { return v.WeekDays }).(pulumi.StringArrayOutput)
}

type RecurrenceSchedulePtrOutput struct{ *pulumi.OutputState }

func (RecurrenceSchedulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrenceSchedule)(nil)).Elem()
}

func (o RecurrenceSchedulePtrOutput) ToRecurrenceSchedulePtrOutput() RecurrenceSchedulePtrOutput {
	return o
}

func (o RecurrenceSchedulePtrOutput) ToRecurrenceSchedulePtrOutputWithContext(ctx context.Context) RecurrenceSchedulePtrOutput {
	return o
}

func (o RecurrenceSchedulePtrOutput) Elem() RecurrenceScheduleOutput {
	return o.ApplyT(func(v *RecurrenceSchedule) RecurrenceSchedule {
		if v != nil {
			return *v
		}
		var ret RecurrenceSchedule
		return ret
	}).(RecurrenceScheduleOutput)
}

// [Required] List of hours for the schedule.
func (o RecurrenceSchedulePtrOutput) Hours() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *RecurrenceSchedule) []int {
		if v == nil {
			return nil
		}
		return v.Hours
	}).(pulumi.IntArrayOutput)
}

// [Required] List of minutes for the schedule.
func (o RecurrenceSchedulePtrOutput) Minutes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *RecurrenceSchedule) []int {
		if v == nil {
			return nil
		}
		return v.Minutes
	}).(pulumi.IntArrayOutput)
}

// List of month days for the schedule
func (o RecurrenceSchedulePtrOutput) MonthDays() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *RecurrenceSchedule) []int {
		if v == nil {
			return nil
		}
		return v.MonthDays
	}).(pulumi.IntArrayOutput)
}

// List of days for the schedule.
func (o RecurrenceSchedulePtrOutput) WeekDays() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RecurrenceSchedule) []string {
		if v == nil {
			return nil
		}
		return v.WeekDays
	}).(pulumi.StringArrayOutput)
}

type RecurrenceScheduleResponse struct {
	// [Required] List of hours for the schedule.
	Hours []int `pulumi:"hours"`
	// [Required] List of minutes for the schedule.
	Minutes []int `pulumi:"minutes"`
	// List of month days for the schedule
	MonthDays []int `pulumi:"monthDays"`
	// List of days for the schedule.
	WeekDays []string `pulumi:"weekDays"`
}

type RecurrenceScheduleResponseOutput struct{ *pulumi.OutputState }

func (RecurrenceScheduleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrenceScheduleResponse)(nil)).Elem()
}

func (o RecurrenceScheduleResponseOutput) ToRecurrenceScheduleResponseOutput() RecurrenceScheduleResponseOutput {
	return o
}

func (o RecurrenceScheduleResponseOutput) ToRecurrenceScheduleResponseOutputWithContext(ctx context.Context) RecurrenceScheduleResponseOutput {
	return o
}

// [Required] List of hours for the schedule.
func (o RecurrenceScheduleResponseOutput) Hours() pulumi.IntArrayOutput {
	return o.ApplyT(func(v RecurrenceScheduleResponse) []int { return v.Hours }).(pulumi.IntArrayOutput)
}

// [Required] List of minutes for the schedule.
func (o RecurrenceScheduleResponseOutput) Minutes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v RecurrenceScheduleResponse) []int { return v.Minutes }).(pulumi.IntArrayOutput)
}

// List of month days for the schedule
func (o RecurrenceScheduleResponseOutput) MonthDays() pulumi.IntArrayOutput {
	return o.ApplyT(func(v RecurrenceScheduleResponse) []int { return v.MonthDays }).(pulumi.IntArrayOutput)
}

// List of days for the schedule.
func (o RecurrenceScheduleResponseOutput) WeekDays() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RecurrenceScheduleResponse) []string { return v.WeekDays }).(pulumi.StringArrayOutput)
}

type RecurrenceScheduleResponsePtrOutput struct{ *pulumi.OutputState }

func (RecurrenceScheduleResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrenceScheduleResponse)(nil)).Elem()
}

func (o RecurrenceScheduleResponsePtrOutput) ToRecurrenceScheduleResponsePtrOutput() RecurrenceScheduleResponsePtrOutput {
	return o
}

func (o RecurrenceScheduleResponsePtrOutput) ToRecurrenceScheduleResponsePtrOutputWithContext(ctx context.Context) RecurrenceScheduleResponsePtrOutput {
	return o
}

func (o RecurrenceScheduleResponsePtrOutput) Elem() RecurrenceScheduleResponseOutput {
	return o.ApplyT(func(v *RecurrenceScheduleResponse) RecurrenceScheduleResponse {
		if v != nil {
			return *v
		}
		var ret RecurrenceScheduleResponse
		return ret
	}).(RecurrenceScheduleResponseOutput)
}

// [Required] List of hours for the schedule.
func (o RecurrenceScheduleResponsePtrOutput) Hours() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *RecurrenceScheduleResponse) []int {
		if v == nil {
			return nil
		}
		return v.Hours
	}).(pulumi.IntArrayOutput)
}

// [Required] List of minutes for the schedule.
func (o RecurrenceScheduleResponsePtrOutput) Minutes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *RecurrenceScheduleResponse) []int {
		if v == nil {
			return nil
		}
		return v.Minutes
	}).(pulumi.IntArrayOutput)
}

// List of month days for the schedule
func (o RecurrenceScheduleResponsePtrOutput) MonthDays() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *RecurrenceScheduleResponse) []int {
		if v == nil {
			return nil
		}
		return v.MonthDays
	}).(pulumi.IntArrayOutput)
}

// List of days for the schedule.
func (o RecurrenceScheduleResponsePtrOutput) WeekDays() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RecurrenceScheduleResponse) []string {
		if v == nil {
			return nil
		}
		return v.WeekDays
	}).(pulumi.StringArrayOutput)
}

type RecurrenceTrigger struct {
	// Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
	// Recommented format would be "2022-06-01T00:00:01"
	// If not present, the schedule will run indefinitely
	EndTime *string `pulumi:"endTime"`
	// [Required] The frequency to trigger schedule.
	Frequency string `pulumi:"frequency"`
	// [Required] Specifies schedule interval in conjunction with frequency
	Interval int `pulumi:"interval"`
	// The recurrence schedule.
	Schedule *RecurrenceSchedule `pulumi:"schedule"`
	// Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `pulumi:"timeZone"`
	// Expected value is 'Recurrence'.
	TriggerType string `pulumi:"triggerType"`
}

// Defaults sets the appropriate defaults for RecurrenceTrigger
func (val *RecurrenceTrigger) Defaults() *RecurrenceTrigger {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.TimeZone == nil {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

// RecurrenceTriggerInput is an input type that accepts RecurrenceTriggerArgs and RecurrenceTriggerOutput values.
// You can construct a concrete instance of `RecurrenceTriggerInput` via:
//
//	RecurrenceTriggerArgs{...}
type RecurrenceTriggerInput interface {
	pulumi.Input

	ToRecurrenceTriggerOutput() RecurrenceTriggerOutput
	ToRecurrenceTriggerOutputWithContext(context.Context) RecurrenceTriggerOutput
}

type RecurrenceTriggerArgs struct {
	// Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
	// Recommented format would be "2022-06-01T00:00:01"
	// If not present, the schedule will run indefinitely
	EndTime pulumi.StringPtrInput `pulumi:"endTime"`
	// [Required] The frequency to trigger schedule.
	Frequency pulumi.StringInput `pulumi:"frequency"`
	// [Required] Specifies schedule interval in conjunction with frequency
	Interval pulumi.IntInput `pulumi:"interval"`
	// The recurrence schedule.
	Schedule RecurrenceSchedulePtrInput `pulumi:"schedule"`
	// Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
	StartTime pulumi.StringPtrInput `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone pulumi.StringPtrInput `pulumi:"timeZone"`
	// Expected value is 'Recurrence'.
	TriggerType pulumi.StringInput `pulumi:"triggerType"`
}

// Defaults sets the appropriate defaults for RecurrenceTriggerArgs
func (val *RecurrenceTriggerArgs) Defaults() *RecurrenceTriggerArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.TimeZone == nil {
		tmp.TimeZone = pulumi.StringPtr("UTC")
	}
	return &tmp
}
func (RecurrenceTriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrenceTrigger)(nil)).Elem()
}

func (i RecurrenceTriggerArgs) ToRecurrenceTriggerOutput() RecurrenceTriggerOutput {
	return i.ToRecurrenceTriggerOutputWithContext(context.Background())
}

func (i RecurrenceTriggerArgs) ToRecurrenceTriggerOutputWithContext(ctx context.Context) RecurrenceTriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrenceTriggerOutput)
}

func (i RecurrenceTriggerArgs) ToRecurrenceTriggerPtrOutput() RecurrenceTriggerPtrOutput {
	return i.ToRecurrenceTriggerPtrOutputWithContext(context.Background())
}

func (i RecurrenceTriggerArgs) ToRecurrenceTriggerPtrOutputWithContext(ctx context.Context) RecurrenceTriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrenceTriggerOutput).ToRecurrenceTriggerPtrOutputWithContext(ctx)
}

// RecurrenceTriggerPtrInput is an input type that accepts RecurrenceTriggerArgs, RecurrenceTriggerPtr and RecurrenceTriggerPtrOutput values.
// You can construct a concrete instance of `RecurrenceTriggerPtrInput` via:
//
//	        RecurrenceTriggerArgs{...}
//
//	or:
//
//	        nil
type RecurrenceTriggerPtrInput interface {
	pulumi.Input

	ToRecurrenceTriggerPtrOutput() RecurrenceTriggerPtrOutput
	ToRecurrenceTriggerPtrOutputWithContext(context.Context) RecurrenceTriggerPtrOutput
}

type recurrenceTriggerPtrType RecurrenceTriggerArgs

func RecurrenceTriggerPtr(v *RecurrenceTriggerArgs) RecurrenceTriggerPtrInput {
	return (*recurrenceTriggerPtrType)(v)
}

func (*recurrenceTriggerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrenceTrigger)(nil)).Elem()
}

func (i *recurrenceTriggerPtrType) ToRecurrenceTriggerPtrOutput() RecurrenceTriggerPtrOutput {
	return i.ToRecurrenceTriggerPtrOutputWithContext(context.Background())
}

func (i *recurrenceTriggerPtrType) ToRecurrenceTriggerPtrOutputWithContext(ctx context.Context) RecurrenceTriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrenceTriggerPtrOutput)
}

type RecurrenceTriggerOutput struct{ *pulumi.OutputState }

func (RecurrenceTriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrenceTrigger)(nil)).Elem()
}

func (o RecurrenceTriggerOutput) ToRecurrenceTriggerOutput() RecurrenceTriggerOutput {
	return o
}

func (o RecurrenceTriggerOutput) ToRecurrenceTriggerOutputWithContext(ctx context.Context) RecurrenceTriggerOutput {
	return o
}

func (o RecurrenceTriggerOutput) ToRecurrenceTriggerPtrOutput() RecurrenceTriggerPtrOutput {
	return o.ToRecurrenceTriggerPtrOutputWithContext(context.Background())
}

func (o RecurrenceTriggerOutput) ToRecurrenceTriggerPtrOutputWithContext(ctx context.Context) RecurrenceTriggerPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RecurrenceTrigger) *RecurrenceTrigger {
		return &v
	}).(RecurrenceTriggerPtrOutput)
}

// Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
// Recommented format would be "2022-06-01T00:00:01"
// If not present, the schedule will run indefinitely
func (o RecurrenceTriggerOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RecurrenceTrigger) *string { return v.EndTime }).(pulumi.StringPtrOutput)
}

// [Required] The frequency to trigger schedule.
func (o RecurrenceTriggerOutput) Frequency() pulumi.StringOutput {
	return o.ApplyT(func(v RecurrenceTrigger) string { return v.Frequency }).(pulumi.StringOutput)
}

// [Required] Specifies schedule interval in conjunction with frequency
func (o RecurrenceTriggerOutput) Interval() pulumi.IntOutput {
	return o.ApplyT(func(v RecurrenceTrigger) int { return v.Interval }).(pulumi.IntOutput)
}

// The recurrence schedule.
func (o RecurrenceTriggerOutput) Schedule() RecurrenceSchedulePtrOutput {
	return o.ApplyT(func(v RecurrenceTrigger) *RecurrenceSchedule { return v.Schedule }).(RecurrenceSchedulePtrOutput)
}

// Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
func (o RecurrenceTriggerOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RecurrenceTrigger) *string { return v.StartTime }).(pulumi.StringPtrOutput)
}

// Specifies time zone in which the schedule runs.
// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
func (o RecurrenceTriggerOutput) TimeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RecurrenceTrigger) *string { return v.TimeZone }).(pulumi.StringPtrOutput)
}

// Expected value is 'Recurrence'.
func (o RecurrenceTriggerOutput) TriggerType() pulumi.StringOutput {
	return o.ApplyT(func(v RecurrenceTrigger) string { return v.TriggerType }).(pulumi.StringOutput)
}

type RecurrenceTriggerPtrOutput struct{ *pulumi.OutputState }

func (RecurrenceTriggerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrenceTrigger)(nil)).Elem()
}

func (o RecurrenceTriggerPtrOutput) ToRecurrenceTriggerPtrOutput() RecurrenceTriggerPtrOutput {
	return o
}

func (o RecurrenceTriggerPtrOutput) ToRecurrenceTriggerPtrOutputWithContext(ctx context.Context) RecurrenceTriggerPtrOutput {
	return o
}

func (o RecurrenceTriggerPtrOutput) Elem() RecurrenceTriggerOutput {
	return o.ApplyT(func(v *RecurrenceTrigger) RecurrenceTrigger {
		if v != nil {
			return *v
		}
		var ret RecurrenceTrigger
		return ret
	}).(RecurrenceTriggerOutput)
}

// Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
// Recommented format would be "2022-06-01T00:00:01"
// If not present, the schedule will run indefinitely
func (o RecurrenceTriggerPtrOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrenceTrigger) *string {
		if v == nil {
			return nil
		}
		return v.EndTime
	}).(pulumi.StringPtrOutput)
}

// [Required] The frequency to trigger schedule.
func (o RecurrenceTriggerPtrOutput) Frequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrenceTrigger) *string {
		if v == nil {
			return nil
		}
		return &v.Frequency
	}).(pulumi.StringPtrOutput)
}

// [Required] Specifies schedule interval in conjunction with frequency
func (o RecurrenceTriggerPtrOutput) Interval() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RecurrenceTrigger) *int {
		if v == nil {
			return nil
		}
		return &v.Interval
	}).(pulumi.IntPtrOutput)
}

// The recurrence schedule.
func (o RecurrenceTriggerPtrOutput) Schedule() RecurrenceSchedulePtrOutput {
	return o.ApplyT(func(v *RecurrenceTrigger) *RecurrenceSchedule {
		if v == nil {
			return nil
		}
		return v.Schedule
	}).(RecurrenceSchedulePtrOutput)
}

// Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
func (o RecurrenceTriggerPtrOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrenceTrigger) *string {
		if v == nil {
			return nil
		}
		return v.StartTime
	}).(pulumi.StringPtrOutput)
}

// Specifies time zone in which the schedule runs.
// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
func (o RecurrenceTriggerPtrOutput) TimeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrenceTrigger) *string {
		if v == nil {
			return nil
		}
		return v.TimeZone
	}).(pulumi.StringPtrOutput)
}

// Expected value is 'Recurrence'.
func (o RecurrenceTriggerPtrOutput) TriggerType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrenceTrigger) *string {
		if v == nil {
			return nil
		}
		return &v.TriggerType
	}).(pulumi.StringPtrOutput)
}

type RecurrenceTriggerResponse struct {
	// Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
	// Recommented format would be "2022-06-01T00:00:01"
	// If not present, the schedule will run indefinitely
	EndTime *string `pulumi:"endTime"`
	// [Required] The frequency to trigger schedule.
	Frequency string `pulumi:"frequency"`
	// [Required] Specifies schedule interval in conjunction with frequency
	Interval int `pulumi:"interval"`
	// The recurrence schedule.
	Schedule *RecurrenceScheduleResponse `pulumi:"schedule"`
	// Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
	StartTime *string `pulumi:"startTime"`
	// Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `pulumi:"timeZone"`
	// Expected value is 'Recurrence'.
	TriggerType string `pulumi:"triggerType"`
}

// Defaults sets the appropriate defaults for RecurrenceTriggerResponse
func (val *RecurrenceTriggerResponse) Defaults() *RecurrenceTriggerResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.TimeZone == nil {
		timeZone_ := "UTC"
		tmp.TimeZone = &timeZone_
	}
	return &tmp
}

type RecurrenceTriggerResponseOutput struct{ *pulumi.OutputState }

func (RecurrenceTriggerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrenceTriggerResponse)(nil)).Elem()
}

func (o RecurrenceTriggerResponseOutput) ToRecurrenceTriggerResponseOutput() RecurrenceTriggerResponseOutput {
	return o
}

func (o RecurrenceTriggerResponseOutput) ToRecurrenceTriggerResponseOutputWithContext(ctx context.Context) RecurrenceTriggerResponseOutput {
	return o
}

// Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
// Recommented format would be "2022-06-01T00:00:01"
// If not present, the schedule will run indefinitely
func (o RecurrenceTriggerResponseOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RecurrenceTriggerResponse) *string { return v.EndTime }).(pulumi.StringPtrOutput)
}

// [Required] The frequency to trigger schedule.
func (o RecurrenceTriggerResponseOutput) Frequency() pulumi.StringOutput {
	return o.ApplyT(func(v RecurrenceTriggerResponse) string { return v.Frequency }).(pulumi.StringOutput)
}

// [Required] Specifies schedule interval in conjunction with frequency
func (o RecurrenceTriggerResponseOutput) Interval() pulumi.IntOutput {
	return o.ApplyT(func(v RecurrenceTriggerResponse) int { return v.Interval }).(pulumi.IntOutput)
}

// The recurrence schedule.
func (o RecurrenceTriggerResponseOutput) Schedule() RecurrenceScheduleResponsePtrOutput {
	return o.ApplyT(func(v RecurrenceTriggerResponse) *RecurrenceScheduleResponse { return v.Schedule }).(RecurrenceScheduleResponsePtrOutput)
}

// Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
func (o RecurrenceTriggerResponseOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RecurrenceTriggerResponse) *string { return v.StartTime }).(pulumi.StringPtrOutput)
}

// Specifies time zone in which the schedule runs.
// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
func (o RecurrenceTriggerResponseOutput) TimeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RecurrenceTriggerResponse) *string { return v.TimeZone }).(pulumi.StringPtrOutput)
}

// Expected value is 'Recurrence'.
func (o RecurrenceTriggerResponseOutput) TriggerType() pulumi.StringOutput {
	return o.ApplyT(func(v RecurrenceTriggerResponse) string { return v.TriggerType }).(pulumi.StringOutput)
}

type RecurrenceTriggerResponsePtrOutput struct{ *pulumi.OutputState }

func (RecurrenceTriggerResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrenceTriggerResponse)(nil)).Elem()
}

func (o RecurrenceTriggerResponsePtrOutput) ToRecurrenceTriggerResponsePtrOutput() RecurrenceTriggerResponsePtrOutput {
	return o
}

func (o RecurrenceTriggerResponsePtrOutput) ToRecurrenceTriggerResponsePtrOutputWithContext(ctx context.Context) RecurrenceTriggerResponsePtrOutput {
	return o
}

func (o RecurrenceTriggerResponsePtrOutput) Elem() RecurrenceTriggerResponseOutput {
	return o.ApplyT(func(v *RecurrenceTriggerResponse) RecurrenceTriggerResponse {
		if v != nil {
			return *v
		}
		var ret RecurrenceTriggerResponse
		return ret
	}).(RecurrenceTriggerResponseOutput)
}

// Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
// Recommented format would be "2022-06-01T00:00:01"
// If not present, the schedule will run indefinitely
func (o RecurrenceTriggerResponsePtrOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrenceTriggerResponse) *string {
		if v == nil {
			return nil
		}
		return v.EndTime
	}).(pulumi.StringPtrOutput)
}

// [Required] The frequency to trigger schedule.
func (o RecurrenceTriggerResponsePtrOutput) Frequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrenceTriggerResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Frequency
	}).(pulumi.StringPtrOutput)
}

// [Required] Specifies schedule interval in conjunction with frequency
func (o RecurrenceTriggerResponsePtrOutput) Interval() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RecurrenceTriggerResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Interval
	}).(pulumi.IntPtrOutput)
}

// The recurrence schedule.
func (o RecurrenceTriggerResponsePtrOutput) Schedule() RecurrenceScheduleResponsePtrOutput {
	return o.ApplyT(func(v *RecurrenceTriggerResponse) *RecurrenceScheduleResponse {
		if v == nil {
			return nil
		}
		return v.Schedule
	}).(RecurrenceScheduleResponsePtrOutput)
}

// Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
func (o RecurrenceTriggerResponsePtrOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrenceTriggerResponse) *string {
		if v == nil {
			return nil
		}
		return v.StartTime
	}).(pulumi.StringPtrOutput)
}

// Specifies time zone in which the schedule runs.
// TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
func (o RecurrenceTriggerResponsePtrOutput) TimeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrenceTriggerResponse) *string {
		if v == nil {
			return nil
		}
		return v.TimeZone
	}).(pulumi.StringPtrOutput)
}

// Expected value is 'Recurrence'.
func (o RecurrenceTriggerResponsePtrOutput) TriggerType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrenceTriggerResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TriggerType
	}).(pulumi.StringPtrOutput)
}

// Details of the Registry
type RegistryType struct {
	// Discovery URL for the Registry
	DiscoveryUrl *string `pulumi:"discoveryUrl"`
	// IntellectualPropertyPublisher for the registry
	IntellectualPropertyPublisher *string `pulumi:"intellectualPropertyPublisher"`
	// ResourceId of the managed RG if the registry has system created resources
	ManagedResourceGroup *ArmResourceId `pulumi:"managedResourceGroup"`
	// MLFlow Registry URI for the Registry
	MlFlowRegistryUri *string `pulumi:"mlFlowRegistryUri"`
	// Is the Registry accessible from the internet?
	// Possible values: "Enabled" or "Disabled"
	PublicNetworkAccess *string `pulumi:"publicNetworkAccess"`
	// Details of each region the registry is in
	RegionDetails []RegistryRegionArmDetails `pulumi:"regionDetails"`
	// Private endpoint connections info used for pending connections in private link portal
	RegistryPrivateEndpointConnections []RegistryPrivateEndpointConnection `pulumi:"registryPrivateEndpointConnections"`
}

// RegistryTypeInput is an input type that accepts RegistryTypeArgs and RegistryTypeOutput values.
// You can construct a concrete instance of `RegistryTypeInput` via:
//
//	RegistryTypeArgs{...}
type RegistryTypeInput interface {
	pulumi.Input

	ToRegistryTypeOutput() RegistryTypeOutput
	ToRegistryTypeOutputWithContext(context.Context) RegistryTypeOutput
}

// Details of the Registry
type RegistryTypeArgs struct {
	// Discovery URL for the Registry
	DiscoveryUrl pulumi.StringPtrInput `pulumi:"discoveryUrl"`
	// IntellectualPropertyPublisher for the registry
	IntellectualPropertyPublisher pulumi.StringPtrInput `pulumi:"intellectualPropertyPublisher"`
	// ResourceId of the managed RG if the registry has system created resources
	ManagedResourceGroup ArmResourceIdPtrInput `pulumi:"managedResourceGroup"`
	// MLFlow Registry URI for the Registry
	MlFlowRegistryUri pulumi.StringPtrInput `pulumi:"mlFlowRegistryUri"`
	// Is the Registry accessible from the internet?
	// Possible values: "Enabled" or "Disabled"
	PublicNetworkAccess pulumi.StringPtrInput `pulumi:"publicNetworkAccess"`
	// Details of each region the registry is in
	RegionDetails RegistryRegionArmDetailsArrayInput `pulumi:"regionDetails"`
	// Private endpoint connections info used for pending connections in private link portal
	RegistryPrivateEndpointConnections RegistryPrivateEndpointConnectionArrayInput `pulumi:"registryPrivateEndpointConnections"`
}

func (RegistryTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryType)(nil)).Elem()
}

func (i RegistryTypeArgs) ToRegistryTypeOutput() RegistryTypeOutput {
	return i.ToRegistryTypeOutputWithContext(context.Background())
}

func (i RegistryTypeArgs) ToRegistryTypeOutputWithContext(ctx context.Context) RegistryTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryTypeOutput)
}

// Details of the Registry
type RegistryTypeOutput struct{ *pulumi.OutputState }

func (RegistryTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryType)(nil)).Elem()
}

func (o RegistryTypeOutput) ToRegistryTypeOutput() RegistryTypeOutput {
	return o
}

func (o RegistryTypeOutput) ToRegistryTypeOutputWithContext(ctx context.Context) RegistryTypeOutput {
	return o
}

// Discovery URL for the Registry
func (o RegistryTypeOutput) DiscoveryUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryType) *string { return v.DiscoveryUrl }).(pulumi.StringPtrOutput)
}

// IntellectualPropertyPublisher for the registry
func (o RegistryTypeOutput) IntellectualPropertyPublisher() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryType) *string { return v.IntellectualPropertyPublisher }).(pulumi.StringPtrOutput)
}

// ResourceId of the managed RG if the registry has system created resources
func (o RegistryTypeOutput) ManagedResourceGroup() ArmResourceIdPtrOutput {
	return o.ApplyT(func(v RegistryType) *ArmResourceId { return v.ManagedResourceGroup }).(ArmResourceIdPtrOutput)
}

// MLFlow Registry URI for the Registry
func (o RegistryTypeOutput) MlFlowRegistryUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryType) *string { return v.MlFlowRegistryUri }).(pulumi.StringPtrOutput)
}

// Is the Registry accessible from the internet?
// Possible values: "Enabled" or "Disabled"
func (o RegistryTypeOutput) PublicNetworkAccess() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryType) *string { return v.PublicNetworkAccess }).(pulumi.StringPtrOutput)
}

// Details of each region the registry is in
func (o RegistryTypeOutput) RegionDetails() RegistryRegionArmDetailsArrayOutput {
	return o.ApplyT(func(v RegistryType) []RegistryRegionArmDetails { return v.RegionDetails }).(RegistryRegionArmDetailsArrayOutput)
}

// Private endpoint connections info used for pending connections in private link portal
func (o RegistryTypeOutput) RegistryPrivateEndpointConnections() RegistryPrivateEndpointConnectionArrayOutput {
	return o.ApplyT(func(v RegistryType) []RegistryPrivateEndpointConnection { return v.RegistryPrivateEndpointConnections }).(RegistryPrivateEndpointConnectionArrayOutput)
}

type RegistryListCredentialsResultResponse struct {
	// The location of the workspace ACR
	Location  string             `pulumi:"location"`
	Passwords []PasswordResponse `pulumi:"passwords"`
	// The username of the workspace ACR
	Username string `pulumi:"username"`
}

type RegistryListCredentialsResultResponseOutput struct{ *pulumi.OutputState }

func (RegistryListCredentialsResultResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryListCredentialsResultResponse)(nil)).Elem()
}

func (o RegistryListCredentialsResultResponseOutput) ToRegistryListCredentialsResultResponseOutput() RegistryListCredentialsResultResponseOutput {
	return o
}

func (o RegistryListCredentialsResultResponseOutput) ToRegistryListCredentialsResultResponseOutputWithContext(ctx context.Context) RegistryListCredentialsResultResponseOutput {
	return o
}

// The location of the workspace ACR
func (o RegistryListCredentialsResultResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v RegistryListCredentialsResultResponse) string { return v.Location }).(pulumi.StringOutput)
}

func (o RegistryListCredentialsResultResponseOutput) Passwords() PasswordResponseArrayOutput {
	return o.ApplyT(func(v RegistryListCredentialsResultResponse) []PasswordResponse { return v.Passwords }).(PasswordResponseArrayOutput)
}

// The username of the workspace ACR
func (o RegistryListCredentialsResultResponseOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v RegistryListCredentialsResultResponse) string { return v.Username }).(pulumi.StringOutput)
}

type RegistryListCredentialsResultResponsePtrOutput struct{ *pulumi.OutputState }

func (RegistryListCredentialsResultResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryListCredentialsResultResponse)(nil)).Elem()
}

func (o RegistryListCredentialsResultResponsePtrOutput) ToRegistryListCredentialsResultResponsePtrOutput() RegistryListCredentialsResultResponsePtrOutput {
	return o
}

func (o RegistryListCredentialsResultResponsePtrOutput) ToRegistryListCredentialsResultResponsePtrOutputWithContext(ctx context.Context) RegistryListCredentialsResultResponsePtrOutput {
	return o
}

func (o RegistryListCredentialsResultResponsePtrOutput) Elem() RegistryListCredentialsResultResponseOutput {
	return o.ApplyT(func(v *RegistryListCredentialsResultResponse) RegistryListCredentialsResultResponse {
		if v != nil {
			return *v
		}
		var ret RegistryListCredentialsResultResponse
		return ret
	}).(RegistryListCredentialsResultResponseOutput)
}

// The location of the workspace ACR
func (o RegistryListCredentialsResultResponsePtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegistryListCredentialsResultResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Location
	}).(pulumi.StringPtrOutput)
}

func (o RegistryListCredentialsResultResponsePtrOutput) Passwords() PasswordResponseArrayOutput {
	return o.ApplyT(func(v *RegistryListCredentialsResultResponse) []PasswordResponse {
		if v == nil {
			return nil
		}
		return v.Passwords
	}).(PasswordResponseArrayOutput)
}

// The username of the workspace ACR
func (o RegistryListCredentialsResultResponsePtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegistryListCredentialsResultResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Username
	}).(pulumi.StringPtrOutput)
}

// Private endpoint connection definition.
type RegistryPrivateEndpointConnection struct {
	// This is the private endpoint connection name created on SRP
	// Full resource id: /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.MachineLearningServices/{resourceType}/{resourceName}/registryPrivateEndpointConnections/{peConnectionName}
	Id *string `pulumi:"id"`
	// Same as workspace location.
	Location *string `pulumi:"location"`
	// Properties of the Private Endpoint Connection
	Properties *RegistryPrivateEndpointConnectionProperties `pulumi:"properties"`
}

// RegistryPrivateEndpointConnectionInput is an input type that accepts RegistryPrivateEndpointConnectionArgs and RegistryPrivateEndpointConnectionOutput values.
// You can construct a concrete instance of `RegistryPrivateEndpointConnectionInput` via:
//
//	RegistryPrivateEndpointConnectionArgs{...}
type RegistryPrivateEndpointConnectionInput interface {
	pulumi.Input

	ToRegistryPrivateEndpointConnectionOutput() RegistryPrivateEndpointConnectionOutput
	ToRegistryPrivateEndpointConnectionOutputWithContext(context.Context) RegistryPrivateEndpointConnectionOutput
}

// Private endpoint connection definition.
type RegistryPrivateEndpointConnectionArgs struct {
	// This is the private endpoint connection name created on SRP
	// Full resource id: /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.MachineLearningServices/{resourceType}/{resourceName}/registryPrivateEndpointConnections/{peConnectionName}
	Id pulumi.StringPtrInput `pulumi:"id"`
	// Same as workspace location.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// Properties of the Private Endpoint Connection
	Properties RegistryPrivateEndpointConnectionPropertiesPtrInput `pulumi:"properties"`
}

func (RegistryPrivateEndpointConnectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryPrivateEndpointConnection)(nil)).Elem()
}

func (i RegistryPrivateEndpointConnectionArgs) ToRegistryPrivateEndpointConnectionOutput() RegistryPrivateEndpointConnectionOutput {
	return i.ToRegistryPrivateEndpointConnectionOutputWithContext(context.Background())
}

func (i RegistryPrivateEndpointConnectionArgs) ToRegistryPrivateEndpointConnectionOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryPrivateEndpointConnectionOutput)
}

// RegistryPrivateEndpointConnectionArrayInput is an input type that accepts RegistryPrivateEndpointConnectionArray and RegistryPrivateEndpointConnectionArrayOutput values.
// You can construct a concrete instance of `RegistryPrivateEndpointConnectionArrayInput` via:
//
//	RegistryPrivateEndpointConnectionArray{ RegistryPrivateEndpointConnectionArgs{...} }
type RegistryPrivateEndpointConnectionArrayInput interface {
	pulumi.Input

	ToRegistryPrivateEndpointConnectionArrayOutput() RegistryPrivateEndpointConnectionArrayOutput
	ToRegistryPrivateEndpointConnectionArrayOutputWithContext(context.Context) RegistryPrivateEndpointConnectionArrayOutput
}

type RegistryPrivateEndpointConnectionArray []RegistryPrivateEndpointConnectionInput

func (RegistryPrivateEndpointConnectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RegistryPrivateEndpointConnection)(nil)).Elem()
}

func (i RegistryPrivateEndpointConnectionArray) ToRegistryPrivateEndpointConnectionArrayOutput() RegistryPrivateEndpointConnectionArrayOutput {
	return i.ToRegistryPrivateEndpointConnectionArrayOutputWithContext(context.Background())
}

func (i RegistryPrivateEndpointConnectionArray) ToRegistryPrivateEndpointConnectionArrayOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryPrivateEndpointConnectionArrayOutput)
}

// Private endpoint connection definition.
type RegistryPrivateEndpointConnectionOutput struct{ *pulumi.OutputState }

func (RegistryPrivateEndpointConnectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryPrivateEndpointConnection)(nil)).Elem()
}

func (o RegistryPrivateEndpointConnectionOutput) ToRegistryPrivateEndpointConnectionOutput() RegistryPrivateEndpointConnectionOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionOutput) ToRegistryPrivateEndpointConnectionOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionOutput {
	return o
}

// This is the private endpoint connection name created on SRP
// Full resource id: /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.MachineLearningServices/{resourceType}/{resourceName}/registryPrivateEndpointConnections/{peConnectionName}
func (o RegistryPrivateEndpointConnectionOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnection) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Same as workspace location.
func (o RegistryPrivateEndpointConnectionOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnection) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Properties of the Private Endpoint Connection
func (o RegistryPrivateEndpointConnectionOutput) Properties() RegistryPrivateEndpointConnectionPropertiesPtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnection) *RegistryPrivateEndpointConnectionProperties {
		return v.Properties
	}).(RegistryPrivateEndpointConnectionPropertiesPtrOutput)
}

type RegistryPrivateEndpointConnectionArrayOutput struct{ *pulumi.OutputState }

func (RegistryPrivateEndpointConnectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RegistryPrivateEndpointConnection)(nil)).Elem()
}

func (o RegistryPrivateEndpointConnectionArrayOutput) ToRegistryPrivateEndpointConnectionArrayOutput() RegistryPrivateEndpointConnectionArrayOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionArrayOutput) ToRegistryPrivateEndpointConnectionArrayOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionArrayOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionArrayOutput) Index(i pulumi.IntInput) RegistryPrivateEndpointConnectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RegistryPrivateEndpointConnection {
		return vs[0].([]RegistryPrivateEndpointConnection)[vs[1].(int)]
	}).(RegistryPrivateEndpointConnectionOutput)
}

// Properties of the Private Endpoint Connection
type RegistryPrivateEndpointConnectionProperties struct {
	// The group ids
	GroupIds []string `pulumi:"groupIds"`
	// The PE network resource that is linked to this PE connection.
	PrivateEndpoint *PrivateEndpointResource `pulumi:"privateEndpoint"`
	// One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
	ProvisioningState *string `pulumi:"provisioningState"`
	// The connection state.
	RegistryPrivateLinkServiceConnectionState *RegistryPrivateLinkServiceConnectionState `pulumi:"registryPrivateLinkServiceConnectionState"`
}

// RegistryPrivateEndpointConnectionPropertiesInput is an input type that accepts RegistryPrivateEndpointConnectionPropertiesArgs and RegistryPrivateEndpointConnectionPropertiesOutput values.
// You can construct a concrete instance of `RegistryPrivateEndpointConnectionPropertiesInput` via:
//
//	RegistryPrivateEndpointConnectionPropertiesArgs{...}
type RegistryPrivateEndpointConnectionPropertiesInput interface {
	pulumi.Input

	ToRegistryPrivateEndpointConnectionPropertiesOutput() RegistryPrivateEndpointConnectionPropertiesOutput
	ToRegistryPrivateEndpointConnectionPropertiesOutputWithContext(context.Context) RegistryPrivateEndpointConnectionPropertiesOutput
}

// Properties of the Private Endpoint Connection
type RegistryPrivateEndpointConnectionPropertiesArgs struct {
	// The group ids
	GroupIds pulumi.StringArrayInput `pulumi:"groupIds"`
	// The PE network resource that is linked to this PE connection.
	PrivateEndpoint PrivateEndpointResourcePtrInput `pulumi:"privateEndpoint"`
	// One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
	ProvisioningState pulumi.StringPtrInput `pulumi:"provisioningState"`
	// The connection state.
	RegistryPrivateLinkServiceConnectionState RegistryPrivateLinkServiceConnectionStatePtrInput `pulumi:"registryPrivateLinkServiceConnectionState"`
}

func (RegistryPrivateEndpointConnectionPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryPrivateEndpointConnectionProperties)(nil)).Elem()
}

func (i RegistryPrivateEndpointConnectionPropertiesArgs) ToRegistryPrivateEndpointConnectionPropertiesOutput() RegistryPrivateEndpointConnectionPropertiesOutput {
	return i.ToRegistryPrivateEndpointConnectionPropertiesOutputWithContext(context.Background())
}

func (i RegistryPrivateEndpointConnectionPropertiesArgs) ToRegistryPrivateEndpointConnectionPropertiesOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryPrivateEndpointConnectionPropertiesOutput)
}

func (i RegistryPrivateEndpointConnectionPropertiesArgs) ToRegistryPrivateEndpointConnectionPropertiesPtrOutput() RegistryPrivateEndpointConnectionPropertiesPtrOutput {
	return i.ToRegistryPrivateEndpointConnectionPropertiesPtrOutputWithContext(context.Background())
}

func (i RegistryPrivateEndpointConnectionPropertiesArgs) ToRegistryPrivateEndpointConnectionPropertiesPtrOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryPrivateEndpointConnectionPropertiesOutput).ToRegistryPrivateEndpointConnectionPropertiesPtrOutputWithContext(ctx)
}

// RegistryPrivateEndpointConnectionPropertiesPtrInput is an input type that accepts RegistryPrivateEndpointConnectionPropertiesArgs, RegistryPrivateEndpointConnectionPropertiesPtr and RegistryPrivateEndpointConnectionPropertiesPtrOutput values.
// You can construct a concrete instance of `RegistryPrivateEndpointConnectionPropertiesPtrInput` via:
//
//	        RegistryPrivateEndpointConnectionPropertiesArgs{...}
//
//	or:
//
//	        nil
type RegistryPrivateEndpointConnectionPropertiesPtrInput interface {
	pulumi.Input

	ToRegistryPrivateEndpointConnectionPropertiesPtrOutput() RegistryPrivateEndpointConnectionPropertiesPtrOutput
	ToRegistryPrivateEndpointConnectionPropertiesPtrOutputWithContext(context.Context) RegistryPrivateEndpointConnectionPropertiesPtrOutput
}

type registryPrivateEndpointConnectionPropertiesPtrType RegistryPrivateEndpointConnectionPropertiesArgs

func RegistryPrivateEndpointConnectionPropertiesPtr(v *RegistryPrivateEndpointConnectionPropertiesArgs) RegistryPrivateEndpointConnectionPropertiesPtrInput {
	return (*registryPrivateEndpointConnectionPropertiesPtrType)(v)
}

func (*registryPrivateEndpointConnectionPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryPrivateEndpointConnectionProperties)(nil)).Elem()
}

func (i *registryPrivateEndpointConnectionPropertiesPtrType) ToRegistryPrivateEndpointConnectionPropertiesPtrOutput() RegistryPrivateEndpointConnectionPropertiesPtrOutput {
	return i.ToRegistryPrivateEndpointConnectionPropertiesPtrOutputWithContext(context.Background())
}

func (i *registryPrivateEndpointConnectionPropertiesPtrType) ToRegistryPrivateEndpointConnectionPropertiesPtrOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryPrivateEndpointConnectionPropertiesPtrOutput)
}

// Properties of the Private Endpoint Connection
type RegistryPrivateEndpointConnectionPropertiesOutput struct{ *pulumi.OutputState }

func (RegistryPrivateEndpointConnectionPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryPrivateEndpointConnectionProperties)(nil)).Elem()
}

func (o RegistryPrivateEndpointConnectionPropertiesOutput) ToRegistryPrivateEndpointConnectionPropertiesOutput() RegistryPrivateEndpointConnectionPropertiesOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionPropertiesOutput) ToRegistryPrivateEndpointConnectionPropertiesOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionPropertiesOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionPropertiesOutput) ToRegistryPrivateEndpointConnectionPropertiesPtrOutput() RegistryPrivateEndpointConnectionPropertiesPtrOutput {
	return o.ToRegistryPrivateEndpointConnectionPropertiesPtrOutputWithContext(context.Background())
}

func (o RegistryPrivateEndpointConnectionPropertiesOutput) ToRegistryPrivateEndpointConnectionPropertiesPtrOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RegistryPrivateEndpointConnectionProperties) *RegistryPrivateEndpointConnectionProperties {
		return &v
	}).(RegistryPrivateEndpointConnectionPropertiesPtrOutput)
}

// The group ids
func (o RegistryPrivateEndpointConnectionPropertiesOutput) GroupIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnectionProperties) []string { return v.GroupIds }).(pulumi.StringArrayOutput)
}

// The PE network resource that is linked to this PE connection.
func (o RegistryPrivateEndpointConnectionPropertiesOutput) PrivateEndpoint() PrivateEndpointResourcePtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnectionProperties) *PrivateEndpointResource { return v.PrivateEndpoint }).(PrivateEndpointResourcePtrOutput)
}

// One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
func (o RegistryPrivateEndpointConnectionPropertiesOutput) ProvisioningState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnectionProperties) *string { return v.ProvisioningState }).(pulumi.StringPtrOutput)
}

// The connection state.
func (o RegistryPrivateEndpointConnectionPropertiesOutput) RegistryPrivateLinkServiceConnectionState() RegistryPrivateLinkServiceConnectionStatePtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnectionProperties) *RegistryPrivateLinkServiceConnectionState {
		return v.RegistryPrivateLinkServiceConnectionState
	}).(RegistryPrivateLinkServiceConnectionStatePtrOutput)
}

type RegistryPrivateEndpointConnectionPropertiesPtrOutput struct{ *pulumi.OutputState }

func (RegistryPrivateEndpointConnectionPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryPrivateEndpointConnectionProperties)(nil)).Elem()
}

func (o RegistryPrivateEndpointConnectionPropertiesPtrOutput) ToRegistryPrivateEndpointConnectionPropertiesPtrOutput() RegistryPrivateEndpointConnectionPropertiesPtrOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionPropertiesPtrOutput) ToRegistryPrivateEndpointConnectionPropertiesPtrOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionPropertiesPtrOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionPropertiesPtrOutput) Elem() RegistryPrivateEndpointConnectionPropertiesOutput {
	return o.ApplyT(func(v *RegistryPrivateEndpointConnectionProperties) RegistryPrivateEndpointConnectionProperties {
		if v != nil {
			return *v
		}
		var ret RegistryPrivateEndpointConnectionProperties
		return ret
	}).(RegistryPrivateEndpointConnectionPropertiesOutput)
}

// The group ids
func (o RegistryPrivateEndpointConnectionPropertiesPtrOutput) GroupIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RegistryPrivateEndpointConnectionProperties) []string {
		if v == nil {
			return nil
		}
		return v.GroupIds
	}).(pulumi.StringArrayOutput)
}

// The PE network resource that is linked to this PE connection.
func (o RegistryPrivateEndpointConnectionPropertiesPtrOutput) PrivateEndpoint() PrivateEndpointResourcePtrOutput {
	return o.ApplyT(func(v *RegistryPrivateEndpointConnectionProperties) *PrivateEndpointResource {
		if v == nil {
			return nil
		}
		return v.PrivateEndpoint
	}).(PrivateEndpointResourcePtrOutput)
}

// One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
func (o RegistryPrivateEndpointConnectionPropertiesPtrOutput) ProvisioningState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegistryPrivateEndpointConnectionProperties) *string {
		if v == nil {
			return nil
		}
		return v.ProvisioningState
	}).(pulumi.StringPtrOutput)
}

// The connection state.
func (o RegistryPrivateEndpointConnectionPropertiesPtrOutput) RegistryPrivateLinkServiceConnectionState() RegistryPrivateLinkServiceConnectionStatePtrOutput {
	return o.ApplyT(func(v *RegistryPrivateEndpointConnectionProperties) *RegistryPrivateLinkServiceConnectionState {
		if v == nil {
			return nil
		}
		return v.RegistryPrivateLinkServiceConnectionState
	}).(RegistryPrivateLinkServiceConnectionStatePtrOutput)
}

// Properties of the Private Endpoint Connection
type RegistryPrivateEndpointConnectionPropertiesResponse struct {
	// The group ids
	GroupIds []string `pulumi:"groupIds"`
	// The PE network resource that is linked to this PE connection.
	PrivateEndpoint *PrivateEndpointResourceResponse `pulumi:"privateEndpoint"`
	// One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
	ProvisioningState *string `pulumi:"provisioningState"`
	// The connection state.
	RegistryPrivateLinkServiceConnectionState *RegistryPrivateLinkServiceConnectionStateResponse `pulumi:"registryPrivateLinkServiceConnectionState"`
}

// Properties of the Private Endpoint Connection
type RegistryPrivateEndpointConnectionPropertiesResponseOutput struct{ *pulumi.OutputState }

func (RegistryPrivateEndpointConnectionPropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryPrivateEndpointConnectionPropertiesResponse)(nil)).Elem()
}

func (o RegistryPrivateEndpointConnectionPropertiesResponseOutput) ToRegistryPrivateEndpointConnectionPropertiesResponseOutput() RegistryPrivateEndpointConnectionPropertiesResponseOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionPropertiesResponseOutput) ToRegistryPrivateEndpointConnectionPropertiesResponseOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionPropertiesResponseOutput {
	return o
}

// The group ids
func (o RegistryPrivateEndpointConnectionPropertiesResponseOutput) GroupIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnectionPropertiesResponse) []string { return v.GroupIds }).(pulumi.StringArrayOutput)
}

// The PE network resource that is linked to this PE connection.
func (o RegistryPrivateEndpointConnectionPropertiesResponseOutput) PrivateEndpoint() PrivateEndpointResourceResponsePtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnectionPropertiesResponse) *PrivateEndpointResourceResponse {
		return v.PrivateEndpoint
	}).(PrivateEndpointResourceResponsePtrOutput)
}

// One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
func (o RegistryPrivateEndpointConnectionPropertiesResponseOutput) ProvisioningState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnectionPropertiesResponse) *string { return v.ProvisioningState }).(pulumi.StringPtrOutput)
}

// The connection state.
func (o RegistryPrivateEndpointConnectionPropertiesResponseOutput) RegistryPrivateLinkServiceConnectionState() RegistryPrivateLinkServiceConnectionStateResponsePtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnectionPropertiesResponse) *RegistryPrivateLinkServiceConnectionStateResponse {
		return v.RegistryPrivateLinkServiceConnectionState
	}).(RegistryPrivateLinkServiceConnectionStateResponsePtrOutput)
}

type RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput struct{ *pulumi.OutputState }

func (RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryPrivateEndpointConnectionPropertiesResponse)(nil)).Elem()
}

func (o RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput) ToRegistryPrivateEndpointConnectionPropertiesResponsePtrOutput() RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput) ToRegistryPrivateEndpointConnectionPropertiesResponsePtrOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput) Elem() RegistryPrivateEndpointConnectionPropertiesResponseOutput {
	return o.ApplyT(func(v *RegistryPrivateEndpointConnectionPropertiesResponse) RegistryPrivateEndpointConnectionPropertiesResponse {
		if v != nil {
			return *v
		}
		var ret RegistryPrivateEndpointConnectionPropertiesResponse
		return ret
	}).(RegistryPrivateEndpointConnectionPropertiesResponseOutput)
}

// The group ids
func (o RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput) GroupIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RegistryPrivateEndpointConnectionPropertiesResponse) []string {
		if v == nil {
			return nil
		}
		return v.GroupIds
	}).(pulumi.StringArrayOutput)
}

// The PE network resource that is linked to this PE connection.
func (o RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput) PrivateEndpoint() PrivateEndpointResourceResponsePtrOutput {
	return o.ApplyT(func(v *RegistryPrivateEndpointConnectionPropertiesResponse) *PrivateEndpointResourceResponse {
		if v == nil {
			return nil
		}
		return v.PrivateEndpoint
	}).(PrivateEndpointResourceResponsePtrOutput)
}

// One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
func (o RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput) ProvisioningState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegistryPrivateEndpointConnectionPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return v.ProvisioningState
	}).(pulumi.StringPtrOutput)
}

// The connection state.
func (o RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput) RegistryPrivateLinkServiceConnectionState() RegistryPrivateLinkServiceConnectionStateResponsePtrOutput {
	return o.ApplyT(func(v *RegistryPrivateEndpointConnectionPropertiesResponse) *RegistryPrivateLinkServiceConnectionStateResponse {
		if v == nil {
			return nil
		}
		return v.RegistryPrivateLinkServiceConnectionState
	}).(RegistryPrivateLinkServiceConnectionStateResponsePtrOutput)
}

// Private endpoint connection definition.
type RegistryPrivateEndpointConnectionResponse struct {
	// This is the private endpoint connection name created on SRP
	// Full resource id: /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.MachineLearningServices/{resourceType}/{resourceName}/registryPrivateEndpointConnections/{peConnectionName}
	Id *string `pulumi:"id"`
	// Same as workspace location.
	Location *string `pulumi:"location"`
	// Properties of the Private Endpoint Connection
	Properties *RegistryPrivateEndpointConnectionPropertiesResponse `pulumi:"properties"`
}

// Private endpoint connection definition.
type RegistryPrivateEndpointConnectionResponseOutput struct{ *pulumi.OutputState }

func (RegistryPrivateEndpointConnectionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryPrivateEndpointConnectionResponse)(nil)).Elem()
}

func (o RegistryPrivateEndpointConnectionResponseOutput) ToRegistryPrivateEndpointConnectionResponseOutput() RegistryPrivateEndpointConnectionResponseOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionResponseOutput) ToRegistryPrivateEndpointConnectionResponseOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionResponseOutput {
	return o
}

// This is the private endpoint connection name created on SRP
// Full resource id: /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.MachineLearningServices/{resourceType}/{resourceName}/registryPrivateEndpointConnections/{peConnectionName}
func (o RegistryPrivateEndpointConnectionResponseOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnectionResponse) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Same as workspace location.
func (o RegistryPrivateEndpointConnectionResponseOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnectionResponse) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Properties of the Private Endpoint Connection
func (o RegistryPrivateEndpointConnectionResponseOutput) Properties() RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput {
	return o.ApplyT(func(v RegistryPrivateEndpointConnectionResponse) *RegistryPrivateEndpointConnectionPropertiesResponse {
		return v.Properties
	}).(RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput)
}

type RegistryPrivateEndpointConnectionResponseArrayOutput struct{ *pulumi.OutputState }

func (RegistryPrivateEndpointConnectionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RegistryPrivateEndpointConnectionResponse)(nil)).Elem()
}

func (o RegistryPrivateEndpointConnectionResponseArrayOutput) ToRegistryPrivateEndpointConnectionResponseArrayOutput() RegistryPrivateEndpointConnectionResponseArrayOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionResponseArrayOutput) ToRegistryPrivateEndpointConnectionResponseArrayOutputWithContext(ctx context.Context) RegistryPrivateEndpointConnectionResponseArrayOutput {
	return o
}

func (o RegistryPrivateEndpointConnectionResponseArrayOutput) Index(i pulumi.IntInput) RegistryPrivateEndpointConnectionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RegistryPrivateEndpointConnectionResponse {
		return vs[0].([]RegistryPrivateEndpointConnectionResponse)[vs[1].(int)]
	}).(RegistryPrivateEndpointConnectionResponseOutput)
}

// The connection state.
type RegistryPrivateLinkServiceConnectionState struct {
	// Some RP chose "None". Other RPs use this for region expansion.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// User-defined message that, per NRP doc, may be used for approval-related message.
	Description *string `pulumi:"description"`
	// Connection status of the service consumer with the service provider
	Status *string `pulumi:"status"`
}

// RegistryPrivateLinkServiceConnectionStateInput is an input type that accepts RegistryPrivateLinkServiceConnectionStateArgs and RegistryPrivateLinkServiceConnectionStateOutput values.
// You can construct a concrete instance of `RegistryPrivateLinkServiceConnectionStateInput` via:
//
//	RegistryPrivateLinkServiceConnectionStateArgs{...}
type RegistryPrivateLinkServiceConnectionStateInput interface {
	pulumi.Input

	ToRegistryPrivateLinkServiceConnectionStateOutput() RegistryPrivateLinkServiceConnectionStateOutput
	ToRegistryPrivateLinkServiceConnectionStateOutputWithContext(context.Context) RegistryPrivateLinkServiceConnectionStateOutput
}

// The connection state.
type RegistryPrivateLinkServiceConnectionStateArgs struct {
	// Some RP chose "None". Other RPs use this for region expansion.
	ActionsRequired pulumi.StringPtrInput `pulumi:"actionsRequired"`
	// User-defined message that, per NRP doc, may be used for approval-related message.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Connection status of the service consumer with the service provider
	Status pulumi.StringPtrInput `pulumi:"status"`
}

func (RegistryPrivateLinkServiceConnectionStateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryPrivateLinkServiceConnectionState)(nil)).Elem()
}

func (i RegistryPrivateLinkServiceConnectionStateArgs) ToRegistryPrivateLinkServiceConnectionStateOutput() RegistryPrivateLinkServiceConnectionStateOutput {
	return i.ToRegistryPrivateLinkServiceConnectionStateOutputWithContext(context.Background())
}

func (i RegistryPrivateLinkServiceConnectionStateArgs) ToRegistryPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) RegistryPrivateLinkServiceConnectionStateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryPrivateLinkServiceConnectionStateOutput)
}

func (i RegistryPrivateLinkServiceConnectionStateArgs) ToRegistryPrivateLinkServiceConnectionStatePtrOutput() RegistryPrivateLinkServiceConnectionStatePtrOutput {
	return i.ToRegistryPrivateLinkServiceConnectionStatePtrOutputWithContext(context.Background())
}

func (i RegistryPrivateLinkServiceConnectionStateArgs) ToRegistryPrivateLinkServiceConnectionStatePtrOutputWithContext(ctx context.Context) RegistryPrivateLinkServiceConnectionStatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryPrivateLinkServiceConnectionStateOutput).ToRegistryPrivateLinkServiceConnectionStatePtrOutputWithContext(ctx)
}

// RegistryPrivateLinkServiceConnectionStatePtrInput is an input type that accepts RegistryPrivateLinkServiceConnectionStateArgs, RegistryPrivateLinkServiceConnectionStatePtr and RegistryPrivateLinkServiceConnectionStatePtrOutput values.
// You can construct a concrete instance of `RegistryPrivateLinkServiceConnectionStatePtrInput` via:
//
//	        RegistryPrivateLinkServiceConnectionStateArgs{...}
//
//	or:
//
//	        nil
type RegistryPrivateLinkServiceConnectionStatePtrInput interface {
	pulumi.Input

	ToRegistryPrivateLinkServiceConnectionStatePtrOutput() RegistryPrivateLinkServiceConnectionStatePtrOutput
	ToRegistryPrivateLinkServiceConnectionStatePtrOutputWithContext(context.Context) RegistryPrivateLinkServiceConnectionStatePtrOutput
}

type registryPrivateLinkServiceConnectionStatePtrType RegistryPrivateLinkServiceConnectionStateArgs

func RegistryPrivateLinkServiceConnectionStatePtr(v *RegistryPrivateLinkServiceConnectionStateArgs) RegistryPrivateLinkServiceConnectionStatePtrInput {
	return (*registryPrivateLinkServiceConnectionStatePtrType)(v)
}

func (*registryPrivateLinkServiceConnectionStatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryPrivateLinkServiceConnectionState)(nil)).Elem()
}

func (i *registryPrivateLinkServiceConnectionStatePtrType) ToRegistryPrivateLinkServiceConnectionStatePtrOutput() RegistryPrivateLinkServiceConnectionStatePtrOutput {
	return i.ToRegistryPrivateLinkServiceConnectionStatePtrOutputWithContext(context.Background())
}

func (i *registryPrivateLinkServiceConnectionStatePtrType) ToRegistryPrivateLinkServiceConnectionStatePtrOutputWithContext(ctx context.Context) RegistryPrivateLinkServiceConnectionStatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryPrivateLinkServiceConnectionStatePtrOutput)
}

// The connection state.
type RegistryPrivateLinkServiceConnectionStateOutput struct{ *pulumi.OutputState }

func (RegistryPrivateLinkServiceConnectionStateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryPrivateLinkServiceConnectionState)(nil)).Elem()
}

func (o RegistryPrivateLinkServiceConnectionStateOutput) ToRegistryPrivateLinkServiceConnectionStateOutput() RegistryPrivateLinkServiceConnectionStateOutput {
	return o
}

func (o RegistryPrivateLinkServiceConnectionStateOutput) ToRegistryPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) RegistryPrivateLinkServiceConnectionStateOutput {
	return o
}

func (o RegistryPrivateLinkServiceConnectionStateOutput) ToRegistryPrivateLinkServiceConnectionStatePtrOutput() RegistryPrivateLinkServiceConnectionStatePtrOutput {
	return o.ToRegistryPrivateLinkServiceConnectionStatePtrOutputWithContext(context.Background())
}

func (o RegistryPrivateLinkServiceConnectionStateOutput) ToRegistryPrivateLinkServiceConnectionStatePtrOutputWithContext(ctx context.Context) RegistryPrivateLinkServiceConnectionStatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RegistryPrivateLinkServiceConnectionState) *RegistryPrivateLinkServiceConnectionState {
		return &v
	}).(RegistryPrivateLinkServiceConnectionStatePtrOutput)
}

// Some RP chose "None". Other RPs use this for region expansion.
func (o RegistryPrivateLinkServiceConnectionStateOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateLinkServiceConnectionState) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// User-defined message that, per NRP doc, may be used for approval-related message.
func (o RegistryPrivateLinkServiceConnectionStateOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateLinkServiceConnectionState) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Connection status of the service consumer with the service provider
func (o RegistryPrivateLinkServiceConnectionStateOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateLinkServiceConnectionState) *string { return v.Status }).(pulumi.StringPtrOutput)
}

type RegistryPrivateLinkServiceConnectionStatePtrOutput struct{ *pulumi.OutputState }

func (RegistryPrivateLinkServiceConnectionStatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryPrivateLinkServiceConnectionState)(nil)).Elem()
}

func (o RegistryPrivateLinkServiceConnectionStatePtrOutput) ToRegistryPrivateLinkServiceConnectionStatePtrOutput() RegistryPrivateLinkServiceConnectionStatePtrOutput {
	return o
}

func (o RegistryPrivateLinkServiceConnectionStatePtrOutput) ToRegistryPrivateLinkServiceConnectionStatePtrOutputWithContext(ctx context.Context) RegistryPrivateLinkServiceConnectionStatePtrOutput {
	return o
}

func (o RegistryPrivateLinkServiceConnectionStatePtrOutput) Elem() RegistryPrivateLinkServiceConnectionStateOutput {
	return o.ApplyT(func(v *RegistryPrivateLinkServiceConnectionState) RegistryPrivateLinkServiceConnectionState {
		if v != nil {
			return *v
		}
		var ret RegistryPrivateLinkServiceConnectionState
		return ret
	}).(RegistryPrivateLinkServiceConnectionStateOutput)
}

// Some RP chose "None". Other RPs use this for region expansion.
func (o RegistryPrivateLinkServiceConnectionStatePtrOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegistryPrivateLinkServiceConnectionState) *string {
		if v == nil {
			return nil
		}
		return v.ActionsRequired
	}).(pulumi.StringPtrOutput)
}

// User-defined message that, per NRP doc, may be used for approval-related message.
func (o RegistryPrivateLinkServiceConnectionStatePtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegistryPrivateLinkServiceConnectionState) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Connection status of the service consumer with the service provider
func (o RegistryPrivateLinkServiceConnectionStatePtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegistryPrivateLinkServiceConnectionState) *string {
		if v == nil {
			return nil
		}
		return v.Status
	}).(pulumi.StringPtrOutput)
}

// The connection state.
type RegistryPrivateLinkServiceConnectionStateResponse struct {
	// Some RP chose "None". Other RPs use this for region expansion.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// User-defined message that, per NRP doc, may be used for approval-related message.
	Description *string `pulumi:"description"`
	// Connection status of the service consumer with the service provider
	Status *string `pulumi:"status"`
}

// The connection state.
type RegistryPrivateLinkServiceConnectionStateResponseOutput struct{ *pulumi.OutputState }

func (RegistryPrivateLinkServiceConnectionStateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryPrivateLinkServiceConnectionStateResponse)(nil)).Elem()
}

func (o RegistryPrivateLinkServiceConnectionStateResponseOutput) ToRegistryPrivateLinkServiceConnectionStateResponseOutput() RegistryPrivateLinkServiceConnectionStateResponseOutput {
	return o
}

func (o RegistryPrivateLinkServiceConnectionStateResponseOutput) ToRegistryPrivateLinkServiceConnectionStateResponseOutputWithContext(ctx context.Context) RegistryPrivateLinkServiceConnectionStateResponseOutput {
	return o
}

// Some RP chose "None". Other RPs use this for region expansion.
func (o RegistryPrivateLinkServiceConnectionStateResponseOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateLinkServiceConnectionStateResponse) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// User-defined message that, per NRP doc, may be used for approval-related message.
func (o RegistryPrivateLinkServiceConnectionStateResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateLinkServiceConnectionStateResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Connection status of the service consumer with the service provider
func (o RegistryPrivateLinkServiceConnectionStateResponseOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryPrivateLinkServiceConnectionStateResponse) *string { return v.Status }).(pulumi.StringPtrOutput)
}

type RegistryPrivateLinkServiceConnectionStateResponsePtrOutput struct{ *pulumi.OutputState }

func (RegistryPrivateLinkServiceConnectionStateResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryPrivateLinkServiceConnectionStateResponse)(nil)).Elem()
}

func (o RegistryPrivateLinkServiceConnectionStateResponsePtrOutput) ToRegistryPrivateLinkServiceConnectionStateResponsePtrOutput() RegistryPrivateLinkServiceConnectionStateResponsePtrOutput {
	return o
}

func (o RegistryPrivateLinkServiceConnectionStateResponsePtrOutput) ToRegistryPrivateLinkServiceConnectionStateResponsePtrOutputWithContext(ctx context.Context) RegistryPrivateLinkServiceConnectionStateResponsePtrOutput {
	return o
}

func (o RegistryPrivateLinkServiceConnectionStateResponsePtrOutput) Elem() RegistryPrivateLinkServiceConnectionStateResponseOutput {
	return o.ApplyT(func(v *RegistryPrivateLinkServiceConnectionStateResponse) RegistryPrivateLinkServiceConnectionStateResponse {
		if v != nil {
			return *v
		}
		var ret RegistryPrivateLinkServiceConnectionStateResponse
		return ret
	}).(RegistryPrivateLinkServiceConnectionStateResponseOutput)
}

// Some RP chose "None". Other RPs use this for region expansion.
func (o RegistryPrivateLinkServiceConnectionStateResponsePtrOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegistryPrivateLinkServiceConnectionStateResponse) *string {
		if v == nil {
			return nil
		}
		return v.ActionsRequired
	}).(pulumi.StringPtrOutput)
}

// User-defined message that, per NRP doc, may be used for approval-related message.
func (o RegistryPrivateLinkServiceConnectionStateResponsePtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegistryPrivateLinkServiceConnectionStateResponse) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Connection status of the service consumer with the service provider
func (o RegistryPrivateLinkServiceConnectionStateResponsePtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegistryPrivateLinkServiceConnectionStateResponse) *string {
		if v == nil {
			return nil
		}
		return v.Status
	}).(pulumi.StringPtrOutput)
}

// Details for each region the registry is in
type RegistryRegionArmDetails struct {
	// List of ACR accounts
	AcrDetails []AcrDetails `pulumi:"acrDetails"`
	// The location where the registry exists
	Location *string `pulumi:"location"`
	// List of storage accounts
	StorageAccountDetails []StorageAccountDetails `pulumi:"storageAccountDetails"`
}

// RegistryRegionArmDetailsInput is an input type that accepts RegistryRegionArmDetailsArgs and RegistryRegionArmDetailsOutput values.
// You can construct a concrete instance of `RegistryRegionArmDetailsInput` via:
//
//	RegistryRegionArmDetailsArgs{...}
type RegistryRegionArmDetailsInput interface {
	pulumi.Input

	ToRegistryRegionArmDetailsOutput() RegistryRegionArmDetailsOutput
	ToRegistryRegionArmDetailsOutputWithContext(context.Context) RegistryRegionArmDetailsOutput
}

// Details for each region the registry is in
type RegistryRegionArmDetailsArgs struct {
	// List of ACR accounts
	AcrDetails AcrDetailsArrayInput `pulumi:"acrDetails"`
	// The location where the registry exists
	Location pulumi.StringPtrInput `pulumi:"location"`
	// List of storage accounts
	StorageAccountDetails StorageAccountDetailsArrayInput `pulumi:"storageAccountDetails"`
}

func (RegistryRegionArmDetailsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryRegionArmDetails)(nil)).Elem()
}

func (i RegistryRegionArmDetailsArgs) ToRegistryRegionArmDetailsOutput() RegistryRegionArmDetailsOutput {
	return i.ToRegistryRegionArmDetailsOutputWithContext(context.Background())
}

func (i RegistryRegionArmDetailsArgs) ToRegistryRegionArmDetailsOutputWithContext(ctx context.Context) RegistryRegionArmDetailsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryRegionArmDetailsOutput)
}

// RegistryRegionArmDetailsArrayInput is an input type that accepts RegistryRegionArmDetailsArray and RegistryRegionArmDetailsArrayOutput values.
// You can construct a concrete instance of `RegistryRegionArmDetailsArrayInput` via:
//
//	RegistryRegionArmDetailsArray{ RegistryRegionArmDetailsArgs{...} }
type RegistryRegionArmDetailsArrayInput interface {
	pulumi.Input

	ToRegistryRegionArmDetailsArrayOutput() RegistryRegionArmDetailsArrayOutput
	ToRegistryRegionArmDetailsArrayOutputWithContext(context.Context) RegistryRegionArmDetailsArrayOutput
}

type RegistryRegionArmDetailsArray []RegistryRegionArmDetailsInput

func (RegistryRegionArmDetailsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RegistryRegionArmDetails)(nil)).Elem()
}

func (i RegistryRegionArmDetailsArray) ToRegistryRegionArmDetailsArrayOutput() RegistryRegionArmDetailsArrayOutput {
	return i.ToRegistryRegionArmDetailsArrayOutputWithContext(context.Background())
}

func (i RegistryRegionArmDetailsArray) ToRegistryRegionArmDetailsArrayOutputWithContext(ctx context.Context) RegistryRegionArmDetailsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryRegionArmDetailsArrayOutput)
}

// Details for each region the registry is in
type RegistryRegionArmDetailsOutput struct{ *pulumi.OutputState }

func (RegistryRegionArmDetailsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryRegionArmDetails)(nil)).Elem()
}

func (o RegistryRegionArmDetailsOutput) ToRegistryRegionArmDetailsOutput() RegistryRegionArmDetailsOutput {
	return o
}

func (o RegistryRegionArmDetailsOutput) ToRegistryRegionArmDetailsOutputWithContext(ctx context.Context) RegistryRegionArmDetailsOutput {
	return o
}

// List of ACR accounts
func (o RegistryRegionArmDetailsOutput) AcrDetails() AcrDetailsArrayOutput {
	return o.ApplyT(func(v RegistryRegionArmDetails) []AcrDetails { return v.AcrDetails }).(AcrDetailsArrayOutput)
}

// The location where the registry exists
func (o RegistryRegionArmDetailsOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryRegionArmDetails) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// List of storage accounts
func (o RegistryRegionArmDetailsOutput) StorageAccountDetails() StorageAccountDetailsArrayOutput {
	return o.ApplyT(func(v RegistryRegionArmDetails) []StorageAccountDetails { return v.StorageAccountDetails }).(StorageAccountDetailsArrayOutput)
}

type RegistryRegionArmDetailsArrayOutput struct{ *pulumi.OutputState }

func (RegistryRegionArmDetailsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RegistryRegionArmDetails)(nil)).Elem()
}

func (o RegistryRegionArmDetailsArrayOutput) ToRegistryRegionArmDetailsArrayOutput() RegistryRegionArmDetailsArrayOutput {
	return o
}

func (o RegistryRegionArmDetailsArrayOutput) ToRegistryRegionArmDetailsArrayOutputWithContext(ctx context.Context) RegistryRegionArmDetailsArrayOutput {
	return o
}

func (o RegistryRegionArmDetailsArrayOutput) Index(i pulumi.IntInput) RegistryRegionArmDetailsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RegistryRegionArmDetails {
		return vs[0].([]RegistryRegionArmDetails)[vs[1].(int)]
	}).(RegistryRegionArmDetailsOutput)
}

// Details for each region the registry is in
type RegistryRegionArmDetailsResponse struct {
	// List of ACR accounts
	AcrDetails []AcrDetailsResponse `pulumi:"acrDetails"`
	// The location where the registry exists
	Location *string `pulumi:"location"`
	// List of storage accounts
	StorageAccountDetails []StorageAccountDetailsResponse `pulumi:"storageAccountDetails"`
}

// Details for each region the registry is in
type RegistryRegionArmDetailsResponseOutput struct{ *pulumi.OutputState }

func (RegistryRegionArmDetailsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryRegionArmDetailsResponse)(nil)).Elem()
}

func (o RegistryRegionArmDetailsResponseOutput) ToRegistryRegionArmDetailsResponseOutput() RegistryRegionArmDetailsResponseOutput {
	return o
}

func (o RegistryRegionArmDetailsResponseOutput) ToRegistryRegionArmDetailsResponseOutputWithContext(ctx context.Context) RegistryRegionArmDetailsResponseOutput {
	return o
}

// List of ACR accounts
func (o RegistryRegionArmDetailsResponseOutput) AcrDetails() AcrDetailsResponseArrayOutput {
	return o.ApplyT(func(v RegistryRegionArmDetailsResponse) []AcrDetailsResponse { return v.AcrDetails }).(AcrDetailsResponseArrayOutput)
}

// The location where the registry exists
func (o RegistryRegionArmDetailsResponseOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryRegionArmDetailsResponse) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// List of storage accounts
func (o RegistryRegionArmDetailsResponseOutput) StorageAccountDetails() StorageAccountDetailsResponseArrayOutput {
	return o.ApplyT(func(v RegistryRegionArmDetailsResponse) []StorageAccountDetailsResponse {
		return v.StorageAccountDetails
	}).(StorageAccountDetailsResponseArrayOutput)
}

type RegistryRegionArmDetailsResponseArrayOutput struct{ *pulumi.OutputState }

func (RegistryRegionArmDetailsResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RegistryRegionArmDetailsResponse)(nil)).Elem()
}

func (o RegistryRegionArmDetailsResponseArrayOutput) ToRegistryRegionArmDetailsResponseArrayOutput() RegistryRegionArmDetailsResponseArrayOutput {
	return o
}

func (o RegistryRegionArmDetailsResponseArrayOutput) ToRegistryRegionArmDetailsResponseArrayOutputWithContext(ctx context.Context) RegistryRegionArmDetailsResponseArrayOutput {
	return o
}

func (o RegistryRegionArmDetailsResponseArrayOutput) Index(i pulumi.IntInput) RegistryRegionArmDetailsResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RegistryRegionArmDetailsResponse {
		return vs[0].([]RegistryRegionArmDetailsResponse)[vs[1].(int)]
	}).(RegistryRegionArmDetailsResponseOutput)
}

// Details of the Registry
type RegistryResponse struct {
	// Discovery URL for the Registry
	DiscoveryUrl *string `pulumi:"discoveryUrl"`
	// IntellectualPropertyPublisher for the registry
	IntellectualPropertyPublisher *string `pulumi:"intellectualPropertyPublisher"`
	// ResourceId of the managed RG if the registry has system created resources
	ManagedResourceGroup *ArmResourceIdResponse `pulumi:"managedResourceGroup"`
	// MLFlow Registry URI for the Registry
	MlFlowRegistryUri *string `pulumi:"mlFlowRegistryUri"`
	// Is the Registry accessible from the internet?
	// Possible values: "Enabled" or "Disabled"
	PublicNetworkAccess *string `pulumi:"publicNetworkAccess"`
	// Details of each region the registry is in
	RegionDetails []RegistryRegionArmDetailsResponse `pulumi:"regionDetails"`
	// Private endpoint connections info used for pending connections in private link portal
	RegistryPrivateEndpointConnections []RegistryPrivateEndpointConnectionResponse `pulumi:"registryPrivateEndpointConnections"`
}

// Details of the Registry
type RegistryResponseOutput struct{ *pulumi.OutputState }

func (RegistryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegistryResponse)(nil)).Elem()
}

func (o RegistryResponseOutput) ToRegistryResponseOutput() RegistryResponseOutput {
	return o
}

func (o RegistryResponseOutput) ToRegistryResponseOutputWithContext(ctx context.Context) RegistryResponseOutput {
	return o
}

// Discovery URL for the Registry
func (o RegistryResponseOutput) DiscoveryUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryResponse) *string { return v.DiscoveryUrl }).(pulumi.StringPtrOutput)
}

// IntellectualPropertyPublisher for the registry
func (o RegistryResponseOutput) IntellectualPropertyPublisher() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryResponse) *string { return v.IntellectualPropertyPublisher }).(pulumi.StringPtrOutput)
}

// ResourceId of the managed RG if the registry has system created resources
func (o RegistryResponseOutput) ManagedResourceGroup() ArmResourceIdResponsePtrOutput {
	return o.ApplyT(func(v RegistryResponse) *ArmResourceIdResponse { return v.ManagedResourceGroup }).(ArmResourceIdResponsePtrOutput)
}

// MLFlow Registry URI for the Registry
func (o RegistryResponseOutput) MlFlowRegistryUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryResponse) *string { return v.MlFlowRegistryUri }).(pulumi.StringPtrOutput)
}

// Is the Registry accessible from the internet?
// Possible values: "Enabled" or "Disabled"
func (o RegistryResponseOutput) PublicNetworkAccess() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RegistryResponse) *string { return v.PublicNetworkAccess }).(pulumi.StringPtrOutput)
}

// Details of each region the registry is in
func (o RegistryResponseOutput) RegionDetails() RegistryRegionArmDetailsResponseArrayOutput {
	return o.ApplyT(func(v RegistryResponse) []RegistryRegionArmDetailsResponse { return v.RegionDetails }).(RegistryRegionArmDetailsResponseArrayOutput)
}

// Private endpoint connections info used for pending connections in private link portal
func (o RegistryResponseOutput) RegistryPrivateEndpointConnections() RegistryPrivateEndpointConnectionResponseArrayOutput {
	return o.ApplyT(func(v RegistryResponse) []RegistryPrivateEndpointConnectionResponse {
		return v.RegistryPrivateEndpointConnections
	}).(RegistryPrivateEndpointConnectionResponseArrayOutput)
}

// Regression task in AutoML Table vertical.
type Regression struct {
	// Columns to use for CVSplit data.
	CvSplitColumnNames []string `pulumi:"cvSplitColumnNames"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettings `pulumi:"featurizationSettings"`
	// Model/training parameters that will remain constant throughout training.
	FixedParameters *TableFixedParameters `pulumi:"fixedParameters"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettings `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Number of cross validation folds to be applied on training dataset
	// when validation dataset is not provided.
	NCrossValidations interface{} `pulumi:"nCrossValidations"`
	// Primary metric for regression task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []TableParameterSubspace `pulumi:"searchSpace"`
	// Settings for model sweeping and hyperparameter tuning.
	SweepSettings *TableSweepSettings `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'Regression'.
	TaskType string `pulumi:"taskType"`
	// Test data input.
	TestData *MLTableJobInput `pulumi:"testData"`
	// The fraction of test dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	TestDataSize *float64 `pulumi:"testDataSize"`
	// [Required] Training data input.
	TrainingData MLTableJobInput `pulumi:"trainingData"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *RegressionTrainingSettings `pulumi:"trainingSettings"`
	// Validation data inputs.
	ValidationData *MLTableJobInput `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
	// The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
	WeightColumnName *string `pulumi:"weightColumnName"`
}

// Defaults sets the appropriate defaults for Regression
func (val *Regression) Defaults() *Regression {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.FixedParameters = tmp.FixedParameters.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "NormalizedRootMeanSquaredError"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

type RegressionModelPerformanceMetricThreshold struct {
	// [Required] The regression model performance metric to calculate.
	Metric string `pulumi:"metric"`
	// Expected value is 'Regression'.
	ModelType string `pulumi:"modelType"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThreshold `pulumi:"threshold"`
}

type RegressionModelPerformanceMetricThresholdResponse struct {
	// [Required] The regression model performance metric to calculate.
	Metric string `pulumi:"metric"`
	// Expected value is 'Regression'.
	ModelType string `pulumi:"modelType"`
	// The threshold value. If null, a default value will be set depending on the selected metric.
	Threshold *MonitoringThresholdResponse `pulumi:"threshold"`
}

// Regression task in AutoML Table vertical.
type RegressionResponse struct {
	// Columns to use for CVSplit data.
	CvSplitColumnNames []string `pulumi:"cvSplitColumnNames"`
	// Featurization inputs needed for AutoML job.
	FeaturizationSettings *TableVerticalFeaturizationSettingsResponse `pulumi:"featurizationSettings"`
	// Model/training parameters that will remain constant throughout training.
	FixedParameters *TableFixedParametersResponse `pulumi:"fixedParameters"`
	// Execution constraints for AutoMLJob.
	LimitSettings *TableVerticalLimitSettingsResponse `pulumi:"limitSettings"`
	// Log verbosity for the job.
	LogVerbosity *string `pulumi:"logVerbosity"`
	// Number of cross validation folds to be applied on training dataset
	// when validation dataset is not provided.
	NCrossValidations interface{} `pulumi:"nCrossValidations"`
	// Primary metric for regression task.
	PrimaryMetric *string `pulumi:"primaryMetric"`
	// Search space for sampling different combinations of models and their hyperparameters.
	SearchSpace []TableParameterSubspaceResponse `pulumi:"searchSpace"`
	// Settings for model sweeping and hyperparameter tuning.
	SweepSettings *TableSweepSettingsResponse `pulumi:"sweepSettings"`
	// Target column name: This is prediction values column.
	// Also known as label column name in context of classification tasks.
	TargetColumnName *string `pulumi:"targetColumnName"`
	// AutoMLJob Task type.
	// Expected value is 'Regression'.
	TaskType string `pulumi:"taskType"`
	// Test data input.
	TestData *MLTableJobInputResponse `pulumi:"testData"`
	// The fraction of test dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	TestDataSize *float64 `pulumi:"testDataSize"`
	// [Required] Training data input.
	TrainingData MLTableJobInputResponse `pulumi:"trainingData"`
	// Inputs for training phase for an AutoML Job.
	TrainingSettings *RegressionTrainingSettingsResponse `pulumi:"trainingSettings"`
	// Validation data inputs.
	ValidationData *MLTableJobInputResponse `pulumi:"validationData"`
	// The fraction of training dataset that needs to be set aside for validation purpose.
	// Values between (0.0 , 1.0)
	// Applied when validation dataset is not provided.
	ValidationDataSize *float64 `pulumi:"validationDataSize"`
	// The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
	WeightColumnName *string `pulumi:"weightColumnName"`
}

// Defaults sets the appropriate defaults for RegressionResponse
func (val *RegressionResponse) Defaults() *RegressionResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.FeaturizationSettings = tmp.FeaturizationSettings.Defaults()

	tmp.FixedParameters = tmp.FixedParameters.Defaults()

	tmp.LimitSettings = tmp.LimitSettings.Defaults()

	if tmp.LogVerbosity == nil {
		logVerbosity_ := "Info"
		tmp.LogVerbosity = &logVerbosity_
	}
	if tmp.PrimaryMetric == nil {
		primaryMetric_ := "NormalizedRootMeanSquaredError"
		tmp.PrimaryMetric = &primaryMetric_
	}
	tmp.TestData = tmp.TestData.Defaults()

	tmp.TrainingData = *tmp.TrainingData.Defaults()

	tmp.TrainingSettings = tmp.TrainingSettings.Defaults()

	tmp.ValidationData = tmp.ValidationData.Defaults()

	return &tmp
}

// Regression Training related configuration.
type RegressionTrainingSettings struct {
	// Allowed models for regression task.
	AllowedTrainingAlgorithms []string `pulumi:"allowedTrainingAlgorithms"`
	// Blocked models for regression task.
	BlockedTrainingAlgorithms []string `pulumi:"blockedTrainingAlgorithms"`
	// Enable recommendation of DNN models.
	EnableDnnTraining *bool `pulumi:"enableDnnTraining"`
	// Flag to turn on explainability on best model.
	EnableModelExplainability *bool `pulumi:"enableModelExplainability"`
	// Flag for enabling onnx compatible models.
	EnableOnnxCompatibleModels *bool `pulumi:"enableOnnxCompatibleModels"`
	// Enable stack ensemble run.
	EnableStackEnsemble *bool `pulumi:"enableStackEnsemble"`
	// Enable voting ensemble run.
	EnableVoteEnsemble *bool `pulumi:"enableVoteEnsemble"`
	// During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
	// Configure this parameter with a higher value than 300 secs, if more time is needed.
	EnsembleModelDownloadTimeout *string `pulumi:"ensembleModelDownloadTimeout"`
	// Stack ensemble settings for stack ensemble run.
	StackEnsembleSettings *StackEnsembleSettings `pulumi:"stackEnsembleSettings"`
	// TrainingMode mode - Setting to 'auto' is same as setting it to 'non-distributed' for now, however in the future may result in mixed mode or heuristics based mode selection. Default is 'auto'.
	// If 'Distributed' then only distributed featurization is used and distributed algorithms are chosen.
	// If 'NonDistributed' then only non distributed algorithms are chosen.
	TrainingMode *string `pulumi:"trainingMode"`
}

// Defaults sets the appropriate defaults for RegressionTrainingSettings
func (val *RegressionTrainingSettings) Defaults() *RegressionTrainingSettings {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.EnableDnnTraining == nil {
		enableDnnTraining_ := false
		tmp.EnableDnnTraining = &enableDnnTraining_
	}
	if tmp.EnableModelExplainability == nil {
		enableModelExplainability_ := true
		tmp.EnableModelExplainability = &enableModelExplainability_
	}
	if tmp.EnableOnnxCompatibleModels == nil {
		enableOnnxCompatibleModels_ := false
		tmp.EnableOnnxCompatibleModels = &enableOnnxCompatibleModels_
	}
	if tmp.EnableStackEnsemble == nil {
		enableStackEnsemble_ := true
		tmp.EnableStackEnsemble = &enableStackEnsemble_
	}
	if tmp.EnableVoteEnsemble == nil {
		enableVoteEnsemble_ := true
		tmp.EnableVoteEnsemble = &enableVoteEnsemble_
	}
	if tmp.EnsembleModelDownloadTimeout == nil {
		ensembleModelDownloadTimeout_ := "PT5M"
		tmp.EnsembleModelDownloadTimeout = &ensembleModelDownloadTimeout_
	}
	tmp.StackEnsembleSettings = tmp.StackEnsembleSettings.Defaults()

	if tmp.TrainingMode == nil {
		trainingMode_ := "Auto"
		tmp.TrainingMode = &trainingMode_
	}
	return &tmp
}

// Regression Training related configuration.
type RegressionTrainingSettingsResponse struct {
	// Allowed models for regression task.
	AllowedTrainingAlgorithms []string `pulumi:"allowedTrainingAlgorithms"`
	// Blocked models for regression task.
	BlockedTrainingAlgorithms []string `pulumi:"blockedTrainingAlgorithms"`
	// Enable recommendation of DNN models.
	EnableDnnTraining *bool `pulumi:"enableDnnTraining"`
	// Flag to turn on explainability on best model.
	EnableModelExplainability *bool `pulumi:"enableModelExplainability"`
	// Flag for enabling onnx compatible models.
	EnableOnnxCompatibleModels *bool `pulumi:"enableOnnxCompatibleModels"`
	// Enable stack ensemble run.
	EnableStackEnsemble *bool `pulumi:"enableStackEnsemble"`
	// Enable voting ensemble run.
	EnableVoteEnsemble *bool `pulumi:"enableVoteEnsemble"`
	// During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
	// Configure this parameter with a higher value than 300 secs, if more time is needed.
	EnsembleModelDownloadTimeout *string `pulumi:"ensembleModelDownloadTimeout"`
	// Stack ensemble settings for stack ensemble run.
	StackEnsembleSettings *StackEnsembleSettingsResponse `pulumi:"stackEnsembleSettings"`
	// TrainingMode mode - Setting to 'auto' is same as setting it to 'non-distributed' for now, however in the future may result in mixed mode or heuristics based mode selection. Default is 'auto'.
	// If 'Distributed' then only distributed featurization is used and distributed algorithms are chosen.
	// If 'NonDistributed' then only non distributed algorithms are chosen.
	TrainingMode *string `pulumi:"trainingMode"`
}

// Defaults sets the appropriate defaults for RegressionTrainingSettingsResponse
func (val *RegressionTrainingSettingsResponse) Defaults() *RegressionTrainingSettingsResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.EnableDnnTraining == nil {
		enableDnnTraining_ := false
		tmp.EnableDnnTraining = &enableDnnTraining_
	}
	if tmp.EnableModelExplainability == nil {
		enableModelExplainability_ := true
		tmp.EnableModelExplainability = &enableModelExplainability_
	}
	if tmp.EnableOnnxCompatibleModels == nil {
		enableOnnxCompatibleModels_ := false
		tmp.EnableOnnxCompatibleModels = &enableOnnxCompatibleModels_
	}
	if tmp.EnableStackEnsemble == nil {
		enableStackEnsemble_ := true
		tmp.EnableStackEnsemble = &enableStackEnsemble_
	}
	if tmp.EnableVoteEnsemble == nil {
		enableVoteEnsemble_ := true
		tmp.EnableVoteEnsemble = &enableVoteEnsemble_
	}
	if tmp.EnsembleModelDownloadTimeout == nil {
		ensembleModelDownloadTimeout_ := "PT5M"
		tmp.EnsembleModelDownloadTimeout = &ensembleModelDownloadTimeout_
	}
	tmp.StackEnsembleSettings = tmp.StackEnsembleSettings.Defaults()

	if tmp.TrainingMode == nil {
		trainingMode_ := "Auto"
		tmp.TrainingMode = &trainingMode_
	}
	return &tmp
}

type RequestLogging struct {
	// For payload logging, we only collect payload by default. If customers also want to collect the specified headers, they can set them in captureHeaders so that backend will collect those headers along with payload.
	CaptureHeaders []string `pulumi:"captureHeaders"`
}

type RequestLoggingResponse struct {
	// For payload logging, we only collect payload by default. If customers also want to collect the specified headers, they can set them in captureHeaders so that backend will collect those headers along with payload.
	CaptureHeaders []string `pulumi:"captureHeaders"`
}

// Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
type ResourceId struct {
	// The ID of the resource
	Id string `pulumi:"id"`
}

// Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
type ResourceIdResponse struct {
	// The ID of the resource
	Id string `pulumi:"id"`
}

type Route struct {
	// [Required] The path for the route.
	Path string `pulumi:"path"`
	// [Required] The port for the route.
	Port int `pulumi:"port"`
}

// RouteInput is an input type that accepts RouteArgs and RouteOutput values.
// You can construct a concrete instance of `RouteInput` via:
//
//	RouteArgs{...}
type RouteInput interface {
	pulumi.Input

	ToRouteOutput() RouteOutput
	ToRouteOutputWithContext(context.Context) RouteOutput
}

type RouteArgs struct {
	// [Required] The path for the route.
	Path pulumi.StringInput `pulumi:"path"`
	// [Required] The port for the route.
	Port pulumi.IntInput `pulumi:"port"`
}

func (RouteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Route)(nil)).Elem()
}

func (i RouteArgs) ToRouteOutput() RouteOutput {
	return i.ToRouteOutputWithContext(context.Background())
}

func (i RouteArgs) ToRouteOutputWithContext(ctx context.Context) RouteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteOutput)
}

func (i RouteArgs) ToRoutePtrOutput() RoutePtrOutput {
	return i.ToRoutePtrOutputWithContext(context.Background())
}

func (i RouteArgs) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteOutput).ToRoutePtrOutputWithContext(ctx)
}

// RoutePtrInput is an input type that accepts RouteArgs, RoutePtr and RoutePtrOutput values.
// You can construct a concrete instance of `RoutePtrInput` via:
//
//	        RouteArgs{...}
//
//	or:
//
//	        nil
type RoutePtrInput interface {
	pulumi.Input

	ToRoutePtrOutput() RoutePtrOutput
	ToRoutePtrOutputWithContext(context.Context) RoutePtrOutput
}

type routePtrType RouteArgs

func RoutePtr(v *RouteArgs) RoutePtrInput {
	return (*routePtrType)(v)
}

func (*routePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Route)(nil)).Elem()
}

func (i *routePtrType) ToRoutePtrOutput() RoutePtrOutput {
	return i.ToRoutePtrOutputWithContext(context.Background())
}

func (i *routePtrType) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoutePtrOutput)
}

type RouteOutput struct{ *pulumi.OutputState }

func (RouteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Route)(nil)).Elem()
}

func (o RouteOutput) ToRouteOutput() RouteOutput {
	return o
}

func (o RouteOutput) ToRouteOutputWithContext(ctx context.Context) RouteOutput {
	return o
}

func (o RouteOutput) ToRoutePtrOutput() RoutePtrOutput {
	return o.ToRoutePtrOutputWithContext(context.Background())
}

func (o RouteOutput) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Route) *Route {
		return &v
	}).(RoutePtrOutput)
}

// [Required] The path for the route.
func (o RouteOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v Route) string { return v.Path }).(pulumi.StringOutput)
}

// [Required] The port for the route.
func (o RouteOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v Route) int { return v.Port }).(pulumi.IntOutput)
}

type RoutePtrOutput struct{ *pulumi.OutputState }

func (RoutePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Route)(nil)).Elem()
}

func (o RoutePtrOutput) ToRoutePtrOutput() RoutePtrOutput {
	return o
}

func (o RoutePtrOutput) ToRoutePtrOutputWithContext(ctx context.Context) RoutePtrOutput {
	return o
}

func (o RoutePtrOutput) Elem() RouteOutput {
	return o.ApplyT(func(v *Route) Route {
		if v != nil {
			return *v
		}
		var ret Route
		return ret
	}).(RouteOutput)
}

// [Required] The path for the route.
func (o RoutePtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Route) *string {
		if v == nil {
			return nil
		}
		return &v.Path
	}).(pulumi.StringPtrOutput)
}

// [Required] The port for the route.
func (o RoutePtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Route) *int {
		if v == nil {
			return nil
		}
		return &v.Port
	}).(pulumi.IntPtrOutput)
}

type RouteResponse struct {
	// [Required] The path for the route.
	Path string `pulumi:"path"`
	// [Required] The port for the route.
	Port int `pulumi:"port"`
}

type RouteResponseOutput struct{ *pulumi.OutputState }

func (RouteResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RouteResponse)(nil)).Elem()
}

func (o RouteResponseOutput) ToRouteResponseOutput() RouteResponseOutput {
	return o
}

func (o RouteResponseOutput) ToRouteResponseOutputWithContext(ctx context.Context) RouteResponseOutput {
	return o
}

// [Required] The path for the route.
func (o RouteResponseOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v RouteResponse) string { return v.Path }).(pulumi.StringOutput)
}

// [Required] The port for the route.
func (o RouteResponseOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v RouteResponse) int { return v.Port }).(pulumi.IntOutput)
}

type RouteResponsePtrOutput struct{ *pulumi.OutputState }

func (RouteResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RouteResponse)(nil)).Elem()
}

func (o RouteResponsePtrOutput) ToRouteResponsePtrOutput() RouteResponsePtrOutput {
	return o
}

func (o RouteResponsePtrOutput) ToRouteResponsePtrOutputWithContext(ctx context.Context) RouteResponsePtrOutput {
	return o
}

func (o RouteResponsePtrOutput) Elem() RouteResponseOutput {
	return o.ApplyT(func(v *RouteResponse) RouteResponse {
		if v != nil {
			return *v
		}
		var ret RouteResponse
		return ret
	}).(RouteResponseOutput)
}

// [Required] The path for the route.
func (o RouteResponsePtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RouteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Path
	}).(pulumi.StringPtrOutput)
}

// [Required] The port for the route.
func (o RouteResponsePtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RouteResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Port
	}).(pulumi.IntPtrOutput)
}

type SASAuthTypeWorkspaceConnectionProperties struct {
	// Authentication type of the connection target
	// Expected value is 'SAS'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category    *string                                   `pulumi:"category"`
	Credentials *WorkspaceConnectionSharedAccessSignature `pulumi:"credentials"`
	ExpiryTime  *string                                   `pulumi:"expiryTime"`
	Metadata    interface{}                               `pulumi:"metadata"`
	Target      *string                                   `pulumi:"target"`
}

type SASAuthTypeWorkspaceConnectionPropertiesResponse struct {
	// Authentication type of the connection target
	// Expected value is 'SAS'.
	AuthType string `pulumi:"authType"`
	// Category of the connection
	Category    *string                                           `pulumi:"category"`
	Credentials *WorkspaceConnectionSharedAccessSignatureResponse `pulumi:"credentials"`
	ExpiryTime  *string                                           `pulumi:"expiryTime"`
	Metadata    interface{}                                       `pulumi:"metadata"`
	Target      *string                                           `pulumi:"target"`
}

// SAS datastore credentials configuration.
type SasDatastoreCredentials struct {
	// Enum to determine the datastore credentials type.
	// Expected value is 'Sas'.
	CredentialsType string `pulumi:"credentialsType"`
	// [Required] Storage container secrets.
	Secrets SasDatastoreSecrets `pulumi:"secrets"`
}

func init() {
	pulumi.RegisterOutputType(AcrDetailsOutput{})
	pulumi.RegisterOutputType(AcrDetailsArrayOutput{})
	pulumi.RegisterOutputType(AcrDetailsResponseOutput{})
	pulumi.RegisterOutputType(AcrDetailsResponseArrayOutput{})
	pulumi.RegisterOutputType(AllNodesOutput{})
	pulumi.RegisterOutputType(AllNodesPtrOutput{})
	pulumi.RegisterOutputType(AllNodesResponseOutput{})
	pulumi.RegisterOutputType(AllNodesResponsePtrOutput{})
	pulumi.RegisterOutputType(AmlComputeNodeInformationResponseOutput{})
	pulumi.RegisterOutputType(AmlComputeNodeInformationResponseArrayOutput{})
	pulumi.RegisterOutputType(ArmResourceIdOutput{})
	pulumi.RegisterOutputType(ArmResourceIdPtrOutput{})
	pulumi.RegisterOutputType(ArmResourceIdResponseOutput{})
	pulumi.RegisterOutputType(ArmResourceIdResponsePtrOutput{})
	pulumi.RegisterOutputType(AutoDeleteSettingOutput{})
	pulumi.RegisterOutputType(AutoDeleteSettingPtrOutput{})
	pulumi.RegisterOutputType(AutoDeleteSettingResponseOutput{})
	pulumi.RegisterOutputType(AutoDeleteSettingResponsePtrOutput{})
	pulumi.RegisterOutputType(AzureDevOpsWebhookOutput{})
	pulumi.RegisterOutputType(AzureDevOpsWebhookMapOutput{})
	pulumi.RegisterOutputType(AzureDevOpsWebhookResponseOutput{})
	pulumi.RegisterOutputType(AzureDevOpsWebhookResponseMapOutput{})
	pulumi.RegisterOutputType(BatchDeploymentTypeOutput{})
	pulumi.RegisterOutputType(BatchDeploymentResponseOutput{})
	pulumi.RegisterOutputType(BatchEndpointTypeOutput{})
	pulumi.RegisterOutputType(BatchEndpointDefaultsOutput{})
	pulumi.RegisterOutputType(BatchEndpointDefaultsPtrOutput{})
	pulumi.RegisterOutputType(BatchEndpointDefaultsResponseOutput{})
	pulumi.RegisterOutputType(BatchEndpointDefaultsResponsePtrOutput{})
	pulumi.RegisterOutputType(BatchEndpointResponseOutput{})
	pulumi.RegisterOutputType(BatchPipelineComponentDeploymentConfigurationOutput{})
	pulumi.RegisterOutputType(BatchPipelineComponentDeploymentConfigurationPtrOutput{})
	pulumi.RegisterOutputType(BatchPipelineComponentDeploymentConfigurationResponseOutput{})
	pulumi.RegisterOutputType(BatchPipelineComponentDeploymentConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(BatchRetrySettingsOutput{})
	pulumi.RegisterOutputType(BatchRetrySettingsPtrOutput{})
	pulumi.RegisterOutputType(BatchRetrySettingsResponseOutput{})
	pulumi.RegisterOutputType(BatchRetrySettingsResponsePtrOutput{})
	pulumi.RegisterOutputType(BuildContextOutput{})
	pulumi.RegisterOutputType(BuildContextPtrOutput{})
	pulumi.RegisterOutputType(BuildContextResponseOutput{})
	pulumi.RegisterOutputType(BuildContextResponsePtrOutput{})
	pulumi.RegisterOutputType(CodeConfigurationOutput{})
	pulumi.RegisterOutputType(CodeConfigurationPtrOutput{})
	pulumi.RegisterOutputType(CodeConfigurationResponseOutput{})
	pulumi.RegisterOutputType(CodeConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(CodeContainerTypeOutput{})
	pulumi.RegisterOutputType(CodeContainerResponseOutput{})
	pulumi.RegisterOutputType(CodeVersionTypeOutput{})
	pulumi.RegisterOutputType(CodeVersionResponseOutput{})
	pulumi.RegisterOutputType(ComponentContainerTypeOutput{})
	pulumi.RegisterOutputType(ComponentContainerResponseOutput{})
	pulumi.RegisterOutputType(ComponentVersionTypeOutput{})
	pulumi.RegisterOutputType(ComponentVersionResponseOutput{})
	pulumi.RegisterOutputType(ComputeRuntimeDtoOutput{})
	pulumi.RegisterOutputType(ComputeRuntimeDtoPtrOutput{})
	pulumi.RegisterOutputType(ComputeRuntimeDtoResponseOutput{})
	pulumi.RegisterOutputType(ComputeRuntimeDtoResponsePtrOutput{})
	pulumi.RegisterOutputType(CosmosDbSettingsOutput{})
	pulumi.RegisterOutputType(CosmosDbSettingsPtrOutput{})
	pulumi.RegisterOutputType(CosmosDbSettingsResponseOutput{})
	pulumi.RegisterOutputType(CosmosDbSettingsResponsePtrOutput{})
	pulumi.RegisterOutputType(DataContainerTypeOutput{})
	pulumi.RegisterOutputType(DataContainerResponseOutput{})
	pulumi.RegisterOutputType(DeploymentResourceConfigurationOutput{})
	pulumi.RegisterOutputType(DeploymentResourceConfigurationPtrOutput{})
	pulumi.RegisterOutputType(DeploymentResourceConfigurationResponseOutput{})
	pulumi.RegisterOutputType(DeploymentResourceConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(EncryptionPropertyOutput{})
	pulumi.RegisterOutputType(EncryptionPropertyPtrOutput{})
	pulumi.RegisterOutputType(EncryptionPropertyResponseOutput{})
	pulumi.RegisterOutputType(EncryptionPropertyResponsePtrOutput{})
	pulumi.RegisterOutputType(EndpointAuthKeysOutput{})
	pulumi.RegisterOutputType(EndpointAuthKeysPtrOutput{})
	pulumi.RegisterOutputType(EnvironmentContainerTypeOutput{})
	pulumi.RegisterOutputType(EnvironmentContainerResponseOutput{})
	pulumi.RegisterOutputType(EnvironmentVersionTypeOutput{})
	pulumi.RegisterOutputType(EnvironmentVersionResponseOutput{})
	pulumi.RegisterOutputType(FeatureStoreSettingsOutput{})
	pulumi.RegisterOutputType(FeatureStoreSettingsPtrOutput{})
	pulumi.RegisterOutputType(FeatureStoreSettingsResponseOutput{})
	pulumi.RegisterOutputType(FeatureStoreSettingsResponsePtrOutput{})
	pulumi.RegisterOutputType(FeatureWindowResponseOutput{})
	pulumi.RegisterOutputType(FeatureWindowResponsePtrOutput{})
	pulumi.RegisterOutputType(FeaturesetContainerOutput{})
	pulumi.RegisterOutputType(FeaturesetContainerResponseOutput{})
	pulumi.RegisterOutputType(FeaturesetJobResponseOutput{})
	pulumi.RegisterOutputType(FeaturesetJobResponseArrayOutput{})
	pulumi.RegisterOutputType(FeaturesetSpecificationOutput{})
	pulumi.RegisterOutputType(FeaturesetSpecificationPtrOutput{})
	pulumi.RegisterOutputType(FeaturesetSpecificationResponseOutput{})
	pulumi.RegisterOutputType(FeaturesetSpecificationResponsePtrOutput{})
	pulumi.RegisterOutputType(FeaturesetVersionTypeOutput{})
	pulumi.RegisterOutputType(FeaturesetVersionResponseOutput{})
	pulumi.RegisterOutputType(FeaturestoreEntityContainerOutput{})
	pulumi.RegisterOutputType(FeaturestoreEntityContainerResponseOutput{})
	pulumi.RegisterOutputType(FeaturestoreEntityVersionTypeOutput{})
	pulumi.RegisterOutputType(FeaturestoreEntityVersionResponseOutput{})
	pulumi.RegisterOutputType(FlavorDataOutput{})
	pulumi.RegisterOutputType(FlavorDataMapOutput{})
	pulumi.RegisterOutputType(FlavorDataResponseOutput{})
	pulumi.RegisterOutputType(FlavorDataResponseMapOutput{})
	pulumi.RegisterOutputType(IdAssetReferenceOutput{})
	pulumi.RegisterOutputType(IdAssetReferencePtrOutput{})
	pulumi.RegisterOutputType(IdAssetReferenceResponseOutput{})
	pulumi.RegisterOutputType(IdAssetReferenceResponsePtrOutput{})
	pulumi.RegisterOutputType(IdentityForCmkOutput{})
	pulumi.RegisterOutputType(IdentityForCmkPtrOutput{})
	pulumi.RegisterOutputType(IdentityForCmkResponseOutput{})
	pulumi.RegisterOutputType(IdentityForCmkResponsePtrOutput{})
	pulumi.RegisterOutputType(IndexColumnOutput{})
	pulumi.RegisterOutputType(IndexColumnArrayOutput{})
	pulumi.RegisterOutputType(IndexColumnResponseOutput{})
	pulumi.RegisterOutputType(IndexColumnResponseArrayOutput{})
	pulumi.RegisterOutputType(InferenceContainerPropertiesOutput{})
	pulumi.RegisterOutputType(InferenceContainerPropertiesPtrOutput{})
	pulumi.RegisterOutputType(InferenceContainerPropertiesResponseOutput{})
	pulumi.RegisterOutputType(InferenceContainerPropertiesResponsePtrOutput{})
	pulumi.RegisterOutputType(IntellectualPropertyOutput{})
	pulumi.RegisterOutputType(IntellectualPropertyPtrOutput{})
	pulumi.RegisterOutputType(IntellectualPropertyResponseOutput{})
	pulumi.RegisterOutputType(IntellectualPropertyResponsePtrOutput{})
	pulumi.RegisterOutputType(JobServiceOutput{})
	pulumi.RegisterOutputType(JobServiceMapOutput{})
	pulumi.RegisterOutputType(JobServiceResponseOutput{})
	pulumi.RegisterOutputType(JobServiceResponseMapOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesPtrOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesResponseOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesResponsePtrOutput{})
	pulumi.RegisterOutputType(LabelCategoryOutput{})
	pulumi.RegisterOutputType(LabelCategoryMapOutput{})
	pulumi.RegisterOutputType(LabelCategoryResponseOutput{})
	pulumi.RegisterOutputType(LabelCategoryResponseMapOutput{})
	pulumi.RegisterOutputType(LabelClassOutput{})
	pulumi.RegisterOutputType(LabelClassMapOutput{})
	pulumi.RegisterOutputType(LabelClassResponseOutput{})
	pulumi.RegisterOutputType(LabelClassResponseMapOutput{})
	pulumi.RegisterOutputType(LabelingDataConfigurationOutput{})
	pulumi.RegisterOutputType(LabelingDataConfigurationPtrOutput{})
	pulumi.RegisterOutputType(LabelingDataConfigurationResponseOutput{})
	pulumi.RegisterOutputType(LabelingDataConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(LabelingJobTypeOutput{})
	pulumi.RegisterOutputType(LabelingJobInstructionsOutput{})
	pulumi.RegisterOutputType(LabelingJobInstructionsPtrOutput{})
	pulumi.RegisterOutputType(LabelingJobInstructionsResponseOutput{})
	pulumi.RegisterOutputType(LabelingJobInstructionsResponsePtrOutput{})
	pulumi.RegisterOutputType(LabelingJobResponseOutput{})
	pulumi.RegisterOutputType(ListNotebookKeysResultResponseOutput{})
	pulumi.RegisterOutputType(ListNotebookKeysResultResponsePtrOutput{})
	pulumi.RegisterOutputType(ManagedNetworkProvisionStatusOutput{})
	pulumi.RegisterOutputType(ManagedNetworkProvisionStatusPtrOutput{})
	pulumi.RegisterOutputType(ManagedNetworkProvisionStatusResponseOutput{})
	pulumi.RegisterOutputType(ManagedNetworkProvisionStatusResponsePtrOutput{})
	pulumi.RegisterOutputType(ManagedNetworkSettingsOutput{})
	pulumi.RegisterOutputType(ManagedNetworkSettingsPtrOutput{})
	pulumi.RegisterOutputType(ManagedNetworkSettingsResponseOutput{})
	pulumi.RegisterOutputType(ManagedNetworkSettingsResponsePtrOutput{})
	pulumi.RegisterOutputType(ManagedServiceIdentityOutput{})
	pulumi.RegisterOutputType(ManagedServiceIdentityPtrOutput{})
	pulumi.RegisterOutputType(ManagedServiceIdentityResponseOutput{})
	pulumi.RegisterOutputType(ManagedServiceIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(MaterializationComputeResourceOutput{})
	pulumi.RegisterOutputType(MaterializationComputeResourcePtrOutput{})
	pulumi.RegisterOutputType(MaterializationComputeResourceResponseOutput{})
	pulumi.RegisterOutputType(MaterializationComputeResourceResponsePtrOutput{})
	pulumi.RegisterOutputType(MaterializationSettingsOutput{})
	pulumi.RegisterOutputType(MaterializationSettingsPtrOutput{})
	pulumi.RegisterOutputType(MaterializationSettingsResponseOutput{})
	pulumi.RegisterOutputType(MaterializationSettingsResponsePtrOutput{})
	pulumi.RegisterOutputType(ModelContainerTypeOutput{})
	pulumi.RegisterOutputType(ModelContainerResponseOutput{})
	pulumi.RegisterOutputType(ModelVersionTypeOutput{})
	pulumi.RegisterOutputType(ModelVersionResponseOutput{})
	pulumi.RegisterOutputType(NotebookPreparationErrorResponseOutput{})
	pulumi.RegisterOutputType(NotebookPreparationErrorResponsePtrOutput{})
	pulumi.RegisterOutputType(NotebookResourceInfoResponseOutput{})
	pulumi.RegisterOutputType(NotificationSettingOutput{})
	pulumi.RegisterOutputType(NotificationSettingPtrOutput{})
	pulumi.RegisterOutputType(NotificationSettingResponseOutput{})
	pulumi.RegisterOutputType(NotificationSettingResponsePtrOutput{})
	pulumi.RegisterOutputType(OnlineEndpointTypeOutput{})
	pulumi.RegisterOutputType(OnlineEndpointResponseOutput{})
	pulumi.RegisterOutputType(PasswordResponseOutput{})
	pulumi.RegisterOutputType(PasswordResponseArrayOutput{})
	pulumi.RegisterOutputType(PrivateEndpointConnectionResponseOutput{})
	pulumi.RegisterOutputType(PrivateEndpointConnectionResponseArrayOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResourceOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResourcePtrOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResourceResponseOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResourceResponsePtrOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStateOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStatePtrOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStateResponseOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStateResponsePtrOutput{})
	pulumi.RegisterOutputType(ProgressMetricsResponseOutput{})
	pulumi.RegisterOutputType(RecurrenceScheduleOutput{})
	pulumi.RegisterOutputType(RecurrenceSchedulePtrOutput{})
	pulumi.RegisterOutputType(RecurrenceScheduleResponseOutput{})
	pulumi.RegisterOutputType(RecurrenceScheduleResponsePtrOutput{})
	pulumi.RegisterOutputType(RecurrenceTriggerOutput{})
	pulumi.RegisterOutputType(RecurrenceTriggerPtrOutput{})
	pulumi.RegisterOutputType(RecurrenceTriggerResponseOutput{})
	pulumi.RegisterOutputType(RecurrenceTriggerResponsePtrOutput{})
	pulumi.RegisterOutputType(RegistryTypeOutput{})
	pulumi.RegisterOutputType(RegistryListCredentialsResultResponseOutput{})
	pulumi.RegisterOutputType(RegistryListCredentialsResultResponsePtrOutput{})
	pulumi.RegisterOutputType(RegistryPrivateEndpointConnectionOutput{})
	pulumi.RegisterOutputType(RegistryPrivateEndpointConnectionArrayOutput{})
	pulumi.RegisterOutputType(RegistryPrivateEndpointConnectionPropertiesOutput{})
	pulumi.RegisterOutputType(RegistryPrivateEndpointConnectionPropertiesPtrOutput{})
	pulumi.RegisterOutputType(RegistryPrivateEndpointConnectionPropertiesResponseOutput{})
	pulumi.RegisterOutputType(RegistryPrivateEndpointConnectionPropertiesResponsePtrOutput{})
	pulumi.RegisterOutputType(RegistryPrivateEndpointConnectionResponseOutput{})
	pulumi.RegisterOutputType(RegistryPrivateEndpointConnectionResponseArrayOutput{})
	pulumi.RegisterOutputType(RegistryPrivateLinkServiceConnectionStateOutput{})
	pulumi.RegisterOutputType(RegistryPrivateLinkServiceConnectionStatePtrOutput{})
	pulumi.RegisterOutputType(RegistryPrivateLinkServiceConnectionStateResponseOutput{})
	pulumi.RegisterOutputType(RegistryPrivateLinkServiceConnectionStateResponsePtrOutput{})
	pulumi.RegisterOutputType(RegistryRegionArmDetailsOutput{})
	pulumi.RegisterOutputType(RegistryRegionArmDetailsArrayOutput{})
	pulumi.RegisterOutputType(RegistryRegionArmDetailsResponseOutput{})
	pulumi.RegisterOutputType(RegistryRegionArmDetailsResponseArrayOutput{})
	pulumi.RegisterOutputType(RegistryResponseOutput{})
	pulumi.RegisterOutputType(RouteOutput{})
	pulumi.RegisterOutputType(RoutePtrOutput{})
	pulumi.RegisterOutputType(RouteResponseOutput{})
	pulumi.RegisterOutputType(RouteResponsePtrOutput{})
}
