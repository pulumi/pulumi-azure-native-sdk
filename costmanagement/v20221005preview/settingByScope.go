// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v20221005preview

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Setting definition.
//
// Deprecated: Please use one of the variants: TagInheritanceSetting.
type SettingByScope struct {
	pulumi.CustomResourceState

	// eTag of the resource. To handle concurrent update scenario, this field will be used to determine whether the user is updating the latest version or not.
	ETag pulumi.StringPtrOutput `pulumi:"eTag"`
	// Specifies the kind of settings.
	Kind pulumi.StringOutput `pulumi:"kind"`
	// Resource name.
	Name pulumi.StringOutput `pulumi:"name"`
	// Resource type.
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewSettingByScope registers a new resource with the given unique name, arguments, and options.
func NewSettingByScope(ctx *pulumi.Context,
	name string, args *SettingByScopeArgs, opts ...pulumi.ResourceOption) (*SettingByScope, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Kind == nil {
		return nil, errors.New("invalid value for required argument 'Kind'")
	}
	if args.Scope == nil {
		return nil, errors.New("invalid value for required argument 'Scope'")
	}
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("azure-native:costmanagement/v20221001preview:SettingByScope"),
		},
	})
	opts = append(opts, aliases)
	var resource SettingByScope
	err := ctx.RegisterResource("azure-native:costmanagement/v20221005preview:SettingByScope", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSettingByScope gets an existing SettingByScope resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSettingByScope(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SettingByScopeState, opts ...pulumi.ResourceOption) (*SettingByScope, error) {
	var resource SettingByScope
	err := ctx.ReadResource("azure-native:costmanagement/v20221005preview:SettingByScope", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SettingByScope resources.
type settingByScopeState struct {
}

type SettingByScopeState struct {
}

func (SettingByScopeState) ElementType() reflect.Type {
	return reflect.TypeOf((*settingByScopeState)(nil)).Elem()
}

type settingByScopeArgs struct {
	// eTag of the resource. To handle concurrent update scenario, this field will be used to determine whether the user is updating the latest version or not.
	ETag *string `pulumi:"eTag"`
	// Specifies the kind of settings.
	Kind string `pulumi:"kind"`
	// The scope associated with setting. This includes 'subscriptions/{subscriptionId}' for subscription scope, 'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope, 'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}' for billing profile scope.
	Scope string `pulumi:"scope"`
	// Setting type.
	Type *string `pulumi:"type"`
}

// The set of arguments for constructing a SettingByScope resource.
type SettingByScopeArgs struct {
	// eTag of the resource. To handle concurrent update scenario, this field will be used to determine whether the user is updating the latest version or not.
	ETag pulumi.StringPtrInput
	// Specifies the kind of settings.
	Kind pulumi.StringInput
	// The scope associated with setting. This includes 'subscriptions/{subscriptionId}' for subscription scope, 'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope, 'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}' for billing profile scope.
	Scope pulumi.StringInput
	// Setting type.
	Type pulumi.StringPtrInput
}

func (SettingByScopeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*settingByScopeArgs)(nil)).Elem()
}

type SettingByScopeInput interface {
	pulumi.Input

	ToSettingByScopeOutput() SettingByScopeOutput
	ToSettingByScopeOutputWithContext(ctx context.Context) SettingByScopeOutput
}

func (*SettingByScope) ElementType() reflect.Type {
	return reflect.TypeOf((**SettingByScope)(nil)).Elem()
}

func (i *SettingByScope) ToSettingByScopeOutput() SettingByScopeOutput {
	return i.ToSettingByScopeOutputWithContext(context.Background())
}

func (i *SettingByScope) ToSettingByScopeOutputWithContext(ctx context.Context) SettingByScopeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingByScopeOutput)
}

type SettingByScopeOutput struct{ *pulumi.OutputState }

func (SettingByScopeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SettingByScope)(nil)).Elem()
}

func (o SettingByScopeOutput) ToSettingByScopeOutput() SettingByScopeOutput {
	return o
}

func (o SettingByScopeOutput) ToSettingByScopeOutputWithContext(ctx context.Context) SettingByScopeOutput {
	return o
}

// eTag of the resource. To handle concurrent update scenario, this field will be used to determine whether the user is updating the latest version or not.
func (o SettingByScopeOutput) ETag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SettingByScope) pulumi.StringPtrOutput { return v.ETag }).(pulumi.StringPtrOutput)
}

// Specifies the kind of settings.
func (o SettingByScopeOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v *SettingByScope) pulumi.StringOutput { return v.Kind }).(pulumi.StringOutput)
}

// Resource name.
func (o SettingByScopeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SettingByScope) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Resource type.
func (o SettingByScopeOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *SettingByScope) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterOutputType(SettingByScopeOutput{})
}
