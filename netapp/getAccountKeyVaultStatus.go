// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package netapp

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-azure-native-sdk/v2/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Contains data from encryption.keyVaultProperties as well as information about which private endpoint is used by each encryption sibling set. Response from this endpoint can be modified and used as request body for POST request.
//
// Uses Azure REST API version 2024-09-01-preview.
func GetAccountKeyVaultStatus(ctx *pulumi.Context, args *GetAccountKeyVaultStatusArgs, opts ...pulumi.InvokeOption) (*GetAccountKeyVaultStatusResult, error) {
	opts = utilities.PkgInvokeDefaultOpts(opts)
	var rv GetAccountKeyVaultStatusResult
	err := ctx.Invoke("azure-native:netapp:getAccountKeyVaultStatus", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

type GetAccountKeyVaultStatusArgs struct {
	// The name of the NetApp account
	AccountName string `pulumi:"accountName"`
	// The name of the resource group. The name is case insensitive.
	ResourceGroupName string `pulumi:"resourceGroupName"`
}

// Result of getKeyVaultStatus with information about how volumes under NetApp account are encrypted.
type GetAccountKeyVaultStatusResult struct {
	// The name of the key that should be used for encryption.
	KeyName *string `pulumi:"keyName"`
	// Pairs of virtual network ID and private endpoint ID. Every virtual network that has volumes encrypted with customer-managed keys needs its own key vault private endpoint.
	KeyVaultPrivateEndpoints []KeyVaultPrivateEndpointResponse `pulumi:"keyVaultPrivateEndpoints"`
	// Azure resource ID of the key vault/managed HSM that should be used for encryption.
	KeyVaultResourceId *string `pulumi:"keyVaultResourceId"`
	// The URI of the key vault/managed HSM that should be used for encryption.
	KeyVaultUri *string `pulumi:"keyVaultUri"`
}

func GetAccountKeyVaultStatusOutput(ctx *pulumi.Context, args GetAccountKeyVaultStatusOutputArgs, opts ...pulumi.InvokeOption) GetAccountKeyVaultStatusResultOutput {
	return pulumi.ToOutputWithContext(ctx.Context(), args).
		ApplyT(func(v interface{}) (GetAccountKeyVaultStatusResultOutput, error) {
			args := v.(GetAccountKeyVaultStatusArgs)
			options := pulumi.InvokeOutputOptions{InvokeOptions: utilities.PkgInvokeDefaultOpts(opts)}
			return ctx.InvokeOutput("azure-native:netapp:getAccountKeyVaultStatus", args, GetAccountKeyVaultStatusResultOutput{}, options).(GetAccountKeyVaultStatusResultOutput), nil
		}).(GetAccountKeyVaultStatusResultOutput)
}

type GetAccountKeyVaultStatusOutputArgs struct {
	// The name of the NetApp account
	AccountName pulumi.StringInput `pulumi:"accountName"`
	// The name of the resource group. The name is case insensitive.
	ResourceGroupName pulumi.StringInput `pulumi:"resourceGroupName"`
}

func (GetAccountKeyVaultStatusOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetAccountKeyVaultStatusArgs)(nil)).Elem()
}

// Result of getKeyVaultStatus with information about how volumes under NetApp account are encrypted.
type GetAccountKeyVaultStatusResultOutput struct{ *pulumi.OutputState }

func (GetAccountKeyVaultStatusResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetAccountKeyVaultStatusResult)(nil)).Elem()
}

func (o GetAccountKeyVaultStatusResultOutput) ToGetAccountKeyVaultStatusResultOutput() GetAccountKeyVaultStatusResultOutput {
	return o
}

func (o GetAccountKeyVaultStatusResultOutput) ToGetAccountKeyVaultStatusResultOutputWithContext(ctx context.Context) GetAccountKeyVaultStatusResultOutput {
	return o
}

// The name of the key that should be used for encryption.
func (o GetAccountKeyVaultStatusResultOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetAccountKeyVaultStatusResult) *string { return v.KeyName }).(pulumi.StringPtrOutput)
}

// Pairs of virtual network ID and private endpoint ID. Every virtual network that has volumes encrypted with customer-managed keys needs its own key vault private endpoint.
func (o GetAccountKeyVaultStatusResultOutput) KeyVaultPrivateEndpoints() KeyVaultPrivateEndpointResponseArrayOutput {
	return o.ApplyT(func(v GetAccountKeyVaultStatusResult) []KeyVaultPrivateEndpointResponse {
		return v.KeyVaultPrivateEndpoints
	}).(KeyVaultPrivateEndpointResponseArrayOutput)
}

// Azure resource ID of the key vault/managed HSM that should be used for encryption.
func (o GetAccountKeyVaultStatusResultOutput) KeyVaultResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetAccountKeyVaultStatusResult) *string { return v.KeyVaultResourceId }).(pulumi.StringPtrOutput)
}

// The URI of the key vault/managed HSM that should be used for encryption.
func (o GetAccountKeyVaultStatusResultOutput) KeyVaultUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetAccountKeyVaultStatusResult) *string { return v.KeyVaultUri }).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(GetAccountKeyVaultStatusResultOutput{})
}
