// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v20240901preview

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-azure-native-sdk/v2/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanism struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AddRemoveIncrementalNamedPartition'.
	Kind string `pulumi:"kind"`
	// Maximum number of named partitions of the service.
	MaxPartitionCount int `pulumi:"maxPartitionCount"`
	// Minimum number of named partitions of the service.
	MinPartitionCount int `pulumi:"minPartitionCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// AddRemoveIncrementalNamedPartitionScalingMechanismInput is an input type that accepts AddRemoveIncrementalNamedPartitionScalingMechanismArgs and AddRemoveIncrementalNamedPartitionScalingMechanismOutput values.
// You can construct a concrete instance of `AddRemoveIncrementalNamedPartitionScalingMechanismInput` via:
//
//	AddRemoveIncrementalNamedPartitionScalingMechanismArgs{...}
type AddRemoveIncrementalNamedPartitionScalingMechanismInput interface {
	pulumi.Input

	ToAddRemoveIncrementalNamedPartitionScalingMechanismOutput() AddRemoveIncrementalNamedPartitionScalingMechanismOutput
	ToAddRemoveIncrementalNamedPartitionScalingMechanismOutputWithContext(context.Context) AddRemoveIncrementalNamedPartitionScalingMechanismOutput
}

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanismArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AddRemoveIncrementalNamedPartition'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// Maximum number of named partitions of the service.
	MaxPartitionCount pulumi.IntInput `pulumi:"maxPartitionCount"`
	// Minimum number of named partitions of the service.
	MinPartitionCount pulumi.IntInput `pulumi:"minPartitionCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement pulumi.IntInput `pulumi:"scaleIncrement"`
}

func (AddRemoveIncrementalNamedPartitionScalingMechanismArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AddRemoveIncrementalNamedPartitionScalingMechanism)(nil)).Elem()
}

func (i AddRemoveIncrementalNamedPartitionScalingMechanismArgs) ToAddRemoveIncrementalNamedPartitionScalingMechanismOutput() AddRemoveIncrementalNamedPartitionScalingMechanismOutput {
	return i.ToAddRemoveIncrementalNamedPartitionScalingMechanismOutputWithContext(context.Background())
}

func (i AddRemoveIncrementalNamedPartitionScalingMechanismArgs) ToAddRemoveIncrementalNamedPartitionScalingMechanismOutputWithContext(ctx context.Context) AddRemoveIncrementalNamedPartitionScalingMechanismOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddRemoveIncrementalNamedPartitionScalingMechanismOutput)
}

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanismOutput struct{ *pulumi.OutputState }

func (AddRemoveIncrementalNamedPartitionScalingMechanismOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AddRemoveIncrementalNamedPartitionScalingMechanism)(nil)).Elem()
}

func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) ToAddRemoveIncrementalNamedPartitionScalingMechanismOutput() AddRemoveIncrementalNamedPartitionScalingMechanismOutput {
	return o
}

func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) ToAddRemoveIncrementalNamedPartitionScalingMechanismOutputWithContext(ctx context.Context) AddRemoveIncrementalNamedPartitionScalingMechanismOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AddRemoveIncrementalNamedPartition'.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanism) string { return v.Kind }).(pulumi.StringOutput)
}

// Maximum number of named partitions of the service.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) MaxPartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanism) int { return v.MaxPartitionCount }).(pulumi.IntOutput)
}

// Minimum number of named partitions of the service.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) MinPartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanism) int { return v.MinPartitionCount }).(pulumi.IntOutput)
}

// The number of instances to add or remove during a scaling operation.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) ScaleIncrement() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanism) int { return v.ScaleIncrement }).(pulumi.IntOutput)
}

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanismResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AddRemoveIncrementalNamedPartition'.
	Kind string `pulumi:"kind"`
	// Maximum number of named partitions of the service.
	MaxPartitionCount int `pulumi:"maxPartitionCount"`
	// Minimum number of named partitions of the service.
	MinPartitionCount int `pulumi:"minPartitionCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput struct{ *pulumi.OutputState }

func (AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AddRemoveIncrementalNamedPartitionScalingMechanismResponse)(nil)).Elem()
}

func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) ToAddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput() AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput {
	return o
}

func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) ToAddRemoveIncrementalNamedPartitionScalingMechanismResponseOutputWithContext(ctx context.Context) AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AddRemoveIncrementalNamedPartition'.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanismResponse) string { return v.Kind }).(pulumi.StringOutput)
}

// Maximum number of named partitions of the service.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) MaxPartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanismResponse) int { return v.MaxPartitionCount }).(pulumi.IntOutput)
}

// Minimum number of named partitions of the service.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) MinPartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanismResponse) int { return v.MinPartitionCount }).(pulumi.IntOutput)
}

// The number of instances to add or remove during a scaling operation.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) ScaleIncrement() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanismResponse) int { return v.ScaleIncrement }).(pulumi.IntOutput)
}

// Specifies the settings for a network interface to attach to the node type.
type AdditionalNetworkInterfaceConfiguration struct {
	// Specifies the DSCP configuration to apply to the network interface.
	DscpConfiguration *SubResource `pulumi:"dscpConfiguration"`
	// Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking *bool `pulumi:"enableAcceleratedNetworking"`
	// Specifies the IP configurations of the network interface.
	IpConfigurations []IpConfiguration `pulumi:"ipConfigurations"`
	// Name of the network interface.
	Name string `pulumi:"name"`
}

// AdditionalNetworkInterfaceConfigurationInput is an input type that accepts AdditionalNetworkInterfaceConfigurationArgs and AdditionalNetworkInterfaceConfigurationOutput values.
// You can construct a concrete instance of `AdditionalNetworkInterfaceConfigurationInput` via:
//
//	AdditionalNetworkInterfaceConfigurationArgs{...}
type AdditionalNetworkInterfaceConfigurationInput interface {
	pulumi.Input

	ToAdditionalNetworkInterfaceConfigurationOutput() AdditionalNetworkInterfaceConfigurationOutput
	ToAdditionalNetworkInterfaceConfigurationOutputWithContext(context.Context) AdditionalNetworkInterfaceConfigurationOutput
}

// Specifies the settings for a network interface to attach to the node type.
type AdditionalNetworkInterfaceConfigurationArgs struct {
	// Specifies the DSCP configuration to apply to the network interface.
	DscpConfiguration SubResourcePtrInput `pulumi:"dscpConfiguration"`
	// Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking pulumi.BoolPtrInput `pulumi:"enableAcceleratedNetworking"`
	// Specifies the IP configurations of the network interface.
	IpConfigurations IpConfigurationArrayInput `pulumi:"ipConfigurations"`
	// Name of the network interface.
	Name pulumi.StringInput `pulumi:"name"`
}

func (AdditionalNetworkInterfaceConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AdditionalNetworkInterfaceConfiguration)(nil)).Elem()
}

func (i AdditionalNetworkInterfaceConfigurationArgs) ToAdditionalNetworkInterfaceConfigurationOutput() AdditionalNetworkInterfaceConfigurationOutput {
	return i.ToAdditionalNetworkInterfaceConfigurationOutputWithContext(context.Background())
}

func (i AdditionalNetworkInterfaceConfigurationArgs) ToAdditionalNetworkInterfaceConfigurationOutputWithContext(ctx context.Context) AdditionalNetworkInterfaceConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AdditionalNetworkInterfaceConfigurationOutput)
}

// AdditionalNetworkInterfaceConfigurationArrayInput is an input type that accepts AdditionalNetworkInterfaceConfigurationArray and AdditionalNetworkInterfaceConfigurationArrayOutput values.
// You can construct a concrete instance of `AdditionalNetworkInterfaceConfigurationArrayInput` via:
//
//	AdditionalNetworkInterfaceConfigurationArray{ AdditionalNetworkInterfaceConfigurationArgs{...} }
type AdditionalNetworkInterfaceConfigurationArrayInput interface {
	pulumi.Input

	ToAdditionalNetworkInterfaceConfigurationArrayOutput() AdditionalNetworkInterfaceConfigurationArrayOutput
	ToAdditionalNetworkInterfaceConfigurationArrayOutputWithContext(context.Context) AdditionalNetworkInterfaceConfigurationArrayOutput
}

type AdditionalNetworkInterfaceConfigurationArray []AdditionalNetworkInterfaceConfigurationInput

func (AdditionalNetworkInterfaceConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AdditionalNetworkInterfaceConfiguration)(nil)).Elem()
}

func (i AdditionalNetworkInterfaceConfigurationArray) ToAdditionalNetworkInterfaceConfigurationArrayOutput() AdditionalNetworkInterfaceConfigurationArrayOutput {
	return i.ToAdditionalNetworkInterfaceConfigurationArrayOutputWithContext(context.Background())
}

func (i AdditionalNetworkInterfaceConfigurationArray) ToAdditionalNetworkInterfaceConfigurationArrayOutputWithContext(ctx context.Context) AdditionalNetworkInterfaceConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AdditionalNetworkInterfaceConfigurationArrayOutput)
}

// Specifies the settings for a network interface to attach to the node type.
type AdditionalNetworkInterfaceConfigurationOutput struct{ *pulumi.OutputState }

func (AdditionalNetworkInterfaceConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AdditionalNetworkInterfaceConfiguration)(nil)).Elem()
}

func (o AdditionalNetworkInterfaceConfigurationOutput) ToAdditionalNetworkInterfaceConfigurationOutput() AdditionalNetworkInterfaceConfigurationOutput {
	return o
}

func (o AdditionalNetworkInterfaceConfigurationOutput) ToAdditionalNetworkInterfaceConfigurationOutputWithContext(ctx context.Context) AdditionalNetworkInterfaceConfigurationOutput {
	return o
}

// Specifies the DSCP configuration to apply to the network interface.
func (o AdditionalNetworkInterfaceConfigurationOutput) DscpConfiguration() SubResourcePtrOutput {
	return o.ApplyT(func(v AdditionalNetworkInterfaceConfiguration) *SubResource { return v.DscpConfiguration }).(SubResourcePtrOutput)
}

// Specifies whether the network interface is accelerated networking-enabled.
func (o AdditionalNetworkInterfaceConfigurationOutput) EnableAcceleratedNetworking() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v AdditionalNetworkInterfaceConfiguration) *bool { return v.EnableAcceleratedNetworking }).(pulumi.BoolPtrOutput)
}

// Specifies the IP configurations of the network interface.
func (o AdditionalNetworkInterfaceConfigurationOutput) IpConfigurations() IpConfigurationArrayOutput {
	return o.ApplyT(func(v AdditionalNetworkInterfaceConfiguration) []IpConfiguration { return v.IpConfigurations }).(IpConfigurationArrayOutput)
}

// Name of the network interface.
func (o AdditionalNetworkInterfaceConfigurationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AdditionalNetworkInterfaceConfiguration) string { return v.Name }).(pulumi.StringOutput)
}

type AdditionalNetworkInterfaceConfigurationArrayOutput struct{ *pulumi.OutputState }

func (AdditionalNetworkInterfaceConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AdditionalNetworkInterfaceConfiguration)(nil)).Elem()
}

func (o AdditionalNetworkInterfaceConfigurationArrayOutput) ToAdditionalNetworkInterfaceConfigurationArrayOutput() AdditionalNetworkInterfaceConfigurationArrayOutput {
	return o
}

func (o AdditionalNetworkInterfaceConfigurationArrayOutput) ToAdditionalNetworkInterfaceConfigurationArrayOutputWithContext(ctx context.Context) AdditionalNetworkInterfaceConfigurationArrayOutput {
	return o
}

func (o AdditionalNetworkInterfaceConfigurationArrayOutput) Index(i pulumi.IntInput) AdditionalNetworkInterfaceConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AdditionalNetworkInterfaceConfiguration {
		return vs[0].([]AdditionalNetworkInterfaceConfiguration)[vs[1].(int)]
	}).(AdditionalNetworkInterfaceConfigurationOutput)
}

// Specifies the settings for a network interface to attach to the node type.
type AdditionalNetworkInterfaceConfigurationResponse struct {
	// Specifies the DSCP configuration to apply to the network interface.
	DscpConfiguration *SubResourceResponse `pulumi:"dscpConfiguration"`
	// Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking *bool `pulumi:"enableAcceleratedNetworking"`
	// Specifies the IP configurations of the network interface.
	IpConfigurations []IpConfigurationResponse `pulumi:"ipConfigurations"`
	// Name of the network interface.
	Name string `pulumi:"name"`
}

// Specifies the settings for a network interface to attach to the node type.
type AdditionalNetworkInterfaceConfigurationResponseOutput struct{ *pulumi.OutputState }

func (AdditionalNetworkInterfaceConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AdditionalNetworkInterfaceConfigurationResponse)(nil)).Elem()
}

func (o AdditionalNetworkInterfaceConfigurationResponseOutput) ToAdditionalNetworkInterfaceConfigurationResponseOutput() AdditionalNetworkInterfaceConfigurationResponseOutput {
	return o
}

func (o AdditionalNetworkInterfaceConfigurationResponseOutput) ToAdditionalNetworkInterfaceConfigurationResponseOutputWithContext(ctx context.Context) AdditionalNetworkInterfaceConfigurationResponseOutput {
	return o
}

// Specifies the DSCP configuration to apply to the network interface.
func (o AdditionalNetworkInterfaceConfigurationResponseOutput) DscpConfiguration() SubResourceResponsePtrOutput {
	return o.ApplyT(func(v AdditionalNetworkInterfaceConfigurationResponse) *SubResourceResponse {
		return v.DscpConfiguration
	}).(SubResourceResponsePtrOutput)
}

// Specifies whether the network interface is accelerated networking-enabled.
func (o AdditionalNetworkInterfaceConfigurationResponseOutput) EnableAcceleratedNetworking() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v AdditionalNetworkInterfaceConfigurationResponse) *bool { return v.EnableAcceleratedNetworking }).(pulumi.BoolPtrOutput)
}

// Specifies the IP configurations of the network interface.
func (o AdditionalNetworkInterfaceConfigurationResponseOutput) IpConfigurations() IpConfigurationResponseArrayOutput {
	return o.ApplyT(func(v AdditionalNetworkInterfaceConfigurationResponse) []IpConfigurationResponse {
		return v.IpConfigurations
	}).(IpConfigurationResponseArrayOutput)
}

// Name of the network interface.
func (o AdditionalNetworkInterfaceConfigurationResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AdditionalNetworkInterfaceConfigurationResponse) string { return v.Name }).(pulumi.StringOutput)
}

type AdditionalNetworkInterfaceConfigurationResponseArrayOutput struct{ *pulumi.OutputState }

func (AdditionalNetworkInterfaceConfigurationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AdditionalNetworkInterfaceConfigurationResponse)(nil)).Elem()
}

func (o AdditionalNetworkInterfaceConfigurationResponseArrayOutput) ToAdditionalNetworkInterfaceConfigurationResponseArrayOutput() AdditionalNetworkInterfaceConfigurationResponseArrayOutput {
	return o
}

func (o AdditionalNetworkInterfaceConfigurationResponseArrayOutput) ToAdditionalNetworkInterfaceConfigurationResponseArrayOutputWithContext(ctx context.Context) AdditionalNetworkInterfaceConfigurationResponseArrayOutput {
	return o
}

func (o AdditionalNetworkInterfaceConfigurationResponseArrayOutput) Index(i pulumi.IntInput) AdditionalNetworkInterfaceConfigurationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AdditionalNetworkInterfaceConfigurationResponse {
		return vs[0].([]AdditionalNetworkInterfaceConfigurationResponse)[vs[1].(int)]
	}).(AdditionalNetworkInterfaceConfigurationResponseOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicy struct {
	// Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError bool `pulumi:"considerWarningAsError"`
	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy *ServiceTypeHealthPolicy `pulumi:"defaultServiceTypeHealthPolicy"`
	// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications int `pulumi:"maxPercentUnhealthyDeployedApplications"`
	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap map[string]ServiceTypeHealthPolicy `pulumi:"serviceTypeHealthPolicyMap"`
}

// ApplicationHealthPolicyInput is an input type that accepts ApplicationHealthPolicyArgs and ApplicationHealthPolicyOutput values.
// You can construct a concrete instance of `ApplicationHealthPolicyInput` via:
//
//	ApplicationHealthPolicyArgs{...}
type ApplicationHealthPolicyInput interface {
	pulumi.Input

	ToApplicationHealthPolicyOutput() ApplicationHealthPolicyOutput
	ToApplicationHealthPolicyOutputWithContext(context.Context) ApplicationHealthPolicyOutput
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyArgs struct {
	// Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError pulumi.BoolInput `pulumi:"considerWarningAsError"`
	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy ServiceTypeHealthPolicyPtrInput `pulumi:"defaultServiceTypeHealthPolicy"`
	// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications pulumi.IntInput `pulumi:"maxPercentUnhealthyDeployedApplications"`
	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap ServiceTypeHealthPolicyMapInput `pulumi:"serviceTypeHealthPolicyMap"`
}

func (ApplicationHealthPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationHealthPolicy)(nil)).Elem()
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyOutput() ApplicationHealthPolicyOutput {
	return i.ToApplicationHealthPolicyOutputWithContext(context.Background())
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyOutputWithContext(ctx context.Context) ApplicationHealthPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyOutput)
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return i.ToApplicationHealthPolicyPtrOutputWithContext(context.Background())
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyOutput).ToApplicationHealthPolicyPtrOutputWithContext(ctx)
}

// ApplicationHealthPolicyPtrInput is an input type that accepts ApplicationHealthPolicyArgs, ApplicationHealthPolicyPtr and ApplicationHealthPolicyPtrOutput values.
// You can construct a concrete instance of `ApplicationHealthPolicyPtrInput` via:
//
//	        ApplicationHealthPolicyArgs{...}
//
//	or:
//
//	        nil
type ApplicationHealthPolicyPtrInput interface {
	pulumi.Input

	ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput
	ToApplicationHealthPolicyPtrOutputWithContext(context.Context) ApplicationHealthPolicyPtrOutput
}

type applicationHealthPolicyPtrType ApplicationHealthPolicyArgs

func ApplicationHealthPolicyPtr(v *ApplicationHealthPolicyArgs) ApplicationHealthPolicyPtrInput {
	return (*applicationHealthPolicyPtrType)(v)
}

func (*applicationHealthPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationHealthPolicy)(nil)).Elem()
}

func (i *applicationHealthPolicyPtrType) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return i.ToApplicationHealthPolicyPtrOutputWithContext(context.Background())
}

func (i *applicationHealthPolicyPtrType) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyPtrOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationHealthPolicy)(nil)).Elem()
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyOutput() ApplicationHealthPolicyOutput {
	return o
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyOutputWithContext(ctx context.Context) ApplicationHealthPolicyOutput {
	return o
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return o.ToApplicationHealthPolicyPtrOutputWithContext(context.Background())
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ApplicationHealthPolicy) *ApplicationHealthPolicy {
		return &v
	}).(ApplicationHealthPolicyPtrOutput)
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyOutput) ConsiderWarningAsError() pulumi.BoolOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) bool { return v.ConsiderWarningAsError }).(pulumi.BoolOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyPtrOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) *ServiceTypeHealthPolicy { return v.DefaultServiceTypeHealthPolicy }).(ServiceTypeHealthPolicyPtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) int { return v.MaxPercentUnhealthyDeployedApplications }).(pulumi.IntOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyMapOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) map[string]ServiceTypeHealthPolicy {
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyMapOutput)
}

type ApplicationHealthPolicyPtrOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationHealthPolicy)(nil)).Elem()
}

func (o ApplicationHealthPolicyPtrOutput) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return o
}

func (o ApplicationHealthPolicyPtrOutput) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return o
}

func (o ApplicationHealthPolicyPtrOutput) Elem() ApplicationHealthPolicyOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) ApplicationHealthPolicy {
		if v != nil {
			return *v
		}
		var ret ApplicationHealthPolicy
		return ret
	}).(ApplicationHealthPolicyOutput)
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyPtrOutput) ConsiderWarningAsError() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) *bool {
		if v == nil {
			return nil
		}
		return &v.ConsiderWarningAsError
	}).(pulumi.BoolPtrOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyPtrOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) *ServiceTypeHealthPolicy {
		if v == nil {
			return nil
		}
		return v.DefaultServiceTypeHealthPolicy
	}).(ServiceTypeHealthPolicyPtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyPtrOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyDeployedApplications
	}).(pulumi.IntPtrOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyPtrOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyMapOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) map[string]ServiceTypeHealthPolicy {
		if v == nil {
			return nil
		}
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyMapOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyResponse struct {
	// Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError bool `pulumi:"considerWarningAsError"`
	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy *ServiceTypeHealthPolicyResponse `pulumi:"defaultServiceTypeHealthPolicy"`
	// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications int `pulumi:"maxPercentUnhealthyDeployedApplications"`
	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap map[string]ServiceTypeHealthPolicyResponse `pulumi:"serviceTypeHealthPolicyMap"`
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyResponseOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationHealthPolicyResponse)(nil)).Elem()
}

func (o ApplicationHealthPolicyResponseOutput) ToApplicationHealthPolicyResponseOutput() ApplicationHealthPolicyResponseOutput {
	return o
}

func (o ApplicationHealthPolicyResponseOutput) ToApplicationHealthPolicyResponseOutputWithContext(ctx context.Context) ApplicationHealthPolicyResponseOutput {
	return o
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyResponseOutput) ConsiderWarningAsError() pulumi.BoolOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) bool { return v.ConsiderWarningAsError }).(pulumi.BoolOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyResponseOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) *ServiceTypeHealthPolicyResponse {
		return v.DefaultServiceTypeHealthPolicy
	}).(ServiceTypeHealthPolicyResponsePtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyResponseOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) int { return v.MaxPercentUnhealthyDeployedApplications }).(pulumi.IntOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyResponseOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyResponseMapOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) map[string]ServiceTypeHealthPolicyResponse {
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyResponseMapOutput)
}

type ApplicationHealthPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationHealthPolicyResponse)(nil)).Elem()
}

func (o ApplicationHealthPolicyResponsePtrOutput) ToApplicationHealthPolicyResponsePtrOutput() ApplicationHealthPolicyResponsePtrOutput {
	return o
}

func (o ApplicationHealthPolicyResponsePtrOutput) ToApplicationHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyResponsePtrOutput {
	return o
}

func (o ApplicationHealthPolicyResponsePtrOutput) Elem() ApplicationHealthPolicyResponseOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) ApplicationHealthPolicyResponse {
		if v != nil {
			return *v
		}
		var ret ApplicationHealthPolicyResponse
		return ret
	}).(ApplicationHealthPolicyResponseOutput)
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyResponsePtrOutput) ConsiderWarningAsError() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.ConsiderWarningAsError
	}).(pulumi.BoolPtrOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyResponsePtrOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) *ServiceTypeHealthPolicyResponse {
		if v == nil {
			return nil
		}
		return v.DefaultServiceTypeHealthPolicy
	}).(ServiceTypeHealthPolicyResponsePtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyResponsePtrOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyDeployedApplications
	}).(pulumi.IntPtrOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyResponsePtrOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyResponseMapOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) map[string]ServiceTypeHealthPolicyResponse {
		if v == nil {
			return nil
		}
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyResponseMapOutput)
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicy struct {
	// Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep int `pulumi:"maxUnusedVersionsToKeep"`
}

// ApplicationTypeVersionsCleanupPolicyInput is an input type that accepts ApplicationTypeVersionsCleanupPolicyArgs and ApplicationTypeVersionsCleanupPolicyOutput values.
// You can construct a concrete instance of `ApplicationTypeVersionsCleanupPolicyInput` via:
//
//	ApplicationTypeVersionsCleanupPolicyArgs{...}
type ApplicationTypeVersionsCleanupPolicyInput interface {
	pulumi.Input

	ToApplicationTypeVersionsCleanupPolicyOutput() ApplicationTypeVersionsCleanupPolicyOutput
	ToApplicationTypeVersionsCleanupPolicyOutputWithContext(context.Context) ApplicationTypeVersionsCleanupPolicyOutput
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyArgs struct {
	// Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep pulumi.IntInput `pulumi:"maxUnusedVersionsToKeep"`
}

func (ApplicationTypeVersionsCleanupPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyOutput() ApplicationTypeVersionsCleanupPolicyOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyOutputWithContext(context.Background())
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyOutput)
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Background())
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyOutput).ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx)
}

// ApplicationTypeVersionsCleanupPolicyPtrInput is an input type that accepts ApplicationTypeVersionsCleanupPolicyArgs, ApplicationTypeVersionsCleanupPolicyPtr and ApplicationTypeVersionsCleanupPolicyPtrOutput values.
// You can construct a concrete instance of `ApplicationTypeVersionsCleanupPolicyPtrInput` via:
//
//	        ApplicationTypeVersionsCleanupPolicyArgs{...}
//
//	or:
//
//	        nil
type ApplicationTypeVersionsCleanupPolicyPtrInput interface {
	pulumi.Input

	ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput
	ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput
}

type applicationTypeVersionsCleanupPolicyPtrType ApplicationTypeVersionsCleanupPolicyArgs

func ApplicationTypeVersionsCleanupPolicyPtr(v *ApplicationTypeVersionsCleanupPolicyArgs) ApplicationTypeVersionsCleanupPolicyPtrInput {
	return (*applicationTypeVersionsCleanupPolicyPtrType)(v)
}

func (*applicationTypeVersionsCleanupPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (i *applicationTypeVersionsCleanupPolicyPtrType) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Background())
}

func (i *applicationTypeVersionsCleanupPolicyPtrType) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyPtrOutput)
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyOutput() ApplicationTypeVersionsCleanupPolicyOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o.ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Background())
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ApplicationTypeVersionsCleanupPolicy) *ApplicationTypeVersionsCleanupPolicy {
		return &v
	}).(ApplicationTypeVersionsCleanupPolicyPtrOutput)
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyOutput) MaxUnusedVersionsToKeep() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationTypeVersionsCleanupPolicy) int { return v.MaxUnusedVersionsToKeep }).(pulumi.IntOutput)
}

type ApplicationTypeVersionsCleanupPolicyPtrOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) Elem() ApplicationTypeVersionsCleanupPolicyOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicy) ApplicationTypeVersionsCleanupPolicy {
		if v != nil {
			return *v
		}
		var ret ApplicationTypeVersionsCleanupPolicy
		return ret
	}).(ApplicationTypeVersionsCleanupPolicyOutput)
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) MaxUnusedVersionsToKeep() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxUnusedVersionsToKeep
	}).(pulumi.IntPtrOutput)
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyResponse struct {
	// Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep int `pulumi:"maxUnusedVersionsToKeep"`
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyResponseOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationTypeVersionsCleanupPolicyResponse)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyResponseOutput) ToApplicationTypeVersionsCleanupPolicyResponseOutput() ApplicationTypeVersionsCleanupPolicyResponseOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyResponseOutput) ToApplicationTypeVersionsCleanupPolicyResponseOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyResponseOutput {
	return o
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyResponseOutput) MaxUnusedVersionsToKeep() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationTypeVersionsCleanupPolicyResponse) int { return v.MaxUnusedVersionsToKeep }).(pulumi.IntOutput)
}

type ApplicationTypeVersionsCleanupPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationTypeVersionsCleanupPolicyResponse)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutput() ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) Elem() ApplicationTypeVersionsCleanupPolicyResponseOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicyResponse) ApplicationTypeVersionsCleanupPolicyResponse {
		if v != nil {
			return *v
		}
		var ret ApplicationTypeVersionsCleanupPolicyResponse
		return ret
	}).(ApplicationTypeVersionsCleanupPolicyResponseOutput)
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) MaxUnusedVersionsToKeep() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxUnusedVersionsToKeep
	}).(pulumi.IntPtrOutput)
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicy struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy *ApplicationHealthPolicy `pulumi:"applicationHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart *bool `pulumi:"forceRestart"`
	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration *float64 `pulumi:"instanceCloseDelayDuration"`
	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
	RecreateApplication *bool `pulumi:"recreateApplication"`
	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy *RollingUpgradeMonitoringPolicy `pulumi:"rollingUpgradeMonitoringPolicy"`
	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode *string `pulumi:"upgradeMode"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout *float64 `pulumi:"upgradeReplicaSetCheckTimeout"`
}

// ApplicationUpgradePolicyInput is an input type that accepts ApplicationUpgradePolicyArgs and ApplicationUpgradePolicyOutput values.
// You can construct a concrete instance of `ApplicationUpgradePolicyInput` via:
//
//	ApplicationUpgradePolicyArgs{...}
type ApplicationUpgradePolicyInput interface {
	pulumi.Input

	ToApplicationUpgradePolicyOutput() ApplicationUpgradePolicyOutput
	ToApplicationUpgradePolicyOutputWithContext(context.Context) ApplicationUpgradePolicyOutput
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyArgs struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy ApplicationHealthPolicyPtrInput `pulumi:"applicationHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart pulumi.BoolPtrInput `pulumi:"forceRestart"`
	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration pulumi.Float64PtrInput `pulumi:"instanceCloseDelayDuration"`
	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
	RecreateApplication pulumi.BoolPtrInput `pulumi:"recreateApplication"`
	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy RollingUpgradeMonitoringPolicyPtrInput `pulumi:"rollingUpgradeMonitoringPolicy"`
	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode pulumi.StringPtrInput `pulumi:"upgradeMode"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout pulumi.Float64PtrInput `pulumi:"upgradeReplicaSetCheckTimeout"`
}

func (ApplicationUpgradePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUpgradePolicy)(nil)).Elem()
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyOutput() ApplicationUpgradePolicyOutput {
	return i.ToApplicationUpgradePolicyOutputWithContext(context.Background())
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyOutputWithContext(ctx context.Context) ApplicationUpgradePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyOutput)
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return i.ToApplicationUpgradePolicyPtrOutputWithContext(context.Background())
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyOutput).ToApplicationUpgradePolicyPtrOutputWithContext(ctx)
}

// ApplicationUpgradePolicyPtrInput is an input type that accepts ApplicationUpgradePolicyArgs, ApplicationUpgradePolicyPtr and ApplicationUpgradePolicyPtrOutput values.
// You can construct a concrete instance of `ApplicationUpgradePolicyPtrInput` via:
//
//	        ApplicationUpgradePolicyArgs{...}
//
//	or:
//
//	        nil
type ApplicationUpgradePolicyPtrInput interface {
	pulumi.Input

	ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput
	ToApplicationUpgradePolicyPtrOutputWithContext(context.Context) ApplicationUpgradePolicyPtrOutput
}

type applicationUpgradePolicyPtrType ApplicationUpgradePolicyArgs

func ApplicationUpgradePolicyPtr(v *ApplicationUpgradePolicyArgs) ApplicationUpgradePolicyPtrInput {
	return (*applicationUpgradePolicyPtrType)(v)
}

func (*applicationUpgradePolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationUpgradePolicy)(nil)).Elem()
}

func (i *applicationUpgradePolicyPtrType) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return i.ToApplicationUpgradePolicyPtrOutputWithContext(context.Background())
}

func (i *applicationUpgradePolicyPtrType) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyPtrOutput)
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUpgradePolicy)(nil)).Elem()
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyOutput() ApplicationUpgradePolicyOutput {
	return o
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyOutputWithContext(ctx context.Context) ApplicationUpgradePolicyOutput {
	return o
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return o.ToApplicationUpgradePolicyPtrOutputWithContext(context.Background())
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ApplicationUpgradePolicy) *ApplicationUpgradePolicy {
		return &v
	}).(ApplicationUpgradePolicyPtrOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyOutput) ApplicationHealthPolicy() ApplicationHealthPolicyPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *ApplicationHealthPolicy { return v.ApplicationHealthPolicy }).(ApplicationHealthPolicyPtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *bool { return v.ForceRestart }).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *float64 { return v.InstanceCloseDelayDuration }).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *bool { return v.RecreateApplication }).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *RollingUpgradeMonitoringPolicy {
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *string { return v.UpgradeMode }).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *float64 { return v.UpgradeReplicaSetCheckTimeout }).(pulumi.Float64PtrOutput)
}

type ApplicationUpgradePolicyPtrOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationUpgradePolicy)(nil)).Elem()
}

func (o ApplicationUpgradePolicyPtrOutput) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return o
}

func (o ApplicationUpgradePolicyPtrOutput) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return o
}

func (o ApplicationUpgradePolicyPtrOutput) Elem() ApplicationUpgradePolicyOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) ApplicationUpgradePolicy {
		if v != nil {
			return *v
		}
		var ret ApplicationUpgradePolicy
		return ret
	}).(ApplicationUpgradePolicyOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyPtrOutput) ApplicationHealthPolicy() ApplicationHealthPolicyPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *ApplicationHealthPolicy {
		if v == nil {
			return nil
		}
		return v.ApplicationHealthPolicy
	}).(ApplicationHealthPolicyPtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyPtrOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.ForceRestart
	}).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyPtrOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *float64 {
		if v == nil {
			return nil
		}
		return v.InstanceCloseDelayDuration
	}).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyPtrOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.RecreateApplication
	}).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyPtrOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *RollingUpgradeMonitoringPolicy {
		if v == nil {
			return nil
		}
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyPtrOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *string {
		if v == nil {
			return nil
		}
		return v.UpgradeMode
	}).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyPtrOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *float64 {
		if v == nil {
			return nil
		}
		return v.UpgradeReplicaSetCheckTimeout
	}).(pulumi.Float64PtrOutput)
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyResponse struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy *ApplicationHealthPolicyResponse `pulumi:"applicationHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart *bool `pulumi:"forceRestart"`
	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration *float64 `pulumi:"instanceCloseDelayDuration"`
	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
	RecreateApplication *bool `pulumi:"recreateApplication"`
	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy *RollingUpgradeMonitoringPolicyResponse `pulumi:"rollingUpgradeMonitoringPolicy"`
	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode *string `pulumi:"upgradeMode"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout *float64 `pulumi:"upgradeReplicaSetCheckTimeout"`
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyResponseOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUpgradePolicyResponse)(nil)).Elem()
}

func (o ApplicationUpgradePolicyResponseOutput) ToApplicationUpgradePolicyResponseOutput() ApplicationUpgradePolicyResponseOutput {
	return o
}

func (o ApplicationUpgradePolicyResponseOutput) ToApplicationUpgradePolicyResponseOutputWithContext(ctx context.Context) ApplicationUpgradePolicyResponseOutput {
	return o
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyResponseOutput) ApplicationHealthPolicy() ApplicationHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *ApplicationHealthPolicyResponse {
		return v.ApplicationHealthPolicy
	}).(ApplicationHealthPolicyResponsePtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyResponseOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *bool { return v.ForceRestart }).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyResponseOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *float64 { return v.InstanceCloseDelayDuration }).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyResponseOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *bool { return v.RecreateApplication }).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyResponseOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *RollingUpgradeMonitoringPolicyResponse {
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyResponsePtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyResponseOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *string { return v.UpgradeMode }).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyResponseOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *float64 { return v.UpgradeReplicaSetCheckTimeout }).(pulumi.Float64PtrOutput)
}

type ApplicationUpgradePolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationUpgradePolicyResponse)(nil)).Elem()
}

func (o ApplicationUpgradePolicyResponsePtrOutput) ToApplicationUpgradePolicyResponsePtrOutput() ApplicationUpgradePolicyResponsePtrOutput {
	return o
}

func (o ApplicationUpgradePolicyResponsePtrOutput) ToApplicationUpgradePolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyResponsePtrOutput {
	return o
}

func (o ApplicationUpgradePolicyResponsePtrOutput) Elem() ApplicationUpgradePolicyResponseOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) ApplicationUpgradePolicyResponse {
		if v != nil {
			return *v
		}
		var ret ApplicationUpgradePolicyResponse
		return ret
	}).(ApplicationUpgradePolicyResponseOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyResponsePtrOutput) ApplicationHealthPolicy() ApplicationHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *ApplicationHealthPolicyResponse {
		if v == nil {
			return nil
		}
		return v.ApplicationHealthPolicy
	}).(ApplicationHealthPolicyResponsePtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyResponsePtrOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *bool {
		if v == nil {
			return nil
		}
		return v.ForceRestart
	}).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyResponsePtrOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.InstanceCloseDelayDuration
	}).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyResponsePtrOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *bool {
		if v == nil {
			return nil
		}
		return v.RecreateApplication
	}).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyResponsePtrOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *RollingUpgradeMonitoringPolicyResponse {
		if v == nil {
			return nil
		}
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyResponsePtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyResponsePtrOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *string {
		if v == nil {
			return nil
		}
		return v.UpgradeMode
	}).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyResponsePtrOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.UpgradeReplicaSetCheckTimeout
	}).(pulumi.Float64PtrOutput)
}

type ApplicationUserAssignedIdentity struct {
	// The friendly name of user assigned identity.
	Name string `pulumi:"name"`
	// The principal id of user assigned identity.
	PrincipalId string `pulumi:"principalId"`
}

// ApplicationUserAssignedIdentityInput is an input type that accepts ApplicationUserAssignedIdentityArgs and ApplicationUserAssignedIdentityOutput values.
// You can construct a concrete instance of `ApplicationUserAssignedIdentityInput` via:
//
//	ApplicationUserAssignedIdentityArgs{...}
type ApplicationUserAssignedIdentityInput interface {
	pulumi.Input

	ToApplicationUserAssignedIdentityOutput() ApplicationUserAssignedIdentityOutput
	ToApplicationUserAssignedIdentityOutputWithContext(context.Context) ApplicationUserAssignedIdentityOutput
}

type ApplicationUserAssignedIdentityArgs struct {
	// The friendly name of user assigned identity.
	Name pulumi.StringInput `pulumi:"name"`
	// The principal id of user assigned identity.
	PrincipalId pulumi.StringInput `pulumi:"principalId"`
}

func (ApplicationUserAssignedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (i ApplicationUserAssignedIdentityArgs) ToApplicationUserAssignedIdentityOutput() ApplicationUserAssignedIdentityOutput {
	return i.ToApplicationUserAssignedIdentityOutputWithContext(context.Background())
}

func (i ApplicationUserAssignedIdentityArgs) ToApplicationUserAssignedIdentityOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUserAssignedIdentityOutput)
}

// ApplicationUserAssignedIdentityArrayInput is an input type that accepts ApplicationUserAssignedIdentityArray and ApplicationUserAssignedIdentityArrayOutput values.
// You can construct a concrete instance of `ApplicationUserAssignedIdentityArrayInput` via:
//
//	ApplicationUserAssignedIdentityArray{ ApplicationUserAssignedIdentityArgs{...} }
type ApplicationUserAssignedIdentityArrayInput interface {
	pulumi.Input

	ToApplicationUserAssignedIdentityArrayOutput() ApplicationUserAssignedIdentityArrayOutput
	ToApplicationUserAssignedIdentityArrayOutputWithContext(context.Context) ApplicationUserAssignedIdentityArrayOutput
}

type ApplicationUserAssignedIdentityArray []ApplicationUserAssignedIdentityInput

func (ApplicationUserAssignedIdentityArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (i ApplicationUserAssignedIdentityArray) ToApplicationUserAssignedIdentityArrayOutput() ApplicationUserAssignedIdentityArrayOutput {
	return i.ToApplicationUserAssignedIdentityArrayOutputWithContext(context.Background())
}

func (i ApplicationUserAssignedIdentityArray) ToApplicationUserAssignedIdentityArrayOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUserAssignedIdentityArrayOutput)
}

type ApplicationUserAssignedIdentityOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityOutput) ToApplicationUserAssignedIdentityOutput() ApplicationUserAssignedIdentityOutput {
	return o
}

func (o ApplicationUserAssignedIdentityOutput) ToApplicationUserAssignedIdentityOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityOutput {
	return o
}

// The friendly name of user assigned identity.
func (o ApplicationUserAssignedIdentityOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentity) string { return v.Name }).(pulumi.StringOutput)
}

// The principal id of user assigned identity.
func (o ApplicationUserAssignedIdentityOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentity) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type ApplicationUserAssignedIdentityArrayOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityArrayOutput) ToApplicationUserAssignedIdentityArrayOutput() ApplicationUserAssignedIdentityArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityArrayOutput) ToApplicationUserAssignedIdentityArrayOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityArrayOutput) Index(i pulumi.IntInput) ApplicationUserAssignedIdentityOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ApplicationUserAssignedIdentity {
		return vs[0].([]ApplicationUserAssignedIdentity)[vs[1].(int)]
	}).(ApplicationUserAssignedIdentityOutput)
}

type ApplicationUserAssignedIdentityResponse struct {
	// The friendly name of user assigned identity.
	Name string `pulumi:"name"`
	// The principal id of user assigned identity.
	PrincipalId string `pulumi:"principalId"`
}

type ApplicationUserAssignedIdentityResponseOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUserAssignedIdentityResponse)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityResponseOutput) ToApplicationUserAssignedIdentityResponseOutput() ApplicationUserAssignedIdentityResponseOutput {
	return o
}

func (o ApplicationUserAssignedIdentityResponseOutput) ToApplicationUserAssignedIdentityResponseOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityResponseOutput {
	return o
}

// The friendly name of user assigned identity.
func (o ApplicationUserAssignedIdentityResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentityResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The principal id of user assigned identity.
func (o ApplicationUserAssignedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type ApplicationUserAssignedIdentityResponseArrayOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationUserAssignedIdentityResponse)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityResponseArrayOutput) ToApplicationUserAssignedIdentityResponseArrayOutput() ApplicationUserAssignedIdentityResponseArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityResponseArrayOutput) ToApplicationUserAssignedIdentityResponseArrayOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityResponseArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityResponseArrayOutput) Index(i pulumi.IntInput) ApplicationUserAssignedIdentityResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ApplicationUserAssignedIdentityResponse {
		return vs[0].([]ApplicationUserAssignedIdentityResponse)[vs[1].(int)]
	}).(ApplicationUserAssignedIdentityResponseOutput)
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTrigger struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AveragePartitionLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
}

// AveragePartitionLoadScalingTriggerInput is an input type that accepts AveragePartitionLoadScalingTriggerArgs and AveragePartitionLoadScalingTriggerOutput values.
// You can construct a concrete instance of `AveragePartitionLoadScalingTriggerInput` via:
//
//	AveragePartitionLoadScalingTriggerArgs{...}
type AveragePartitionLoadScalingTriggerInput interface {
	pulumi.Input

	ToAveragePartitionLoadScalingTriggerOutput() AveragePartitionLoadScalingTriggerOutput
	ToAveragePartitionLoadScalingTriggerOutputWithContext(context.Context) AveragePartitionLoadScalingTriggerOutput
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTriggerArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AveragePartitionLoadTrigger'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold pulumi.Float64Input `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName pulumi.StringInput `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval pulumi.StringInput `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold pulumi.Float64Input `pulumi:"upperLoadThreshold"`
}

func (AveragePartitionLoadScalingTriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AveragePartitionLoadScalingTrigger)(nil)).Elem()
}

func (i AveragePartitionLoadScalingTriggerArgs) ToAveragePartitionLoadScalingTriggerOutput() AveragePartitionLoadScalingTriggerOutput {
	return i.ToAveragePartitionLoadScalingTriggerOutputWithContext(context.Background())
}

func (i AveragePartitionLoadScalingTriggerArgs) ToAveragePartitionLoadScalingTriggerOutputWithContext(ctx context.Context) AveragePartitionLoadScalingTriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AveragePartitionLoadScalingTriggerOutput)
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTriggerOutput struct{ *pulumi.OutputState }

func (AveragePartitionLoadScalingTriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AveragePartitionLoadScalingTrigger)(nil)).Elem()
}

func (o AveragePartitionLoadScalingTriggerOutput) ToAveragePartitionLoadScalingTriggerOutput() AveragePartitionLoadScalingTriggerOutput {
	return o
}

func (o AveragePartitionLoadScalingTriggerOutput) ToAveragePartitionLoadScalingTriggerOutputWithContext(ctx context.Context) AveragePartitionLoadScalingTriggerOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AveragePartitionLoadTrigger'.
func (o AveragePartitionLoadScalingTriggerOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTrigger) string { return v.Kind }).(pulumi.StringOutput)
}

// The lower limit of the load below which a scale in operation should be performed.
func (o AveragePartitionLoadScalingTriggerOutput) LowerLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AveragePartitionLoadScalingTrigger) float64 { return v.LowerLoadThreshold }).(pulumi.Float64Output)
}

// The name of the metric for which usage should be tracked.
func (o AveragePartitionLoadScalingTriggerOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTrigger) string { return v.MetricName }).(pulumi.StringOutput)
}

// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
func (o AveragePartitionLoadScalingTriggerOutput) ScaleInterval() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTrigger) string { return v.ScaleInterval }).(pulumi.StringOutput)
}

// The upper limit of the load beyond which a scale out operation should be performed.
func (o AveragePartitionLoadScalingTriggerOutput) UpperLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AveragePartitionLoadScalingTrigger) float64 { return v.UpperLoadThreshold }).(pulumi.Float64Output)
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTriggerResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AveragePartitionLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTriggerResponseOutput struct{ *pulumi.OutputState }

func (AveragePartitionLoadScalingTriggerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AveragePartitionLoadScalingTriggerResponse)(nil)).Elem()
}

func (o AveragePartitionLoadScalingTriggerResponseOutput) ToAveragePartitionLoadScalingTriggerResponseOutput() AveragePartitionLoadScalingTriggerResponseOutput {
	return o
}

func (o AveragePartitionLoadScalingTriggerResponseOutput) ToAveragePartitionLoadScalingTriggerResponseOutputWithContext(ctx context.Context) AveragePartitionLoadScalingTriggerResponseOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AveragePartitionLoadTrigger'.
func (o AveragePartitionLoadScalingTriggerResponseOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTriggerResponse) string { return v.Kind }).(pulumi.StringOutput)
}

// The lower limit of the load below which a scale in operation should be performed.
func (o AveragePartitionLoadScalingTriggerResponseOutput) LowerLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AveragePartitionLoadScalingTriggerResponse) float64 { return v.LowerLoadThreshold }).(pulumi.Float64Output)
}

// The name of the metric for which usage should be tracked.
func (o AveragePartitionLoadScalingTriggerResponseOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTriggerResponse) string { return v.MetricName }).(pulumi.StringOutput)
}

// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
func (o AveragePartitionLoadScalingTriggerResponseOutput) ScaleInterval() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTriggerResponse) string { return v.ScaleInterval }).(pulumi.StringOutput)
}

// The upper limit of the load beyond which a scale out operation should be performed.
func (o AveragePartitionLoadScalingTriggerResponseOutput) UpperLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AveragePartitionLoadScalingTriggerResponse) float64 { return v.UpperLoadThreshold }).(pulumi.Float64Output)
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTrigger struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AverageServiceLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
	// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
	UseOnlyPrimaryLoad bool `pulumi:"useOnlyPrimaryLoad"`
}

// AverageServiceLoadScalingTriggerInput is an input type that accepts AverageServiceLoadScalingTriggerArgs and AverageServiceLoadScalingTriggerOutput values.
// You can construct a concrete instance of `AverageServiceLoadScalingTriggerInput` via:
//
//	AverageServiceLoadScalingTriggerArgs{...}
type AverageServiceLoadScalingTriggerInput interface {
	pulumi.Input

	ToAverageServiceLoadScalingTriggerOutput() AverageServiceLoadScalingTriggerOutput
	ToAverageServiceLoadScalingTriggerOutputWithContext(context.Context) AverageServiceLoadScalingTriggerOutput
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTriggerArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AverageServiceLoadTrigger'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold pulumi.Float64Input `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName pulumi.StringInput `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval pulumi.StringInput `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold pulumi.Float64Input `pulumi:"upperLoadThreshold"`
	// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
	UseOnlyPrimaryLoad pulumi.BoolInput `pulumi:"useOnlyPrimaryLoad"`
}

func (AverageServiceLoadScalingTriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AverageServiceLoadScalingTrigger)(nil)).Elem()
}

func (i AverageServiceLoadScalingTriggerArgs) ToAverageServiceLoadScalingTriggerOutput() AverageServiceLoadScalingTriggerOutput {
	return i.ToAverageServiceLoadScalingTriggerOutputWithContext(context.Background())
}

func (i AverageServiceLoadScalingTriggerArgs) ToAverageServiceLoadScalingTriggerOutputWithContext(ctx context.Context) AverageServiceLoadScalingTriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AverageServiceLoadScalingTriggerOutput)
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTriggerOutput struct{ *pulumi.OutputState }

func (AverageServiceLoadScalingTriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AverageServiceLoadScalingTrigger)(nil)).Elem()
}

func (o AverageServiceLoadScalingTriggerOutput) ToAverageServiceLoadScalingTriggerOutput() AverageServiceLoadScalingTriggerOutput {
	return o
}

func (o AverageServiceLoadScalingTriggerOutput) ToAverageServiceLoadScalingTriggerOutputWithContext(ctx context.Context) AverageServiceLoadScalingTriggerOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AverageServiceLoadTrigger'.
func (o AverageServiceLoadScalingTriggerOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) string { return v.Kind }).(pulumi.StringOutput)
}

// The lower limit of the load below which a scale in operation should be performed.
func (o AverageServiceLoadScalingTriggerOutput) LowerLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) float64 { return v.LowerLoadThreshold }).(pulumi.Float64Output)
}

// The name of the metric for which usage should be tracked.
func (o AverageServiceLoadScalingTriggerOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) string { return v.MetricName }).(pulumi.StringOutput)
}

// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
func (o AverageServiceLoadScalingTriggerOutput) ScaleInterval() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) string { return v.ScaleInterval }).(pulumi.StringOutput)
}

// The upper limit of the load beyond which a scale out operation should be performed.
func (o AverageServiceLoadScalingTriggerOutput) UpperLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) float64 { return v.UpperLoadThreshold }).(pulumi.Float64Output)
}

// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
func (o AverageServiceLoadScalingTriggerOutput) UseOnlyPrimaryLoad() pulumi.BoolOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) bool { return v.UseOnlyPrimaryLoad }).(pulumi.BoolOutput)
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTriggerResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AverageServiceLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
	// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
	UseOnlyPrimaryLoad bool `pulumi:"useOnlyPrimaryLoad"`
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTriggerResponseOutput struct{ *pulumi.OutputState }

func (AverageServiceLoadScalingTriggerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AverageServiceLoadScalingTriggerResponse)(nil)).Elem()
}

func (o AverageServiceLoadScalingTriggerResponseOutput) ToAverageServiceLoadScalingTriggerResponseOutput() AverageServiceLoadScalingTriggerResponseOutput {
	return o
}

func (o AverageServiceLoadScalingTriggerResponseOutput) ToAverageServiceLoadScalingTriggerResponseOutputWithContext(ctx context.Context) AverageServiceLoadScalingTriggerResponseOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AverageServiceLoadTrigger'.
func (o AverageServiceLoadScalingTriggerResponseOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) string { return v.Kind }).(pulumi.StringOutput)
}

// The lower limit of the load below which a scale in operation should be performed.
func (o AverageServiceLoadScalingTriggerResponseOutput) LowerLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) float64 { return v.LowerLoadThreshold }).(pulumi.Float64Output)
}

// The name of the metric for which usage should be tracked.
func (o AverageServiceLoadScalingTriggerResponseOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) string { return v.MetricName }).(pulumi.StringOutput)
}

// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
func (o AverageServiceLoadScalingTriggerResponseOutput) ScaleInterval() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) string { return v.ScaleInterval }).(pulumi.StringOutput)
}

// The upper limit of the load beyond which a scale out operation should be performed.
func (o AverageServiceLoadScalingTriggerResponseOutput) UpperLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) float64 { return v.UpperLoadThreshold }).(pulumi.Float64Output)
}

// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
func (o AverageServiceLoadScalingTriggerResponseOutput) UseOnlyPrimaryLoad() pulumi.BoolOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) bool { return v.UseOnlyPrimaryLoad }).(pulumi.BoolOutput)
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectory struct {
	// Azure active directory client application id.
	ClientApplication *string `pulumi:"clientApplication"`
	// Azure active directory cluster application id.
	ClusterApplication *string `pulumi:"clusterApplication"`
	// Azure active directory tenant id.
	TenantId *string `pulumi:"tenantId"`
}

// AzureActiveDirectoryInput is an input type that accepts AzureActiveDirectoryArgs and AzureActiveDirectoryOutput values.
// You can construct a concrete instance of `AzureActiveDirectoryInput` via:
//
//	AzureActiveDirectoryArgs{...}
type AzureActiveDirectoryInput interface {
	pulumi.Input

	ToAzureActiveDirectoryOutput() AzureActiveDirectoryOutput
	ToAzureActiveDirectoryOutputWithContext(context.Context) AzureActiveDirectoryOutput
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryArgs struct {
	// Azure active directory client application id.
	ClientApplication pulumi.StringPtrInput `pulumi:"clientApplication"`
	// Azure active directory cluster application id.
	ClusterApplication pulumi.StringPtrInput `pulumi:"clusterApplication"`
	// Azure active directory tenant id.
	TenantId pulumi.StringPtrInput `pulumi:"tenantId"`
}

func (AzureActiveDirectoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureActiveDirectory)(nil)).Elem()
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryOutput() AzureActiveDirectoryOutput {
	return i.ToAzureActiveDirectoryOutputWithContext(context.Background())
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryOutputWithContext(ctx context.Context) AzureActiveDirectoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryOutput)
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return i.ToAzureActiveDirectoryPtrOutputWithContext(context.Background())
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryOutput).ToAzureActiveDirectoryPtrOutputWithContext(ctx)
}

// AzureActiveDirectoryPtrInput is an input type that accepts AzureActiveDirectoryArgs, AzureActiveDirectoryPtr and AzureActiveDirectoryPtrOutput values.
// You can construct a concrete instance of `AzureActiveDirectoryPtrInput` via:
//
//	        AzureActiveDirectoryArgs{...}
//
//	or:
//
//	        nil
type AzureActiveDirectoryPtrInput interface {
	pulumi.Input

	ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput
	ToAzureActiveDirectoryPtrOutputWithContext(context.Context) AzureActiveDirectoryPtrOutput
}

type azureActiveDirectoryPtrType AzureActiveDirectoryArgs

func AzureActiveDirectoryPtr(v *AzureActiveDirectoryArgs) AzureActiveDirectoryPtrInput {
	return (*azureActiveDirectoryPtrType)(v)
}

func (*azureActiveDirectoryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureActiveDirectory)(nil)).Elem()
}

func (i *azureActiveDirectoryPtrType) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return i.ToAzureActiveDirectoryPtrOutputWithContext(context.Background())
}

func (i *azureActiveDirectoryPtrType) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryPtrOutput)
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureActiveDirectory)(nil)).Elem()
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryOutput() AzureActiveDirectoryOutput {
	return o
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryOutputWithContext(ctx context.Context) AzureActiveDirectoryOutput {
	return o
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return o.ToAzureActiveDirectoryPtrOutputWithContext(context.Background())
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AzureActiveDirectory) *AzureActiveDirectory {
		return &v
	}).(AzureActiveDirectoryPtrOutput)
}

// Azure active directory client application id.
func (o AzureActiveDirectoryOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectory) *string { return v.ClientApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectory) *string { return v.ClusterApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectory) *string { return v.TenantId }).(pulumi.StringPtrOutput)
}

type AzureActiveDirectoryPtrOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureActiveDirectory)(nil)).Elem()
}

func (o AzureActiveDirectoryPtrOutput) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return o
}

func (o AzureActiveDirectoryPtrOutput) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return o
}

func (o AzureActiveDirectoryPtrOutput) Elem() AzureActiveDirectoryOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) AzureActiveDirectory {
		if v != nil {
			return *v
		}
		var ret AzureActiveDirectory
		return ret
	}).(AzureActiveDirectoryOutput)
}

// Azure active directory client application id.
func (o AzureActiveDirectoryPtrOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) *string {
		if v == nil {
			return nil
		}
		return v.ClientApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryPtrOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) *string {
		if v == nil {
			return nil
		}
		return v.ClusterApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryPtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) *string {
		if v == nil {
			return nil
		}
		return v.TenantId
	}).(pulumi.StringPtrOutput)
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryResponse struct {
	// Azure active directory client application id.
	ClientApplication *string `pulumi:"clientApplication"`
	// Azure active directory cluster application id.
	ClusterApplication *string `pulumi:"clusterApplication"`
	// Azure active directory tenant id.
	TenantId *string `pulumi:"tenantId"`
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryResponseOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureActiveDirectoryResponse)(nil)).Elem()
}

func (o AzureActiveDirectoryResponseOutput) ToAzureActiveDirectoryResponseOutput() AzureActiveDirectoryResponseOutput {
	return o
}

func (o AzureActiveDirectoryResponseOutput) ToAzureActiveDirectoryResponseOutputWithContext(ctx context.Context) AzureActiveDirectoryResponseOutput {
	return o
}

// Azure active directory client application id.
func (o AzureActiveDirectoryResponseOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectoryResponse) *string { return v.ClientApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryResponseOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectoryResponse) *string { return v.ClusterApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryResponseOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectoryResponse) *string { return v.TenantId }).(pulumi.StringPtrOutput)
}

type AzureActiveDirectoryResponsePtrOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureActiveDirectoryResponse)(nil)).Elem()
}

func (o AzureActiveDirectoryResponsePtrOutput) ToAzureActiveDirectoryResponsePtrOutput() AzureActiveDirectoryResponsePtrOutput {
	return o
}

func (o AzureActiveDirectoryResponsePtrOutput) ToAzureActiveDirectoryResponsePtrOutputWithContext(ctx context.Context) AzureActiveDirectoryResponsePtrOutput {
	return o
}

func (o AzureActiveDirectoryResponsePtrOutput) Elem() AzureActiveDirectoryResponseOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) AzureActiveDirectoryResponse {
		if v != nil {
			return *v
		}
		var ret AzureActiveDirectoryResponse
		return ret
	}).(AzureActiveDirectoryResponseOutput)
}

// Azure active directory client application id.
func (o AzureActiveDirectoryResponsePtrOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) *string {
		if v == nil {
			return nil
		}
		return v.ClientApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryResponsePtrOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) *string {
		if v == nil {
			return nil
		}
		return v.ClusterApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryResponsePtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) *string {
		if v == nil {
			return nil
		}
		return v.TenantId
	}).(pulumi.StringPtrOutput)
}

// Client certificate definition.
type ClientCertificate struct {
	// Certificate common name.
	CommonName *string `pulumi:"commonName"`
	// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin bool `pulumi:"isAdmin"`
	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint *string `pulumi:"issuerThumbprint"`
	// Certificate thumbprint.
	Thumbprint *string `pulumi:"thumbprint"`
}

// ClientCertificateInput is an input type that accepts ClientCertificateArgs and ClientCertificateOutput values.
// You can construct a concrete instance of `ClientCertificateInput` via:
//
//	ClientCertificateArgs{...}
type ClientCertificateInput interface {
	pulumi.Input

	ToClientCertificateOutput() ClientCertificateOutput
	ToClientCertificateOutputWithContext(context.Context) ClientCertificateOutput
}

// Client certificate definition.
type ClientCertificateArgs struct {
	// Certificate common name.
	CommonName pulumi.StringPtrInput `pulumi:"commonName"`
	// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin pulumi.BoolInput `pulumi:"isAdmin"`
	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint pulumi.StringPtrInput `pulumi:"issuerThumbprint"`
	// Certificate thumbprint.
	Thumbprint pulumi.StringPtrInput `pulumi:"thumbprint"`
}

func (ClientCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientCertificate)(nil)).Elem()
}

func (i ClientCertificateArgs) ToClientCertificateOutput() ClientCertificateOutput {
	return i.ToClientCertificateOutputWithContext(context.Background())
}

func (i ClientCertificateArgs) ToClientCertificateOutputWithContext(ctx context.Context) ClientCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClientCertificateOutput)
}

// ClientCertificateArrayInput is an input type that accepts ClientCertificateArray and ClientCertificateArrayOutput values.
// You can construct a concrete instance of `ClientCertificateArrayInput` via:
//
//	ClientCertificateArray{ ClientCertificateArgs{...} }
type ClientCertificateArrayInput interface {
	pulumi.Input

	ToClientCertificateArrayOutput() ClientCertificateArrayOutput
	ToClientCertificateArrayOutputWithContext(context.Context) ClientCertificateArrayOutput
}

type ClientCertificateArray []ClientCertificateInput

func (ClientCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClientCertificate)(nil)).Elem()
}

func (i ClientCertificateArray) ToClientCertificateArrayOutput() ClientCertificateArrayOutput {
	return i.ToClientCertificateArrayOutputWithContext(context.Background())
}

func (i ClientCertificateArray) ToClientCertificateArrayOutputWithContext(ctx context.Context) ClientCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClientCertificateArrayOutput)
}

// Client certificate definition.
type ClientCertificateOutput struct{ *pulumi.OutputState }

func (ClientCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientCertificate)(nil)).Elem()
}

func (o ClientCertificateOutput) ToClientCertificateOutput() ClientCertificateOutput {
	return o
}

func (o ClientCertificateOutput) ToClientCertificateOutputWithContext(ctx context.Context) ClientCertificateOutput {
	return o
}

// Certificate common name.
func (o ClientCertificateOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificate) *string { return v.CommonName }).(pulumi.StringPtrOutput)
}

// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
func (o ClientCertificateOutput) IsAdmin() pulumi.BoolOutput {
	return o.ApplyT(func(v ClientCertificate) bool { return v.IsAdmin }).(pulumi.BoolOutput)
}

// Issuer thumbprint for the certificate. Only used together with CommonName.
func (o ClientCertificateOutput) IssuerThumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificate) *string { return v.IssuerThumbprint }).(pulumi.StringPtrOutput)
}

// Certificate thumbprint.
func (o ClientCertificateOutput) Thumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificate) *string { return v.Thumbprint }).(pulumi.StringPtrOutput)
}

type ClientCertificateArrayOutput struct{ *pulumi.OutputState }

func (ClientCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClientCertificate)(nil)).Elem()
}

func (o ClientCertificateArrayOutput) ToClientCertificateArrayOutput() ClientCertificateArrayOutput {
	return o
}

func (o ClientCertificateArrayOutput) ToClientCertificateArrayOutputWithContext(ctx context.Context) ClientCertificateArrayOutput {
	return o
}

func (o ClientCertificateArrayOutput) Index(i pulumi.IntInput) ClientCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClientCertificate {
		return vs[0].([]ClientCertificate)[vs[1].(int)]
	}).(ClientCertificateOutput)
}

// Client certificate definition.
type ClientCertificateResponse struct {
	// Certificate common name.
	CommonName *string `pulumi:"commonName"`
	// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin bool `pulumi:"isAdmin"`
	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint *string `pulumi:"issuerThumbprint"`
	// Certificate thumbprint.
	Thumbprint *string `pulumi:"thumbprint"`
}

// Client certificate definition.
type ClientCertificateResponseOutput struct{ *pulumi.OutputState }

func (ClientCertificateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientCertificateResponse)(nil)).Elem()
}

func (o ClientCertificateResponseOutput) ToClientCertificateResponseOutput() ClientCertificateResponseOutput {
	return o
}

func (o ClientCertificateResponseOutput) ToClientCertificateResponseOutputWithContext(ctx context.Context) ClientCertificateResponseOutput {
	return o
}

// Certificate common name.
func (o ClientCertificateResponseOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificateResponse) *string { return v.CommonName }).(pulumi.StringPtrOutput)
}

// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
func (o ClientCertificateResponseOutput) IsAdmin() pulumi.BoolOutput {
	return o.ApplyT(func(v ClientCertificateResponse) bool { return v.IsAdmin }).(pulumi.BoolOutput)
}

// Issuer thumbprint for the certificate. Only used together with CommonName.
func (o ClientCertificateResponseOutput) IssuerThumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificateResponse) *string { return v.IssuerThumbprint }).(pulumi.StringPtrOutput)
}

// Certificate thumbprint.
func (o ClientCertificateResponseOutput) Thumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificateResponse) *string { return v.Thumbprint }).(pulumi.StringPtrOutput)
}

type ClientCertificateResponseArrayOutput struct{ *pulumi.OutputState }

func (ClientCertificateResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClientCertificateResponse)(nil)).Elem()
}

func (o ClientCertificateResponseArrayOutput) ToClientCertificateResponseArrayOutput() ClientCertificateResponseArrayOutput {
	return o
}

func (o ClientCertificateResponseArrayOutput) ToClientCertificateResponseArrayOutputWithContext(ctx context.Context) ClientCertificateResponseArrayOutput {
	return o
}

func (o ClientCertificateResponseArrayOutput) Index(i pulumi.IntInput) ClientCertificateResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClientCertificateResponse {
		return vs[0].([]ClientCertificateResponse)[vs[1].(int)]
	}).(ClientCertificateResponseOutput)
}

// Defines a health policy used to evaluate the health of the cluster or of a cluster node.
type ClusterHealthPolicy struct {
	// The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.
	//
	// The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error.
	// If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap.
	// The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
	MaxPercentUnhealthyApplications int `pulumi:"maxPercentUnhealthyApplications"`
	// The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
	//
	// The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error.
	// If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	//
	// In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.
	MaxPercentUnhealthyNodes int `pulumi:"maxPercentUnhealthyNodes"`
}

// Defaults sets the appropriate defaults for ClusterHealthPolicy
func (val *ClusterHealthPolicy) Defaults() *ClusterHealthPolicy {
	if val == nil {
		return nil
	}
	tmp := *val
	if utilities.IsZero(tmp.MaxPercentUnhealthyApplications) {
		tmp.MaxPercentUnhealthyApplications = 0
	}
	if utilities.IsZero(tmp.MaxPercentUnhealthyNodes) {
		tmp.MaxPercentUnhealthyNodes = 0
	}
	return &tmp
}

// ClusterHealthPolicyInput is an input type that accepts ClusterHealthPolicyArgs and ClusterHealthPolicyOutput values.
// You can construct a concrete instance of `ClusterHealthPolicyInput` via:
//
//	ClusterHealthPolicyArgs{...}
type ClusterHealthPolicyInput interface {
	pulumi.Input

	ToClusterHealthPolicyOutput() ClusterHealthPolicyOutput
	ToClusterHealthPolicyOutputWithContext(context.Context) ClusterHealthPolicyOutput
}

// Defines a health policy used to evaluate the health of the cluster or of a cluster node.
type ClusterHealthPolicyArgs struct {
	// The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.
	//
	// The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error.
	// If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap.
	// The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
	MaxPercentUnhealthyApplications pulumi.IntInput `pulumi:"maxPercentUnhealthyApplications"`
	// The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
	//
	// The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error.
	// If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	//
	// In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.
	MaxPercentUnhealthyNodes pulumi.IntInput `pulumi:"maxPercentUnhealthyNodes"`
}

// Defaults sets the appropriate defaults for ClusterHealthPolicyArgs
func (val *ClusterHealthPolicyArgs) Defaults() *ClusterHealthPolicyArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.MaxPercentUnhealthyApplications == nil {
		tmp.MaxPercentUnhealthyApplications = pulumi.Int(0)
	}
	if tmp.MaxPercentUnhealthyNodes == nil {
		tmp.MaxPercentUnhealthyNodes = pulumi.Int(0)
	}
	return &tmp
}
func (ClusterHealthPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterHealthPolicy)(nil)).Elem()
}

func (i ClusterHealthPolicyArgs) ToClusterHealthPolicyOutput() ClusterHealthPolicyOutput {
	return i.ToClusterHealthPolicyOutputWithContext(context.Background())
}

func (i ClusterHealthPolicyArgs) ToClusterHealthPolicyOutputWithContext(ctx context.Context) ClusterHealthPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterHealthPolicyOutput)
}

func (i ClusterHealthPolicyArgs) ToClusterHealthPolicyPtrOutput() ClusterHealthPolicyPtrOutput {
	return i.ToClusterHealthPolicyPtrOutputWithContext(context.Background())
}

func (i ClusterHealthPolicyArgs) ToClusterHealthPolicyPtrOutputWithContext(ctx context.Context) ClusterHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterHealthPolicyOutput).ToClusterHealthPolicyPtrOutputWithContext(ctx)
}

// ClusterHealthPolicyPtrInput is an input type that accepts ClusterHealthPolicyArgs, ClusterHealthPolicyPtr and ClusterHealthPolicyPtrOutput values.
// You can construct a concrete instance of `ClusterHealthPolicyPtrInput` via:
//
//	        ClusterHealthPolicyArgs{...}
//
//	or:
//
//	        nil
type ClusterHealthPolicyPtrInput interface {
	pulumi.Input

	ToClusterHealthPolicyPtrOutput() ClusterHealthPolicyPtrOutput
	ToClusterHealthPolicyPtrOutputWithContext(context.Context) ClusterHealthPolicyPtrOutput
}

type clusterHealthPolicyPtrType ClusterHealthPolicyArgs

func ClusterHealthPolicyPtr(v *ClusterHealthPolicyArgs) ClusterHealthPolicyPtrInput {
	return (*clusterHealthPolicyPtrType)(v)
}

func (*clusterHealthPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterHealthPolicy)(nil)).Elem()
}

func (i *clusterHealthPolicyPtrType) ToClusterHealthPolicyPtrOutput() ClusterHealthPolicyPtrOutput {
	return i.ToClusterHealthPolicyPtrOutputWithContext(context.Background())
}

func (i *clusterHealthPolicyPtrType) ToClusterHealthPolicyPtrOutputWithContext(ctx context.Context) ClusterHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterHealthPolicyPtrOutput)
}

// Defines a health policy used to evaluate the health of the cluster or of a cluster node.
type ClusterHealthPolicyOutput struct{ *pulumi.OutputState }

func (ClusterHealthPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterHealthPolicy)(nil)).Elem()
}

func (o ClusterHealthPolicyOutput) ToClusterHealthPolicyOutput() ClusterHealthPolicyOutput {
	return o
}

func (o ClusterHealthPolicyOutput) ToClusterHealthPolicyOutputWithContext(ctx context.Context) ClusterHealthPolicyOutput {
	return o
}

func (o ClusterHealthPolicyOutput) ToClusterHealthPolicyPtrOutput() ClusterHealthPolicyPtrOutput {
	return o.ToClusterHealthPolicyPtrOutputWithContext(context.Background())
}

func (o ClusterHealthPolicyOutput) ToClusterHealthPolicyPtrOutputWithContext(ctx context.Context) ClusterHealthPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterHealthPolicy) *ClusterHealthPolicy {
		return &v
	}).(ClusterHealthPolicyPtrOutput)
}

// The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.
//
// The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error.
// If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap.
// The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
func (o ClusterHealthPolicyOutput) MaxPercentUnhealthyApplications() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterHealthPolicy) int { return v.MaxPercentUnhealthyApplications }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
//
// The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error.
// If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
//
// In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.
func (o ClusterHealthPolicyOutput) MaxPercentUnhealthyNodes() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterHealthPolicy) int { return v.MaxPercentUnhealthyNodes }).(pulumi.IntOutput)
}

type ClusterHealthPolicyPtrOutput struct{ *pulumi.OutputState }

func (ClusterHealthPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterHealthPolicy)(nil)).Elem()
}

func (o ClusterHealthPolicyPtrOutput) ToClusterHealthPolicyPtrOutput() ClusterHealthPolicyPtrOutput {
	return o
}

func (o ClusterHealthPolicyPtrOutput) ToClusterHealthPolicyPtrOutputWithContext(ctx context.Context) ClusterHealthPolicyPtrOutput {
	return o
}

func (o ClusterHealthPolicyPtrOutput) Elem() ClusterHealthPolicyOutput {
	return o.ApplyT(func(v *ClusterHealthPolicy) ClusterHealthPolicy {
		if v != nil {
			return *v
		}
		var ret ClusterHealthPolicy
		return ret
	}).(ClusterHealthPolicyOutput)
}

// The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.
//
// The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error.
// If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap.
// The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
func (o ClusterHealthPolicyPtrOutput) MaxPercentUnhealthyApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyApplications
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
//
// The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error.
// If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
//
// In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.
func (o ClusterHealthPolicyPtrOutput) MaxPercentUnhealthyNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyNodes
	}).(pulumi.IntPtrOutput)
}

// Defines a health policy used to evaluate the health of the cluster or of a cluster node.
type ClusterHealthPolicyResponse struct {
	// The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.
	//
	// The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error.
	// If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap.
	// The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
	MaxPercentUnhealthyApplications int `pulumi:"maxPercentUnhealthyApplications"`
	// The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
	//
	// The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error.
	// If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	//
	// In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.
	MaxPercentUnhealthyNodes int `pulumi:"maxPercentUnhealthyNodes"`
}

// Defaults sets the appropriate defaults for ClusterHealthPolicyResponse
func (val *ClusterHealthPolicyResponse) Defaults() *ClusterHealthPolicyResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if utilities.IsZero(tmp.MaxPercentUnhealthyApplications) {
		tmp.MaxPercentUnhealthyApplications = 0
	}
	if utilities.IsZero(tmp.MaxPercentUnhealthyNodes) {
		tmp.MaxPercentUnhealthyNodes = 0
	}
	return &tmp
}

// Defines a health policy used to evaluate the health of the cluster or of a cluster node.
type ClusterHealthPolicyResponseOutput struct{ *pulumi.OutputState }

func (ClusterHealthPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterHealthPolicyResponse)(nil)).Elem()
}

func (o ClusterHealthPolicyResponseOutput) ToClusterHealthPolicyResponseOutput() ClusterHealthPolicyResponseOutput {
	return o
}

func (o ClusterHealthPolicyResponseOutput) ToClusterHealthPolicyResponseOutputWithContext(ctx context.Context) ClusterHealthPolicyResponseOutput {
	return o
}

// The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.
//
// The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error.
// If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap.
// The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
func (o ClusterHealthPolicyResponseOutput) MaxPercentUnhealthyApplications() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterHealthPolicyResponse) int { return v.MaxPercentUnhealthyApplications }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
//
// The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error.
// If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
//
// In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.
func (o ClusterHealthPolicyResponseOutput) MaxPercentUnhealthyNodes() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterHealthPolicyResponse) int { return v.MaxPercentUnhealthyNodes }).(pulumi.IntOutput)
}

type ClusterHealthPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ClusterHealthPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterHealthPolicyResponse)(nil)).Elem()
}

func (o ClusterHealthPolicyResponsePtrOutput) ToClusterHealthPolicyResponsePtrOutput() ClusterHealthPolicyResponsePtrOutput {
	return o
}

func (o ClusterHealthPolicyResponsePtrOutput) ToClusterHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ClusterHealthPolicyResponsePtrOutput {
	return o
}

func (o ClusterHealthPolicyResponsePtrOutput) Elem() ClusterHealthPolicyResponseOutput {
	return o.ApplyT(func(v *ClusterHealthPolicyResponse) ClusterHealthPolicyResponse {
		if v != nil {
			return *v
		}
		var ret ClusterHealthPolicyResponse
		return ret
	}).(ClusterHealthPolicyResponseOutput)
}

// The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.
//
// The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error.
// If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap.
// The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
func (o ClusterHealthPolicyResponsePtrOutput) MaxPercentUnhealthyApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyApplications
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
//
// The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error.
// If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
//
// In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.
func (o ClusterHealthPolicyResponsePtrOutput) MaxPercentUnhealthyNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyNodes
	}).(pulumi.IntPtrOutput)
}

// Describes the monitoring policies for the cluster upgrade.
type ClusterMonitoringPolicy struct {
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckRetryTimeout string `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckStableDuration string `pulumi:"healthCheckStableDuration"`
	// The length of time to wait after completing an upgrade domain before performing health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckWaitDuration string `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	UpgradeDomainTimeout string `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	UpgradeTimeout string `pulumi:"upgradeTimeout"`
}

// ClusterMonitoringPolicyInput is an input type that accepts ClusterMonitoringPolicyArgs and ClusterMonitoringPolicyOutput values.
// You can construct a concrete instance of `ClusterMonitoringPolicyInput` via:
//
//	ClusterMonitoringPolicyArgs{...}
type ClusterMonitoringPolicyInput interface {
	pulumi.Input

	ToClusterMonitoringPolicyOutput() ClusterMonitoringPolicyOutput
	ToClusterMonitoringPolicyOutputWithContext(context.Context) ClusterMonitoringPolicyOutput
}

// Describes the monitoring policies for the cluster upgrade.
type ClusterMonitoringPolicyArgs struct {
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckRetryTimeout pulumi.StringInput `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckStableDuration pulumi.StringInput `pulumi:"healthCheckStableDuration"`
	// The length of time to wait after completing an upgrade domain before performing health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckWaitDuration pulumi.StringInput `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	UpgradeDomainTimeout pulumi.StringInput `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	UpgradeTimeout pulumi.StringInput `pulumi:"upgradeTimeout"`
}

func (ClusterMonitoringPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMonitoringPolicy)(nil)).Elem()
}

func (i ClusterMonitoringPolicyArgs) ToClusterMonitoringPolicyOutput() ClusterMonitoringPolicyOutput {
	return i.ToClusterMonitoringPolicyOutputWithContext(context.Background())
}

func (i ClusterMonitoringPolicyArgs) ToClusterMonitoringPolicyOutputWithContext(ctx context.Context) ClusterMonitoringPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMonitoringPolicyOutput)
}

func (i ClusterMonitoringPolicyArgs) ToClusterMonitoringPolicyPtrOutput() ClusterMonitoringPolicyPtrOutput {
	return i.ToClusterMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (i ClusterMonitoringPolicyArgs) ToClusterMonitoringPolicyPtrOutputWithContext(ctx context.Context) ClusterMonitoringPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMonitoringPolicyOutput).ToClusterMonitoringPolicyPtrOutputWithContext(ctx)
}

// ClusterMonitoringPolicyPtrInput is an input type that accepts ClusterMonitoringPolicyArgs, ClusterMonitoringPolicyPtr and ClusterMonitoringPolicyPtrOutput values.
// You can construct a concrete instance of `ClusterMonitoringPolicyPtrInput` via:
//
//	        ClusterMonitoringPolicyArgs{...}
//
//	or:
//
//	        nil
type ClusterMonitoringPolicyPtrInput interface {
	pulumi.Input

	ToClusterMonitoringPolicyPtrOutput() ClusterMonitoringPolicyPtrOutput
	ToClusterMonitoringPolicyPtrOutputWithContext(context.Context) ClusterMonitoringPolicyPtrOutput
}

type clusterMonitoringPolicyPtrType ClusterMonitoringPolicyArgs

func ClusterMonitoringPolicyPtr(v *ClusterMonitoringPolicyArgs) ClusterMonitoringPolicyPtrInput {
	return (*clusterMonitoringPolicyPtrType)(v)
}

func (*clusterMonitoringPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterMonitoringPolicy)(nil)).Elem()
}

func (i *clusterMonitoringPolicyPtrType) ToClusterMonitoringPolicyPtrOutput() ClusterMonitoringPolicyPtrOutput {
	return i.ToClusterMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (i *clusterMonitoringPolicyPtrType) ToClusterMonitoringPolicyPtrOutputWithContext(ctx context.Context) ClusterMonitoringPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMonitoringPolicyPtrOutput)
}

// Describes the monitoring policies for the cluster upgrade.
type ClusterMonitoringPolicyOutput struct{ *pulumi.OutputState }

func (ClusterMonitoringPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMonitoringPolicy)(nil)).Elem()
}

func (o ClusterMonitoringPolicyOutput) ToClusterMonitoringPolicyOutput() ClusterMonitoringPolicyOutput {
	return o
}

func (o ClusterMonitoringPolicyOutput) ToClusterMonitoringPolicyOutputWithContext(ctx context.Context) ClusterMonitoringPolicyOutput {
	return o
}

func (o ClusterMonitoringPolicyOutput) ToClusterMonitoringPolicyPtrOutput() ClusterMonitoringPolicyPtrOutput {
	return o.ToClusterMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (o ClusterMonitoringPolicyOutput) ToClusterMonitoringPolicyPtrOutputWithContext(ctx context.Context) ClusterMonitoringPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterMonitoringPolicy) *ClusterMonitoringPolicy {
		return &v
	}).(ClusterMonitoringPolicyPtrOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyOutput) HealthCheckRetryTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMonitoringPolicy) string { return v.HealthCheckRetryTimeout }).(pulumi.StringOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyOutput) HealthCheckStableDuration() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMonitoringPolicy) string { return v.HealthCheckStableDuration }).(pulumi.StringOutput)
}

// The length of time to wait after completing an upgrade domain before performing health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyOutput) HealthCheckWaitDuration() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMonitoringPolicy) string { return v.HealthCheckWaitDuration }).(pulumi.StringOutput)
}

// The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyOutput) UpgradeDomainTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMonitoringPolicy) string { return v.UpgradeDomainTimeout }).(pulumi.StringOutput)
}

// The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyOutput) UpgradeTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMonitoringPolicy) string { return v.UpgradeTimeout }).(pulumi.StringOutput)
}

type ClusterMonitoringPolicyPtrOutput struct{ *pulumi.OutputState }

func (ClusterMonitoringPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterMonitoringPolicy)(nil)).Elem()
}

func (o ClusterMonitoringPolicyPtrOutput) ToClusterMonitoringPolicyPtrOutput() ClusterMonitoringPolicyPtrOutput {
	return o
}

func (o ClusterMonitoringPolicyPtrOutput) ToClusterMonitoringPolicyPtrOutputWithContext(ctx context.Context) ClusterMonitoringPolicyPtrOutput {
	return o
}

func (o ClusterMonitoringPolicyPtrOutput) Elem() ClusterMonitoringPolicyOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicy) ClusterMonitoringPolicy {
		if v != nil {
			return *v
		}
		var ret ClusterMonitoringPolicy
		return ret
	}).(ClusterMonitoringPolicyOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyPtrOutput) HealthCheckRetryTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckRetryTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyPtrOutput) HealthCheckStableDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckStableDuration
	}).(pulumi.StringPtrOutput)
}

// The length of time to wait after completing an upgrade domain before performing health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyPtrOutput) HealthCheckWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckWaitDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyPtrOutput) UpgradeDomainTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeDomainTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyPtrOutput) UpgradeTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeTimeout
	}).(pulumi.StringPtrOutput)
}

// Describes the monitoring policies for the cluster upgrade.
type ClusterMonitoringPolicyResponse struct {
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckRetryTimeout string `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckStableDuration string `pulumi:"healthCheckStableDuration"`
	// The length of time to wait after completing an upgrade domain before performing health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	HealthCheckWaitDuration string `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	UpgradeDomainTimeout string `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	UpgradeTimeout string `pulumi:"upgradeTimeout"`
}

// Describes the monitoring policies for the cluster upgrade.
type ClusterMonitoringPolicyResponseOutput struct{ *pulumi.OutputState }

func (ClusterMonitoringPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMonitoringPolicyResponse)(nil)).Elem()
}

func (o ClusterMonitoringPolicyResponseOutput) ToClusterMonitoringPolicyResponseOutput() ClusterMonitoringPolicyResponseOutput {
	return o
}

func (o ClusterMonitoringPolicyResponseOutput) ToClusterMonitoringPolicyResponseOutputWithContext(ctx context.Context) ClusterMonitoringPolicyResponseOutput {
	return o
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyResponseOutput) HealthCheckRetryTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMonitoringPolicyResponse) string { return v.HealthCheckRetryTimeout }).(pulumi.StringOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyResponseOutput) HealthCheckStableDuration() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMonitoringPolicyResponse) string { return v.HealthCheckStableDuration }).(pulumi.StringOutput)
}

// The length of time to wait after completing an upgrade domain before performing health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyResponseOutput) HealthCheckWaitDuration() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMonitoringPolicyResponse) string { return v.HealthCheckWaitDuration }).(pulumi.StringOutput)
}

// The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyResponseOutput) UpgradeDomainTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMonitoringPolicyResponse) string { return v.UpgradeDomainTimeout }).(pulumi.StringOutput)
}

// The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyResponseOutput) UpgradeTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMonitoringPolicyResponse) string { return v.UpgradeTimeout }).(pulumi.StringOutput)
}

type ClusterMonitoringPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ClusterMonitoringPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterMonitoringPolicyResponse)(nil)).Elem()
}

func (o ClusterMonitoringPolicyResponsePtrOutput) ToClusterMonitoringPolicyResponsePtrOutput() ClusterMonitoringPolicyResponsePtrOutput {
	return o
}

func (o ClusterMonitoringPolicyResponsePtrOutput) ToClusterMonitoringPolicyResponsePtrOutputWithContext(ctx context.Context) ClusterMonitoringPolicyResponsePtrOutput {
	return o
}

func (o ClusterMonitoringPolicyResponsePtrOutput) Elem() ClusterMonitoringPolicyResponseOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicyResponse) ClusterMonitoringPolicyResponse {
		if v != nil {
			return *v
		}
		var ret ClusterMonitoringPolicyResponse
		return ret
	}).(ClusterMonitoringPolicyResponseOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyResponsePtrOutput) HealthCheckRetryTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckRetryTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyResponsePtrOutput) HealthCheckStableDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckStableDuration
	}).(pulumi.StringPtrOutput)
}

// The length of time to wait after completing an upgrade domain before performing health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyResponsePtrOutput) HealthCheckWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckWaitDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyResponsePtrOutput) UpgradeDomainTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeDomainTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
func (o ClusterMonitoringPolicyResponsePtrOutput) UpgradeTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeTimeout
	}).(pulumi.StringPtrOutput)
}

// Describes the delta health policies for the cluster upgrade.
type ClusterUpgradeDeltaHealthPolicy struct {
	// The maximum allowed percentage of applications health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the applications at the beginning of upgrade and the state of the applications at the time of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits. System services are not included in this.
	// NOTE: This value will overwrite the value specified in properties.UpgradeDescription.HealthPolicy.MaxPercentUnhealthyApplications
	MaxPercentDeltaUnhealthyApplications *int `pulumi:"maxPercentDeltaUnhealthyApplications"`
	// The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the nodes at the beginning of upgrade and the state of the nodes at the time of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits.
	MaxPercentDeltaUnhealthyNodes int `pulumi:"maxPercentDeltaUnhealthyNodes"`
	// The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the upgrade domain nodes at the beginning of upgrade and the state of the upgrade domain nodes at the time of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion for all completed upgrade domains to make sure the state of the upgrade domains is within tolerated limits.
	MaxPercentUpgradeDomainDeltaUnhealthyNodes *int `pulumi:"maxPercentUpgradeDomainDeltaUnhealthyNodes"`
}

// ClusterUpgradeDeltaHealthPolicyInput is an input type that accepts ClusterUpgradeDeltaHealthPolicyArgs and ClusterUpgradeDeltaHealthPolicyOutput values.
// You can construct a concrete instance of `ClusterUpgradeDeltaHealthPolicyInput` via:
//
//	ClusterUpgradeDeltaHealthPolicyArgs{...}
type ClusterUpgradeDeltaHealthPolicyInput interface {
	pulumi.Input

	ToClusterUpgradeDeltaHealthPolicyOutput() ClusterUpgradeDeltaHealthPolicyOutput
	ToClusterUpgradeDeltaHealthPolicyOutputWithContext(context.Context) ClusterUpgradeDeltaHealthPolicyOutput
}

// Describes the delta health policies for the cluster upgrade.
type ClusterUpgradeDeltaHealthPolicyArgs struct {
	// The maximum allowed percentage of applications health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the applications at the beginning of upgrade and the state of the applications at the time of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits. System services are not included in this.
	// NOTE: This value will overwrite the value specified in properties.UpgradeDescription.HealthPolicy.MaxPercentUnhealthyApplications
	MaxPercentDeltaUnhealthyApplications pulumi.IntPtrInput `pulumi:"maxPercentDeltaUnhealthyApplications"`
	// The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the nodes at the beginning of upgrade and the state of the nodes at the time of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits.
	MaxPercentDeltaUnhealthyNodes pulumi.IntInput `pulumi:"maxPercentDeltaUnhealthyNodes"`
	// The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the upgrade domain nodes at the beginning of upgrade and the state of the upgrade domain nodes at the time of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion for all completed upgrade domains to make sure the state of the upgrade domains is within tolerated limits.
	MaxPercentUpgradeDomainDeltaUnhealthyNodes pulumi.IntPtrInput `pulumi:"maxPercentUpgradeDomainDeltaUnhealthyNodes"`
}

func (ClusterUpgradeDeltaHealthPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterUpgradeDeltaHealthPolicy)(nil)).Elem()
}

func (i ClusterUpgradeDeltaHealthPolicyArgs) ToClusterUpgradeDeltaHealthPolicyOutput() ClusterUpgradeDeltaHealthPolicyOutput {
	return i.ToClusterUpgradeDeltaHealthPolicyOutputWithContext(context.Background())
}

func (i ClusterUpgradeDeltaHealthPolicyArgs) ToClusterUpgradeDeltaHealthPolicyOutputWithContext(ctx context.Context) ClusterUpgradeDeltaHealthPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterUpgradeDeltaHealthPolicyOutput)
}

func (i ClusterUpgradeDeltaHealthPolicyArgs) ToClusterUpgradeDeltaHealthPolicyPtrOutput() ClusterUpgradeDeltaHealthPolicyPtrOutput {
	return i.ToClusterUpgradeDeltaHealthPolicyPtrOutputWithContext(context.Background())
}

func (i ClusterUpgradeDeltaHealthPolicyArgs) ToClusterUpgradeDeltaHealthPolicyPtrOutputWithContext(ctx context.Context) ClusterUpgradeDeltaHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterUpgradeDeltaHealthPolicyOutput).ToClusterUpgradeDeltaHealthPolicyPtrOutputWithContext(ctx)
}

// ClusterUpgradeDeltaHealthPolicyPtrInput is an input type that accepts ClusterUpgradeDeltaHealthPolicyArgs, ClusterUpgradeDeltaHealthPolicyPtr and ClusterUpgradeDeltaHealthPolicyPtrOutput values.
// You can construct a concrete instance of `ClusterUpgradeDeltaHealthPolicyPtrInput` via:
//
//	        ClusterUpgradeDeltaHealthPolicyArgs{...}
//
//	or:
//
//	        nil
type ClusterUpgradeDeltaHealthPolicyPtrInput interface {
	pulumi.Input

	ToClusterUpgradeDeltaHealthPolicyPtrOutput() ClusterUpgradeDeltaHealthPolicyPtrOutput
	ToClusterUpgradeDeltaHealthPolicyPtrOutputWithContext(context.Context) ClusterUpgradeDeltaHealthPolicyPtrOutput
}

type clusterUpgradeDeltaHealthPolicyPtrType ClusterUpgradeDeltaHealthPolicyArgs

func ClusterUpgradeDeltaHealthPolicyPtr(v *ClusterUpgradeDeltaHealthPolicyArgs) ClusterUpgradeDeltaHealthPolicyPtrInput {
	return (*clusterUpgradeDeltaHealthPolicyPtrType)(v)
}

func (*clusterUpgradeDeltaHealthPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterUpgradeDeltaHealthPolicy)(nil)).Elem()
}

func (i *clusterUpgradeDeltaHealthPolicyPtrType) ToClusterUpgradeDeltaHealthPolicyPtrOutput() ClusterUpgradeDeltaHealthPolicyPtrOutput {
	return i.ToClusterUpgradeDeltaHealthPolicyPtrOutputWithContext(context.Background())
}

func (i *clusterUpgradeDeltaHealthPolicyPtrType) ToClusterUpgradeDeltaHealthPolicyPtrOutputWithContext(ctx context.Context) ClusterUpgradeDeltaHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterUpgradeDeltaHealthPolicyPtrOutput)
}

// Describes the delta health policies for the cluster upgrade.
type ClusterUpgradeDeltaHealthPolicyOutput struct{ *pulumi.OutputState }

func (ClusterUpgradeDeltaHealthPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterUpgradeDeltaHealthPolicy)(nil)).Elem()
}

func (o ClusterUpgradeDeltaHealthPolicyOutput) ToClusterUpgradeDeltaHealthPolicyOutput() ClusterUpgradeDeltaHealthPolicyOutput {
	return o
}

func (o ClusterUpgradeDeltaHealthPolicyOutput) ToClusterUpgradeDeltaHealthPolicyOutputWithContext(ctx context.Context) ClusterUpgradeDeltaHealthPolicyOutput {
	return o
}

func (o ClusterUpgradeDeltaHealthPolicyOutput) ToClusterUpgradeDeltaHealthPolicyPtrOutput() ClusterUpgradeDeltaHealthPolicyPtrOutput {
	return o.ToClusterUpgradeDeltaHealthPolicyPtrOutputWithContext(context.Background())
}

func (o ClusterUpgradeDeltaHealthPolicyOutput) ToClusterUpgradeDeltaHealthPolicyPtrOutputWithContext(ctx context.Context) ClusterUpgradeDeltaHealthPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterUpgradeDeltaHealthPolicy) *ClusterUpgradeDeltaHealthPolicy {
		return &v
	}).(ClusterUpgradeDeltaHealthPolicyPtrOutput)
}

// The maximum allowed percentage of applications health degradation allowed during cluster upgrades.
// The delta is measured between the state of the applications at the beginning of upgrade and the state of the applications at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits. System services are not included in this.
// NOTE: This value will overwrite the value specified in properties.UpgradeDescription.HealthPolicy.MaxPercentUnhealthyApplications
func (o ClusterUpgradeDeltaHealthPolicyOutput) MaxPercentDeltaUnhealthyApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterUpgradeDeltaHealthPolicy) *int { return v.MaxPercentDeltaUnhealthyApplications }).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
// The delta is measured between the state of the nodes at the beginning of upgrade and the state of the nodes at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits.
func (o ClusterUpgradeDeltaHealthPolicyOutput) MaxPercentDeltaUnhealthyNodes() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterUpgradeDeltaHealthPolicy) int { return v.MaxPercentDeltaUnhealthyNodes }).(pulumi.IntOutput)
}

// The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades.
// The delta is measured between the state of the upgrade domain nodes at the beginning of upgrade and the state of the upgrade domain nodes at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion for all completed upgrade domains to make sure the state of the upgrade domains is within tolerated limits.
func (o ClusterUpgradeDeltaHealthPolicyOutput) MaxPercentUpgradeDomainDeltaUnhealthyNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterUpgradeDeltaHealthPolicy) *int { return v.MaxPercentUpgradeDomainDeltaUnhealthyNodes }).(pulumi.IntPtrOutput)
}

type ClusterUpgradeDeltaHealthPolicyPtrOutput struct{ *pulumi.OutputState }

func (ClusterUpgradeDeltaHealthPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterUpgradeDeltaHealthPolicy)(nil)).Elem()
}

func (o ClusterUpgradeDeltaHealthPolicyPtrOutput) ToClusterUpgradeDeltaHealthPolicyPtrOutput() ClusterUpgradeDeltaHealthPolicyPtrOutput {
	return o
}

func (o ClusterUpgradeDeltaHealthPolicyPtrOutput) ToClusterUpgradeDeltaHealthPolicyPtrOutputWithContext(ctx context.Context) ClusterUpgradeDeltaHealthPolicyPtrOutput {
	return o
}

func (o ClusterUpgradeDeltaHealthPolicyPtrOutput) Elem() ClusterUpgradeDeltaHealthPolicyOutput {
	return o.ApplyT(func(v *ClusterUpgradeDeltaHealthPolicy) ClusterUpgradeDeltaHealthPolicy {
		if v != nil {
			return *v
		}
		var ret ClusterUpgradeDeltaHealthPolicy
		return ret
	}).(ClusterUpgradeDeltaHealthPolicyOutput)
}

// The maximum allowed percentage of applications health degradation allowed during cluster upgrades.
// The delta is measured between the state of the applications at the beginning of upgrade and the state of the applications at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits. System services are not included in this.
// NOTE: This value will overwrite the value specified in properties.UpgradeDescription.HealthPolicy.MaxPercentUnhealthyApplications
func (o ClusterUpgradeDeltaHealthPolicyPtrOutput) MaxPercentDeltaUnhealthyApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradeDeltaHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return v.MaxPercentDeltaUnhealthyApplications
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
// The delta is measured between the state of the nodes at the beginning of upgrade and the state of the nodes at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits.
func (o ClusterUpgradeDeltaHealthPolicyPtrOutput) MaxPercentDeltaUnhealthyNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradeDeltaHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentDeltaUnhealthyNodes
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades.
// The delta is measured between the state of the upgrade domain nodes at the beginning of upgrade and the state of the upgrade domain nodes at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion for all completed upgrade domains to make sure the state of the upgrade domains is within tolerated limits.
func (o ClusterUpgradeDeltaHealthPolicyPtrOutput) MaxPercentUpgradeDomainDeltaUnhealthyNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradeDeltaHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return v.MaxPercentUpgradeDomainDeltaUnhealthyNodes
	}).(pulumi.IntPtrOutput)
}

// Describes the delta health policies for the cluster upgrade.
type ClusterUpgradeDeltaHealthPolicyResponse struct {
	// The maximum allowed percentage of applications health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the applications at the beginning of upgrade and the state of the applications at the time of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits. System services are not included in this.
	// NOTE: This value will overwrite the value specified in properties.UpgradeDescription.HealthPolicy.MaxPercentUnhealthyApplications
	MaxPercentDeltaUnhealthyApplications *int `pulumi:"maxPercentDeltaUnhealthyApplications"`
	// The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the nodes at the beginning of upgrade and the state of the nodes at the time of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits.
	MaxPercentDeltaUnhealthyNodes int `pulumi:"maxPercentDeltaUnhealthyNodes"`
	// The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades.
	// The delta is measured between the state of the upgrade domain nodes at the beginning of upgrade and the state of the upgrade domain nodes at the time of the health evaluation.
	// The check is performed after every upgrade domain upgrade completion for all completed upgrade domains to make sure the state of the upgrade domains is within tolerated limits.
	MaxPercentUpgradeDomainDeltaUnhealthyNodes *int `pulumi:"maxPercentUpgradeDomainDeltaUnhealthyNodes"`
}

// Describes the delta health policies for the cluster upgrade.
type ClusterUpgradeDeltaHealthPolicyResponseOutput struct{ *pulumi.OutputState }

func (ClusterUpgradeDeltaHealthPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterUpgradeDeltaHealthPolicyResponse)(nil)).Elem()
}

func (o ClusterUpgradeDeltaHealthPolicyResponseOutput) ToClusterUpgradeDeltaHealthPolicyResponseOutput() ClusterUpgradeDeltaHealthPolicyResponseOutput {
	return o
}

func (o ClusterUpgradeDeltaHealthPolicyResponseOutput) ToClusterUpgradeDeltaHealthPolicyResponseOutputWithContext(ctx context.Context) ClusterUpgradeDeltaHealthPolicyResponseOutput {
	return o
}

// The maximum allowed percentage of applications health degradation allowed during cluster upgrades.
// The delta is measured between the state of the applications at the beginning of upgrade and the state of the applications at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits. System services are not included in this.
// NOTE: This value will overwrite the value specified in properties.UpgradeDescription.HealthPolicy.MaxPercentUnhealthyApplications
func (o ClusterUpgradeDeltaHealthPolicyResponseOutput) MaxPercentDeltaUnhealthyApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterUpgradeDeltaHealthPolicyResponse) *int { return v.MaxPercentDeltaUnhealthyApplications }).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
// The delta is measured between the state of the nodes at the beginning of upgrade and the state of the nodes at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits.
func (o ClusterUpgradeDeltaHealthPolicyResponseOutput) MaxPercentDeltaUnhealthyNodes() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterUpgradeDeltaHealthPolicyResponse) int { return v.MaxPercentDeltaUnhealthyNodes }).(pulumi.IntOutput)
}

// The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades.
// The delta is measured between the state of the upgrade domain nodes at the beginning of upgrade and the state of the upgrade domain nodes at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion for all completed upgrade domains to make sure the state of the upgrade domains is within tolerated limits.
func (o ClusterUpgradeDeltaHealthPolicyResponseOutput) MaxPercentUpgradeDomainDeltaUnhealthyNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterUpgradeDeltaHealthPolicyResponse) *int {
		return v.MaxPercentUpgradeDomainDeltaUnhealthyNodes
	}).(pulumi.IntPtrOutput)
}

type ClusterUpgradeDeltaHealthPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ClusterUpgradeDeltaHealthPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterUpgradeDeltaHealthPolicyResponse)(nil)).Elem()
}

func (o ClusterUpgradeDeltaHealthPolicyResponsePtrOutput) ToClusterUpgradeDeltaHealthPolicyResponsePtrOutput() ClusterUpgradeDeltaHealthPolicyResponsePtrOutput {
	return o
}

func (o ClusterUpgradeDeltaHealthPolicyResponsePtrOutput) ToClusterUpgradeDeltaHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ClusterUpgradeDeltaHealthPolicyResponsePtrOutput {
	return o
}

func (o ClusterUpgradeDeltaHealthPolicyResponsePtrOutput) Elem() ClusterUpgradeDeltaHealthPolicyResponseOutput {
	return o.ApplyT(func(v *ClusterUpgradeDeltaHealthPolicyResponse) ClusterUpgradeDeltaHealthPolicyResponse {
		if v != nil {
			return *v
		}
		var ret ClusterUpgradeDeltaHealthPolicyResponse
		return ret
	}).(ClusterUpgradeDeltaHealthPolicyResponseOutput)
}

// The maximum allowed percentage of applications health degradation allowed during cluster upgrades.
// The delta is measured between the state of the applications at the beginning of upgrade and the state of the applications at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits. System services are not included in this.
// NOTE: This value will overwrite the value specified in properties.UpgradeDescription.HealthPolicy.MaxPercentUnhealthyApplications
func (o ClusterUpgradeDeltaHealthPolicyResponsePtrOutput) MaxPercentDeltaUnhealthyApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradeDeltaHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return v.MaxPercentDeltaUnhealthyApplications
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
// The delta is measured between the state of the nodes at the beginning of upgrade and the state of the nodes at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits.
func (o ClusterUpgradeDeltaHealthPolicyResponsePtrOutput) MaxPercentDeltaUnhealthyNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradeDeltaHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentDeltaUnhealthyNodes
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades.
// The delta is measured between the state of the upgrade domain nodes at the beginning of upgrade and the state of the upgrade domain nodes at the time of the health evaluation.
// The check is performed after every upgrade domain upgrade completion for all completed upgrade domains to make sure the state of the upgrade domains is within tolerated limits.
func (o ClusterUpgradeDeltaHealthPolicyResponsePtrOutput) MaxPercentUpgradeDomainDeltaUnhealthyNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradeDeltaHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return v.MaxPercentUpgradeDomainDeltaUnhealthyNodes
	}).(pulumi.IntPtrOutput)
}

// Describes the policy used when upgrading the cluster.
type ClusterUpgradePolicy struct {
	// The cluster delta health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
	DeltaHealthPolicy *ClusterUpgradeDeltaHealthPolicy `pulumi:"deltaHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart *bool `pulumi:"forceRestart"`
	// The cluster health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
	HealthPolicy *ClusterHealthPolicy `pulumi:"healthPolicy"`
	// The cluster monitoring policy describes the parameters for monitoring an upgrade in Monitored mode.
	MonitoringPolicy *ClusterMonitoringPolicy `pulumi:"monitoringPolicy"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues.
	// When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues.
	// The timeout is reset at the start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	// This value must be between 00:00:00 and 49710.06:28:15 (unsigned 32 bit integer for seconds)
	UpgradeReplicaSetCheckTimeout *string `pulumi:"upgradeReplicaSetCheckTimeout"`
}

// Defaults sets the appropriate defaults for ClusterUpgradePolicy
func (val *ClusterUpgradePolicy) Defaults() *ClusterUpgradePolicy {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.HealthPolicy = tmp.HealthPolicy.Defaults()

	return &tmp
}

// ClusterUpgradePolicyInput is an input type that accepts ClusterUpgradePolicyArgs and ClusterUpgradePolicyOutput values.
// You can construct a concrete instance of `ClusterUpgradePolicyInput` via:
//
//	ClusterUpgradePolicyArgs{...}
type ClusterUpgradePolicyInput interface {
	pulumi.Input

	ToClusterUpgradePolicyOutput() ClusterUpgradePolicyOutput
	ToClusterUpgradePolicyOutputWithContext(context.Context) ClusterUpgradePolicyOutput
}

// Describes the policy used when upgrading the cluster.
type ClusterUpgradePolicyArgs struct {
	// The cluster delta health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
	DeltaHealthPolicy ClusterUpgradeDeltaHealthPolicyPtrInput `pulumi:"deltaHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart pulumi.BoolPtrInput `pulumi:"forceRestart"`
	// The cluster health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
	HealthPolicy ClusterHealthPolicyPtrInput `pulumi:"healthPolicy"`
	// The cluster monitoring policy describes the parameters for monitoring an upgrade in Monitored mode.
	MonitoringPolicy ClusterMonitoringPolicyPtrInput `pulumi:"monitoringPolicy"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues.
	// When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues.
	// The timeout is reset at the start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	// This value must be between 00:00:00 and 49710.06:28:15 (unsigned 32 bit integer for seconds)
	UpgradeReplicaSetCheckTimeout pulumi.StringPtrInput `pulumi:"upgradeReplicaSetCheckTimeout"`
}

// Defaults sets the appropriate defaults for ClusterUpgradePolicyArgs
func (val *ClusterUpgradePolicyArgs) Defaults() *ClusterUpgradePolicyArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (ClusterUpgradePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterUpgradePolicy)(nil)).Elem()
}

func (i ClusterUpgradePolicyArgs) ToClusterUpgradePolicyOutput() ClusterUpgradePolicyOutput {
	return i.ToClusterUpgradePolicyOutputWithContext(context.Background())
}

func (i ClusterUpgradePolicyArgs) ToClusterUpgradePolicyOutputWithContext(ctx context.Context) ClusterUpgradePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterUpgradePolicyOutput)
}

func (i ClusterUpgradePolicyArgs) ToClusterUpgradePolicyPtrOutput() ClusterUpgradePolicyPtrOutput {
	return i.ToClusterUpgradePolicyPtrOutputWithContext(context.Background())
}

func (i ClusterUpgradePolicyArgs) ToClusterUpgradePolicyPtrOutputWithContext(ctx context.Context) ClusterUpgradePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterUpgradePolicyOutput).ToClusterUpgradePolicyPtrOutputWithContext(ctx)
}

// ClusterUpgradePolicyPtrInput is an input type that accepts ClusterUpgradePolicyArgs, ClusterUpgradePolicyPtr and ClusterUpgradePolicyPtrOutput values.
// You can construct a concrete instance of `ClusterUpgradePolicyPtrInput` via:
//
//	        ClusterUpgradePolicyArgs{...}
//
//	or:
//
//	        nil
type ClusterUpgradePolicyPtrInput interface {
	pulumi.Input

	ToClusterUpgradePolicyPtrOutput() ClusterUpgradePolicyPtrOutput
	ToClusterUpgradePolicyPtrOutputWithContext(context.Context) ClusterUpgradePolicyPtrOutput
}

type clusterUpgradePolicyPtrType ClusterUpgradePolicyArgs

func ClusterUpgradePolicyPtr(v *ClusterUpgradePolicyArgs) ClusterUpgradePolicyPtrInput {
	return (*clusterUpgradePolicyPtrType)(v)
}

func (*clusterUpgradePolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterUpgradePolicy)(nil)).Elem()
}

func (i *clusterUpgradePolicyPtrType) ToClusterUpgradePolicyPtrOutput() ClusterUpgradePolicyPtrOutput {
	return i.ToClusterUpgradePolicyPtrOutputWithContext(context.Background())
}

func (i *clusterUpgradePolicyPtrType) ToClusterUpgradePolicyPtrOutputWithContext(ctx context.Context) ClusterUpgradePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterUpgradePolicyPtrOutput)
}

// Describes the policy used when upgrading the cluster.
type ClusterUpgradePolicyOutput struct{ *pulumi.OutputState }

func (ClusterUpgradePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterUpgradePolicy)(nil)).Elem()
}

func (o ClusterUpgradePolicyOutput) ToClusterUpgradePolicyOutput() ClusterUpgradePolicyOutput {
	return o
}

func (o ClusterUpgradePolicyOutput) ToClusterUpgradePolicyOutputWithContext(ctx context.Context) ClusterUpgradePolicyOutput {
	return o
}

func (o ClusterUpgradePolicyOutput) ToClusterUpgradePolicyPtrOutput() ClusterUpgradePolicyPtrOutput {
	return o.ToClusterUpgradePolicyPtrOutputWithContext(context.Background())
}

func (o ClusterUpgradePolicyOutput) ToClusterUpgradePolicyPtrOutputWithContext(ctx context.Context) ClusterUpgradePolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterUpgradePolicy) *ClusterUpgradePolicy {
		return &v
	}).(ClusterUpgradePolicyPtrOutput)
}

// The cluster delta health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
func (o ClusterUpgradePolicyOutput) DeltaHealthPolicy() ClusterUpgradeDeltaHealthPolicyPtrOutput {
	return o.ApplyT(func(v ClusterUpgradePolicy) *ClusterUpgradeDeltaHealthPolicy { return v.DeltaHealthPolicy }).(ClusterUpgradeDeltaHealthPolicyPtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ClusterUpgradePolicyOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterUpgradePolicy) *bool { return v.ForceRestart }).(pulumi.BoolPtrOutput)
}

// The cluster health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
func (o ClusterUpgradePolicyOutput) HealthPolicy() ClusterHealthPolicyPtrOutput {
	return o.ApplyT(func(v ClusterUpgradePolicy) *ClusterHealthPolicy { return v.HealthPolicy }).(ClusterHealthPolicyPtrOutput)
}

// The cluster monitoring policy describes the parameters for monitoring an upgrade in Monitored mode.
func (o ClusterUpgradePolicyOutput) MonitoringPolicy() ClusterMonitoringPolicyPtrOutput {
	return o.ApplyT(func(v ClusterUpgradePolicy) *ClusterMonitoringPolicy { return v.MonitoringPolicy }).(ClusterMonitoringPolicyPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues.
// When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues.
// The timeout is reset at the start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
// This value must be between 00:00:00 and 49710.06:28:15 (unsigned 32 bit integer for seconds)
func (o ClusterUpgradePolicyOutput) UpgradeReplicaSetCheckTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterUpgradePolicy) *string { return v.UpgradeReplicaSetCheckTimeout }).(pulumi.StringPtrOutput)
}

type ClusterUpgradePolicyPtrOutput struct{ *pulumi.OutputState }

func (ClusterUpgradePolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterUpgradePolicy)(nil)).Elem()
}

func (o ClusterUpgradePolicyPtrOutput) ToClusterUpgradePolicyPtrOutput() ClusterUpgradePolicyPtrOutput {
	return o
}

func (o ClusterUpgradePolicyPtrOutput) ToClusterUpgradePolicyPtrOutputWithContext(ctx context.Context) ClusterUpgradePolicyPtrOutput {
	return o
}

func (o ClusterUpgradePolicyPtrOutput) Elem() ClusterUpgradePolicyOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicy) ClusterUpgradePolicy {
		if v != nil {
			return *v
		}
		var ret ClusterUpgradePolicy
		return ret
	}).(ClusterUpgradePolicyOutput)
}

// The cluster delta health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
func (o ClusterUpgradePolicyPtrOutput) DeltaHealthPolicy() ClusterUpgradeDeltaHealthPolicyPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicy) *ClusterUpgradeDeltaHealthPolicy {
		if v == nil {
			return nil
		}
		return v.DeltaHealthPolicy
	}).(ClusterUpgradeDeltaHealthPolicyPtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ClusterUpgradePolicyPtrOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.ForceRestart
	}).(pulumi.BoolPtrOutput)
}

// The cluster health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
func (o ClusterUpgradePolicyPtrOutput) HealthPolicy() ClusterHealthPolicyPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicy) *ClusterHealthPolicy {
		if v == nil {
			return nil
		}
		return v.HealthPolicy
	}).(ClusterHealthPolicyPtrOutput)
}

// The cluster monitoring policy describes the parameters for monitoring an upgrade in Monitored mode.
func (o ClusterUpgradePolicyPtrOutput) MonitoringPolicy() ClusterMonitoringPolicyPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicy) *ClusterMonitoringPolicy {
		if v == nil {
			return nil
		}
		return v.MonitoringPolicy
	}).(ClusterMonitoringPolicyPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues.
// When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues.
// The timeout is reset at the start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
// This value must be between 00:00:00 and 49710.06:28:15 (unsigned 32 bit integer for seconds)
func (o ClusterUpgradePolicyPtrOutput) UpgradeReplicaSetCheckTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicy) *string {
		if v == nil {
			return nil
		}
		return v.UpgradeReplicaSetCheckTimeout
	}).(pulumi.StringPtrOutput)
}

// Describes the policy used when upgrading the cluster.
type ClusterUpgradePolicyResponse struct {
	// The cluster delta health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
	DeltaHealthPolicy *ClusterUpgradeDeltaHealthPolicyResponse `pulumi:"deltaHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart *bool `pulumi:"forceRestart"`
	// The cluster health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
	HealthPolicy *ClusterHealthPolicyResponse `pulumi:"healthPolicy"`
	// The cluster monitoring policy describes the parameters for monitoring an upgrade in Monitored mode.
	MonitoringPolicy *ClusterMonitoringPolicyResponse `pulumi:"monitoringPolicy"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues.
	// When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues.
	// The timeout is reset at the start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
	// This value must be between 00:00:00 and 49710.06:28:15 (unsigned 32 bit integer for seconds)
	UpgradeReplicaSetCheckTimeout *string `pulumi:"upgradeReplicaSetCheckTimeout"`
}

// Defaults sets the appropriate defaults for ClusterUpgradePolicyResponse
func (val *ClusterUpgradePolicyResponse) Defaults() *ClusterUpgradePolicyResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.HealthPolicy = tmp.HealthPolicy.Defaults()

	return &tmp
}

// Describes the policy used when upgrading the cluster.
type ClusterUpgradePolicyResponseOutput struct{ *pulumi.OutputState }

func (ClusterUpgradePolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterUpgradePolicyResponse)(nil)).Elem()
}

func (o ClusterUpgradePolicyResponseOutput) ToClusterUpgradePolicyResponseOutput() ClusterUpgradePolicyResponseOutput {
	return o
}

func (o ClusterUpgradePolicyResponseOutput) ToClusterUpgradePolicyResponseOutputWithContext(ctx context.Context) ClusterUpgradePolicyResponseOutput {
	return o
}

// The cluster delta health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
func (o ClusterUpgradePolicyResponseOutput) DeltaHealthPolicy() ClusterUpgradeDeltaHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v ClusterUpgradePolicyResponse) *ClusterUpgradeDeltaHealthPolicyResponse {
		return v.DeltaHealthPolicy
	}).(ClusterUpgradeDeltaHealthPolicyResponsePtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ClusterUpgradePolicyResponseOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterUpgradePolicyResponse) *bool { return v.ForceRestart }).(pulumi.BoolPtrOutput)
}

// The cluster health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
func (o ClusterUpgradePolicyResponseOutput) HealthPolicy() ClusterHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v ClusterUpgradePolicyResponse) *ClusterHealthPolicyResponse { return v.HealthPolicy }).(ClusterHealthPolicyResponsePtrOutput)
}

// The cluster monitoring policy describes the parameters for monitoring an upgrade in Monitored mode.
func (o ClusterUpgradePolicyResponseOutput) MonitoringPolicy() ClusterMonitoringPolicyResponsePtrOutput {
	return o.ApplyT(func(v ClusterUpgradePolicyResponse) *ClusterMonitoringPolicyResponse { return v.MonitoringPolicy }).(ClusterMonitoringPolicyResponsePtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues.
// When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues.
// The timeout is reset at the start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
// This value must be between 00:00:00 and 49710.06:28:15 (unsigned 32 bit integer for seconds)
func (o ClusterUpgradePolicyResponseOutput) UpgradeReplicaSetCheckTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterUpgradePolicyResponse) *string { return v.UpgradeReplicaSetCheckTimeout }).(pulumi.StringPtrOutput)
}

type ClusterUpgradePolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ClusterUpgradePolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterUpgradePolicyResponse)(nil)).Elem()
}

func (o ClusterUpgradePolicyResponsePtrOutput) ToClusterUpgradePolicyResponsePtrOutput() ClusterUpgradePolicyResponsePtrOutput {
	return o
}

func (o ClusterUpgradePolicyResponsePtrOutput) ToClusterUpgradePolicyResponsePtrOutputWithContext(ctx context.Context) ClusterUpgradePolicyResponsePtrOutput {
	return o
}

func (o ClusterUpgradePolicyResponsePtrOutput) Elem() ClusterUpgradePolicyResponseOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicyResponse) ClusterUpgradePolicyResponse {
		if v != nil {
			return *v
		}
		var ret ClusterUpgradePolicyResponse
		return ret
	}).(ClusterUpgradePolicyResponseOutput)
}

// The cluster delta health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
func (o ClusterUpgradePolicyResponsePtrOutput) DeltaHealthPolicy() ClusterUpgradeDeltaHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicyResponse) *ClusterUpgradeDeltaHealthPolicyResponse {
		if v == nil {
			return nil
		}
		return v.DeltaHealthPolicy
	}).(ClusterUpgradeDeltaHealthPolicyResponsePtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ClusterUpgradePolicyResponsePtrOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicyResponse) *bool {
		if v == nil {
			return nil
		}
		return v.ForceRestart
	}).(pulumi.BoolPtrOutput)
}

// The cluster health policy defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
func (o ClusterUpgradePolicyResponsePtrOutput) HealthPolicy() ClusterHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicyResponse) *ClusterHealthPolicyResponse {
		if v == nil {
			return nil
		}
		return v.HealthPolicy
	}).(ClusterHealthPolicyResponsePtrOutput)
}

// The cluster monitoring policy describes the parameters for monitoring an upgrade in Monitored mode.
func (o ClusterUpgradePolicyResponsePtrOutput) MonitoringPolicy() ClusterMonitoringPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicyResponse) *ClusterMonitoringPolicyResponse {
		if v == nil {
			return nil
		}
		return v.MonitoringPolicy
	}).(ClusterMonitoringPolicyResponsePtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues.
// When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues.
// The timeout is reset at the start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
// This value must be between 00:00:00 and 49710.06:28:15 (unsigned 32 bit integer for seconds)
func (o ClusterUpgradePolicyResponsePtrOutput) UpgradeReplicaSetCheckTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterUpgradePolicyResponse) *string {
		if v == nil {
			return nil
		}
		return v.UpgradeReplicaSetCheckTimeout
	}).(pulumi.StringPtrOutput)
}

// Port range details
type EndpointRangeDescription struct {
	// End port of a range of ports
	EndPort int `pulumi:"endPort"`
	// Starting port of a range of ports
	StartPort int `pulumi:"startPort"`
}

// EndpointRangeDescriptionInput is an input type that accepts EndpointRangeDescriptionArgs and EndpointRangeDescriptionOutput values.
// You can construct a concrete instance of `EndpointRangeDescriptionInput` via:
//
//	EndpointRangeDescriptionArgs{...}
type EndpointRangeDescriptionInput interface {
	pulumi.Input

	ToEndpointRangeDescriptionOutput() EndpointRangeDescriptionOutput
	ToEndpointRangeDescriptionOutputWithContext(context.Context) EndpointRangeDescriptionOutput
}

// Port range details
type EndpointRangeDescriptionArgs struct {
	// End port of a range of ports
	EndPort pulumi.IntInput `pulumi:"endPort"`
	// Starting port of a range of ports
	StartPort pulumi.IntInput `pulumi:"startPort"`
}

func (EndpointRangeDescriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointRangeDescription)(nil)).Elem()
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionOutput() EndpointRangeDescriptionOutput {
	return i.ToEndpointRangeDescriptionOutputWithContext(context.Background())
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionOutputWithContext(ctx context.Context) EndpointRangeDescriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionOutput)
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return i.ToEndpointRangeDescriptionPtrOutputWithContext(context.Background())
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionOutput).ToEndpointRangeDescriptionPtrOutputWithContext(ctx)
}

// EndpointRangeDescriptionPtrInput is an input type that accepts EndpointRangeDescriptionArgs, EndpointRangeDescriptionPtr and EndpointRangeDescriptionPtrOutput values.
// You can construct a concrete instance of `EndpointRangeDescriptionPtrInput` via:
//
//	        EndpointRangeDescriptionArgs{...}
//
//	or:
//
//	        nil
type EndpointRangeDescriptionPtrInput interface {
	pulumi.Input

	ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput
	ToEndpointRangeDescriptionPtrOutputWithContext(context.Context) EndpointRangeDescriptionPtrOutput
}

type endpointRangeDescriptionPtrType EndpointRangeDescriptionArgs

func EndpointRangeDescriptionPtr(v *EndpointRangeDescriptionArgs) EndpointRangeDescriptionPtrInput {
	return (*endpointRangeDescriptionPtrType)(v)
}

func (*endpointRangeDescriptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointRangeDescription)(nil)).Elem()
}

func (i *endpointRangeDescriptionPtrType) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return i.ToEndpointRangeDescriptionPtrOutputWithContext(context.Background())
}

func (i *endpointRangeDescriptionPtrType) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionPtrOutput)
}

// Port range details
type EndpointRangeDescriptionOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointRangeDescription)(nil)).Elem()
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionOutput() EndpointRangeDescriptionOutput {
	return o
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionOutputWithContext(ctx context.Context) EndpointRangeDescriptionOutput {
	return o
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return o.ToEndpointRangeDescriptionPtrOutputWithContext(context.Background())
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EndpointRangeDescription) *EndpointRangeDescription {
		return &v
	}).(EndpointRangeDescriptionPtrOutput)
}

// End port of a range of ports
func (o EndpointRangeDescriptionOutput) EndPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescription) int { return v.EndPort }).(pulumi.IntOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionOutput) StartPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescription) int { return v.StartPort }).(pulumi.IntOutput)
}

type EndpointRangeDescriptionPtrOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointRangeDescription)(nil)).Elem()
}

func (o EndpointRangeDescriptionPtrOutput) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return o
}

func (o EndpointRangeDescriptionPtrOutput) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return o
}

func (o EndpointRangeDescriptionPtrOutput) Elem() EndpointRangeDescriptionOutput {
	return o.ApplyT(func(v *EndpointRangeDescription) EndpointRangeDescription {
		if v != nil {
			return *v
		}
		var ret EndpointRangeDescription
		return ret
	}).(EndpointRangeDescriptionOutput)
}

// End port of a range of ports
func (o EndpointRangeDescriptionPtrOutput) EndPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescription) *int {
		if v == nil {
			return nil
		}
		return &v.EndPort
	}).(pulumi.IntPtrOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionPtrOutput) StartPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescription) *int {
		if v == nil {
			return nil
		}
		return &v.StartPort
	}).(pulumi.IntPtrOutput)
}

// Port range details
type EndpointRangeDescriptionResponse struct {
	// End port of a range of ports
	EndPort int `pulumi:"endPort"`
	// Starting port of a range of ports
	StartPort int `pulumi:"startPort"`
}

// Port range details
type EndpointRangeDescriptionResponseOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointRangeDescriptionResponse)(nil)).Elem()
}

func (o EndpointRangeDescriptionResponseOutput) ToEndpointRangeDescriptionResponseOutput() EndpointRangeDescriptionResponseOutput {
	return o
}

func (o EndpointRangeDescriptionResponseOutput) ToEndpointRangeDescriptionResponseOutputWithContext(ctx context.Context) EndpointRangeDescriptionResponseOutput {
	return o
}

// End port of a range of ports
func (o EndpointRangeDescriptionResponseOutput) EndPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescriptionResponse) int { return v.EndPort }).(pulumi.IntOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionResponseOutput) StartPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescriptionResponse) int { return v.StartPort }).(pulumi.IntOutput)
}

type EndpointRangeDescriptionResponsePtrOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointRangeDescriptionResponse)(nil)).Elem()
}

func (o EndpointRangeDescriptionResponsePtrOutput) ToEndpointRangeDescriptionResponsePtrOutput() EndpointRangeDescriptionResponsePtrOutput {
	return o
}

func (o EndpointRangeDescriptionResponsePtrOutput) ToEndpointRangeDescriptionResponsePtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionResponsePtrOutput {
	return o
}

func (o EndpointRangeDescriptionResponsePtrOutput) Elem() EndpointRangeDescriptionResponseOutput {
	return o.ApplyT(func(v *EndpointRangeDescriptionResponse) EndpointRangeDescriptionResponse {
		if v != nil {
			return *v
		}
		var ret EndpointRangeDescriptionResponse
		return ret
	}).(EndpointRangeDescriptionResponseOutput)
}

// End port of a range of ports
func (o EndpointRangeDescriptionResponsePtrOutput) EndPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescriptionResponse) *int {
		if v == nil {
			return nil
		}
		return &v.EndPort
	}).(pulumi.IntPtrOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionResponsePtrOutput) StartPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescriptionResponse) *int {
		if v == nil {
			return nil
		}
		return &v.StartPort
	}).(pulumi.IntPtrOutput)
}

// Describes the frontend configurations for the node type.
type FrontendConfiguration struct {
	// The resource Id of application gateway backend address pool. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/applicationGateways/<applicationGatewayName>/backendAddressPools/<backendAddressPoolName>'.
	ApplicationGatewayBackendAddressPoolId *string `pulumi:"applicationGatewayBackendAddressPoolId"`
	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IpAddressType *string `pulumi:"ipAddressType"`
	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
	LoadBalancerBackendAddressPoolId *string `pulumi:"loadBalancerBackendAddressPoolId"`
	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
	LoadBalancerInboundNatPoolId *string `pulumi:"loadBalancerInboundNatPoolId"`
}

// FrontendConfigurationInput is an input type that accepts FrontendConfigurationArgs and FrontendConfigurationOutput values.
// You can construct a concrete instance of `FrontendConfigurationInput` via:
//
//	FrontendConfigurationArgs{...}
type FrontendConfigurationInput interface {
	pulumi.Input

	ToFrontendConfigurationOutput() FrontendConfigurationOutput
	ToFrontendConfigurationOutputWithContext(context.Context) FrontendConfigurationOutput
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationArgs struct {
	// The resource Id of application gateway backend address pool. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/applicationGateways/<applicationGatewayName>/backendAddressPools/<backendAddressPoolName>'.
	ApplicationGatewayBackendAddressPoolId pulumi.StringPtrInput `pulumi:"applicationGatewayBackendAddressPoolId"`
	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IpAddressType pulumi.StringPtrInput `pulumi:"ipAddressType"`
	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
	LoadBalancerBackendAddressPoolId pulumi.StringPtrInput `pulumi:"loadBalancerBackendAddressPoolId"`
	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
	LoadBalancerInboundNatPoolId pulumi.StringPtrInput `pulumi:"loadBalancerInboundNatPoolId"`
}

func (FrontendConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FrontendConfiguration)(nil)).Elem()
}

func (i FrontendConfigurationArgs) ToFrontendConfigurationOutput() FrontendConfigurationOutput {
	return i.ToFrontendConfigurationOutputWithContext(context.Background())
}

func (i FrontendConfigurationArgs) ToFrontendConfigurationOutputWithContext(ctx context.Context) FrontendConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FrontendConfigurationOutput)
}

// FrontendConfigurationArrayInput is an input type that accepts FrontendConfigurationArray and FrontendConfigurationArrayOutput values.
// You can construct a concrete instance of `FrontendConfigurationArrayInput` via:
//
//	FrontendConfigurationArray{ FrontendConfigurationArgs{...} }
type FrontendConfigurationArrayInput interface {
	pulumi.Input

	ToFrontendConfigurationArrayOutput() FrontendConfigurationArrayOutput
	ToFrontendConfigurationArrayOutputWithContext(context.Context) FrontendConfigurationArrayOutput
}

type FrontendConfigurationArray []FrontendConfigurationInput

func (FrontendConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FrontendConfiguration)(nil)).Elem()
}

func (i FrontendConfigurationArray) ToFrontendConfigurationArrayOutput() FrontendConfigurationArrayOutput {
	return i.ToFrontendConfigurationArrayOutputWithContext(context.Background())
}

func (i FrontendConfigurationArray) ToFrontendConfigurationArrayOutputWithContext(ctx context.Context) FrontendConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FrontendConfigurationArrayOutput)
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FrontendConfiguration)(nil)).Elem()
}

func (o FrontendConfigurationOutput) ToFrontendConfigurationOutput() FrontendConfigurationOutput {
	return o
}

func (o FrontendConfigurationOutput) ToFrontendConfigurationOutputWithContext(ctx context.Context) FrontendConfigurationOutput {
	return o
}

// The resource Id of application gateway backend address pool. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/applicationGateways/<applicationGatewayName>/backendAddressPools/<backendAddressPoolName>'.
func (o FrontendConfigurationOutput) ApplicationGatewayBackendAddressPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfiguration) *string { return v.ApplicationGatewayBackendAddressPoolId }).(pulumi.StringPtrOutput)
}

// The IP address type of this frontend configuration. If omitted the default value is IPv4.
func (o FrontendConfigurationOutput) IpAddressType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfiguration) *string { return v.IpAddressType }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
func (o FrontendConfigurationOutput) LoadBalancerBackendAddressPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfiguration) *string { return v.LoadBalancerBackendAddressPoolId }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
func (o FrontendConfigurationOutput) LoadBalancerInboundNatPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfiguration) *string { return v.LoadBalancerInboundNatPoolId }).(pulumi.StringPtrOutput)
}

type FrontendConfigurationArrayOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FrontendConfiguration)(nil)).Elem()
}

func (o FrontendConfigurationArrayOutput) ToFrontendConfigurationArrayOutput() FrontendConfigurationArrayOutput {
	return o
}

func (o FrontendConfigurationArrayOutput) ToFrontendConfigurationArrayOutputWithContext(ctx context.Context) FrontendConfigurationArrayOutput {
	return o
}

func (o FrontendConfigurationArrayOutput) Index(i pulumi.IntInput) FrontendConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FrontendConfiguration {
		return vs[0].([]FrontendConfiguration)[vs[1].(int)]
	}).(FrontendConfigurationOutput)
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationResponse struct {
	// The resource Id of application gateway backend address pool. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/applicationGateways/<applicationGatewayName>/backendAddressPools/<backendAddressPoolName>'.
	ApplicationGatewayBackendAddressPoolId *string `pulumi:"applicationGatewayBackendAddressPoolId"`
	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IpAddressType *string `pulumi:"ipAddressType"`
	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
	LoadBalancerBackendAddressPoolId *string `pulumi:"loadBalancerBackendAddressPoolId"`
	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
	LoadBalancerInboundNatPoolId *string `pulumi:"loadBalancerInboundNatPoolId"`
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationResponseOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FrontendConfigurationResponse)(nil)).Elem()
}

func (o FrontendConfigurationResponseOutput) ToFrontendConfigurationResponseOutput() FrontendConfigurationResponseOutput {
	return o
}

func (o FrontendConfigurationResponseOutput) ToFrontendConfigurationResponseOutputWithContext(ctx context.Context) FrontendConfigurationResponseOutput {
	return o
}

// The resource Id of application gateway backend address pool. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/applicationGateways/<applicationGatewayName>/backendAddressPools/<backendAddressPoolName>'.
func (o FrontendConfigurationResponseOutput) ApplicationGatewayBackendAddressPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfigurationResponse) *string { return v.ApplicationGatewayBackendAddressPoolId }).(pulumi.StringPtrOutput)
}

// The IP address type of this frontend configuration. If omitted the default value is IPv4.
func (o FrontendConfigurationResponseOutput) IpAddressType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfigurationResponse) *string { return v.IpAddressType }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
func (o FrontendConfigurationResponseOutput) LoadBalancerBackendAddressPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfigurationResponse) *string { return v.LoadBalancerBackendAddressPoolId }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
func (o FrontendConfigurationResponseOutput) LoadBalancerInboundNatPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfigurationResponse) *string { return v.LoadBalancerInboundNatPoolId }).(pulumi.StringPtrOutput)
}

type FrontendConfigurationResponseArrayOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FrontendConfigurationResponse)(nil)).Elem()
}

func (o FrontendConfigurationResponseArrayOutput) ToFrontendConfigurationResponseArrayOutput() FrontendConfigurationResponseArrayOutput {
	return o
}

func (o FrontendConfigurationResponseArrayOutput) ToFrontendConfigurationResponseArrayOutputWithContext(ctx context.Context) FrontendConfigurationResponseArrayOutput {
	return o
}

func (o FrontendConfigurationResponseArrayOutput) Index(i pulumi.IntInput) FrontendConfigurationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FrontendConfigurationResponse {
		return vs[0].([]FrontendConfigurationResponse)[vs[1].(int)]
	}).(FrontendConfigurationResponseOutput)
}

// Specifies an IP configuration of the network interface.
type IpConfiguration struct {
	// Specifies an array of references to backend address pools of application gateways. A node type can reference backend address pools of multiple application gateways. Multiple node types cannot use the same application gateway.
	ApplicationGatewayBackendAddressPools []SubResource `pulumi:"applicationGatewayBackendAddressPools"`
	// Specifies an array of references to backend address pools of load balancers. A node type can reference backend address pools of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
	LoadBalancerBackendAddressPools []SubResource `pulumi:"loadBalancerBackendAddressPools"`
	// Specifies an array of references to inbound Nat pools of the load balancers. A node type can reference inbound nat pools of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
	LoadBalancerInboundNatPools []SubResource `pulumi:"loadBalancerInboundNatPools"`
	// Name of the network interface.
	Name string `pulumi:"name"`
	// Specifies whether the IP configuration's private IP is IPv4 or IPv6. Default is IPv4.
	PrivateIPAddressVersion *string `pulumi:"privateIPAddressVersion"`
	// The public IP address configuration of the network interface.
	PublicIPAddressConfiguration *IpConfigurationPublicIPAddressConfiguration `pulumi:"publicIPAddressConfiguration"`
	// Specifies the subnet of the network interface.
	Subnet *SubResource `pulumi:"subnet"`
}

// Defaults sets the appropriate defaults for IpConfiguration
func (val *IpConfiguration) Defaults() *IpConfiguration {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.PrivateIPAddressVersion == nil {
		privateIPAddressVersion_ := "IPv4"
		tmp.PrivateIPAddressVersion = &privateIPAddressVersion_
	}
	tmp.PublicIPAddressConfiguration = tmp.PublicIPAddressConfiguration.Defaults()

	return &tmp
}

// IpConfigurationInput is an input type that accepts IpConfigurationArgs and IpConfigurationOutput values.
// You can construct a concrete instance of `IpConfigurationInput` via:
//
//	IpConfigurationArgs{...}
type IpConfigurationInput interface {
	pulumi.Input

	ToIpConfigurationOutput() IpConfigurationOutput
	ToIpConfigurationOutputWithContext(context.Context) IpConfigurationOutput
}

// Specifies an IP configuration of the network interface.
type IpConfigurationArgs struct {
	// Specifies an array of references to backend address pools of application gateways. A node type can reference backend address pools of multiple application gateways. Multiple node types cannot use the same application gateway.
	ApplicationGatewayBackendAddressPools SubResourceArrayInput `pulumi:"applicationGatewayBackendAddressPools"`
	// Specifies an array of references to backend address pools of load balancers. A node type can reference backend address pools of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
	LoadBalancerBackendAddressPools SubResourceArrayInput `pulumi:"loadBalancerBackendAddressPools"`
	// Specifies an array of references to inbound Nat pools of the load balancers. A node type can reference inbound nat pools of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
	LoadBalancerInboundNatPools SubResourceArrayInput `pulumi:"loadBalancerInboundNatPools"`
	// Name of the network interface.
	Name pulumi.StringInput `pulumi:"name"`
	// Specifies whether the IP configuration's private IP is IPv4 or IPv6. Default is IPv4.
	PrivateIPAddressVersion pulumi.StringPtrInput `pulumi:"privateIPAddressVersion"`
	// The public IP address configuration of the network interface.
	PublicIPAddressConfiguration IpConfigurationPublicIPAddressConfigurationPtrInput `pulumi:"publicIPAddressConfiguration"`
	// Specifies the subnet of the network interface.
	Subnet SubResourcePtrInput `pulumi:"subnet"`
}

// Defaults sets the appropriate defaults for IpConfigurationArgs
func (val *IpConfigurationArgs) Defaults() *IpConfigurationArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.PrivateIPAddressVersion == nil {
		tmp.PrivateIPAddressVersion = pulumi.StringPtr("IPv4")
	}

	return &tmp
}
func (IpConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IpConfiguration)(nil)).Elem()
}

func (i IpConfigurationArgs) ToIpConfigurationOutput() IpConfigurationOutput {
	return i.ToIpConfigurationOutputWithContext(context.Background())
}

func (i IpConfigurationArgs) ToIpConfigurationOutputWithContext(ctx context.Context) IpConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpConfigurationOutput)
}

// IpConfigurationArrayInput is an input type that accepts IpConfigurationArray and IpConfigurationArrayOutput values.
// You can construct a concrete instance of `IpConfigurationArrayInput` via:
//
//	IpConfigurationArray{ IpConfigurationArgs{...} }
type IpConfigurationArrayInput interface {
	pulumi.Input

	ToIpConfigurationArrayOutput() IpConfigurationArrayOutput
	ToIpConfigurationArrayOutputWithContext(context.Context) IpConfigurationArrayOutput
}

type IpConfigurationArray []IpConfigurationInput

func (IpConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IpConfiguration)(nil)).Elem()
}

func (i IpConfigurationArray) ToIpConfigurationArrayOutput() IpConfigurationArrayOutput {
	return i.ToIpConfigurationArrayOutputWithContext(context.Background())
}

func (i IpConfigurationArray) ToIpConfigurationArrayOutputWithContext(ctx context.Context) IpConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpConfigurationArrayOutput)
}

// Specifies an IP configuration of the network interface.
type IpConfigurationOutput struct{ *pulumi.OutputState }

func (IpConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IpConfiguration)(nil)).Elem()
}

func (o IpConfigurationOutput) ToIpConfigurationOutput() IpConfigurationOutput {
	return o
}

func (o IpConfigurationOutput) ToIpConfigurationOutputWithContext(ctx context.Context) IpConfigurationOutput {
	return o
}

// Specifies an array of references to backend address pools of application gateways. A node type can reference backend address pools of multiple application gateways. Multiple node types cannot use the same application gateway.
func (o IpConfigurationOutput) ApplicationGatewayBackendAddressPools() SubResourceArrayOutput {
	return o.ApplyT(func(v IpConfiguration) []SubResource { return v.ApplicationGatewayBackendAddressPools }).(SubResourceArrayOutput)
}

// Specifies an array of references to backend address pools of load balancers. A node type can reference backend address pools of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
func (o IpConfigurationOutput) LoadBalancerBackendAddressPools() SubResourceArrayOutput {
	return o.ApplyT(func(v IpConfiguration) []SubResource { return v.LoadBalancerBackendAddressPools }).(SubResourceArrayOutput)
}

// Specifies an array of references to inbound Nat pools of the load balancers. A node type can reference inbound nat pools of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
func (o IpConfigurationOutput) LoadBalancerInboundNatPools() SubResourceArrayOutput {
	return o.ApplyT(func(v IpConfiguration) []SubResource { return v.LoadBalancerInboundNatPools }).(SubResourceArrayOutput)
}

// Name of the network interface.
func (o IpConfigurationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v IpConfiguration) string { return v.Name }).(pulumi.StringOutput)
}

// Specifies whether the IP configuration's private IP is IPv4 or IPv6. Default is IPv4.
func (o IpConfigurationOutput) PrivateIPAddressVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IpConfiguration) *string { return v.PrivateIPAddressVersion }).(pulumi.StringPtrOutput)
}

// The public IP address configuration of the network interface.
func (o IpConfigurationOutput) PublicIPAddressConfiguration() IpConfigurationPublicIPAddressConfigurationPtrOutput {
	return o.ApplyT(func(v IpConfiguration) *IpConfigurationPublicIPAddressConfiguration {
		return v.PublicIPAddressConfiguration
	}).(IpConfigurationPublicIPAddressConfigurationPtrOutput)
}

// Specifies the subnet of the network interface.
func (o IpConfigurationOutput) Subnet() SubResourcePtrOutput {
	return o.ApplyT(func(v IpConfiguration) *SubResource { return v.Subnet }).(SubResourcePtrOutput)
}

type IpConfigurationArrayOutput struct{ *pulumi.OutputState }

func (IpConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IpConfiguration)(nil)).Elem()
}

func (o IpConfigurationArrayOutput) ToIpConfigurationArrayOutput() IpConfigurationArrayOutput {
	return o
}

func (o IpConfigurationArrayOutput) ToIpConfigurationArrayOutputWithContext(ctx context.Context) IpConfigurationArrayOutput {
	return o
}

func (o IpConfigurationArrayOutput) Index(i pulumi.IntInput) IpConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IpConfiguration {
		return vs[0].([]IpConfiguration)[vs[1].(int)]
	}).(IpConfigurationOutput)
}

// The public IP address configuration of the network interface.
type IpConfigurationPublicIPAddressConfiguration struct {
	// Specifies the list of IP tags associated with the public IP address.
	IpTags []IpTag `pulumi:"ipTags"`
	// Name of the network interface.
	Name string `pulumi:"name"`
	// Specifies whether the IP configuration's public IP is IPv4 or IPv6. Default is IPv4.
	PublicIPAddressVersion *string `pulumi:"publicIPAddressVersion"`
}

// Defaults sets the appropriate defaults for IpConfigurationPublicIPAddressConfiguration
func (val *IpConfigurationPublicIPAddressConfiguration) Defaults() *IpConfigurationPublicIPAddressConfiguration {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.PublicIPAddressVersion == nil {
		publicIPAddressVersion_ := "IPv4"
		tmp.PublicIPAddressVersion = &publicIPAddressVersion_
	}
	return &tmp
}

// IpConfigurationPublicIPAddressConfigurationInput is an input type that accepts IpConfigurationPublicIPAddressConfigurationArgs and IpConfigurationPublicIPAddressConfigurationOutput values.
// You can construct a concrete instance of `IpConfigurationPublicIPAddressConfigurationInput` via:
//
//	IpConfigurationPublicIPAddressConfigurationArgs{...}
type IpConfigurationPublicIPAddressConfigurationInput interface {
	pulumi.Input

	ToIpConfigurationPublicIPAddressConfigurationOutput() IpConfigurationPublicIPAddressConfigurationOutput
	ToIpConfigurationPublicIPAddressConfigurationOutputWithContext(context.Context) IpConfigurationPublicIPAddressConfigurationOutput
}

// The public IP address configuration of the network interface.
type IpConfigurationPublicIPAddressConfigurationArgs struct {
	// Specifies the list of IP tags associated with the public IP address.
	IpTags IpTagArrayInput `pulumi:"ipTags"`
	// Name of the network interface.
	Name pulumi.StringInput `pulumi:"name"`
	// Specifies whether the IP configuration's public IP is IPv4 or IPv6. Default is IPv4.
	PublicIPAddressVersion pulumi.StringPtrInput `pulumi:"publicIPAddressVersion"`
}

// Defaults sets the appropriate defaults for IpConfigurationPublicIPAddressConfigurationArgs
func (val *IpConfigurationPublicIPAddressConfigurationArgs) Defaults() *IpConfigurationPublicIPAddressConfigurationArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.PublicIPAddressVersion == nil {
		tmp.PublicIPAddressVersion = pulumi.StringPtr("IPv4")
	}
	return &tmp
}
func (IpConfigurationPublicIPAddressConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IpConfigurationPublicIPAddressConfiguration)(nil)).Elem()
}

func (i IpConfigurationPublicIPAddressConfigurationArgs) ToIpConfigurationPublicIPAddressConfigurationOutput() IpConfigurationPublicIPAddressConfigurationOutput {
	return i.ToIpConfigurationPublicIPAddressConfigurationOutputWithContext(context.Background())
}

func (i IpConfigurationPublicIPAddressConfigurationArgs) ToIpConfigurationPublicIPAddressConfigurationOutputWithContext(ctx context.Context) IpConfigurationPublicIPAddressConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpConfigurationPublicIPAddressConfigurationOutput)
}

func (i IpConfigurationPublicIPAddressConfigurationArgs) ToIpConfigurationPublicIPAddressConfigurationPtrOutput() IpConfigurationPublicIPAddressConfigurationPtrOutput {
	return i.ToIpConfigurationPublicIPAddressConfigurationPtrOutputWithContext(context.Background())
}

func (i IpConfigurationPublicIPAddressConfigurationArgs) ToIpConfigurationPublicIPAddressConfigurationPtrOutputWithContext(ctx context.Context) IpConfigurationPublicIPAddressConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpConfigurationPublicIPAddressConfigurationOutput).ToIpConfigurationPublicIPAddressConfigurationPtrOutputWithContext(ctx)
}

// IpConfigurationPublicIPAddressConfigurationPtrInput is an input type that accepts IpConfigurationPublicIPAddressConfigurationArgs, IpConfigurationPublicIPAddressConfigurationPtr and IpConfigurationPublicIPAddressConfigurationPtrOutput values.
// You can construct a concrete instance of `IpConfigurationPublicIPAddressConfigurationPtrInput` via:
//
//	        IpConfigurationPublicIPAddressConfigurationArgs{...}
//
//	or:
//
//	        nil
type IpConfigurationPublicIPAddressConfigurationPtrInput interface {
	pulumi.Input

	ToIpConfigurationPublicIPAddressConfigurationPtrOutput() IpConfigurationPublicIPAddressConfigurationPtrOutput
	ToIpConfigurationPublicIPAddressConfigurationPtrOutputWithContext(context.Context) IpConfigurationPublicIPAddressConfigurationPtrOutput
}

type ipConfigurationPublicIPAddressConfigurationPtrType IpConfigurationPublicIPAddressConfigurationArgs

func IpConfigurationPublicIPAddressConfigurationPtr(v *IpConfigurationPublicIPAddressConfigurationArgs) IpConfigurationPublicIPAddressConfigurationPtrInput {
	return (*ipConfigurationPublicIPAddressConfigurationPtrType)(v)
}

func (*ipConfigurationPublicIPAddressConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IpConfigurationPublicIPAddressConfiguration)(nil)).Elem()
}

func (i *ipConfigurationPublicIPAddressConfigurationPtrType) ToIpConfigurationPublicIPAddressConfigurationPtrOutput() IpConfigurationPublicIPAddressConfigurationPtrOutput {
	return i.ToIpConfigurationPublicIPAddressConfigurationPtrOutputWithContext(context.Background())
}

func (i *ipConfigurationPublicIPAddressConfigurationPtrType) ToIpConfigurationPublicIPAddressConfigurationPtrOutputWithContext(ctx context.Context) IpConfigurationPublicIPAddressConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpConfigurationPublicIPAddressConfigurationPtrOutput)
}

// The public IP address configuration of the network interface.
type IpConfigurationPublicIPAddressConfigurationOutput struct{ *pulumi.OutputState }

func (IpConfigurationPublicIPAddressConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IpConfigurationPublicIPAddressConfiguration)(nil)).Elem()
}

func (o IpConfigurationPublicIPAddressConfigurationOutput) ToIpConfigurationPublicIPAddressConfigurationOutput() IpConfigurationPublicIPAddressConfigurationOutput {
	return o
}

func (o IpConfigurationPublicIPAddressConfigurationOutput) ToIpConfigurationPublicIPAddressConfigurationOutputWithContext(ctx context.Context) IpConfigurationPublicIPAddressConfigurationOutput {
	return o
}

func (o IpConfigurationPublicIPAddressConfigurationOutput) ToIpConfigurationPublicIPAddressConfigurationPtrOutput() IpConfigurationPublicIPAddressConfigurationPtrOutput {
	return o.ToIpConfigurationPublicIPAddressConfigurationPtrOutputWithContext(context.Background())
}

func (o IpConfigurationPublicIPAddressConfigurationOutput) ToIpConfigurationPublicIPAddressConfigurationPtrOutputWithContext(ctx context.Context) IpConfigurationPublicIPAddressConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IpConfigurationPublicIPAddressConfiguration) *IpConfigurationPublicIPAddressConfiguration {
		return &v
	}).(IpConfigurationPublicIPAddressConfigurationPtrOutput)
}

// Specifies the list of IP tags associated with the public IP address.
func (o IpConfigurationPublicIPAddressConfigurationOutput) IpTags() IpTagArrayOutput {
	return o.ApplyT(func(v IpConfigurationPublicIPAddressConfiguration) []IpTag { return v.IpTags }).(IpTagArrayOutput)
}

// Name of the network interface.
func (o IpConfigurationPublicIPAddressConfigurationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v IpConfigurationPublicIPAddressConfiguration) string { return v.Name }).(pulumi.StringOutput)
}

// Specifies whether the IP configuration's public IP is IPv4 or IPv6. Default is IPv4.
func (o IpConfigurationPublicIPAddressConfigurationOutput) PublicIPAddressVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IpConfigurationPublicIPAddressConfiguration) *string { return v.PublicIPAddressVersion }).(pulumi.StringPtrOutput)
}

type IpConfigurationPublicIPAddressConfigurationPtrOutput struct{ *pulumi.OutputState }

func (IpConfigurationPublicIPAddressConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IpConfigurationPublicIPAddressConfiguration)(nil)).Elem()
}

func (o IpConfigurationPublicIPAddressConfigurationPtrOutput) ToIpConfigurationPublicIPAddressConfigurationPtrOutput() IpConfigurationPublicIPAddressConfigurationPtrOutput {
	return o
}

func (o IpConfigurationPublicIPAddressConfigurationPtrOutput) ToIpConfigurationPublicIPAddressConfigurationPtrOutputWithContext(ctx context.Context) IpConfigurationPublicIPAddressConfigurationPtrOutput {
	return o
}

func (o IpConfigurationPublicIPAddressConfigurationPtrOutput) Elem() IpConfigurationPublicIPAddressConfigurationOutput {
	return o.ApplyT(func(v *IpConfigurationPublicIPAddressConfiguration) IpConfigurationPublicIPAddressConfiguration {
		if v != nil {
			return *v
		}
		var ret IpConfigurationPublicIPAddressConfiguration
		return ret
	}).(IpConfigurationPublicIPAddressConfigurationOutput)
}

// Specifies the list of IP tags associated with the public IP address.
func (o IpConfigurationPublicIPAddressConfigurationPtrOutput) IpTags() IpTagArrayOutput {
	return o.ApplyT(func(v *IpConfigurationPublicIPAddressConfiguration) []IpTag {
		if v == nil {
			return nil
		}
		return v.IpTags
	}).(IpTagArrayOutput)
}

// Name of the network interface.
func (o IpConfigurationPublicIPAddressConfigurationPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpConfigurationPublicIPAddressConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Specifies whether the IP configuration's public IP is IPv4 or IPv6. Default is IPv4.
func (o IpConfigurationPublicIPAddressConfigurationPtrOutput) PublicIPAddressVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpConfigurationPublicIPAddressConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.PublicIPAddressVersion
	}).(pulumi.StringPtrOutput)
}

// Specifies an IP configuration of the network interface.
type IpConfigurationResponse struct {
	// Specifies an array of references to backend address pools of application gateways. A node type can reference backend address pools of multiple application gateways. Multiple node types cannot use the same application gateway.
	ApplicationGatewayBackendAddressPools []SubResourceResponse `pulumi:"applicationGatewayBackendAddressPools"`
	// Specifies an array of references to backend address pools of load balancers. A node type can reference backend address pools of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
	LoadBalancerBackendAddressPools []SubResourceResponse `pulumi:"loadBalancerBackendAddressPools"`
	// Specifies an array of references to inbound Nat pools of the load balancers. A node type can reference inbound nat pools of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
	LoadBalancerInboundNatPools []SubResourceResponse `pulumi:"loadBalancerInboundNatPools"`
	// Name of the network interface.
	Name string `pulumi:"name"`
	// Specifies whether the IP configuration's private IP is IPv4 or IPv6. Default is IPv4.
	PrivateIPAddressVersion *string `pulumi:"privateIPAddressVersion"`
	// The public IP address configuration of the network interface.
	PublicIPAddressConfiguration *IpConfigurationResponsePublicIPAddressConfiguration `pulumi:"publicIPAddressConfiguration"`
	// Specifies the subnet of the network interface.
	Subnet *SubResourceResponse `pulumi:"subnet"`
}

// Defaults sets the appropriate defaults for IpConfigurationResponse
func (val *IpConfigurationResponse) Defaults() *IpConfigurationResponse {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.PrivateIPAddressVersion == nil {
		privateIPAddressVersion_ := "IPv4"
		tmp.PrivateIPAddressVersion = &privateIPAddressVersion_
	}
	tmp.PublicIPAddressConfiguration = tmp.PublicIPAddressConfiguration.Defaults()

	return &tmp
}

// Specifies an IP configuration of the network interface.
type IpConfigurationResponseOutput struct{ *pulumi.OutputState }

func (IpConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IpConfigurationResponse)(nil)).Elem()
}

func (o IpConfigurationResponseOutput) ToIpConfigurationResponseOutput() IpConfigurationResponseOutput {
	return o
}

func (o IpConfigurationResponseOutput) ToIpConfigurationResponseOutputWithContext(ctx context.Context) IpConfigurationResponseOutput {
	return o
}

// Specifies an array of references to backend address pools of application gateways. A node type can reference backend address pools of multiple application gateways. Multiple node types cannot use the same application gateway.
func (o IpConfigurationResponseOutput) ApplicationGatewayBackendAddressPools() SubResourceResponseArrayOutput {
	return o.ApplyT(func(v IpConfigurationResponse) []SubResourceResponse { return v.ApplicationGatewayBackendAddressPools }).(SubResourceResponseArrayOutput)
}

// Specifies an array of references to backend address pools of load balancers. A node type can reference backend address pools of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
func (o IpConfigurationResponseOutput) LoadBalancerBackendAddressPools() SubResourceResponseArrayOutput {
	return o.ApplyT(func(v IpConfigurationResponse) []SubResourceResponse { return v.LoadBalancerBackendAddressPools }).(SubResourceResponseArrayOutput)
}

// Specifies an array of references to inbound Nat pools of the load balancers. A node type can reference inbound nat pools of one public and one internal load balancer. Multiple node types cannot use the same basic sku load balancer.
func (o IpConfigurationResponseOutput) LoadBalancerInboundNatPools() SubResourceResponseArrayOutput {
	return o.ApplyT(func(v IpConfigurationResponse) []SubResourceResponse { return v.LoadBalancerInboundNatPools }).(SubResourceResponseArrayOutput)
}

// Name of the network interface.
func (o IpConfigurationResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v IpConfigurationResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Specifies whether the IP configuration's private IP is IPv4 or IPv6. Default is IPv4.
func (o IpConfigurationResponseOutput) PrivateIPAddressVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IpConfigurationResponse) *string { return v.PrivateIPAddressVersion }).(pulumi.StringPtrOutput)
}

// The public IP address configuration of the network interface.
func (o IpConfigurationResponseOutput) PublicIPAddressConfiguration() IpConfigurationResponsePublicIPAddressConfigurationPtrOutput {
	return o.ApplyT(func(v IpConfigurationResponse) *IpConfigurationResponsePublicIPAddressConfiguration {
		return v.PublicIPAddressConfiguration
	}).(IpConfigurationResponsePublicIPAddressConfigurationPtrOutput)
}

// Specifies the subnet of the network interface.
func (o IpConfigurationResponseOutput) Subnet() SubResourceResponsePtrOutput {
	return o.ApplyT(func(v IpConfigurationResponse) *SubResourceResponse { return v.Subnet }).(SubResourceResponsePtrOutput)
}

type IpConfigurationResponseArrayOutput struct{ *pulumi.OutputState }

func (IpConfigurationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IpConfigurationResponse)(nil)).Elem()
}

func (o IpConfigurationResponseArrayOutput) ToIpConfigurationResponseArrayOutput() IpConfigurationResponseArrayOutput {
	return o
}

func (o IpConfigurationResponseArrayOutput) ToIpConfigurationResponseArrayOutputWithContext(ctx context.Context) IpConfigurationResponseArrayOutput {
	return o
}

func (o IpConfigurationResponseArrayOutput) Index(i pulumi.IntInput) IpConfigurationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IpConfigurationResponse {
		return vs[0].([]IpConfigurationResponse)[vs[1].(int)]
	}).(IpConfigurationResponseOutput)
}

// The public IP address configuration of the network interface.
type IpConfigurationResponsePublicIPAddressConfiguration struct {
	// Specifies the list of IP tags associated with the public IP address.
	IpTags []IpTagResponse `pulumi:"ipTags"`
	// Name of the network interface.
	Name string `pulumi:"name"`
	// Specifies whether the IP configuration's public IP is IPv4 or IPv6. Default is IPv4.
	PublicIPAddressVersion *string `pulumi:"publicIPAddressVersion"`
}

// Defaults sets the appropriate defaults for IpConfigurationResponsePublicIPAddressConfiguration
func (val *IpConfigurationResponsePublicIPAddressConfiguration) Defaults() *IpConfigurationResponsePublicIPAddressConfiguration {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.PublicIPAddressVersion == nil {
		publicIPAddressVersion_ := "IPv4"
		tmp.PublicIPAddressVersion = &publicIPAddressVersion_
	}
	return &tmp
}

// The public IP address configuration of the network interface.
type IpConfigurationResponsePublicIPAddressConfigurationOutput struct{ *pulumi.OutputState }

func (IpConfigurationResponsePublicIPAddressConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IpConfigurationResponsePublicIPAddressConfiguration)(nil)).Elem()
}

func (o IpConfigurationResponsePublicIPAddressConfigurationOutput) ToIpConfigurationResponsePublicIPAddressConfigurationOutput() IpConfigurationResponsePublicIPAddressConfigurationOutput {
	return o
}

func (o IpConfigurationResponsePublicIPAddressConfigurationOutput) ToIpConfigurationResponsePublicIPAddressConfigurationOutputWithContext(ctx context.Context) IpConfigurationResponsePublicIPAddressConfigurationOutput {
	return o
}

// Specifies the list of IP tags associated with the public IP address.
func (o IpConfigurationResponsePublicIPAddressConfigurationOutput) IpTags() IpTagResponseArrayOutput {
	return o.ApplyT(func(v IpConfigurationResponsePublicIPAddressConfiguration) []IpTagResponse { return v.IpTags }).(IpTagResponseArrayOutput)
}

// Name of the network interface.
func (o IpConfigurationResponsePublicIPAddressConfigurationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v IpConfigurationResponsePublicIPAddressConfiguration) string { return v.Name }).(pulumi.StringOutput)
}

// Specifies whether the IP configuration's public IP is IPv4 or IPv6. Default is IPv4.
func (o IpConfigurationResponsePublicIPAddressConfigurationOutput) PublicIPAddressVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IpConfigurationResponsePublicIPAddressConfiguration) *string { return v.PublicIPAddressVersion }).(pulumi.StringPtrOutput)
}

type IpConfigurationResponsePublicIPAddressConfigurationPtrOutput struct{ *pulumi.OutputState }

func (IpConfigurationResponsePublicIPAddressConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IpConfigurationResponsePublicIPAddressConfiguration)(nil)).Elem()
}

func (o IpConfigurationResponsePublicIPAddressConfigurationPtrOutput) ToIpConfigurationResponsePublicIPAddressConfigurationPtrOutput() IpConfigurationResponsePublicIPAddressConfigurationPtrOutput {
	return o
}

func (o IpConfigurationResponsePublicIPAddressConfigurationPtrOutput) ToIpConfigurationResponsePublicIPAddressConfigurationPtrOutputWithContext(ctx context.Context) IpConfigurationResponsePublicIPAddressConfigurationPtrOutput {
	return o
}

func (o IpConfigurationResponsePublicIPAddressConfigurationPtrOutput) Elem() IpConfigurationResponsePublicIPAddressConfigurationOutput {
	return o.ApplyT(func(v *IpConfigurationResponsePublicIPAddressConfiguration) IpConfigurationResponsePublicIPAddressConfiguration {
		if v != nil {
			return *v
		}
		var ret IpConfigurationResponsePublicIPAddressConfiguration
		return ret
	}).(IpConfigurationResponsePublicIPAddressConfigurationOutput)
}

// Specifies the list of IP tags associated with the public IP address.
func (o IpConfigurationResponsePublicIPAddressConfigurationPtrOutput) IpTags() IpTagResponseArrayOutput {
	return o.ApplyT(func(v *IpConfigurationResponsePublicIPAddressConfiguration) []IpTagResponse {
		if v == nil {
			return nil
		}
		return v.IpTags
	}).(IpTagResponseArrayOutput)
}

// Name of the network interface.
func (o IpConfigurationResponsePublicIPAddressConfigurationPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpConfigurationResponsePublicIPAddressConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Specifies whether the IP configuration's public IP is IPv4 or IPv6. Default is IPv4.
func (o IpConfigurationResponsePublicIPAddressConfigurationPtrOutput) PublicIPAddressVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpConfigurationResponsePublicIPAddressConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.PublicIPAddressVersion
	}).(pulumi.StringPtrOutput)
}

// The IP tag associated with the public IP address.
type IpTag struct {
	// IP tag type. Example: FirstPartyUsage.
	IpTagType string `pulumi:"ipTagType"`
	// IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag string `pulumi:"tag"`
}

// IpTagInput is an input type that accepts IpTagArgs and IpTagOutput values.
// You can construct a concrete instance of `IpTagInput` via:
//
//	IpTagArgs{...}
type IpTagInput interface {
	pulumi.Input

	ToIpTagOutput() IpTagOutput
	ToIpTagOutputWithContext(context.Context) IpTagOutput
}

// The IP tag associated with the public IP address.
type IpTagArgs struct {
	// IP tag type. Example: FirstPartyUsage.
	IpTagType pulumi.StringInput `pulumi:"ipTagType"`
	// IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag pulumi.StringInput `pulumi:"tag"`
}

func (IpTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IpTag)(nil)).Elem()
}

func (i IpTagArgs) ToIpTagOutput() IpTagOutput {
	return i.ToIpTagOutputWithContext(context.Background())
}

func (i IpTagArgs) ToIpTagOutputWithContext(ctx context.Context) IpTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpTagOutput)
}

// IpTagArrayInput is an input type that accepts IpTagArray and IpTagArrayOutput values.
// You can construct a concrete instance of `IpTagArrayInput` via:
//
//	IpTagArray{ IpTagArgs{...} }
type IpTagArrayInput interface {
	pulumi.Input

	ToIpTagArrayOutput() IpTagArrayOutput
	ToIpTagArrayOutputWithContext(context.Context) IpTagArrayOutput
}

type IpTagArray []IpTagInput

func (IpTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IpTag)(nil)).Elem()
}

func (i IpTagArray) ToIpTagArrayOutput() IpTagArrayOutput {
	return i.ToIpTagArrayOutputWithContext(context.Background())
}

func (i IpTagArray) ToIpTagArrayOutputWithContext(ctx context.Context) IpTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpTagArrayOutput)
}

// The IP tag associated with the public IP address.
type IpTagOutput struct{ *pulumi.OutputState }

func (IpTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IpTag)(nil)).Elem()
}

func (o IpTagOutput) ToIpTagOutput() IpTagOutput {
	return o
}

func (o IpTagOutput) ToIpTagOutputWithContext(ctx context.Context) IpTagOutput {
	return o
}

// IP tag type. Example: FirstPartyUsage.
func (o IpTagOutput) IpTagType() pulumi.StringOutput {
	return o.ApplyT(func(v IpTag) string { return v.IpTagType }).(pulumi.StringOutput)
}

// IP tag associated with the public IP. Example: SQL, Storage etc.
func (o IpTagOutput) Tag() pulumi.StringOutput {
	return o.ApplyT(func(v IpTag) string { return v.Tag }).(pulumi.StringOutput)
}

type IpTagArrayOutput struct{ *pulumi.OutputState }

func (IpTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IpTag)(nil)).Elem()
}

func (o IpTagArrayOutput) ToIpTagArrayOutput() IpTagArrayOutput {
	return o
}

func (o IpTagArrayOutput) ToIpTagArrayOutputWithContext(ctx context.Context) IpTagArrayOutput {
	return o
}

func (o IpTagArrayOutput) Index(i pulumi.IntInput) IpTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IpTag {
		return vs[0].([]IpTag)[vs[1].(int)]
	}).(IpTagOutput)
}

// The IP tag associated with the public IP address.
type IpTagResponse struct {
	// IP tag type. Example: FirstPartyUsage.
	IpTagType string `pulumi:"ipTagType"`
	// IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag string `pulumi:"tag"`
}

// The IP tag associated with the public IP address.
type IpTagResponseOutput struct{ *pulumi.OutputState }

func (IpTagResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IpTagResponse)(nil)).Elem()
}

func (o IpTagResponseOutput) ToIpTagResponseOutput() IpTagResponseOutput {
	return o
}

func (o IpTagResponseOutput) ToIpTagResponseOutputWithContext(ctx context.Context) IpTagResponseOutput {
	return o
}

// IP tag type. Example: FirstPartyUsage.
func (o IpTagResponseOutput) IpTagType() pulumi.StringOutput {
	return o.ApplyT(func(v IpTagResponse) string { return v.IpTagType }).(pulumi.StringOutput)
}

// IP tag associated with the public IP. Example: SQL, Storage etc.
func (o IpTagResponseOutput) Tag() pulumi.StringOutput {
	return o.ApplyT(func(v IpTagResponse) string { return v.Tag }).(pulumi.StringOutput)
}

type IpTagResponseArrayOutput struct{ *pulumi.OutputState }

func (IpTagResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IpTagResponse)(nil)).Elem()
}

func (o IpTagResponseArrayOutput) ToIpTagResponseArrayOutput() IpTagResponseArrayOutput {
	return o
}

func (o IpTagResponseArrayOutput) ToIpTagResponseArrayOutputWithContext(ctx context.Context) IpTagResponseArrayOutput {
	return o
}

func (o IpTagResponseArrayOutput) Index(i pulumi.IntInput) IpTagResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IpTagResponse {
		return vs[0].([]IpTagResponse)[vs[1].(int)]
	}).(IpTagResponseOutput)
}

// Describes a load balancing rule.
type LoadBalancingRule struct {
	// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort int `pulumi:"backendPort"`
	// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
	FrontendPort int `pulumi:"frontendPort"`
	// The load distribution policy for this rule.
	LoadDistribution *string `pulumi:"loadDistribution"`
	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort *int `pulumi:"probePort"`
	// the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol string `pulumi:"probeProtocol"`
	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath *string `pulumi:"probeRequestPath"`
	// The reference to the transport protocol used by the load balancing rule.
	Protocol string `pulumi:"protocol"`
}

// LoadBalancingRuleInput is an input type that accepts LoadBalancingRuleArgs and LoadBalancingRuleOutput values.
// You can construct a concrete instance of `LoadBalancingRuleInput` via:
//
//	LoadBalancingRuleArgs{...}
type LoadBalancingRuleInput interface {
	pulumi.Input

	ToLoadBalancingRuleOutput() LoadBalancingRuleOutput
	ToLoadBalancingRuleOutputWithContext(context.Context) LoadBalancingRuleOutput
}

// Describes a load balancing rule.
type LoadBalancingRuleArgs struct {
	// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort pulumi.IntInput `pulumi:"backendPort"`
	// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
	FrontendPort pulumi.IntInput `pulumi:"frontendPort"`
	// The load distribution policy for this rule.
	LoadDistribution pulumi.StringPtrInput `pulumi:"loadDistribution"`
	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort pulumi.IntPtrInput `pulumi:"probePort"`
	// the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol pulumi.StringInput `pulumi:"probeProtocol"`
	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath pulumi.StringPtrInput `pulumi:"probeRequestPath"`
	// The reference to the transport protocol used by the load balancing rule.
	Protocol pulumi.StringInput `pulumi:"protocol"`
}

func (LoadBalancingRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoadBalancingRule)(nil)).Elem()
}

func (i LoadBalancingRuleArgs) ToLoadBalancingRuleOutput() LoadBalancingRuleOutput {
	return i.ToLoadBalancingRuleOutputWithContext(context.Background())
}

func (i LoadBalancingRuleArgs) ToLoadBalancingRuleOutputWithContext(ctx context.Context) LoadBalancingRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancingRuleOutput)
}

// LoadBalancingRuleArrayInput is an input type that accepts LoadBalancingRuleArray and LoadBalancingRuleArrayOutput values.
// You can construct a concrete instance of `LoadBalancingRuleArrayInput` via:
//
//	LoadBalancingRuleArray{ LoadBalancingRuleArgs{...} }
type LoadBalancingRuleArrayInput interface {
	pulumi.Input

	ToLoadBalancingRuleArrayOutput() LoadBalancingRuleArrayOutput
	ToLoadBalancingRuleArrayOutputWithContext(context.Context) LoadBalancingRuleArrayOutput
}

type LoadBalancingRuleArray []LoadBalancingRuleInput

func (LoadBalancingRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoadBalancingRule)(nil)).Elem()
}

func (i LoadBalancingRuleArray) ToLoadBalancingRuleArrayOutput() LoadBalancingRuleArrayOutput {
	return i.ToLoadBalancingRuleArrayOutputWithContext(context.Background())
}

func (i LoadBalancingRuleArray) ToLoadBalancingRuleArrayOutputWithContext(ctx context.Context) LoadBalancingRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancingRuleArrayOutput)
}

// Describes a load balancing rule.
type LoadBalancingRuleOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoadBalancingRule)(nil)).Elem()
}

func (o LoadBalancingRuleOutput) ToLoadBalancingRuleOutput() LoadBalancingRuleOutput {
	return o
}

func (o LoadBalancingRuleOutput) ToLoadBalancingRuleOutputWithContext(ctx context.Context) LoadBalancingRuleOutput {
	return o
}

// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleOutput) BackendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRule) int { return v.BackendPort }).(pulumi.IntOutput)
}

// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
func (o LoadBalancingRuleOutput) FrontendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRule) int { return v.FrontendPort }).(pulumi.IntOutput)
}

// The load distribution policy for this rule.
func (o LoadBalancingRuleOutput) LoadDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancingRule) *string { return v.LoadDistribution }).(pulumi.StringPtrOutput)
}

// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleOutput) ProbePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LoadBalancingRule) *int { return v.ProbePort }).(pulumi.IntPtrOutput)
}

// the reference to the load balancer probe used by the load balancing rule.
func (o LoadBalancingRuleOutput) ProbeProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRule) string { return v.ProbeProtocol }).(pulumi.StringOutput)
}

// The probe request path. Only supported for HTTP/HTTPS probes.
func (o LoadBalancingRuleOutput) ProbeRequestPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancingRule) *string { return v.ProbeRequestPath }).(pulumi.StringPtrOutput)
}

// The reference to the transport protocol used by the load balancing rule.
func (o LoadBalancingRuleOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRule) string { return v.Protocol }).(pulumi.StringOutput)
}

type LoadBalancingRuleArrayOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoadBalancingRule)(nil)).Elem()
}

func (o LoadBalancingRuleArrayOutput) ToLoadBalancingRuleArrayOutput() LoadBalancingRuleArrayOutput {
	return o
}

func (o LoadBalancingRuleArrayOutput) ToLoadBalancingRuleArrayOutputWithContext(ctx context.Context) LoadBalancingRuleArrayOutput {
	return o
}

func (o LoadBalancingRuleArrayOutput) Index(i pulumi.IntInput) LoadBalancingRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LoadBalancingRule {
		return vs[0].([]LoadBalancingRule)[vs[1].(int)]
	}).(LoadBalancingRuleOutput)
}

// Describes a load balancing rule.
type LoadBalancingRuleResponse struct {
	// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort int `pulumi:"backendPort"`
	// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
	FrontendPort int `pulumi:"frontendPort"`
	// The load distribution policy for this rule.
	LoadDistribution *string `pulumi:"loadDistribution"`
	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort *int `pulumi:"probePort"`
	// the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol string `pulumi:"probeProtocol"`
	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath *string `pulumi:"probeRequestPath"`
	// The reference to the transport protocol used by the load balancing rule.
	Protocol string `pulumi:"protocol"`
}

// Describes a load balancing rule.
type LoadBalancingRuleResponseOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoadBalancingRuleResponse)(nil)).Elem()
}

func (o LoadBalancingRuleResponseOutput) ToLoadBalancingRuleResponseOutput() LoadBalancingRuleResponseOutput {
	return o
}

func (o LoadBalancingRuleResponseOutput) ToLoadBalancingRuleResponseOutputWithContext(ctx context.Context) LoadBalancingRuleResponseOutput {
	return o
}

// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleResponseOutput) BackendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) int { return v.BackendPort }).(pulumi.IntOutput)
}

// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
func (o LoadBalancingRuleResponseOutput) FrontendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) int { return v.FrontendPort }).(pulumi.IntOutput)
}

// The load distribution policy for this rule.
func (o LoadBalancingRuleResponseOutput) LoadDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) *string { return v.LoadDistribution }).(pulumi.StringPtrOutput)
}

// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleResponseOutput) ProbePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) *int { return v.ProbePort }).(pulumi.IntPtrOutput)
}

// the reference to the load balancer probe used by the load balancing rule.
func (o LoadBalancingRuleResponseOutput) ProbeProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) string { return v.ProbeProtocol }).(pulumi.StringOutput)
}

// The probe request path. Only supported for HTTP/HTTPS probes.
func (o LoadBalancingRuleResponseOutput) ProbeRequestPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) *string { return v.ProbeRequestPath }).(pulumi.StringPtrOutput)
}

// The reference to the transport protocol used by the load balancing rule.
func (o LoadBalancingRuleResponseOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) string { return v.Protocol }).(pulumi.StringOutput)
}

type LoadBalancingRuleResponseArrayOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoadBalancingRuleResponse)(nil)).Elem()
}

func (o LoadBalancingRuleResponseArrayOutput) ToLoadBalancingRuleResponseArrayOutput() LoadBalancingRuleResponseArrayOutput {
	return o
}

func (o LoadBalancingRuleResponseArrayOutput) ToLoadBalancingRuleResponseArrayOutputWithContext(ctx context.Context) LoadBalancingRuleResponseArrayOutput {
	return o
}

func (o LoadBalancingRuleResponseArrayOutput) Index(i pulumi.IntInput) LoadBalancingRuleResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LoadBalancingRuleResponse {
		return vs[0].([]LoadBalancingRuleResponse)[vs[1].(int)]
	}).(LoadBalancingRuleResponseOutput)
}

// Describes the managed identities for an Azure resource.
type ManagedIdentity struct {
	// The type of managed identity for the resource.
	Type *ManagedIdentityType `pulumi:"type"`
	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []string `pulumi:"userAssignedIdentities"`
}

// ManagedIdentityInput is an input type that accepts ManagedIdentityArgs and ManagedIdentityOutput values.
// You can construct a concrete instance of `ManagedIdentityInput` via:
//
//	ManagedIdentityArgs{...}
type ManagedIdentityInput interface {
	pulumi.Input

	ToManagedIdentityOutput() ManagedIdentityOutput
	ToManagedIdentityOutputWithContext(context.Context) ManagedIdentityOutput
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityArgs struct {
	// The type of managed identity for the resource.
	Type ManagedIdentityTypePtrInput `pulumi:"type"`
	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities pulumi.StringArrayInput `pulumi:"userAssignedIdentities"`
}

func (ManagedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedIdentity)(nil)).Elem()
}

func (i ManagedIdentityArgs) ToManagedIdentityOutput() ManagedIdentityOutput {
	return i.ToManagedIdentityOutputWithContext(context.Background())
}

func (i ManagedIdentityArgs) ToManagedIdentityOutputWithContext(ctx context.Context) ManagedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityOutput)
}

func (i ManagedIdentityArgs) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return i.ToManagedIdentityPtrOutputWithContext(context.Background())
}

func (i ManagedIdentityArgs) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityOutput).ToManagedIdentityPtrOutputWithContext(ctx)
}

// ManagedIdentityPtrInput is an input type that accepts ManagedIdentityArgs, ManagedIdentityPtr and ManagedIdentityPtrOutput values.
// You can construct a concrete instance of `ManagedIdentityPtrInput` via:
//
//	        ManagedIdentityArgs{...}
//
//	or:
//
//	        nil
type ManagedIdentityPtrInput interface {
	pulumi.Input

	ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput
	ToManagedIdentityPtrOutputWithContext(context.Context) ManagedIdentityPtrOutput
}

type managedIdentityPtrType ManagedIdentityArgs

func ManagedIdentityPtr(v *ManagedIdentityArgs) ManagedIdentityPtrInput {
	return (*managedIdentityPtrType)(v)
}

func (*managedIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedIdentity)(nil)).Elem()
}

func (i *managedIdentityPtrType) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return i.ToManagedIdentityPtrOutputWithContext(context.Background())
}

func (i *managedIdentityPtrType) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityPtrOutput)
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityOutput struct{ *pulumi.OutputState }

func (ManagedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedIdentity)(nil)).Elem()
}

func (o ManagedIdentityOutput) ToManagedIdentityOutput() ManagedIdentityOutput {
	return o
}

func (o ManagedIdentityOutput) ToManagedIdentityOutputWithContext(ctx context.Context) ManagedIdentityOutput {
	return o
}

func (o ManagedIdentityOutput) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return o.ToManagedIdentityPtrOutputWithContext(context.Background())
}

func (o ManagedIdentityOutput) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ManagedIdentity) *ManagedIdentity {
		return &v
	}).(ManagedIdentityPtrOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityOutput) Type() ManagedIdentityTypePtrOutput {
	return o.ApplyT(func(v ManagedIdentity) *ManagedIdentityType { return v.Type }).(ManagedIdentityTypePtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ManagedIdentity) []string { return v.UserAssignedIdentities }).(pulumi.StringArrayOutput)
}

type ManagedIdentityPtrOutput struct{ *pulumi.OutputState }

func (ManagedIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedIdentity)(nil)).Elem()
}

func (o ManagedIdentityPtrOutput) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return o
}

func (o ManagedIdentityPtrOutput) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return o
}

func (o ManagedIdentityPtrOutput) Elem() ManagedIdentityOutput {
	return o.ApplyT(func(v *ManagedIdentity) ManagedIdentity {
		if v != nil {
			return *v
		}
		var ret ManagedIdentity
		return ret
	}).(ManagedIdentityOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityPtrOutput) Type() ManagedIdentityTypePtrOutput {
	return o.ApplyT(func(v *ManagedIdentity) *ManagedIdentityType {
		if v == nil {
			return nil
		}
		return v.Type
	}).(ManagedIdentityTypePtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityPtrOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ManagedIdentity) []string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.StringArrayOutput)
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityResponse struct {
	// The principal id of the managed identity. This property will only be provided for a system assigned identity.
	PrincipalId string `pulumi:"principalId"`
	// The tenant id of the managed identity. This property will only be provided for a system assigned identity.
	TenantId string `pulumi:"tenantId"`
	// The type of managed identity for the resource.
	Type *string `pulumi:"type"`
	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]UserAssignedIdentityResponse `pulumi:"userAssignedIdentities"`
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityResponseOutput struct{ *pulumi.OutputState }

func (ManagedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedIdentityResponse)(nil)).Elem()
}

func (o ManagedIdentityResponseOutput) ToManagedIdentityResponseOutput() ManagedIdentityResponseOutput {
	return o
}

func (o ManagedIdentityResponseOutput) ToManagedIdentityResponseOutputWithContext(ctx context.Context) ManagedIdentityResponseOutput {
	return o
}

// The principal id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

// The tenant id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponseOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) string { return v.TenantId }).(pulumi.StringOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityResponseOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityResponseOutput) UserAssignedIdentities() UserAssignedIdentityResponseMapOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) map[string]UserAssignedIdentityResponse {
		return v.UserAssignedIdentities
	}).(UserAssignedIdentityResponseMapOutput)
}

type ManagedIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (ManagedIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedIdentityResponse)(nil)).Elem()
}

func (o ManagedIdentityResponsePtrOutput) ToManagedIdentityResponsePtrOutput() ManagedIdentityResponsePtrOutput {
	return o
}

func (o ManagedIdentityResponsePtrOutput) ToManagedIdentityResponsePtrOutputWithContext(ctx context.Context) ManagedIdentityResponsePtrOutput {
	return o
}

func (o ManagedIdentityResponsePtrOutput) Elem() ManagedIdentityResponseOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) ManagedIdentityResponse {
		if v != nil {
			return *v
		}
		var ret ManagedIdentityResponse
		return ret
	}).(ManagedIdentityResponseOutput)
}

// The principal id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponsePtrOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PrincipalId
	}).(pulumi.StringPtrOutput)
}

// The tenant id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponsePtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TenantId
	}).(pulumi.StringPtrOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityResponsePtrOutput) UserAssignedIdentities() UserAssignedIdentityResponseMapOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) map[string]UserAssignedIdentityResponse {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(UserAssignedIdentityResponseMapOutput)
}

// Describes the named partition scheme of the service.
type NamedPartitionScheme struct {
	// Array for the names of the partitions.
	Names []string `pulumi:"names"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Named'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// NamedPartitionSchemeInput is an input type that accepts NamedPartitionSchemeArgs and NamedPartitionSchemeOutput values.
// You can construct a concrete instance of `NamedPartitionSchemeInput` via:
//
//	NamedPartitionSchemeArgs{...}
type NamedPartitionSchemeInput interface {
	pulumi.Input

	ToNamedPartitionSchemeOutput() NamedPartitionSchemeOutput
	ToNamedPartitionSchemeOutputWithContext(context.Context) NamedPartitionSchemeOutput
}

// Describes the named partition scheme of the service.
type NamedPartitionSchemeArgs struct {
	// Array for the names of the partitions.
	Names pulumi.StringArrayInput `pulumi:"names"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Named'.
	PartitionScheme pulumi.StringInput `pulumi:"partitionScheme"`
}

func (NamedPartitionSchemeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamedPartitionScheme)(nil)).Elem()
}

func (i NamedPartitionSchemeArgs) ToNamedPartitionSchemeOutput() NamedPartitionSchemeOutput {
	return i.ToNamedPartitionSchemeOutputWithContext(context.Background())
}

func (i NamedPartitionSchemeArgs) ToNamedPartitionSchemeOutputWithContext(ctx context.Context) NamedPartitionSchemeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamedPartitionSchemeOutput)
}

func (i NamedPartitionSchemeArgs) ToNamedPartitionSchemePtrOutput() NamedPartitionSchemePtrOutput {
	return i.ToNamedPartitionSchemePtrOutputWithContext(context.Background())
}

func (i NamedPartitionSchemeArgs) ToNamedPartitionSchemePtrOutputWithContext(ctx context.Context) NamedPartitionSchemePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamedPartitionSchemeOutput).ToNamedPartitionSchemePtrOutputWithContext(ctx)
}

// NamedPartitionSchemePtrInput is an input type that accepts NamedPartitionSchemeArgs, NamedPartitionSchemePtr and NamedPartitionSchemePtrOutput values.
// You can construct a concrete instance of `NamedPartitionSchemePtrInput` via:
//
//	        NamedPartitionSchemeArgs{...}
//
//	or:
//
//	        nil
type NamedPartitionSchemePtrInput interface {
	pulumi.Input

	ToNamedPartitionSchemePtrOutput() NamedPartitionSchemePtrOutput
	ToNamedPartitionSchemePtrOutputWithContext(context.Context) NamedPartitionSchemePtrOutput
}

type namedPartitionSchemePtrType NamedPartitionSchemeArgs

func NamedPartitionSchemePtr(v *NamedPartitionSchemeArgs) NamedPartitionSchemePtrInput {
	return (*namedPartitionSchemePtrType)(v)
}

func (*namedPartitionSchemePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NamedPartitionScheme)(nil)).Elem()
}

func (i *namedPartitionSchemePtrType) ToNamedPartitionSchemePtrOutput() NamedPartitionSchemePtrOutput {
	return i.ToNamedPartitionSchemePtrOutputWithContext(context.Background())
}

func (i *namedPartitionSchemePtrType) ToNamedPartitionSchemePtrOutputWithContext(ctx context.Context) NamedPartitionSchemePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamedPartitionSchemePtrOutput)
}

// Describes the named partition scheme of the service.
type NamedPartitionSchemeOutput struct{ *pulumi.OutputState }

func (NamedPartitionSchemeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamedPartitionScheme)(nil)).Elem()
}

func (o NamedPartitionSchemeOutput) ToNamedPartitionSchemeOutput() NamedPartitionSchemeOutput {
	return o
}

func (o NamedPartitionSchemeOutput) ToNamedPartitionSchemeOutputWithContext(ctx context.Context) NamedPartitionSchemeOutput {
	return o
}

func (o NamedPartitionSchemeOutput) ToNamedPartitionSchemePtrOutput() NamedPartitionSchemePtrOutput {
	return o.ToNamedPartitionSchemePtrOutputWithContext(context.Background())
}

func (o NamedPartitionSchemeOutput) ToNamedPartitionSchemePtrOutputWithContext(ctx context.Context) NamedPartitionSchemePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NamedPartitionScheme) *NamedPartitionScheme {
		return &v
	}).(NamedPartitionSchemePtrOutput)
}

// Array for the names of the partitions.
func (o NamedPartitionSchemeOutput) Names() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NamedPartitionScheme) []string { return v.Names }).(pulumi.StringArrayOutput)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'Named'.
func (o NamedPartitionSchemeOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v NamedPartitionScheme) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

type NamedPartitionSchemePtrOutput struct{ *pulumi.OutputState }

func (NamedPartitionSchemePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamedPartitionScheme)(nil)).Elem()
}

func (o NamedPartitionSchemePtrOutput) ToNamedPartitionSchemePtrOutput() NamedPartitionSchemePtrOutput {
	return o
}

func (o NamedPartitionSchemePtrOutput) ToNamedPartitionSchemePtrOutputWithContext(ctx context.Context) NamedPartitionSchemePtrOutput {
	return o
}

func (o NamedPartitionSchemePtrOutput) Elem() NamedPartitionSchemeOutput {
	return o.ApplyT(func(v *NamedPartitionScheme) NamedPartitionScheme {
		if v != nil {
			return *v
		}
		var ret NamedPartitionScheme
		return ret
	}).(NamedPartitionSchemeOutput)
}

// Array for the names of the partitions.
func (o NamedPartitionSchemePtrOutput) Names() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NamedPartitionScheme) []string {
		if v == nil {
			return nil
		}
		return v.Names
	}).(pulumi.StringArrayOutput)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'Named'.
func (o NamedPartitionSchemePtrOutput) PartitionScheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NamedPartitionScheme) *string {
		if v == nil {
			return nil
		}
		return &v.PartitionScheme
	}).(pulumi.StringPtrOutput)
}

// Describes the named partition scheme of the service.
type NamedPartitionSchemeResponse struct {
	// Array for the names of the partitions.
	Names []string `pulumi:"names"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Named'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// Describes the named partition scheme of the service.
type NamedPartitionSchemeResponseOutput struct{ *pulumi.OutputState }

func (NamedPartitionSchemeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamedPartitionSchemeResponse)(nil)).Elem()
}

func (o NamedPartitionSchemeResponseOutput) ToNamedPartitionSchemeResponseOutput() NamedPartitionSchemeResponseOutput {
	return o
}

func (o NamedPartitionSchemeResponseOutput) ToNamedPartitionSchemeResponseOutputWithContext(ctx context.Context) NamedPartitionSchemeResponseOutput {
	return o
}

// Array for the names of the partitions.
func (o NamedPartitionSchemeResponseOutput) Names() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NamedPartitionSchemeResponse) []string { return v.Names }).(pulumi.StringArrayOutput)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'Named'.
func (o NamedPartitionSchemeResponseOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v NamedPartitionSchemeResponse) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

// Describes a network security rule.
type NetworkSecurityRule struct {
	// The network traffic is allowed or denied.
	Access string `pulumi:"access"`
	// Network security rule description.
	Description *string `pulumi:"description"`
	// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
	DestinationAddressPrefix *string `pulumi:"destinationAddressPrefix"`
	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes []string `pulumi:"destinationAddressPrefixes"`
	// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	DestinationPortRange *string `pulumi:"destinationPortRange"`
	// The destination port ranges.
	DestinationPortRanges []string `pulumi:"destinationPortRanges"`
	// Network security rule direction.
	Direction string `pulumi:"direction"`
	// Network security rule name.
	Name string `pulumi:"name"`
	// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority int `pulumi:"priority"`
	// Network protocol this rule applies to.
	Protocol string `pulumi:"protocol"`
	// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
	SourceAddressPrefix *string `pulumi:"sourceAddressPrefix"`
	// The CIDR or source IP ranges.
	SourceAddressPrefixes []string `pulumi:"sourceAddressPrefixes"`
	// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	SourcePortRange *string `pulumi:"sourcePortRange"`
	// The source port ranges.
	SourcePortRanges []string `pulumi:"sourcePortRanges"`
}

// NetworkSecurityRuleInput is an input type that accepts NetworkSecurityRuleArgs and NetworkSecurityRuleOutput values.
// You can construct a concrete instance of `NetworkSecurityRuleInput` via:
//
//	NetworkSecurityRuleArgs{...}
type NetworkSecurityRuleInput interface {
	pulumi.Input

	ToNetworkSecurityRuleOutput() NetworkSecurityRuleOutput
	ToNetworkSecurityRuleOutputWithContext(context.Context) NetworkSecurityRuleOutput
}

// Describes a network security rule.
type NetworkSecurityRuleArgs struct {
	// The network traffic is allowed or denied.
	Access pulumi.StringInput `pulumi:"access"`
	// Network security rule description.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
	DestinationAddressPrefix pulumi.StringPtrInput `pulumi:"destinationAddressPrefix"`
	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes pulumi.StringArrayInput `pulumi:"destinationAddressPrefixes"`
	// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	DestinationPortRange pulumi.StringPtrInput `pulumi:"destinationPortRange"`
	// The destination port ranges.
	DestinationPortRanges pulumi.StringArrayInput `pulumi:"destinationPortRanges"`
	// Network security rule direction.
	Direction pulumi.StringInput `pulumi:"direction"`
	// Network security rule name.
	Name pulumi.StringInput `pulumi:"name"`
	// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority pulumi.IntInput `pulumi:"priority"`
	// Network protocol this rule applies to.
	Protocol pulumi.StringInput `pulumi:"protocol"`
	// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
	SourceAddressPrefix pulumi.StringPtrInput `pulumi:"sourceAddressPrefix"`
	// The CIDR or source IP ranges.
	SourceAddressPrefixes pulumi.StringArrayInput `pulumi:"sourceAddressPrefixes"`
	// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	SourcePortRange pulumi.StringPtrInput `pulumi:"sourcePortRange"`
	// The source port ranges.
	SourcePortRanges pulumi.StringArrayInput `pulumi:"sourcePortRanges"`
}

func (NetworkSecurityRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkSecurityRule)(nil)).Elem()
}

func (i NetworkSecurityRuleArgs) ToNetworkSecurityRuleOutput() NetworkSecurityRuleOutput {
	return i.ToNetworkSecurityRuleOutputWithContext(context.Background())
}

func (i NetworkSecurityRuleArgs) ToNetworkSecurityRuleOutputWithContext(ctx context.Context) NetworkSecurityRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkSecurityRuleOutput)
}

// NetworkSecurityRuleArrayInput is an input type that accepts NetworkSecurityRuleArray and NetworkSecurityRuleArrayOutput values.
// You can construct a concrete instance of `NetworkSecurityRuleArrayInput` via:
//
//	NetworkSecurityRuleArray{ NetworkSecurityRuleArgs{...} }
type NetworkSecurityRuleArrayInput interface {
	pulumi.Input

	ToNetworkSecurityRuleArrayOutput() NetworkSecurityRuleArrayOutput
	ToNetworkSecurityRuleArrayOutputWithContext(context.Context) NetworkSecurityRuleArrayOutput
}

type NetworkSecurityRuleArray []NetworkSecurityRuleInput

func (NetworkSecurityRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkSecurityRule)(nil)).Elem()
}

func (i NetworkSecurityRuleArray) ToNetworkSecurityRuleArrayOutput() NetworkSecurityRuleArrayOutput {
	return i.ToNetworkSecurityRuleArrayOutputWithContext(context.Background())
}

func (i NetworkSecurityRuleArray) ToNetworkSecurityRuleArrayOutputWithContext(ctx context.Context) NetworkSecurityRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkSecurityRuleArrayOutput)
}

// Describes a network security rule.
type NetworkSecurityRuleOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkSecurityRule)(nil)).Elem()
}

func (o NetworkSecurityRuleOutput) ToNetworkSecurityRuleOutput() NetworkSecurityRuleOutput {
	return o
}

func (o NetworkSecurityRuleOutput) ToNetworkSecurityRuleOutputWithContext(ctx context.Context) NetworkSecurityRuleOutput {
	return o
}

// The network traffic is allowed or denied.
func (o NetworkSecurityRuleOutput) Access() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Access }).(pulumi.StringOutput)
}

// Network security rule description.
func (o NetworkSecurityRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRule) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
func (o NetworkSecurityRuleOutput) DestinationAddressPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRule) *string { return v.DestinationAddressPrefix }).(pulumi.StringPtrOutput)
}

// The destination address prefixes. CIDR or destination IP ranges.
func (o NetworkSecurityRuleOutput) DestinationAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.DestinationAddressPrefixes }).(pulumi.StringArrayOutput)
}

// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
func (o NetworkSecurityRuleOutput) DestinationPortRange() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRule) *string { return v.DestinationPortRange }).(pulumi.StringPtrOutput)
}

// The destination port ranges.
func (o NetworkSecurityRuleOutput) DestinationPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.DestinationPortRanges }).(pulumi.StringArrayOutput)
}

// Network security rule direction.
func (o NetworkSecurityRuleOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Direction }).(pulumi.StringOutput)
}

// Network security rule name.
func (o NetworkSecurityRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Name }).(pulumi.StringOutput)
}

// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
func (o NetworkSecurityRuleOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v NetworkSecurityRule) int { return v.Priority }).(pulumi.IntOutput)
}

// Network protocol this rule applies to.
func (o NetworkSecurityRuleOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Protocol }).(pulumi.StringOutput)
}

// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
func (o NetworkSecurityRuleOutput) SourceAddressPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRule) *string { return v.SourceAddressPrefix }).(pulumi.StringPtrOutput)
}

// The CIDR or source IP ranges.
func (o NetworkSecurityRuleOutput) SourceAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.SourceAddressPrefixes }).(pulumi.StringArrayOutput)
}

// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
func (o NetworkSecurityRuleOutput) SourcePortRange() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRule) *string { return v.SourcePortRange }).(pulumi.StringPtrOutput)
}

// The source port ranges.
func (o NetworkSecurityRuleOutput) SourcePortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.SourcePortRanges }).(pulumi.StringArrayOutput)
}

type NetworkSecurityRuleArrayOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkSecurityRule)(nil)).Elem()
}

func (o NetworkSecurityRuleArrayOutput) ToNetworkSecurityRuleArrayOutput() NetworkSecurityRuleArrayOutput {
	return o
}

func (o NetworkSecurityRuleArrayOutput) ToNetworkSecurityRuleArrayOutputWithContext(ctx context.Context) NetworkSecurityRuleArrayOutput {
	return o
}

func (o NetworkSecurityRuleArrayOutput) Index(i pulumi.IntInput) NetworkSecurityRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkSecurityRule {
		return vs[0].([]NetworkSecurityRule)[vs[1].(int)]
	}).(NetworkSecurityRuleOutput)
}

// Describes a network security rule.
type NetworkSecurityRuleResponse struct {
	// The network traffic is allowed or denied.
	Access string `pulumi:"access"`
	// Network security rule description.
	Description *string `pulumi:"description"`
	// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
	DestinationAddressPrefix *string `pulumi:"destinationAddressPrefix"`
	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes []string `pulumi:"destinationAddressPrefixes"`
	// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	DestinationPortRange *string `pulumi:"destinationPortRange"`
	// The destination port ranges.
	DestinationPortRanges []string `pulumi:"destinationPortRanges"`
	// Network security rule direction.
	Direction string `pulumi:"direction"`
	// Network security rule name.
	Name string `pulumi:"name"`
	// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority int `pulumi:"priority"`
	// Network protocol this rule applies to.
	Protocol string `pulumi:"protocol"`
	// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
	SourceAddressPrefix *string `pulumi:"sourceAddressPrefix"`
	// The CIDR or source IP ranges.
	SourceAddressPrefixes []string `pulumi:"sourceAddressPrefixes"`
	// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	SourcePortRange *string `pulumi:"sourcePortRange"`
	// The source port ranges.
	SourcePortRanges []string `pulumi:"sourcePortRanges"`
}

// Describes a network security rule.
type NetworkSecurityRuleResponseOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkSecurityRuleResponse)(nil)).Elem()
}

func (o NetworkSecurityRuleResponseOutput) ToNetworkSecurityRuleResponseOutput() NetworkSecurityRuleResponseOutput {
	return o
}

func (o NetworkSecurityRuleResponseOutput) ToNetworkSecurityRuleResponseOutputWithContext(ctx context.Context) NetworkSecurityRuleResponseOutput {
	return o
}

// The network traffic is allowed or denied.
func (o NetworkSecurityRuleResponseOutput) Access() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Access }).(pulumi.StringOutput)
}

// Network security rule description.
func (o NetworkSecurityRuleResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
func (o NetworkSecurityRuleResponseOutput) DestinationAddressPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) *string { return v.DestinationAddressPrefix }).(pulumi.StringPtrOutput)
}

// The destination address prefixes. CIDR or destination IP ranges.
func (o NetworkSecurityRuleResponseOutput) DestinationAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.DestinationAddressPrefixes }).(pulumi.StringArrayOutput)
}

// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
func (o NetworkSecurityRuleResponseOutput) DestinationPortRange() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) *string { return v.DestinationPortRange }).(pulumi.StringPtrOutput)
}

// The destination port ranges.
func (o NetworkSecurityRuleResponseOutput) DestinationPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.DestinationPortRanges }).(pulumi.StringArrayOutput)
}

// Network security rule direction.
func (o NetworkSecurityRuleResponseOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Direction }).(pulumi.StringOutput)
}

// Network security rule name.
func (o NetworkSecurityRuleResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
func (o NetworkSecurityRuleResponseOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) int { return v.Priority }).(pulumi.IntOutput)
}

// Network protocol this rule applies to.
func (o NetworkSecurityRuleResponseOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Protocol }).(pulumi.StringOutput)
}

// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
func (o NetworkSecurityRuleResponseOutput) SourceAddressPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) *string { return v.SourceAddressPrefix }).(pulumi.StringPtrOutput)
}

// The CIDR or source IP ranges.
func (o NetworkSecurityRuleResponseOutput) SourceAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.SourceAddressPrefixes }).(pulumi.StringArrayOutput)
}

// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
func (o NetworkSecurityRuleResponseOutput) SourcePortRange() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) *string { return v.SourcePortRange }).(pulumi.StringPtrOutput)
}

// The source port ranges.
func (o NetworkSecurityRuleResponseOutput) SourcePortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.SourcePortRanges }).(pulumi.StringArrayOutput)
}

type NetworkSecurityRuleResponseArrayOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkSecurityRuleResponse)(nil)).Elem()
}

func (o NetworkSecurityRuleResponseArrayOutput) ToNetworkSecurityRuleResponseArrayOutput() NetworkSecurityRuleResponseArrayOutput {
	return o
}

func (o NetworkSecurityRuleResponseArrayOutput) ToNetworkSecurityRuleResponseArrayOutputWithContext(ctx context.Context) NetworkSecurityRuleResponseArrayOutput {
	return o
}

func (o NetworkSecurityRuleResponseArrayOutput) Index(i pulumi.IntInput) NetworkSecurityRuleResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkSecurityRuleResponse {
		return vs[0].([]NetworkSecurityRuleResponse)[vs[1].(int)]
	}).(NetworkSecurityRuleResponseOutput)
}

// Provides information about NAT configuration on the default public Load Balancer for the node type.
type NodeTypeNatConfig struct {
	// The internal port for the NAT configuration.
	BackendPort *int `pulumi:"backendPort"`
	// The port range end for the external endpoint.
	FrontendPortRangeEnd *int `pulumi:"frontendPortRangeEnd"`
	// The port range start for the external endpoint.
	FrontendPortRangeStart *int `pulumi:"frontendPortRangeStart"`
}

// NodeTypeNatConfigInput is an input type that accepts NodeTypeNatConfigArgs and NodeTypeNatConfigOutput values.
// You can construct a concrete instance of `NodeTypeNatConfigInput` via:
//
//	NodeTypeNatConfigArgs{...}
type NodeTypeNatConfigInput interface {
	pulumi.Input

	ToNodeTypeNatConfigOutput() NodeTypeNatConfigOutput
	ToNodeTypeNatConfigOutputWithContext(context.Context) NodeTypeNatConfigOutput
}

// Provides information about NAT configuration on the default public Load Balancer for the node type.
type NodeTypeNatConfigArgs struct {
	// The internal port for the NAT configuration.
	BackendPort pulumi.IntPtrInput `pulumi:"backendPort"`
	// The port range end for the external endpoint.
	FrontendPortRangeEnd pulumi.IntPtrInput `pulumi:"frontendPortRangeEnd"`
	// The port range start for the external endpoint.
	FrontendPortRangeStart pulumi.IntPtrInput `pulumi:"frontendPortRangeStart"`
}

func (NodeTypeNatConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeNatConfig)(nil)).Elem()
}

func (i NodeTypeNatConfigArgs) ToNodeTypeNatConfigOutput() NodeTypeNatConfigOutput {
	return i.ToNodeTypeNatConfigOutputWithContext(context.Background())
}

func (i NodeTypeNatConfigArgs) ToNodeTypeNatConfigOutputWithContext(ctx context.Context) NodeTypeNatConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeNatConfigOutput)
}

// NodeTypeNatConfigArrayInput is an input type that accepts NodeTypeNatConfigArray and NodeTypeNatConfigArrayOutput values.
// You can construct a concrete instance of `NodeTypeNatConfigArrayInput` via:
//
//	NodeTypeNatConfigArray{ NodeTypeNatConfigArgs{...} }
type NodeTypeNatConfigArrayInput interface {
	pulumi.Input

	ToNodeTypeNatConfigArrayOutput() NodeTypeNatConfigArrayOutput
	ToNodeTypeNatConfigArrayOutputWithContext(context.Context) NodeTypeNatConfigArrayOutput
}

type NodeTypeNatConfigArray []NodeTypeNatConfigInput

func (NodeTypeNatConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NodeTypeNatConfig)(nil)).Elem()
}

func (i NodeTypeNatConfigArray) ToNodeTypeNatConfigArrayOutput() NodeTypeNatConfigArrayOutput {
	return i.ToNodeTypeNatConfigArrayOutputWithContext(context.Background())
}

func (i NodeTypeNatConfigArray) ToNodeTypeNatConfigArrayOutputWithContext(ctx context.Context) NodeTypeNatConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeNatConfigArrayOutput)
}

// Provides information about NAT configuration on the default public Load Balancer for the node type.
type NodeTypeNatConfigOutput struct{ *pulumi.OutputState }

func (NodeTypeNatConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeNatConfig)(nil)).Elem()
}

func (o NodeTypeNatConfigOutput) ToNodeTypeNatConfigOutput() NodeTypeNatConfigOutput {
	return o
}

func (o NodeTypeNatConfigOutput) ToNodeTypeNatConfigOutputWithContext(ctx context.Context) NodeTypeNatConfigOutput {
	return o
}

// The internal port for the NAT configuration.
func (o NodeTypeNatConfigOutput) BackendPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v NodeTypeNatConfig) *int { return v.BackendPort }).(pulumi.IntPtrOutput)
}

// The port range end for the external endpoint.
func (o NodeTypeNatConfigOutput) FrontendPortRangeEnd() pulumi.IntPtrOutput {
	return o.ApplyT(func(v NodeTypeNatConfig) *int { return v.FrontendPortRangeEnd }).(pulumi.IntPtrOutput)
}

// The port range start for the external endpoint.
func (o NodeTypeNatConfigOutput) FrontendPortRangeStart() pulumi.IntPtrOutput {
	return o.ApplyT(func(v NodeTypeNatConfig) *int { return v.FrontendPortRangeStart }).(pulumi.IntPtrOutput)
}

type NodeTypeNatConfigArrayOutput struct{ *pulumi.OutputState }

func (NodeTypeNatConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NodeTypeNatConfig)(nil)).Elem()
}

func (o NodeTypeNatConfigArrayOutput) ToNodeTypeNatConfigArrayOutput() NodeTypeNatConfigArrayOutput {
	return o
}

func (o NodeTypeNatConfigArrayOutput) ToNodeTypeNatConfigArrayOutputWithContext(ctx context.Context) NodeTypeNatConfigArrayOutput {
	return o
}

func (o NodeTypeNatConfigArrayOutput) Index(i pulumi.IntInput) NodeTypeNatConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NodeTypeNatConfig {
		return vs[0].([]NodeTypeNatConfig)[vs[1].(int)]
	}).(NodeTypeNatConfigOutput)
}

// Provides information about NAT configuration on the default public Load Balancer for the node type.
type NodeTypeNatConfigResponse struct {
	// The internal port for the NAT configuration.
	BackendPort *int `pulumi:"backendPort"`
	// The port range end for the external endpoint.
	FrontendPortRangeEnd *int `pulumi:"frontendPortRangeEnd"`
	// The port range start for the external endpoint.
	FrontendPortRangeStart *int `pulumi:"frontendPortRangeStart"`
}

// Provides information about NAT configuration on the default public Load Balancer for the node type.
type NodeTypeNatConfigResponseOutput struct{ *pulumi.OutputState }

func (NodeTypeNatConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeNatConfigResponse)(nil)).Elem()
}

func (o NodeTypeNatConfigResponseOutput) ToNodeTypeNatConfigResponseOutput() NodeTypeNatConfigResponseOutput {
	return o
}

func (o NodeTypeNatConfigResponseOutput) ToNodeTypeNatConfigResponseOutputWithContext(ctx context.Context) NodeTypeNatConfigResponseOutput {
	return o
}

// The internal port for the NAT configuration.
func (o NodeTypeNatConfigResponseOutput) BackendPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v NodeTypeNatConfigResponse) *int { return v.BackendPort }).(pulumi.IntPtrOutput)
}

// The port range end for the external endpoint.
func (o NodeTypeNatConfigResponseOutput) FrontendPortRangeEnd() pulumi.IntPtrOutput {
	return o.ApplyT(func(v NodeTypeNatConfigResponse) *int { return v.FrontendPortRangeEnd }).(pulumi.IntPtrOutput)
}

// The port range start for the external endpoint.
func (o NodeTypeNatConfigResponseOutput) FrontendPortRangeStart() pulumi.IntPtrOutput {
	return o.ApplyT(func(v NodeTypeNatConfigResponse) *int { return v.FrontendPortRangeStart }).(pulumi.IntPtrOutput)
}

type NodeTypeNatConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (NodeTypeNatConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NodeTypeNatConfigResponse)(nil)).Elem()
}

func (o NodeTypeNatConfigResponseArrayOutput) ToNodeTypeNatConfigResponseArrayOutput() NodeTypeNatConfigResponseArrayOutput {
	return o
}

func (o NodeTypeNatConfigResponseArrayOutput) ToNodeTypeNatConfigResponseArrayOutputWithContext(ctx context.Context) NodeTypeNatConfigResponseArrayOutput {
	return o
}

func (o NodeTypeNatConfigResponseArrayOutput) Index(i pulumi.IntInput) NodeTypeNatConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NodeTypeNatConfigResponse {
		return vs[0].([]NodeTypeNatConfigResponse)[vs[1].(int)]
	}).(NodeTypeNatConfigResponseOutput)
}

// Describes a node type sku.
type NodeTypeSku struct {
	// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
	Capacity int `pulumi:"capacity"`
	// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
	Name *string `pulumi:"name"`
	// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
	Tier *string `pulumi:"tier"`
}

// NodeTypeSkuInput is an input type that accepts NodeTypeSkuArgs and NodeTypeSkuOutput values.
// You can construct a concrete instance of `NodeTypeSkuInput` via:
//
//	NodeTypeSkuArgs{...}
type NodeTypeSkuInput interface {
	pulumi.Input

	ToNodeTypeSkuOutput() NodeTypeSkuOutput
	ToNodeTypeSkuOutputWithContext(context.Context) NodeTypeSkuOutput
}

// Describes a node type sku.
type NodeTypeSkuArgs struct {
	// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
	Capacity pulumi.IntInput `pulumi:"capacity"`
	// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
	Tier pulumi.StringPtrInput `pulumi:"tier"`
}

func (NodeTypeSkuArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeSku)(nil)).Elem()
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuOutput() NodeTypeSkuOutput {
	return i.ToNodeTypeSkuOutputWithContext(context.Background())
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuOutputWithContext(ctx context.Context) NodeTypeSkuOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuOutput)
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return i.ToNodeTypeSkuPtrOutputWithContext(context.Background())
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuOutput).ToNodeTypeSkuPtrOutputWithContext(ctx)
}

// NodeTypeSkuPtrInput is an input type that accepts NodeTypeSkuArgs, NodeTypeSkuPtr and NodeTypeSkuPtrOutput values.
// You can construct a concrete instance of `NodeTypeSkuPtrInput` via:
//
//	        NodeTypeSkuArgs{...}
//
//	or:
//
//	        nil
type NodeTypeSkuPtrInput interface {
	pulumi.Input

	ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput
	ToNodeTypeSkuPtrOutputWithContext(context.Context) NodeTypeSkuPtrOutput
}

type nodeTypeSkuPtrType NodeTypeSkuArgs

func NodeTypeSkuPtr(v *NodeTypeSkuArgs) NodeTypeSkuPtrInput {
	return (*nodeTypeSkuPtrType)(v)
}

func (*nodeTypeSkuPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeTypeSku)(nil)).Elem()
}

func (i *nodeTypeSkuPtrType) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return i.ToNodeTypeSkuPtrOutputWithContext(context.Background())
}

func (i *nodeTypeSkuPtrType) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuPtrOutput)
}

// Describes a node type sku.
type NodeTypeSkuOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeSku)(nil)).Elem()
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuOutput() NodeTypeSkuOutput {
	return o
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuOutputWithContext(ctx context.Context) NodeTypeSkuOutput {
	return o
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return o.ToNodeTypeSkuPtrOutputWithContext(context.Background())
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NodeTypeSku) *NodeTypeSku {
		return &v
	}).(NodeTypeSkuPtrOutput)
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuOutput) Capacity() pulumi.IntOutput {
	return o.ApplyT(func(v NodeTypeSku) int { return v.Capacity }).(pulumi.IntOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSku) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSku) *string { return v.Tier }).(pulumi.StringPtrOutput)
}

type NodeTypeSkuPtrOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeTypeSku)(nil)).Elem()
}

func (o NodeTypeSkuPtrOutput) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return o
}

func (o NodeTypeSkuPtrOutput) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return o
}

func (o NodeTypeSkuPtrOutput) Elem() NodeTypeSkuOutput {
	return o.ApplyT(func(v *NodeTypeSku) NodeTypeSku {
		if v != nil {
			return *v
		}
		var ret NodeTypeSku
		return ret
	}).(NodeTypeSkuOutput)
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuPtrOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NodeTypeSku) *int {
		if v == nil {
			return nil
		}
		return &v.Capacity
	}).(pulumi.IntPtrOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSku) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuPtrOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSku) *string {
		if v == nil {
			return nil
		}
		return v.Tier
	}).(pulumi.StringPtrOutput)
}

// Describes a node type sku.
type NodeTypeSkuResponse struct {
	// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
	Capacity int `pulumi:"capacity"`
	// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
	Name *string `pulumi:"name"`
	// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
	Tier *string `pulumi:"tier"`
}

// Describes a node type sku.
type NodeTypeSkuResponseOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeSkuResponse)(nil)).Elem()
}

func (o NodeTypeSkuResponseOutput) ToNodeTypeSkuResponseOutput() NodeTypeSkuResponseOutput {
	return o
}

func (o NodeTypeSkuResponseOutput) ToNodeTypeSkuResponseOutputWithContext(ctx context.Context) NodeTypeSkuResponseOutput {
	return o
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuResponseOutput) Capacity() pulumi.IntOutput {
	return o.ApplyT(func(v NodeTypeSkuResponse) int { return v.Capacity }).(pulumi.IntOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuResponseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSkuResponse) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuResponseOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSkuResponse) *string { return v.Tier }).(pulumi.StringPtrOutput)
}

type NodeTypeSkuResponsePtrOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeTypeSkuResponse)(nil)).Elem()
}

func (o NodeTypeSkuResponsePtrOutput) ToNodeTypeSkuResponsePtrOutput() NodeTypeSkuResponsePtrOutput {
	return o
}

func (o NodeTypeSkuResponsePtrOutput) ToNodeTypeSkuResponsePtrOutputWithContext(ctx context.Context) NodeTypeSkuResponsePtrOutput {
	return o
}

func (o NodeTypeSkuResponsePtrOutput) Elem() NodeTypeSkuResponseOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) NodeTypeSkuResponse {
		if v != nil {
			return *v
		}
		var ret NodeTypeSkuResponse
		return ret
	}).(NodeTypeSkuResponseOutput)
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuResponsePtrOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Capacity
	}).(pulumi.IntPtrOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuResponsePtrOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) *string {
		if v == nil {
			return nil
		}
		return v.Tier
	}).(pulumi.StringPtrOutput)
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanism struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'ScalePartitionInstanceCount'.
	Kind string `pulumi:"kind"`
	// Maximum number of instances of the partition.
	MaxInstanceCount int `pulumi:"maxInstanceCount"`
	// Minimum number of instances of the partition.
	MinInstanceCount int `pulumi:"minInstanceCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// PartitionInstanceCountScaleMechanismInput is an input type that accepts PartitionInstanceCountScaleMechanismArgs and PartitionInstanceCountScaleMechanismOutput values.
// You can construct a concrete instance of `PartitionInstanceCountScaleMechanismInput` via:
//
//	PartitionInstanceCountScaleMechanismArgs{...}
type PartitionInstanceCountScaleMechanismInput interface {
	pulumi.Input

	ToPartitionInstanceCountScaleMechanismOutput() PartitionInstanceCountScaleMechanismOutput
	ToPartitionInstanceCountScaleMechanismOutputWithContext(context.Context) PartitionInstanceCountScaleMechanismOutput
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanismArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'ScalePartitionInstanceCount'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// Maximum number of instances of the partition.
	MaxInstanceCount pulumi.IntInput `pulumi:"maxInstanceCount"`
	// Minimum number of instances of the partition.
	MinInstanceCount pulumi.IntInput `pulumi:"minInstanceCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement pulumi.IntInput `pulumi:"scaleIncrement"`
}

func (PartitionInstanceCountScaleMechanismArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PartitionInstanceCountScaleMechanism)(nil)).Elem()
}

func (i PartitionInstanceCountScaleMechanismArgs) ToPartitionInstanceCountScaleMechanismOutput() PartitionInstanceCountScaleMechanismOutput {
	return i.ToPartitionInstanceCountScaleMechanismOutputWithContext(context.Background())
}

func (i PartitionInstanceCountScaleMechanismArgs) ToPartitionInstanceCountScaleMechanismOutputWithContext(ctx context.Context) PartitionInstanceCountScaleMechanismOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PartitionInstanceCountScaleMechanismOutput)
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanismOutput struct{ *pulumi.OutputState }

func (PartitionInstanceCountScaleMechanismOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PartitionInstanceCountScaleMechanism)(nil)).Elem()
}

func (o PartitionInstanceCountScaleMechanismOutput) ToPartitionInstanceCountScaleMechanismOutput() PartitionInstanceCountScaleMechanismOutput {
	return o
}

func (o PartitionInstanceCountScaleMechanismOutput) ToPartitionInstanceCountScaleMechanismOutputWithContext(ctx context.Context) PartitionInstanceCountScaleMechanismOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'ScalePartitionInstanceCount'.
func (o PartitionInstanceCountScaleMechanismOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanism) string { return v.Kind }).(pulumi.StringOutput)
}

// Maximum number of instances of the partition.
func (o PartitionInstanceCountScaleMechanismOutput) MaxInstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanism) int { return v.MaxInstanceCount }).(pulumi.IntOutput)
}

// Minimum number of instances of the partition.
func (o PartitionInstanceCountScaleMechanismOutput) MinInstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanism) int { return v.MinInstanceCount }).(pulumi.IntOutput)
}

// The number of instances to add or remove during a scaling operation.
func (o PartitionInstanceCountScaleMechanismOutput) ScaleIncrement() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanism) int { return v.ScaleIncrement }).(pulumi.IntOutput)
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanismResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'ScalePartitionInstanceCount'.
	Kind string `pulumi:"kind"`
	// Maximum number of instances of the partition.
	MaxInstanceCount int `pulumi:"maxInstanceCount"`
	// Minimum number of instances of the partition.
	MinInstanceCount int `pulumi:"minInstanceCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanismResponseOutput struct{ *pulumi.OutputState }

func (PartitionInstanceCountScaleMechanismResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PartitionInstanceCountScaleMechanismResponse)(nil)).Elem()
}

func (o PartitionInstanceCountScaleMechanismResponseOutput) ToPartitionInstanceCountScaleMechanismResponseOutput() PartitionInstanceCountScaleMechanismResponseOutput {
	return o
}

func (o PartitionInstanceCountScaleMechanismResponseOutput) ToPartitionInstanceCountScaleMechanismResponseOutputWithContext(ctx context.Context) PartitionInstanceCountScaleMechanismResponseOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'ScalePartitionInstanceCount'.
func (o PartitionInstanceCountScaleMechanismResponseOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanismResponse) string { return v.Kind }).(pulumi.StringOutput)
}

// Maximum number of instances of the partition.
func (o PartitionInstanceCountScaleMechanismResponseOutput) MaxInstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanismResponse) int { return v.MaxInstanceCount }).(pulumi.IntOutput)
}

// Minimum number of instances of the partition.
func (o PartitionInstanceCountScaleMechanismResponseOutput) MinInstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanismResponse) int { return v.MinInstanceCount }).(pulumi.IntOutput)
}

// The number of instances to add or remove during a scaling operation.
func (o PartitionInstanceCountScaleMechanismResponseOutput) ScaleIncrement() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanismResponse) int { return v.ScaleIncrement }).(pulumi.IntOutput)
}

// Describes Az Resiliency status of Base resources
type ResourceAzStatusResponse struct {
	// Zone resiliency status details for the resource.
	Details string `pulumi:"details"`
	// VM Size name.
	IsZoneResilient bool `pulumi:"isZoneResilient"`
	// VM Size properties.
	ResourceName string `pulumi:"resourceName"`
	// VM Size id.
	ResourceType string `pulumi:"resourceType"`
}

// Describes Az Resiliency status of Base resources
type ResourceAzStatusResponseOutput struct{ *pulumi.OutputState }

func (ResourceAzStatusResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceAzStatusResponse)(nil)).Elem()
}

func (o ResourceAzStatusResponseOutput) ToResourceAzStatusResponseOutput() ResourceAzStatusResponseOutput {
	return o
}

func (o ResourceAzStatusResponseOutput) ToResourceAzStatusResponseOutputWithContext(ctx context.Context) ResourceAzStatusResponseOutput {
	return o
}

// Zone resiliency status details for the resource.
func (o ResourceAzStatusResponseOutput) Details() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceAzStatusResponse) string { return v.Details }).(pulumi.StringOutput)
}

// VM Size name.
func (o ResourceAzStatusResponseOutput) IsZoneResilient() pulumi.BoolOutput {
	return o.ApplyT(func(v ResourceAzStatusResponse) bool { return v.IsZoneResilient }).(pulumi.BoolOutput)
}

// VM Size properties.
func (o ResourceAzStatusResponseOutput) ResourceName() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceAzStatusResponse) string { return v.ResourceName }).(pulumi.StringOutput)
}

// VM Size id.
func (o ResourceAzStatusResponseOutput) ResourceType() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceAzStatusResponse) string { return v.ResourceType }).(pulumi.StringOutput)
}

type ResourceAzStatusResponseArrayOutput struct{ *pulumi.OutputState }

func (ResourceAzStatusResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceAzStatusResponse)(nil)).Elem()
}

func (o ResourceAzStatusResponseArrayOutput) ToResourceAzStatusResponseArrayOutput() ResourceAzStatusResponseArrayOutput {
	return o
}

func (o ResourceAzStatusResponseArrayOutput) ToResourceAzStatusResponseArrayOutputWithContext(ctx context.Context) ResourceAzStatusResponseArrayOutput {
	return o
}

func (o ResourceAzStatusResponseArrayOutput) Index(i pulumi.IntInput) ResourceAzStatusResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceAzStatusResponse {
		return vs[0].([]ResourceAzStatusResponse)[vs[1].(int)]
	}).(ResourceAzStatusResponseOutput)
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicy struct {
	// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
	FailureAction string `pulumi:"failureAction"`
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout string `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckStableDuration string `pulumi:"healthCheckStableDuration"`
	// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration string `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeDomainTimeout string `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeTimeout string `pulumi:"upgradeTimeout"`
}

// RollingUpgradeMonitoringPolicyInput is an input type that accepts RollingUpgradeMonitoringPolicyArgs and RollingUpgradeMonitoringPolicyOutput values.
// You can construct a concrete instance of `RollingUpgradeMonitoringPolicyInput` via:
//
//	RollingUpgradeMonitoringPolicyArgs{...}
type RollingUpgradeMonitoringPolicyInput interface {
	pulumi.Input

	ToRollingUpgradeMonitoringPolicyOutput() RollingUpgradeMonitoringPolicyOutput
	ToRollingUpgradeMonitoringPolicyOutputWithContext(context.Context) RollingUpgradeMonitoringPolicyOutput
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyArgs struct {
	// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
	FailureAction pulumi.StringInput `pulumi:"failureAction"`
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout pulumi.StringInput `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckStableDuration pulumi.StringInput `pulumi:"healthCheckStableDuration"`
	// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration pulumi.StringInput `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeDomainTimeout pulumi.StringInput `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeTimeout pulumi.StringInput `pulumi:"upgradeTimeout"`
}

func (RollingUpgradeMonitoringPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyOutput() RollingUpgradeMonitoringPolicyOutput {
	return i.ToRollingUpgradeMonitoringPolicyOutputWithContext(context.Background())
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyOutput)
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return i.ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyOutput).ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx)
}

// RollingUpgradeMonitoringPolicyPtrInput is an input type that accepts RollingUpgradeMonitoringPolicyArgs, RollingUpgradeMonitoringPolicyPtr and RollingUpgradeMonitoringPolicyPtrOutput values.
// You can construct a concrete instance of `RollingUpgradeMonitoringPolicyPtrInput` via:
//
//	        RollingUpgradeMonitoringPolicyArgs{...}
//
//	or:
//
//	        nil
type RollingUpgradeMonitoringPolicyPtrInput interface {
	pulumi.Input

	ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput
	ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Context) RollingUpgradeMonitoringPolicyPtrOutput
}

type rollingUpgradeMonitoringPolicyPtrType RollingUpgradeMonitoringPolicyArgs

func RollingUpgradeMonitoringPolicyPtr(v *RollingUpgradeMonitoringPolicyArgs) RollingUpgradeMonitoringPolicyPtrInput {
	return (*rollingUpgradeMonitoringPolicyPtrType)(v)
}

func (*rollingUpgradeMonitoringPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (i *rollingUpgradeMonitoringPolicyPtrType) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return i.ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (i *rollingUpgradeMonitoringPolicyPtrType) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyOutput() RollingUpgradeMonitoringPolicyOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RollingUpgradeMonitoringPolicy) *RollingUpgradeMonitoringPolicy {
		return &v
	}).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyOutput) FailureAction() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.FailureAction }).(pulumi.StringOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) HealthCheckRetryTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.HealthCheckRetryTimeout }).(pulumi.StringOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) HealthCheckStableDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.HealthCheckStableDuration }).(pulumi.StringOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) HealthCheckWaitDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.HealthCheckWaitDuration }).(pulumi.StringOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) UpgradeDomainTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.UpgradeDomainTimeout }).(pulumi.StringOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) UpgradeTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.UpgradeTimeout }).(pulumi.StringOutput)
}

type RollingUpgradeMonitoringPolicyPtrOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyPtrOutput) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyPtrOutput) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyPtrOutput) Elem() RollingUpgradeMonitoringPolicyOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) RollingUpgradeMonitoringPolicy {
		if v != nil {
			return *v
		}
		var ret RollingUpgradeMonitoringPolicy
		return ret
	}).(RollingUpgradeMonitoringPolicyOutput)
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyPtrOutput) FailureAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.FailureAction
	}).(pulumi.StringPtrOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) HealthCheckRetryTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckRetryTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) HealthCheckStableDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckStableDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) HealthCheckWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckWaitDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) UpgradeDomainTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeDomainTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) UpgradeTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeTimeout
	}).(pulumi.StringPtrOutput)
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyResponse struct {
	// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
	FailureAction string `pulumi:"failureAction"`
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout string `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckStableDuration string `pulumi:"healthCheckStableDuration"`
	// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration string `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeDomainTimeout string `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeTimeout string `pulumi:"upgradeTimeout"`
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyResponseOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpgradeMonitoringPolicyResponse)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyResponseOutput) ToRollingUpgradeMonitoringPolicyResponseOutput() RollingUpgradeMonitoringPolicyResponseOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyResponseOutput) ToRollingUpgradeMonitoringPolicyResponseOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyResponseOutput {
	return o
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyResponseOutput) FailureAction() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.FailureAction }).(pulumi.StringOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) HealthCheckRetryTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.HealthCheckRetryTimeout }).(pulumi.StringOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) HealthCheckStableDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.HealthCheckStableDuration }).(pulumi.StringOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) HealthCheckWaitDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.HealthCheckWaitDuration }).(pulumi.StringOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) UpgradeDomainTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.UpgradeDomainTimeout }).(pulumi.StringOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) UpgradeTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.UpgradeTimeout }).(pulumi.StringOutput)
}

type RollingUpgradeMonitoringPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpgradeMonitoringPolicyResponse)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) ToRollingUpgradeMonitoringPolicyResponsePtrOutput() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) ToRollingUpgradeMonitoringPolicyResponsePtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) Elem() RollingUpgradeMonitoringPolicyResponseOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) RollingUpgradeMonitoringPolicyResponse {
		if v != nil {
			return *v
		}
		var ret RollingUpgradeMonitoringPolicyResponse
		return ret
	}).(RollingUpgradeMonitoringPolicyResponseOutput)
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) FailureAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.FailureAction
	}).(pulumi.StringPtrOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) HealthCheckRetryTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckRetryTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) HealthCheckStableDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckStableDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) HealthCheckWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckWaitDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) UpgradeDomainTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeDomainTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) UpgradeTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeTimeout
	}).(pulumi.StringPtrOutput)
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicy struct {
	// Specifies the mechanism associated with this scaling policy
	ScalingMechanism interface{} `pulumi:"scalingMechanism"`
	// Specifies the trigger associated with this scaling policy.
	ScalingTrigger interface{} `pulumi:"scalingTrigger"`
}

// ScalingPolicyInput is an input type that accepts ScalingPolicyArgs and ScalingPolicyOutput values.
// You can construct a concrete instance of `ScalingPolicyInput` via:
//
//	ScalingPolicyArgs{...}
type ScalingPolicyInput interface {
	pulumi.Input

	ToScalingPolicyOutput() ScalingPolicyOutput
	ToScalingPolicyOutputWithContext(context.Context) ScalingPolicyOutput
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicyArgs struct {
	// Specifies the mechanism associated with this scaling policy
	ScalingMechanism pulumi.Input `pulumi:"scalingMechanism"`
	// Specifies the trigger associated with this scaling policy.
	ScalingTrigger pulumi.Input `pulumi:"scalingTrigger"`
}

func (ScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScalingPolicy)(nil)).Elem()
}

func (i ScalingPolicyArgs) ToScalingPolicyOutput() ScalingPolicyOutput {
	return i.ToScalingPolicyOutputWithContext(context.Background())
}

func (i ScalingPolicyArgs) ToScalingPolicyOutputWithContext(ctx context.Context) ScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScalingPolicyOutput)
}

// ScalingPolicyArrayInput is an input type that accepts ScalingPolicyArray and ScalingPolicyArrayOutput values.
// You can construct a concrete instance of `ScalingPolicyArrayInput` via:
//
//	ScalingPolicyArray{ ScalingPolicyArgs{...} }
type ScalingPolicyArrayInput interface {
	pulumi.Input

	ToScalingPolicyArrayOutput() ScalingPolicyArrayOutput
	ToScalingPolicyArrayOutputWithContext(context.Context) ScalingPolicyArrayOutput
}

type ScalingPolicyArray []ScalingPolicyInput

func (ScalingPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScalingPolicy)(nil)).Elem()
}

func (i ScalingPolicyArray) ToScalingPolicyArrayOutput() ScalingPolicyArrayOutput {
	return i.ToScalingPolicyArrayOutputWithContext(context.Background())
}

func (i ScalingPolicyArray) ToScalingPolicyArrayOutputWithContext(ctx context.Context) ScalingPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScalingPolicyArrayOutput)
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicyOutput struct{ *pulumi.OutputState }

func (ScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScalingPolicy)(nil)).Elem()
}

func (o ScalingPolicyOutput) ToScalingPolicyOutput() ScalingPolicyOutput {
	return o
}

func (o ScalingPolicyOutput) ToScalingPolicyOutputWithContext(ctx context.Context) ScalingPolicyOutput {
	return o
}

// Specifies the mechanism associated with this scaling policy
func (o ScalingPolicyOutput) ScalingMechanism() pulumi.AnyOutput {
	return o.ApplyT(func(v ScalingPolicy) interface{} { return v.ScalingMechanism }).(pulumi.AnyOutput)
}

// Specifies the trigger associated with this scaling policy.
func (o ScalingPolicyOutput) ScalingTrigger() pulumi.AnyOutput {
	return o.ApplyT(func(v ScalingPolicy) interface{} { return v.ScalingTrigger }).(pulumi.AnyOutput)
}

type ScalingPolicyArrayOutput struct{ *pulumi.OutputState }

func (ScalingPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScalingPolicy)(nil)).Elem()
}

func (o ScalingPolicyArrayOutput) ToScalingPolicyArrayOutput() ScalingPolicyArrayOutput {
	return o
}

func (o ScalingPolicyArrayOutput) ToScalingPolicyArrayOutputWithContext(ctx context.Context) ScalingPolicyArrayOutput {
	return o
}

func (o ScalingPolicyArrayOutput) Index(i pulumi.IntInput) ScalingPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ScalingPolicy {
		return vs[0].([]ScalingPolicy)[vs[1].(int)]
	}).(ScalingPolicyOutput)
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicyResponse struct {
	// Specifies the mechanism associated with this scaling policy
	ScalingMechanism interface{} `pulumi:"scalingMechanism"`
	// Specifies the trigger associated with this scaling policy.
	ScalingTrigger interface{} `pulumi:"scalingTrigger"`
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicyResponseOutput struct{ *pulumi.OutputState }

func (ScalingPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScalingPolicyResponse)(nil)).Elem()
}

func (o ScalingPolicyResponseOutput) ToScalingPolicyResponseOutput() ScalingPolicyResponseOutput {
	return o
}

func (o ScalingPolicyResponseOutput) ToScalingPolicyResponseOutputWithContext(ctx context.Context) ScalingPolicyResponseOutput {
	return o
}

// Specifies the mechanism associated with this scaling policy
func (o ScalingPolicyResponseOutput) ScalingMechanism() pulumi.AnyOutput {
	return o.ApplyT(func(v ScalingPolicyResponse) interface{} { return v.ScalingMechanism }).(pulumi.AnyOutput)
}

// Specifies the trigger associated with this scaling policy.
func (o ScalingPolicyResponseOutput) ScalingTrigger() pulumi.AnyOutput {
	return o.ApplyT(func(v ScalingPolicyResponse) interface{} { return v.ScalingTrigger }).(pulumi.AnyOutput)
}

type ScalingPolicyResponseArrayOutput struct{ *pulumi.OutputState }

func (ScalingPolicyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScalingPolicyResponse)(nil)).Elem()
}

func (o ScalingPolicyResponseArrayOutput) ToScalingPolicyResponseArrayOutput() ScalingPolicyResponseArrayOutput {
	return o
}

func (o ScalingPolicyResponseArrayOutput) ToScalingPolicyResponseArrayOutputWithContext(ctx context.Context) ScalingPolicyResponseArrayOutput {
	return o
}

func (o ScalingPolicyResponseArrayOutput) Index(i pulumi.IntInput) ScalingPolicyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ScalingPolicyResponse {
		return vs[0].([]ScalingPolicyResponse)[vs[1].(int)]
	}).(ScalingPolicyResponseOutput)
}

// Creates a particular correlation between services.
type ServiceCorrelation struct {
	// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
	Scheme string `pulumi:"scheme"`
	// The Arm Resource ID of the service that the correlation relationship is established with.
	ServiceName string `pulumi:"serviceName"`
}

// ServiceCorrelationInput is an input type that accepts ServiceCorrelationArgs and ServiceCorrelationOutput values.
// You can construct a concrete instance of `ServiceCorrelationInput` via:
//
//	ServiceCorrelationArgs{...}
type ServiceCorrelationInput interface {
	pulumi.Input

	ToServiceCorrelationOutput() ServiceCorrelationOutput
	ToServiceCorrelationOutputWithContext(context.Context) ServiceCorrelationOutput
}

// Creates a particular correlation between services.
type ServiceCorrelationArgs struct {
	// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
	Scheme pulumi.StringInput `pulumi:"scheme"`
	// The Arm Resource ID of the service that the correlation relationship is established with.
	ServiceName pulumi.StringInput `pulumi:"serviceName"`
}

func (ServiceCorrelationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceCorrelation)(nil)).Elem()
}

func (i ServiceCorrelationArgs) ToServiceCorrelationOutput() ServiceCorrelationOutput {
	return i.ToServiceCorrelationOutputWithContext(context.Background())
}

func (i ServiceCorrelationArgs) ToServiceCorrelationOutputWithContext(ctx context.Context) ServiceCorrelationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceCorrelationOutput)
}

// ServiceCorrelationArrayInput is an input type that accepts ServiceCorrelationArray and ServiceCorrelationArrayOutput values.
// You can construct a concrete instance of `ServiceCorrelationArrayInput` via:
//
//	ServiceCorrelationArray{ ServiceCorrelationArgs{...} }
type ServiceCorrelationArrayInput interface {
	pulumi.Input

	ToServiceCorrelationArrayOutput() ServiceCorrelationArrayOutput
	ToServiceCorrelationArrayOutputWithContext(context.Context) ServiceCorrelationArrayOutput
}

type ServiceCorrelationArray []ServiceCorrelationInput

func (ServiceCorrelationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceCorrelation)(nil)).Elem()
}

func (i ServiceCorrelationArray) ToServiceCorrelationArrayOutput() ServiceCorrelationArrayOutput {
	return i.ToServiceCorrelationArrayOutputWithContext(context.Background())
}

func (i ServiceCorrelationArray) ToServiceCorrelationArrayOutputWithContext(ctx context.Context) ServiceCorrelationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceCorrelationArrayOutput)
}

// Creates a particular correlation between services.
type ServiceCorrelationOutput struct{ *pulumi.OutputState }

func (ServiceCorrelationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceCorrelation)(nil)).Elem()
}

func (o ServiceCorrelationOutput) ToServiceCorrelationOutput() ServiceCorrelationOutput {
	return o
}

func (o ServiceCorrelationOutput) ToServiceCorrelationOutputWithContext(ctx context.Context) ServiceCorrelationOutput {
	return o
}

// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
func (o ServiceCorrelationOutput) Scheme() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceCorrelation) string { return v.Scheme }).(pulumi.StringOutput)
}

// The Arm Resource ID of the service that the correlation relationship is established with.
func (o ServiceCorrelationOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceCorrelation) string { return v.ServiceName }).(pulumi.StringOutput)
}

type ServiceCorrelationArrayOutput struct{ *pulumi.OutputState }

func (ServiceCorrelationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceCorrelation)(nil)).Elem()
}

func (o ServiceCorrelationArrayOutput) ToServiceCorrelationArrayOutput() ServiceCorrelationArrayOutput {
	return o
}

func (o ServiceCorrelationArrayOutput) ToServiceCorrelationArrayOutputWithContext(ctx context.Context) ServiceCorrelationArrayOutput {
	return o
}

func (o ServiceCorrelationArrayOutput) Index(i pulumi.IntInput) ServiceCorrelationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceCorrelation {
		return vs[0].([]ServiceCorrelation)[vs[1].(int)]
	}).(ServiceCorrelationOutput)
}

// Creates a particular correlation between services.
type ServiceCorrelationResponse struct {
	// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
	Scheme string `pulumi:"scheme"`
	// The Arm Resource ID of the service that the correlation relationship is established with.
	ServiceName string `pulumi:"serviceName"`
}

// Creates a particular correlation between services.
type ServiceCorrelationResponseOutput struct{ *pulumi.OutputState }

func (ServiceCorrelationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceCorrelationResponse)(nil)).Elem()
}

func (o ServiceCorrelationResponseOutput) ToServiceCorrelationResponseOutput() ServiceCorrelationResponseOutput {
	return o
}

func (o ServiceCorrelationResponseOutput) ToServiceCorrelationResponseOutputWithContext(ctx context.Context) ServiceCorrelationResponseOutput {
	return o
}

// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
func (o ServiceCorrelationResponseOutput) Scheme() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceCorrelationResponse) string { return v.Scheme }).(pulumi.StringOutput)
}

// The Arm Resource ID of the service that the correlation relationship is established with.
func (o ServiceCorrelationResponseOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceCorrelationResponse) string { return v.ServiceName }).(pulumi.StringOutput)
}

type ServiceCorrelationResponseArrayOutput struct{ *pulumi.OutputState }

func (ServiceCorrelationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceCorrelationResponse)(nil)).Elem()
}

func (o ServiceCorrelationResponseArrayOutput) ToServiceCorrelationResponseArrayOutput() ServiceCorrelationResponseArrayOutput {
	return o
}

func (o ServiceCorrelationResponseArrayOutput) ToServiceCorrelationResponseArrayOutputWithContext(ctx context.Context) ServiceCorrelationResponseArrayOutput {
	return o
}

func (o ServiceCorrelationResponseArrayOutput) Index(i pulumi.IntInput) ServiceCorrelationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceCorrelationResponse {
		return vs[0].([]ServiceCorrelationResponse)[vs[1].(int)]
	}).(ServiceCorrelationResponseOutput)
}

// The service endpoint properties.
type ServiceEndpoint struct {
	// A list of locations.
	Locations []string `pulumi:"locations"`
	// The type of the endpoint service.
	Service string `pulumi:"service"`
}

// ServiceEndpointInput is an input type that accepts ServiceEndpointArgs and ServiceEndpointOutput values.
// You can construct a concrete instance of `ServiceEndpointInput` via:
//
//	ServiceEndpointArgs{...}
type ServiceEndpointInput interface {
	pulumi.Input

	ToServiceEndpointOutput() ServiceEndpointOutput
	ToServiceEndpointOutputWithContext(context.Context) ServiceEndpointOutput
}

// The service endpoint properties.
type ServiceEndpointArgs struct {
	// A list of locations.
	Locations pulumi.StringArrayInput `pulumi:"locations"`
	// The type of the endpoint service.
	Service pulumi.StringInput `pulumi:"service"`
}

func (ServiceEndpointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceEndpoint)(nil)).Elem()
}

func (i ServiceEndpointArgs) ToServiceEndpointOutput() ServiceEndpointOutput {
	return i.ToServiceEndpointOutputWithContext(context.Background())
}

func (i ServiceEndpointArgs) ToServiceEndpointOutputWithContext(ctx context.Context) ServiceEndpointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceEndpointOutput)
}

// ServiceEndpointArrayInput is an input type that accepts ServiceEndpointArray and ServiceEndpointArrayOutput values.
// You can construct a concrete instance of `ServiceEndpointArrayInput` via:
//
//	ServiceEndpointArray{ ServiceEndpointArgs{...} }
type ServiceEndpointArrayInput interface {
	pulumi.Input

	ToServiceEndpointArrayOutput() ServiceEndpointArrayOutput
	ToServiceEndpointArrayOutputWithContext(context.Context) ServiceEndpointArrayOutput
}

type ServiceEndpointArray []ServiceEndpointInput

func (ServiceEndpointArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceEndpoint)(nil)).Elem()
}

func (i ServiceEndpointArray) ToServiceEndpointArrayOutput() ServiceEndpointArrayOutput {
	return i.ToServiceEndpointArrayOutputWithContext(context.Background())
}

func (i ServiceEndpointArray) ToServiceEndpointArrayOutputWithContext(ctx context.Context) ServiceEndpointArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceEndpointArrayOutput)
}

// The service endpoint properties.
type ServiceEndpointOutput struct{ *pulumi.OutputState }

func (ServiceEndpointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceEndpoint)(nil)).Elem()
}

func (o ServiceEndpointOutput) ToServiceEndpointOutput() ServiceEndpointOutput {
	return o
}

func (o ServiceEndpointOutput) ToServiceEndpointOutputWithContext(ctx context.Context) ServiceEndpointOutput {
	return o
}

// A list of locations.
func (o ServiceEndpointOutput) Locations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServiceEndpoint) []string { return v.Locations }).(pulumi.StringArrayOutput)
}

// The type of the endpoint service.
func (o ServiceEndpointOutput) Service() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceEndpoint) string { return v.Service }).(pulumi.StringOutput)
}

type ServiceEndpointArrayOutput struct{ *pulumi.OutputState }

func (ServiceEndpointArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceEndpoint)(nil)).Elem()
}

func (o ServiceEndpointArrayOutput) ToServiceEndpointArrayOutput() ServiceEndpointArrayOutput {
	return o
}

func (o ServiceEndpointArrayOutput) ToServiceEndpointArrayOutputWithContext(ctx context.Context) ServiceEndpointArrayOutput {
	return o
}

func (o ServiceEndpointArrayOutput) Index(i pulumi.IntInput) ServiceEndpointOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceEndpoint {
		return vs[0].([]ServiceEndpoint)[vs[1].(int)]
	}).(ServiceEndpointOutput)
}

// The service endpoint properties.
type ServiceEndpointResponse struct {
	// A list of locations.
	Locations []string `pulumi:"locations"`
	// The type of the endpoint service.
	Service string `pulumi:"service"`
}

// The service endpoint properties.
type ServiceEndpointResponseOutput struct{ *pulumi.OutputState }

func (ServiceEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceEndpointResponse)(nil)).Elem()
}

func (o ServiceEndpointResponseOutput) ToServiceEndpointResponseOutput() ServiceEndpointResponseOutput {
	return o
}

func (o ServiceEndpointResponseOutput) ToServiceEndpointResponseOutputWithContext(ctx context.Context) ServiceEndpointResponseOutput {
	return o
}

// A list of locations.
func (o ServiceEndpointResponseOutput) Locations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServiceEndpointResponse) []string { return v.Locations }).(pulumi.StringArrayOutput)
}

// The type of the endpoint service.
func (o ServiceEndpointResponseOutput) Service() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceEndpointResponse) string { return v.Service }).(pulumi.StringOutput)
}

type ServiceEndpointResponseArrayOutput struct{ *pulumi.OutputState }

func (ServiceEndpointResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceEndpointResponse)(nil)).Elem()
}

func (o ServiceEndpointResponseArrayOutput) ToServiceEndpointResponseArrayOutput() ServiceEndpointResponseArrayOutput {
	return o
}

func (o ServiceEndpointResponseArrayOutput) ToServiceEndpointResponseArrayOutputWithContext(ctx context.Context) ServiceEndpointResponseArrayOutput {
	return o
}

func (o ServiceEndpointResponseArrayOutput) Index(i pulumi.IntInput) ServiceEndpointResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceEndpointResponse {
		return vs[0].([]ServiceEndpointResponse)[vs[1].(int)]
	}).(ServiceEndpointResponseOutput)
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetric struct {
	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad *int `pulumi:"defaultLoad"`
	// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
	Name string `pulumi:"name"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
	PrimaryDefaultLoad *int `pulumi:"primaryDefaultLoad"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
	SecondaryDefaultLoad *int `pulumi:"secondaryDefaultLoad"`
	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight *string `pulumi:"weight"`
}

// ServiceLoadMetricInput is an input type that accepts ServiceLoadMetricArgs and ServiceLoadMetricOutput values.
// You can construct a concrete instance of `ServiceLoadMetricInput` via:
//
//	ServiceLoadMetricArgs{...}
type ServiceLoadMetricInput interface {
	pulumi.Input

	ToServiceLoadMetricOutput() ServiceLoadMetricOutput
	ToServiceLoadMetricOutputWithContext(context.Context) ServiceLoadMetricOutput
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetricArgs struct {
	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad pulumi.IntPtrInput `pulumi:"defaultLoad"`
	// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
	Name pulumi.StringInput `pulumi:"name"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
	PrimaryDefaultLoad pulumi.IntPtrInput `pulumi:"primaryDefaultLoad"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
	SecondaryDefaultLoad pulumi.IntPtrInput `pulumi:"secondaryDefaultLoad"`
	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight pulumi.StringPtrInput `pulumi:"weight"`
}

func (ServiceLoadMetricArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLoadMetric)(nil)).Elem()
}

func (i ServiceLoadMetricArgs) ToServiceLoadMetricOutput() ServiceLoadMetricOutput {
	return i.ToServiceLoadMetricOutputWithContext(context.Background())
}

func (i ServiceLoadMetricArgs) ToServiceLoadMetricOutputWithContext(ctx context.Context) ServiceLoadMetricOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLoadMetricOutput)
}

// ServiceLoadMetricArrayInput is an input type that accepts ServiceLoadMetricArray and ServiceLoadMetricArrayOutput values.
// You can construct a concrete instance of `ServiceLoadMetricArrayInput` via:
//
//	ServiceLoadMetricArray{ ServiceLoadMetricArgs{...} }
type ServiceLoadMetricArrayInput interface {
	pulumi.Input

	ToServiceLoadMetricArrayOutput() ServiceLoadMetricArrayOutput
	ToServiceLoadMetricArrayOutputWithContext(context.Context) ServiceLoadMetricArrayOutput
}

type ServiceLoadMetricArray []ServiceLoadMetricInput

func (ServiceLoadMetricArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceLoadMetric)(nil)).Elem()
}

func (i ServiceLoadMetricArray) ToServiceLoadMetricArrayOutput() ServiceLoadMetricArrayOutput {
	return i.ToServiceLoadMetricArrayOutputWithContext(context.Background())
}

func (i ServiceLoadMetricArray) ToServiceLoadMetricArrayOutputWithContext(ctx context.Context) ServiceLoadMetricArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLoadMetricArrayOutput)
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetricOutput struct{ *pulumi.OutputState }

func (ServiceLoadMetricOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLoadMetric)(nil)).Elem()
}

func (o ServiceLoadMetricOutput) ToServiceLoadMetricOutput() ServiceLoadMetricOutput {
	return o
}

func (o ServiceLoadMetricOutput) ToServiceLoadMetricOutputWithContext(ctx context.Context) ServiceLoadMetricOutput {
	return o
}

// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
func (o ServiceLoadMetricOutput) DefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetric) *int { return v.DefaultLoad }).(pulumi.IntPtrOutput)
}

// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
func (o ServiceLoadMetricOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceLoadMetric) string { return v.Name }).(pulumi.StringOutput)
}

// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
func (o ServiceLoadMetricOutput) PrimaryDefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetric) *int { return v.PrimaryDefaultLoad }).(pulumi.IntPtrOutput)
}

// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
func (o ServiceLoadMetricOutput) SecondaryDefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetric) *int { return v.SecondaryDefaultLoad }).(pulumi.IntPtrOutput)
}

// The service load metric relative weight, compared to other metrics configured for this service, as a number.
func (o ServiceLoadMetricOutput) Weight() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetric) *string { return v.Weight }).(pulumi.StringPtrOutput)
}

type ServiceLoadMetricArrayOutput struct{ *pulumi.OutputState }

func (ServiceLoadMetricArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceLoadMetric)(nil)).Elem()
}

func (o ServiceLoadMetricArrayOutput) ToServiceLoadMetricArrayOutput() ServiceLoadMetricArrayOutput {
	return o
}

func (o ServiceLoadMetricArrayOutput) ToServiceLoadMetricArrayOutputWithContext(ctx context.Context) ServiceLoadMetricArrayOutput {
	return o
}

func (o ServiceLoadMetricArrayOutput) Index(i pulumi.IntInput) ServiceLoadMetricOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceLoadMetric {
		return vs[0].([]ServiceLoadMetric)[vs[1].(int)]
	}).(ServiceLoadMetricOutput)
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetricResponse struct {
	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad *int `pulumi:"defaultLoad"`
	// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
	Name string `pulumi:"name"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
	PrimaryDefaultLoad *int `pulumi:"primaryDefaultLoad"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
	SecondaryDefaultLoad *int `pulumi:"secondaryDefaultLoad"`
	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight *string `pulumi:"weight"`
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetricResponseOutput struct{ *pulumi.OutputState }

func (ServiceLoadMetricResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLoadMetricResponse)(nil)).Elem()
}

func (o ServiceLoadMetricResponseOutput) ToServiceLoadMetricResponseOutput() ServiceLoadMetricResponseOutput {
	return o
}

func (o ServiceLoadMetricResponseOutput) ToServiceLoadMetricResponseOutputWithContext(ctx context.Context) ServiceLoadMetricResponseOutput {
	return o
}

// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
func (o ServiceLoadMetricResponseOutput) DefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetricResponse) *int { return v.DefaultLoad }).(pulumi.IntPtrOutput)
}

// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
func (o ServiceLoadMetricResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceLoadMetricResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
func (o ServiceLoadMetricResponseOutput) PrimaryDefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetricResponse) *int { return v.PrimaryDefaultLoad }).(pulumi.IntPtrOutput)
}

// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
func (o ServiceLoadMetricResponseOutput) SecondaryDefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetricResponse) *int { return v.SecondaryDefaultLoad }).(pulumi.IntPtrOutput)
}

// The service load metric relative weight, compared to other metrics configured for this service, as a number.
func (o ServiceLoadMetricResponseOutput) Weight() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetricResponse) *string { return v.Weight }).(pulumi.StringPtrOutput)
}

type ServiceLoadMetricResponseArrayOutput struct{ *pulumi.OutputState }

func (ServiceLoadMetricResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceLoadMetricResponse)(nil)).Elem()
}

func (o ServiceLoadMetricResponseArrayOutput) ToServiceLoadMetricResponseArrayOutput() ServiceLoadMetricResponseArrayOutput {
	return o
}

func (o ServiceLoadMetricResponseArrayOutput) ToServiceLoadMetricResponseArrayOutputWithContext(ctx context.Context) ServiceLoadMetricResponseArrayOutput {
	return o
}

func (o ServiceLoadMetricResponseArrayOutput) Index(i pulumi.IntInput) ServiceLoadMetricResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceLoadMetricResponse {
		return vs[0].([]ServiceLoadMetricResponse)[vs[1].(int)]
	}).(ServiceLoadMetricResponseOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicy struct {
	// The name of the domain that should not be used for placement.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'InvalidDomain'.
	Type string `pulumi:"type"`
}

// ServicePlacementInvalidDomainPolicyInput is an input type that accepts ServicePlacementInvalidDomainPolicyArgs and ServicePlacementInvalidDomainPolicyOutput values.
// You can construct a concrete instance of `ServicePlacementInvalidDomainPolicyInput` via:
//
//	ServicePlacementInvalidDomainPolicyArgs{...}
type ServicePlacementInvalidDomainPolicyInput interface {
	pulumi.Input

	ToServicePlacementInvalidDomainPolicyOutput() ServicePlacementInvalidDomainPolicyOutput
	ToServicePlacementInvalidDomainPolicyOutputWithContext(context.Context) ServicePlacementInvalidDomainPolicyOutput
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicyArgs struct {
	// The name of the domain that should not be used for placement.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'InvalidDomain'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementInvalidDomainPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementInvalidDomainPolicy)(nil)).Elem()
}

func (i ServicePlacementInvalidDomainPolicyArgs) ToServicePlacementInvalidDomainPolicyOutput() ServicePlacementInvalidDomainPolicyOutput {
	return i.ToServicePlacementInvalidDomainPolicyOutputWithContext(context.Background())
}

func (i ServicePlacementInvalidDomainPolicyArgs) ToServicePlacementInvalidDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementInvalidDomainPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementInvalidDomainPolicyOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicyOutput struct{ *pulumi.OutputState }

func (ServicePlacementInvalidDomainPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementInvalidDomainPolicy)(nil)).Elem()
}

func (o ServicePlacementInvalidDomainPolicyOutput) ToServicePlacementInvalidDomainPolicyOutput() ServicePlacementInvalidDomainPolicyOutput {
	return o
}

func (o ServicePlacementInvalidDomainPolicyOutput) ToServicePlacementInvalidDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementInvalidDomainPolicyOutput {
	return o
}

// The name of the domain that should not be used for placement.
func (o ServicePlacementInvalidDomainPolicyOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementInvalidDomainPolicy) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'InvalidDomain'.
func (o ServicePlacementInvalidDomainPolicyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementInvalidDomainPolicy) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicyResponse struct {
	// The name of the domain that should not be used for placement.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'InvalidDomain'.
	Type string `pulumi:"type"`
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicyResponseOutput struct{ *pulumi.OutputState }

func (ServicePlacementInvalidDomainPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementInvalidDomainPolicyResponse)(nil)).Elem()
}

func (o ServicePlacementInvalidDomainPolicyResponseOutput) ToServicePlacementInvalidDomainPolicyResponseOutput() ServicePlacementInvalidDomainPolicyResponseOutput {
	return o
}

func (o ServicePlacementInvalidDomainPolicyResponseOutput) ToServicePlacementInvalidDomainPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementInvalidDomainPolicyResponseOutput {
	return o
}

// The name of the domain that should not be used for placement.
func (o ServicePlacementInvalidDomainPolicyResponseOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementInvalidDomainPolicyResponse) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'InvalidDomain'.
func (o ServicePlacementInvalidDomainPolicyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementInvalidDomainPolicyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicy struct {
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'NonPartiallyPlaceService'.
	Type string `pulumi:"type"`
}

// ServicePlacementNonPartiallyPlaceServicePolicyInput is an input type that accepts ServicePlacementNonPartiallyPlaceServicePolicyArgs and ServicePlacementNonPartiallyPlaceServicePolicyOutput values.
// You can construct a concrete instance of `ServicePlacementNonPartiallyPlaceServicePolicyInput` via:
//
//	ServicePlacementNonPartiallyPlaceServicePolicyArgs{...}
type ServicePlacementNonPartiallyPlaceServicePolicyInput interface {
	pulumi.Input

	ToServicePlacementNonPartiallyPlaceServicePolicyOutput() ServicePlacementNonPartiallyPlaceServicePolicyOutput
	ToServicePlacementNonPartiallyPlaceServicePolicyOutputWithContext(context.Context) ServicePlacementNonPartiallyPlaceServicePolicyOutput
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicyArgs struct {
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'NonPartiallyPlaceService'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementNonPartiallyPlaceServicePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementNonPartiallyPlaceServicePolicy)(nil)).Elem()
}

func (i ServicePlacementNonPartiallyPlaceServicePolicyArgs) ToServicePlacementNonPartiallyPlaceServicePolicyOutput() ServicePlacementNonPartiallyPlaceServicePolicyOutput {
	return i.ToServicePlacementNonPartiallyPlaceServicePolicyOutputWithContext(context.Background())
}

func (i ServicePlacementNonPartiallyPlaceServicePolicyArgs) ToServicePlacementNonPartiallyPlaceServicePolicyOutputWithContext(ctx context.Context) ServicePlacementNonPartiallyPlaceServicePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementNonPartiallyPlaceServicePolicyOutput)
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicyOutput struct{ *pulumi.OutputState }

func (ServicePlacementNonPartiallyPlaceServicePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementNonPartiallyPlaceServicePolicy)(nil)).Elem()
}

func (o ServicePlacementNonPartiallyPlaceServicePolicyOutput) ToServicePlacementNonPartiallyPlaceServicePolicyOutput() ServicePlacementNonPartiallyPlaceServicePolicyOutput {
	return o
}

func (o ServicePlacementNonPartiallyPlaceServicePolicyOutput) ToServicePlacementNonPartiallyPlaceServicePolicyOutputWithContext(ctx context.Context) ServicePlacementNonPartiallyPlaceServicePolicyOutput {
	return o
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'NonPartiallyPlaceService'.
func (o ServicePlacementNonPartiallyPlaceServicePolicyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementNonPartiallyPlaceServicePolicy) string { return v.Type }).(pulumi.StringOutput)
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicyResponse struct {
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'NonPartiallyPlaceService'.
	Type string `pulumi:"type"`
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput struct{ *pulumi.OutputState }

func (ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementNonPartiallyPlaceServicePolicyResponse)(nil)).Elem()
}

func (o ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput) ToServicePlacementNonPartiallyPlaceServicePolicyResponseOutput() ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput {
	return o
}

func (o ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput) ToServicePlacementNonPartiallyPlaceServicePolicyResponseOutputWithContext(ctx context.Context) ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput {
	return o
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'NonPartiallyPlaceService'.
func (o ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementNonPartiallyPlaceServicePolicyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicy struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'PreferredPrimaryDomain'.
	Type string `pulumi:"type"`
}

// ServicePlacementPreferPrimaryDomainPolicyInput is an input type that accepts ServicePlacementPreferPrimaryDomainPolicyArgs and ServicePlacementPreferPrimaryDomainPolicyOutput values.
// You can construct a concrete instance of `ServicePlacementPreferPrimaryDomainPolicyInput` via:
//
//	ServicePlacementPreferPrimaryDomainPolicyArgs{...}
type ServicePlacementPreferPrimaryDomainPolicyInput interface {
	pulumi.Input

	ToServicePlacementPreferPrimaryDomainPolicyOutput() ServicePlacementPreferPrimaryDomainPolicyOutput
	ToServicePlacementPreferPrimaryDomainPolicyOutputWithContext(context.Context) ServicePlacementPreferPrimaryDomainPolicyOutput
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicyArgs struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'PreferredPrimaryDomain'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementPreferPrimaryDomainPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementPreferPrimaryDomainPolicy)(nil)).Elem()
}

func (i ServicePlacementPreferPrimaryDomainPolicyArgs) ToServicePlacementPreferPrimaryDomainPolicyOutput() ServicePlacementPreferPrimaryDomainPolicyOutput {
	return i.ToServicePlacementPreferPrimaryDomainPolicyOutputWithContext(context.Background())
}

func (i ServicePlacementPreferPrimaryDomainPolicyArgs) ToServicePlacementPreferPrimaryDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementPreferPrimaryDomainPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementPreferPrimaryDomainPolicyOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicyOutput struct{ *pulumi.OutputState }

func (ServicePlacementPreferPrimaryDomainPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementPreferPrimaryDomainPolicy)(nil)).Elem()
}

func (o ServicePlacementPreferPrimaryDomainPolicyOutput) ToServicePlacementPreferPrimaryDomainPolicyOutput() ServicePlacementPreferPrimaryDomainPolicyOutput {
	return o
}

func (o ServicePlacementPreferPrimaryDomainPolicyOutput) ToServicePlacementPreferPrimaryDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementPreferPrimaryDomainPolicyOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementPreferPrimaryDomainPolicyOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementPreferPrimaryDomainPolicy) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'PreferredPrimaryDomain'.
func (o ServicePlacementPreferPrimaryDomainPolicyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementPreferPrimaryDomainPolicy) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicyResponse struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'PreferredPrimaryDomain'.
	Type string `pulumi:"type"`
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicyResponseOutput struct{ *pulumi.OutputState }

func (ServicePlacementPreferPrimaryDomainPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementPreferPrimaryDomainPolicyResponse)(nil)).Elem()
}

func (o ServicePlacementPreferPrimaryDomainPolicyResponseOutput) ToServicePlacementPreferPrimaryDomainPolicyResponseOutput() ServicePlacementPreferPrimaryDomainPolicyResponseOutput {
	return o
}

func (o ServicePlacementPreferPrimaryDomainPolicyResponseOutput) ToServicePlacementPreferPrimaryDomainPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementPreferPrimaryDomainPolicyResponseOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementPreferPrimaryDomainPolicyResponseOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementPreferPrimaryDomainPolicyResponse) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'PreferredPrimaryDomain'.
func (o ServicePlacementPreferPrimaryDomainPolicyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementPreferPrimaryDomainPolicyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicy struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomainDistribution'.
	Type string `pulumi:"type"`
}

// ServicePlacementRequireDomainDistributionPolicyInput is an input type that accepts ServicePlacementRequireDomainDistributionPolicyArgs and ServicePlacementRequireDomainDistributionPolicyOutput values.
// You can construct a concrete instance of `ServicePlacementRequireDomainDistributionPolicyInput` via:
//
//	ServicePlacementRequireDomainDistributionPolicyArgs{...}
type ServicePlacementRequireDomainDistributionPolicyInput interface {
	pulumi.Input

	ToServicePlacementRequireDomainDistributionPolicyOutput() ServicePlacementRequireDomainDistributionPolicyOutput
	ToServicePlacementRequireDomainDistributionPolicyOutputWithContext(context.Context) ServicePlacementRequireDomainDistributionPolicyOutput
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicyArgs struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomainDistribution'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementRequireDomainDistributionPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequireDomainDistributionPolicy)(nil)).Elem()
}

func (i ServicePlacementRequireDomainDistributionPolicyArgs) ToServicePlacementRequireDomainDistributionPolicyOutput() ServicePlacementRequireDomainDistributionPolicyOutput {
	return i.ToServicePlacementRequireDomainDistributionPolicyOutputWithContext(context.Background())
}

func (i ServicePlacementRequireDomainDistributionPolicyArgs) ToServicePlacementRequireDomainDistributionPolicyOutputWithContext(ctx context.Context) ServicePlacementRequireDomainDistributionPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementRequireDomainDistributionPolicyOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicyOutput struct{ *pulumi.OutputState }

func (ServicePlacementRequireDomainDistributionPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequireDomainDistributionPolicy)(nil)).Elem()
}

func (o ServicePlacementRequireDomainDistributionPolicyOutput) ToServicePlacementRequireDomainDistributionPolicyOutput() ServicePlacementRequireDomainDistributionPolicyOutput {
	return o
}

func (o ServicePlacementRequireDomainDistributionPolicyOutput) ToServicePlacementRequireDomainDistributionPolicyOutputWithContext(ctx context.Context) ServicePlacementRequireDomainDistributionPolicyOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementRequireDomainDistributionPolicyOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequireDomainDistributionPolicy) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'RequiredDomainDistribution'.
func (o ServicePlacementRequireDomainDistributionPolicyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequireDomainDistributionPolicy) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicyResponse struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomainDistribution'.
	Type string `pulumi:"type"`
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicyResponseOutput struct{ *pulumi.OutputState }

func (ServicePlacementRequireDomainDistributionPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequireDomainDistributionPolicyResponse)(nil)).Elem()
}

func (o ServicePlacementRequireDomainDistributionPolicyResponseOutput) ToServicePlacementRequireDomainDistributionPolicyResponseOutput() ServicePlacementRequireDomainDistributionPolicyResponseOutput {
	return o
}

func (o ServicePlacementRequireDomainDistributionPolicyResponseOutput) ToServicePlacementRequireDomainDistributionPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementRequireDomainDistributionPolicyResponseOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementRequireDomainDistributionPolicyResponseOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequireDomainDistributionPolicyResponse) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'RequiredDomainDistribution'.
func (o ServicePlacementRequireDomainDistributionPolicyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequireDomainDistributionPolicyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicy struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomain'.
	Type string `pulumi:"type"`
}

// ServicePlacementRequiredDomainPolicyInput is an input type that accepts ServicePlacementRequiredDomainPolicyArgs and ServicePlacementRequiredDomainPolicyOutput values.
// You can construct a concrete instance of `ServicePlacementRequiredDomainPolicyInput` via:
//
//	ServicePlacementRequiredDomainPolicyArgs{...}
type ServicePlacementRequiredDomainPolicyInput interface {
	pulumi.Input

	ToServicePlacementRequiredDomainPolicyOutput() ServicePlacementRequiredDomainPolicyOutput
	ToServicePlacementRequiredDomainPolicyOutputWithContext(context.Context) ServicePlacementRequiredDomainPolicyOutput
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicyArgs struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomain'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementRequiredDomainPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequiredDomainPolicy)(nil)).Elem()
}

func (i ServicePlacementRequiredDomainPolicyArgs) ToServicePlacementRequiredDomainPolicyOutput() ServicePlacementRequiredDomainPolicyOutput {
	return i.ToServicePlacementRequiredDomainPolicyOutputWithContext(context.Background())
}

func (i ServicePlacementRequiredDomainPolicyArgs) ToServicePlacementRequiredDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementRequiredDomainPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementRequiredDomainPolicyOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicyOutput struct{ *pulumi.OutputState }

func (ServicePlacementRequiredDomainPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequiredDomainPolicy)(nil)).Elem()
}

func (o ServicePlacementRequiredDomainPolicyOutput) ToServicePlacementRequiredDomainPolicyOutput() ServicePlacementRequiredDomainPolicyOutput {
	return o
}

func (o ServicePlacementRequiredDomainPolicyOutput) ToServicePlacementRequiredDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementRequiredDomainPolicyOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementRequiredDomainPolicyOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequiredDomainPolicy) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'RequiredDomain'.
func (o ServicePlacementRequiredDomainPolicyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequiredDomainPolicy) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicyResponse struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomain'.
	Type string `pulumi:"type"`
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicyResponseOutput struct{ *pulumi.OutputState }

func (ServicePlacementRequiredDomainPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequiredDomainPolicyResponse)(nil)).Elem()
}

func (o ServicePlacementRequiredDomainPolicyResponseOutput) ToServicePlacementRequiredDomainPolicyResponseOutput() ServicePlacementRequiredDomainPolicyResponseOutput {
	return o
}

func (o ServicePlacementRequiredDomainPolicyResponseOutput) ToServicePlacementRequiredDomainPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementRequiredDomainPolicyResponseOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementRequiredDomainPolicyResponseOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequiredDomainPolicyResponse) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'RequiredDomain'.
func (o ServicePlacementRequiredDomainPolicyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequiredDomainPolicyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicy struct {
	// The maximum allowed percentage of unhealthy partitions per service.
	//
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService int `pulumi:"maxPercentUnhealthyPartitionsPerService"`
	// The maximum allowed percentage of unhealthy replicas per partition.
	//
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition int `pulumi:"maxPercentUnhealthyReplicasPerPartition"`
	// The maximum allowed percentage of unhealthy services.
	//
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices int `pulumi:"maxPercentUnhealthyServices"`
}

// ServiceTypeHealthPolicyInput is an input type that accepts ServiceTypeHealthPolicyArgs and ServiceTypeHealthPolicyOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyInput` via:
//
//	ServiceTypeHealthPolicyArgs{...}
type ServiceTypeHealthPolicyInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyOutput() ServiceTypeHealthPolicyOutput
	ToServiceTypeHealthPolicyOutputWithContext(context.Context) ServiceTypeHealthPolicyOutput
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyArgs struct {
	// The maximum allowed percentage of unhealthy partitions per service.
	//
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService pulumi.IntInput `pulumi:"maxPercentUnhealthyPartitionsPerService"`
	// The maximum allowed percentage of unhealthy replicas per partition.
	//
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition pulumi.IntInput `pulumi:"maxPercentUnhealthyReplicasPerPartition"`
	// The maximum allowed percentage of unhealthy services.
	//
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices pulumi.IntInput `pulumi:"maxPercentUnhealthyServices"`
}

func (ServiceTypeHealthPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceTypeHealthPolicy)(nil)).Elem()
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyOutput() ServiceTypeHealthPolicyOutput {
	return i.ToServiceTypeHealthPolicyOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyOutput)
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return i.ToServiceTypeHealthPolicyPtrOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyOutput).ToServiceTypeHealthPolicyPtrOutputWithContext(ctx)
}

// ServiceTypeHealthPolicyPtrInput is an input type that accepts ServiceTypeHealthPolicyArgs, ServiceTypeHealthPolicyPtr and ServiceTypeHealthPolicyPtrOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyPtrInput` via:
//
//	        ServiceTypeHealthPolicyArgs{...}
//
//	or:
//
//	        nil
type ServiceTypeHealthPolicyPtrInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput
	ToServiceTypeHealthPolicyPtrOutputWithContext(context.Context) ServiceTypeHealthPolicyPtrOutput
}

type serviceTypeHealthPolicyPtrType ServiceTypeHealthPolicyArgs

func ServiceTypeHealthPolicyPtr(v *ServiceTypeHealthPolicyArgs) ServiceTypeHealthPolicyPtrInput {
	return (*serviceTypeHealthPolicyPtrType)(v)
}

func (*serviceTypeHealthPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceTypeHealthPolicy)(nil)).Elem()
}

func (i *serviceTypeHealthPolicyPtrType) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return i.ToServiceTypeHealthPolicyPtrOutputWithContext(context.Background())
}

func (i *serviceTypeHealthPolicyPtrType) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyPtrOutput)
}

// ServiceTypeHealthPolicyMapInput is an input type that accepts ServiceTypeHealthPolicyMap and ServiceTypeHealthPolicyMapOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyMapInput` via:
//
//	ServiceTypeHealthPolicyMap{ "key": ServiceTypeHealthPolicyArgs{...} }
type ServiceTypeHealthPolicyMapInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyMapOutput() ServiceTypeHealthPolicyMapOutput
	ToServiceTypeHealthPolicyMapOutputWithContext(context.Context) ServiceTypeHealthPolicyMapOutput
}

type ServiceTypeHealthPolicyMap map[string]ServiceTypeHealthPolicyInput

func (ServiceTypeHealthPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ServiceTypeHealthPolicy)(nil)).Elem()
}

func (i ServiceTypeHealthPolicyMap) ToServiceTypeHealthPolicyMapOutput() ServiceTypeHealthPolicyMapOutput {
	return i.ToServiceTypeHealthPolicyMapOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyMap) ToServiceTypeHealthPolicyMapOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyMapOutput)
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceTypeHealthPolicy)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyOutput() ServiceTypeHealthPolicyOutput {
	return o
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyOutput {
	return o
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return o.ToServiceTypeHealthPolicyPtrOutputWithContext(context.Background())
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServiceTypeHealthPolicy) *ServiceTypeHealthPolicy {
		return &v
	}).(ServiceTypeHealthPolicyPtrOutput)
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicy) int { return v.MaxPercentUnhealthyPartitionsPerService }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicy) int { return v.MaxPercentUnhealthyReplicasPerPartition }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyOutput) MaxPercentUnhealthyServices() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicy) int { return v.MaxPercentUnhealthyServices }).(pulumi.IntOutput)
}

type ServiceTypeHealthPolicyPtrOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceTypeHealthPolicy)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyPtrOutput) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyPtrOutput) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyPtrOutput) Elem() ServiceTypeHealthPolicyOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) ServiceTypeHealthPolicy {
		if v != nil {
			return *v
		}
		var ret ServiceTypeHealthPolicy
		return ret
	}).(ServiceTypeHealthPolicyOutput)
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyPtrOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyPartitionsPerService
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyPtrOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyReplicasPerPartition
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyPtrOutput) MaxPercentUnhealthyServices() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyServices
	}).(pulumi.IntPtrOutput)
}

type ServiceTypeHealthPolicyMapOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ServiceTypeHealthPolicy)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyMapOutput) ToServiceTypeHealthPolicyMapOutput() ServiceTypeHealthPolicyMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyMapOutput) ToServiceTypeHealthPolicyMapOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyMapOutput) MapIndex(k pulumi.StringInput) ServiceTypeHealthPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) ServiceTypeHealthPolicy {
		return vs[0].(map[string]ServiceTypeHealthPolicy)[vs[1].(string)]
	}).(ServiceTypeHealthPolicyOutput)
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyResponse struct {
	// The maximum allowed percentage of unhealthy partitions per service.
	//
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService int `pulumi:"maxPercentUnhealthyPartitionsPerService"`
	// The maximum allowed percentage of unhealthy replicas per partition.
	//
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition int `pulumi:"maxPercentUnhealthyReplicasPerPartition"`
	// The maximum allowed percentage of unhealthy services.
	//
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices int `pulumi:"maxPercentUnhealthyServices"`
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyResponseOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyResponseOutput) ToServiceTypeHealthPolicyResponseOutput() ServiceTypeHealthPolicyResponseOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponseOutput) ToServiceTypeHealthPolicyResponseOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponseOutput {
	return o
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyResponseOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicyResponse) int { return v.MaxPercentUnhealthyPartitionsPerService }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyResponseOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicyResponse) int { return v.MaxPercentUnhealthyReplicasPerPartition }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyResponseOutput) MaxPercentUnhealthyServices() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicyResponse) int { return v.MaxPercentUnhealthyServices }).(pulumi.IntOutput)
}

type ServiceTypeHealthPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyResponsePtrOutput) ToServiceTypeHealthPolicyResponsePtrOutput() ServiceTypeHealthPolicyResponsePtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponsePtrOutput) ToServiceTypeHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponsePtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponsePtrOutput) Elem() ServiceTypeHealthPolicyResponseOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) ServiceTypeHealthPolicyResponse {
		if v != nil {
			return *v
		}
		var ret ServiceTypeHealthPolicyResponse
		return ret
	}).(ServiceTypeHealthPolicyResponseOutput)
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyResponsePtrOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyPartitionsPerService
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyResponsePtrOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyReplicasPerPartition
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyResponsePtrOutput) MaxPercentUnhealthyServices() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyServices
	}).(pulumi.IntPtrOutput)
}

type ServiceTypeHealthPolicyResponseMapOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyResponseMapOutput) ToServiceTypeHealthPolicyResponseMapOutput() ServiceTypeHealthPolicyResponseMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponseMapOutput) ToServiceTypeHealthPolicyResponseMapOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponseMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponseMapOutput) MapIndex(k pulumi.StringInput) ServiceTypeHealthPolicyResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) ServiceTypeHealthPolicyResponse {
		return vs[0].(map[string]ServiceTypeHealthPolicyResponse)[vs[1].(string)]
	}).(ServiceTypeHealthPolicyResponseOutput)
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescription struct {
	// The parameter name of fabric setting.
	Name string `pulumi:"name"`
	// The parameter value of fabric setting.
	Value string `pulumi:"value"`
}

// SettingsParameterDescriptionInput is an input type that accepts SettingsParameterDescriptionArgs and SettingsParameterDescriptionOutput values.
// You can construct a concrete instance of `SettingsParameterDescriptionInput` via:
//
//	SettingsParameterDescriptionArgs{...}
type SettingsParameterDescriptionInput interface {
	pulumi.Input

	ToSettingsParameterDescriptionOutput() SettingsParameterDescriptionOutput
	ToSettingsParameterDescriptionOutputWithContext(context.Context) SettingsParameterDescriptionOutput
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionArgs struct {
	// The parameter name of fabric setting.
	Name pulumi.StringInput `pulumi:"name"`
	// The parameter value of fabric setting.
	Value pulumi.StringInput `pulumi:"value"`
}

func (SettingsParameterDescriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsParameterDescription)(nil)).Elem()
}

func (i SettingsParameterDescriptionArgs) ToSettingsParameterDescriptionOutput() SettingsParameterDescriptionOutput {
	return i.ToSettingsParameterDescriptionOutputWithContext(context.Background())
}

func (i SettingsParameterDescriptionArgs) ToSettingsParameterDescriptionOutputWithContext(ctx context.Context) SettingsParameterDescriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsParameterDescriptionOutput)
}

// SettingsParameterDescriptionArrayInput is an input type that accepts SettingsParameterDescriptionArray and SettingsParameterDescriptionArrayOutput values.
// You can construct a concrete instance of `SettingsParameterDescriptionArrayInput` via:
//
//	SettingsParameterDescriptionArray{ SettingsParameterDescriptionArgs{...} }
type SettingsParameterDescriptionArrayInput interface {
	pulumi.Input

	ToSettingsParameterDescriptionArrayOutput() SettingsParameterDescriptionArrayOutput
	ToSettingsParameterDescriptionArrayOutputWithContext(context.Context) SettingsParameterDescriptionArrayOutput
}

type SettingsParameterDescriptionArray []SettingsParameterDescriptionInput

func (SettingsParameterDescriptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsParameterDescription)(nil)).Elem()
}

func (i SettingsParameterDescriptionArray) ToSettingsParameterDescriptionArrayOutput() SettingsParameterDescriptionArrayOutput {
	return i.ToSettingsParameterDescriptionArrayOutputWithContext(context.Background())
}

func (i SettingsParameterDescriptionArray) ToSettingsParameterDescriptionArrayOutputWithContext(ctx context.Context) SettingsParameterDescriptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsParameterDescriptionArrayOutput)
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsParameterDescription)(nil)).Elem()
}

func (o SettingsParameterDescriptionOutput) ToSettingsParameterDescriptionOutput() SettingsParameterDescriptionOutput {
	return o
}

func (o SettingsParameterDescriptionOutput) ToSettingsParameterDescriptionOutputWithContext(ctx context.Context) SettingsParameterDescriptionOutput {
	return o
}

// The parameter name of fabric setting.
func (o SettingsParameterDescriptionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescription) string { return v.Name }).(pulumi.StringOutput)
}

// The parameter value of fabric setting.
func (o SettingsParameterDescriptionOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescription) string { return v.Value }).(pulumi.StringOutput)
}

type SettingsParameterDescriptionArrayOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsParameterDescription)(nil)).Elem()
}

func (o SettingsParameterDescriptionArrayOutput) ToSettingsParameterDescriptionArrayOutput() SettingsParameterDescriptionArrayOutput {
	return o
}

func (o SettingsParameterDescriptionArrayOutput) ToSettingsParameterDescriptionArrayOutputWithContext(ctx context.Context) SettingsParameterDescriptionArrayOutput {
	return o
}

func (o SettingsParameterDescriptionArrayOutput) Index(i pulumi.IntInput) SettingsParameterDescriptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsParameterDescription {
		return vs[0].([]SettingsParameterDescription)[vs[1].(int)]
	}).(SettingsParameterDescriptionOutput)
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionResponse struct {
	// The parameter name of fabric setting.
	Name string `pulumi:"name"`
	// The parameter value of fabric setting.
	Value string `pulumi:"value"`
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionResponseOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsParameterDescriptionResponse)(nil)).Elem()
}

func (o SettingsParameterDescriptionResponseOutput) ToSettingsParameterDescriptionResponseOutput() SettingsParameterDescriptionResponseOutput {
	return o
}

func (o SettingsParameterDescriptionResponseOutput) ToSettingsParameterDescriptionResponseOutputWithContext(ctx context.Context) SettingsParameterDescriptionResponseOutput {
	return o
}

// The parameter name of fabric setting.
func (o SettingsParameterDescriptionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescriptionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The parameter value of fabric setting.
func (o SettingsParameterDescriptionResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescriptionResponse) string { return v.Value }).(pulumi.StringOutput)
}

type SettingsParameterDescriptionResponseArrayOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsParameterDescriptionResponse)(nil)).Elem()
}

func (o SettingsParameterDescriptionResponseArrayOutput) ToSettingsParameterDescriptionResponseArrayOutput() SettingsParameterDescriptionResponseArrayOutput {
	return o
}

func (o SettingsParameterDescriptionResponseArrayOutput) ToSettingsParameterDescriptionResponseArrayOutputWithContext(ctx context.Context) SettingsParameterDescriptionResponseArrayOutput {
	return o
}

func (o SettingsParameterDescriptionResponseArrayOutput) Index(i pulumi.IntInput) SettingsParameterDescriptionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsParameterDescriptionResponse {
		return vs[0].([]SettingsParameterDescriptionResponse)[vs[1].(int)]
	}).(SettingsParameterDescriptionResponseOutput)
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescription struct {
	// The section name of the fabric settings.
	Name string `pulumi:"name"`
	// The collection of parameters in the section.
	Parameters []SettingsParameterDescription `pulumi:"parameters"`
}

// SettingsSectionDescriptionInput is an input type that accepts SettingsSectionDescriptionArgs and SettingsSectionDescriptionOutput values.
// You can construct a concrete instance of `SettingsSectionDescriptionInput` via:
//
//	SettingsSectionDescriptionArgs{...}
type SettingsSectionDescriptionInput interface {
	pulumi.Input

	ToSettingsSectionDescriptionOutput() SettingsSectionDescriptionOutput
	ToSettingsSectionDescriptionOutputWithContext(context.Context) SettingsSectionDescriptionOutput
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionArgs struct {
	// The section name of the fabric settings.
	Name pulumi.StringInput `pulumi:"name"`
	// The collection of parameters in the section.
	Parameters SettingsParameterDescriptionArrayInput `pulumi:"parameters"`
}

func (SettingsSectionDescriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsSectionDescription)(nil)).Elem()
}

func (i SettingsSectionDescriptionArgs) ToSettingsSectionDescriptionOutput() SettingsSectionDescriptionOutput {
	return i.ToSettingsSectionDescriptionOutputWithContext(context.Background())
}

func (i SettingsSectionDescriptionArgs) ToSettingsSectionDescriptionOutputWithContext(ctx context.Context) SettingsSectionDescriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsSectionDescriptionOutput)
}

// SettingsSectionDescriptionArrayInput is an input type that accepts SettingsSectionDescriptionArray and SettingsSectionDescriptionArrayOutput values.
// You can construct a concrete instance of `SettingsSectionDescriptionArrayInput` via:
//
//	SettingsSectionDescriptionArray{ SettingsSectionDescriptionArgs{...} }
type SettingsSectionDescriptionArrayInput interface {
	pulumi.Input

	ToSettingsSectionDescriptionArrayOutput() SettingsSectionDescriptionArrayOutput
	ToSettingsSectionDescriptionArrayOutputWithContext(context.Context) SettingsSectionDescriptionArrayOutput
}

type SettingsSectionDescriptionArray []SettingsSectionDescriptionInput

func (SettingsSectionDescriptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsSectionDescription)(nil)).Elem()
}

func (i SettingsSectionDescriptionArray) ToSettingsSectionDescriptionArrayOutput() SettingsSectionDescriptionArrayOutput {
	return i.ToSettingsSectionDescriptionArrayOutputWithContext(context.Background())
}

func (i SettingsSectionDescriptionArray) ToSettingsSectionDescriptionArrayOutputWithContext(ctx context.Context) SettingsSectionDescriptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsSectionDescriptionArrayOutput)
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsSectionDescription)(nil)).Elem()
}

func (o SettingsSectionDescriptionOutput) ToSettingsSectionDescriptionOutput() SettingsSectionDescriptionOutput {
	return o
}

func (o SettingsSectionDescriptionOutput) ToSettingsSectionDescriptionOutputWithContext(ctx context.Context) SettingsSectionDescriptionOutput {
	return o
}

// The section name of the fabric settings.
func (o SettingsSectionDescriptionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsSectionDescription) string { return v.Name }).(pulumi.StringOutput)
}

// The collection of parameters in the section.
func (o SettingsSectionDescriptionOutput) Parameters() SettingsParameterDescriptionArrayOutput {
	return o.ApplyT(func(v SettingsSectionDescription) []SettingsParameterDescription { return v.Parameters }).(SettingsParameterDescriptionArrayOutput)
}

type SettingsSectionDescriptionArrayOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsSectionDescription)(nil)).Elem()
}

func (o SettingsSectionDescriptionArrayOutput) ToSettingsSectionDescriptionArrayOutput() SettingsSectionDescriptionArrayOutput {
	return o
}

func (o SettingsSectionDescriptionArrayOutput) ToSettingsSectionDescriptionArrayOutputWithContext(ctx context.Context) SettingsSectionDescriptionArrayOutput {
	return o
}

func (o SettingsSectionDescriptionArrayOutput) Index(i pulumi.IntInput) SettingsSectionDescriptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsSectionDescription {
		return vs[0].([]SettingsSectionDescription)[vs[1].(int)]
	}).(SettingsSectionDescriptionOutput)
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionResponse struct {
	// The section name of the fabric settings.
	Name string `pulumi:"name"`
	// The collection of parameters in the section.
	Parameters []SettingsParameterDescriptionResponse `pulumi:"parameters"`
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionResponseOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsSectionDescriptionResponse)(nil)).Elem()
}

func (o SettingsSectionDescriptionResponseOutput) ToSettingsSectionDescriptionResponseOutput() SettingsSectionDescriptionResponseOutput {
	return o
}

func (o SettingsSectionDescriptionResponseOutput) ToSettingsSectionDescriptionResponseOutputWithContext(ctx context.Context) SettingsSectionDescriptionResponseOutput {
	return o
}

// The section name of the fabric settings.
func (o SettingsSectionDescriptionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsSectionDescriptionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The collection of parameters in the section.
func (o SettingsSectionDescriptionResponseOutput) Parameters() SettingsParameterDescriptionResponseArrayOutput {
	return o.ApplyT(func(v SettingsSectionDescriptionResponse) []SettingsParameterDescriptionResponse { return v.Parameters }).(SettingsParameterDescriptionResponseArrayOutput)
}

type SettingsSectionDescriptionResponseArrayOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsSectionDescriptionResponse)(nil)).Elem()
}

func (o SettingsSectionDescriptionResponseArrayOutput) ToSettingsSectionDescriptionResponseArrayOutput() SettingsSectionDescriptionResponseArrayOutput {
	return o
}

func (o SettingsSectionDescriptionResponseArrayOutput) ToSettingsSectionDescriptionResponseArrayOutputWithContext(ctx context.Context) SettingsSectionDescriptionResponseArrayOutput {
	return o
}

func (o SettingsSectionDescriptionResponseArrayOutput) Index(i pulumi.IntInput) SettingsSectionDescriptionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsSectionDescriptionResponse {
		return vs[0].([]SettingsSectionDescriptionResponse)[vs[1].(int)]
	}).(SettingsSectionDescriptionResponseOutput)
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionScheme struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Singleton'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// SingletonPartitionSchemeInput is an input type that accepts SingletonPartitionSchemeArgs and SingletonPartitionSchemeOutput values.
// You can construct a concrete instance of `SingletonPartitionSchemeInput` via:
//
//	SingletonPartitionSchemeArgs{...}
type SingletonPartitionSchemeInput interface {
	pulumi.Input

	ToSingletonPartitionSchemeOutput() SingletonPartitionSchemeOutput
	ToSingletonPartitionSchemeOutputWithContext(context.Context) SingletonPartitionSchemeOutput
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionSchemeArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Singleton'.
	PartitionScheme pulumi.StringInput `pulumi:"partitionScheme"`
}

func (SingletonPartitionSchemeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SingletonPartitionScheme)(nil)).Elem()
}

func (i SingletonPartitionSchemeArgs) ToSingletonPartitionSchemeOutput() SingletonPartitionSchemeOutput {
	return i.ToSingletonPartitionSchemeOutputWithContext(context.Background())
}

func (i SingletonPartitionSchemeArgs) ToSingletonPartitionSchemeOutputWithContext(ctx context.Context) SingletonPartitionSchemeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SingletonPartitionSchemeOutput)
}

func (i SingletonPartitionSchemeArgs) ToSingletonPartitionSchemePtrOutput() SingletonPartitionSchemePtrOutput {
	return i.ToSingletonPartitionSchemePtrOutputWithContext(context.Background())
}

func (i SingletonPartitionSchemeArgs) ToSingletonPartitionSchemePtrOutputWithContext(ctx context.Context) SingletonPartitionSchemePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SingletonPartitionSchemeOutput).ToSingletonPartitionSchemePtrOutputWithContext(ctx)
}

// SingletonPartitionSchemePtrInput is an input type that accepts SingletonPartitionSchemeArgs, SingletonPartitionSchemePtr and SingletonPartitionSchemePtrOutput values.
// You can construct a concrete instance of `SingletonPartitionSchemePtrInput` via:
//
//	        SingletonPartitionSchemeArgs{...}
//
//	or:
//
//	        nil
type SingletonPartitionSchemePtrInput interface {
	pulumi.Input

	ToSingletonPartitionSchemePtrOutput() SingletonPartitionSchemePtrOutput
	ToSingletonPartitionSchemePtrOutputWithContext(context.Context) SingletonPartitionSchemePtrOutput
}

type singletonPartitionSchemePtrType SingletonPartitionSchemeArgs

func SingletonPartitionSchemePtr(v *SingletonPartitionSchemeArgs) SingletonPartitionSchemePtrInput {
	return (*singletonPartitionSchemePtrType)(v)
}

func (*singletonPartitionSchemePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SingletonPartitionScheme)(nil)).Elem()
}

func (i *singletonPartitionSchemePtrType) ToSingletonPartitionSchemePtrOutput() SingletonPartitionSchemePtrOutput {
	return i.ToSingletonPartitionSchemePtrOutputWithContext(context.Background())
}

func (i *singletonPartitionSchemePtrType) ToSingletonPartitionSchemePtrOutputWithContext(ctx context.Context) SingletonPartitionSchemePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SingletonPartitionSchemePtrOutput)
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionSchemeOutput struct{ *pulumi.OutputState }

func (SingletonPartitionSchemeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SingletonPartitionScheme)(nil)).Elem()
}

func (o SingletonPartitionSchemeOutput) ToSingletonPartitionSchemeOutput() SingletonPartitionSchemeOutput {
	return o
}

func (o SingletonPartitionSchemeOutput) ToSingletonPartitionSchemeOutputWithContext(ctx context.Context) SingletonPartitionSchemeOutput {
	return o
}

func (o SingletonPartitionSchemeOutput) ToSingletonPartitionSchemePtrOutput() SingletonPartitionSchemePtrOutput {
	return o.ToSingletonPartitionSchemePtrOutputWithContext(context.Background())
}

func (o SingletonPartitionSchemeOutput) ToSingletonPartitionSchemePtrOutputWithContext(ctx context.Context) SingletonPartitionSchemePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SingletonPartitionScheme) *SingletonPartitionScheme {
		return &v
	}).(SingletonPartitionSchemePtrOutput)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'Singleton'.
func (o SingletonPartitionSchemeOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v SingletonPartitionScheme) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

type SingletonPartitionSchemePtrOutput struct{ *pulumi.OutputState }

func (SingletonPartitionSchemePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SingletonPartitionScheme)(nil)).Elem()
}

func (o SingletonPartitionSchemePtrOutput) ToSingletonPartitionSchemePtrOutput() SingletonPartitionSchemePtrOutput {
	return o
}

func (o SingletonPartitionSchemePtrOutput) ToSingletonPartitionSchemePtrOutputWithContext(ctx context.Context) SingletonPartitionSchemePtrOutput {
	return o
}

func (o SingletonPartitionSchemePtrOutput) Elem() SingletonPartitionSchemeOutput {
	return o.ApplyT(func(v *SingletonPartitionScheme) SingletonPartitionScheme {
		if v != nil {
			return *v
		}
		var ret SingletonPartitionScheme
		return ret
	}).(SingletonPartitionSchemeOutput)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'Singleton'.
func (o SingletonPartitionSchemePtrOutput) PartitionScheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SingletonPartitionScheme) *string {
		if v == nil {
			return nil
		}
		return &v.PartitionScheme
	}).(pulumi.StringPtrOutput)
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionSchemeResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Singleton'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionSchemeResponseOutput struct{ *pulumi.OutputState }

func (SingletonPartitionSchemeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SingletonPartitionSchemeResponse)(nil)).Elem()
}

func (o SingletonPartitionSchemeResponseOutput) ToSingletonPartitionSchemeResponseOutput() SingletonPartitionSchemeResponseOutput {
	return o
}

func (o SingletonPartitionSchemeResponseOutput) ToSingletonPartitionSchemeResponseOutputWithContext(ctx context.Context) SingletonPartitionSchemeResponseOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'Singleton'.
func (o SingletonPartitionSchemeResponseOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v SingletonPartitionSchemeResponse) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

// Service Fabric managed cluster Sku definition
type Sku struct {
	// Sku Name.
	Name string `pulumi:"name"`
}

// SkuInput is an input type that accepts SkuArgs and SkuOutput values.
// You can construct a concrete instance of `SkuInput` via:
//
//	SkuArgs{...}
type SkuInput interface {
	pulumi.Input

	ToSkuOutput() SkuOutput
	ToSkuOutputWithContext(context.Context) SkuOutput
}

// Service Fabric managed cluster Sku definition
type SkuArgs struct {
	// Sku Name.
	Name pulumi.StringInput `pulumi:"name"`
}

func (SkuArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Sku)(nil)).Elem()
}

func (i SkuArgs) ToSkuOutput() SkuOutput {
	return i.ToSkuOutputWithContext(context.Background())
}

func (i SkuArgs) ToSkuOutputWithContext(ctx context.Context) SkuOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuOutput)
}

// Service Fabric managed cluster Sku definition
type SkuOutput struct{ *pulumi.OutputState }

func (SkuOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Sku)(nil)).Elem()
}

func (o SkuOutput) ToSkuOutput() SkuOutput {
	return o
}

func (o SkuOutput) ToSkuOutputWithContext(ctx context.Context) SkuOutput {
	return o
}

// Sku Name.
func (o SkuOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Sku) string { return v.Name }).(pulumi.StringOutput)
}

// Service Fabric managed cluster Sku definition
type SkuResponse struct {
	// Sku Name.
	Name string `pulumi:"name"`
}

// Service Fabric managed cluster Sku definition
type SkuResponseOutput struct{ *pulumi.OutputState }

func (SkuResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SkuResponse)(nil)).Elem()
}

func (o SkuResponseOutput) ToSkuResponseOutput() SkuResponseOutput {
	return o
}

func (o SkuResponseOutput) ToSkuResponseOutputWithContext(ctx context.Context) SkuResponseOutput {
	return o
}

// Sku Name.
func (o SkuResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SkuResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The properties of a stateful service resource.
type StatefulServiceProperties struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelation `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
	HasPersistedState *bool `pulumi:"hasPersistedState"`
	// The minimum replica set size as a number.
	MinReplicaSetSize *int `pulumi:"minReplicaSetSize"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
	QuorumLossWaitDuration *string `pulumi:"quorumLossWaitDuration"`
	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
	ReplicaRestartWaitDuration *string `pulumi:"replicaRestartWaitDuration"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicy `pulumi:"scalingPolicies"`
	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
	// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
	// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDnsName *string `pulumi:"serviceDnsName"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateful'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetric `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
	ServicePlacementTimeLimit *string `pulumi:"servicePlacementTimeLimit"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
	StandByReplicaKeepDuration *string `pulumi:"standByReplicaKeepDuration"`
	// The target replica set size as a number.
	TargetReplicaSetSize *int `pulumi:"targetReplicaSetSize"`
}

// StatefulServicePropertiesInput is an input type that accepts StatefulServicePropertiesArgs and StatefulServicePropertiesOutput values.
// You can construct a concrete instance of `StatefulServicePropertiesInput` via:
//
//	StatefulServicePropertiesArgs{...}
type StatefulServicePropertiesInput interface {
	pulumi.Input

	ToStatefulServicePropertiesOutput() StatefulServicePropertiesOutput
	ToStatefulServicePropertiesOutputWithContext(context.Context) StatefulServicePropertiesOutput
}

// The properties of a stateful service resource.
type StatefulServicePropertiesArgs struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme ServiceCorrelationArrayInput `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost pulumi.StringPtrInput `pulumi:"defaultMoveCost"`
	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
	HasPersistedState pulumi.BoolPtrInput `pulumi:"hasPersistedState"`
	// The minimum replica set size as a number.
	MinReplicaSetSize pulumi.IntPtrInput `pulumi:"minReplicaSetSize"`
	// Describes how the service is partitioned.
	PartitionDescription pulumi.Input `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints pulumi.StringPtrInput `pulumi:"placementConstraints"`
	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
	QuorumLossWaitDuration pulumi.StringPtrInput `pulumi:"quorumLossWaitDuration"`
	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
	ReplicaRestartWaitDuration pulumi.StringPtrInput `pulumi:"replicaRestartWaitDuration"`
	// Scaling policies for this service.
	ScalingPolicies ScalingPolicyArrayInput `pulumi:"scalingPolicies"`
	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
	// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
	// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDnsName pulumi.StringPtrInput `pulumi:"serviceDnsName"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateful'.
	ServiceKind pulumi.StringInput `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics ServiceLoadMetricArrayInput `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode pulumi.StringPtrInput `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies pulumi.ArrayInput `pulumi:"servicePlacementPolicies"`
	// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
	ServicePlacementTimeLimit pulumi.StringPtrInput `pulumi:"servicePlacementTimeLimit"`
	// The name of the service type
	ServiceTypeName pulumi.StringInput `pulumi:"serviceTypeName"`
	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
	StandByReplicaKeepDuration pulumi.StringPtrInput `pulumi:"standByReplicaKeepDuration"`
	// The target replica set size as a number.
	TargetReplicaSetSize pulumi.IntPtrInput `pulumi:"targetReplicaSetSize"`
}

func (StatefulServicePropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulServiceProperties)(nil)).Elem()
}

func (i StatefulServicePropertiesArgs) ToStatefulServicePropertiesOutput() StatefulServicePropertiesOutput {
	return i.ToStatefulServicePropertiesOutputWithContext(context.Background())
}

func (i StatefulServicePropertiesArgs) ToStatefulServicePropertiesOutputWithContext(ctx context.Context) StatefulServicePropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulServicePropertiesOutput)
}

func (i StatefulServicePropertiesArgs) ToStatefulServicePropertiesPtrOutput() StatefulServicePropertiesPtrOutput {
	return i.ToStatefulServicePropertiesPtrOutputWithContext(context.Background())
}

func (i StatefulServicePropertiesArgs) ToStatefulServicePropertiesPtrOutputWithContext(ctx context.Context) StatefulServicePropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulServicePropertiesOutput).ToStatefulServicePropertiesPtrOutputWithContext(ctx)
}

// StatefulServicePropertiesPtrInput is an input type that accepts StatefulServicePropertiesArgs, StatefulServicePropertiesPtr and StatefulServicePropertiesPtrOutput values.
// You can construct a concrete instance of `StatefulServicePropertiesPtrInput` via:
//
//	        StatefulServicePropertiesArgs{...}
//
//	or:
//
//	        nil
type StatefulServicePropertiesPtrInput interface {
	pulumi.Input

	ToStatefulServicePropertiesPtrOutput() StatefulServicePropertiesPtrOutput
	ToStatefulServicePropertiesPtrOutputWithContext(context.Context) StatefulServicePropertiesPtrOutput
}

type statefulServicePropertiesPtrType StatefulServicePropertiesArgs

func StatefulServicePropertiesPtr(v *StatefulServicePropertiesArgs) StatefulServicePropertiesPtrInput {
	return (*statefulServicePropertiesPtrType)(v)
}

func (*statefulServicePropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StatefulServiceProperties)(nil)).Elem()
}

func (i *statefulServicePropertiesPtrType) ToStatefulServicePropertiesPtrOutput() StatefulServicePropertiesPtrOutput {
	return i.ToStatefulServicePropertiesPtrOutputWithContext(context.Background())
}

func (i *statefulServicePropertiesPtrType) ToStatefulServicePropertiesPtrOutputWithContext(ctx context.Context) StatefulServicePropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulServicePropertiesPtrOutput)
}

// The properties of a stateful service resource.
type StatefulServicePropertiesOutput struct{ *pulumi.OutputState }

func (StatefulServicePropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulServiceProperties)(nil)).Elem()
}

func (o StatefulServicePropertiesOutput) ToStatefulServicePropertiesOutput() StatefulServicePropertiesOutput {
	return o
}

func (o StatefulServicePropertiesOutput) ToStatefulServicePropertiesOutputWithContext(ctx context.Context) StatefulServicePropertiesOutput {
	return o
}

func (o StatefulServicePropertiesOutput) ToStatefulServicePropertiesPtrOutput() StatefulServicePropertiesPtrOutput {
	return o.ToStatefulServicePropertiesPtrOutputWithContext(context.Background())
}

func (o StatefulServicePropertiesOutput) ToStatefulServicePropertiesPtrOutputWithContext(ctx context.Context) StatefulServicePropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StatefulServiceProperties) *StatefulServiceProperties {
		return &v
	}).(StatefulServicePropertiesPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatefulServicePropertiesOutput) CorrelationScheme() ServiceCorrelationArrayOutput {
	return o.ApplyT(func(v StatefulServiceProperties) []ServiceCorrelation { return v.CorrelationScheme }).(ServiceCorrelationArrayOutput)
}

// Specifies the move cost for the service.
func (o StatefulServicePropertiesOutput) DefaultMoveCost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.DefaultMoveCost }).(pulumi.StringPtrOutput)
}

// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
func (o StatefulServicePropertiesOutput) HasPersistedState() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *bool { return v.HasPersistedState }).(pulumi.BoolPtrOutput)
}

// The minimum replica set size as a number.
func (o StatefulServicePropertiesOutput) MinReplicaSetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *int { return v.MinReplicaSetSize }).(pulumi.IntPtrOutput)
}

// Describes how the service is partitioned.
func (o StatefulServicePropertiesOutput) PartitionDescription() pulumi.AnyOutput {
	return o.ApplyT(func(v StatefulServiceProperties) interface{} { return v.PartitionDescription }).(pulumi.AnyOutput)
}

// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
func (o StatefulServicePropertiesOutput) PlacementConstraints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.PlacementConstraints }).(pulumi.StringPtrOutput)
}

// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesOutput) QuorumLossWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.QuorumLossWaitDuration }).(pulumi.StringPtrOutput)
}

// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesOutput) ReplicaRestartWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.ReplicaRestartWaitDuration }).(pulumi.StringPtrOutput)
}

// Scaling policies for this service.
func (o StatefulServicePropertiesOutput) ScalingPolicies() ScalingPolicyArrayOutput {
	return o.ApplyT(func(v StatefulServiceProperties) []ScalingPolicy { return v.ScalingPolicies }).(ScalingPolicyArrayOutput)
}

// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
func (o StatefulServicePropertiesOutput) ServiceDnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.ServiceDnsName }).(pulumi.StringPtrOutput)
}

// The kind of service (Stateless or Stateful).
// Expected value is 'Stateful'.
func (o StatefulServicePropertiesOutput) ServiceKind() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulServiceProperties) string { return v.ServiceKind }).(pulumi.StringOutput)
}

// The service load metrics is given as an array of ServiceLoadMetric objects.
func (o StatefulServicePropertiesOutput) ServiceLoadMetrics() ServiceLoadMetricArrayOutput {
	return o.ApplyT(func(v StatefulServiceProperties) []ServiceLoadMetric { return v.ServiceLoadMetrics }).(ServiceLoadMetricArrayOutput)
}

// The activation Mode of the service package
func (o StatefulServicePropertiesOutput) ServicePackageActivationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.ServicePackageActivationMode }).(pulumi.StringPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatefulServicePropertiesOutput) ServicePlacementPolicies() pulumi.ArrayOutput {
	return o.ApplyT(func(v StatefulServiceProperties) []interface{} { return v.ServicePlacementPolicies }).(pulumi.ArrayOutput)
}

// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesOutput) ServicePlacementTimeLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.ServicePlacementTimeLimit }).(pulumi.StringPtrOutput)
}

// The name of the service type
func (o StatefulServicePropertiesOutput) ServiceTypeName() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulServiceProperties) string { return v.ServiceTypeName }).(pulumi.StringOutput)
}

// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesOutput) StandByReplicaKeepDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.StandByReplicaKeepDuration }).(pulumi.StringPtrOutput)
}

// The target replica set size as a number.
func (o StatefulServicePropertiesOutput) TargetReplicaSetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *int { return v.TargetReplicaSetSize }).(pulumi.IntPtrOutput)
}

type StatefulServicePropertiesPtrOutput struct{ *pulumi.OutputState }

func (StatefulServicePropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StatefulServiceProperties)(nil)).Elem()
}

func (o StatefulServicePropertiesPtrOutput) ToStatefulServicePropertiesPtrOutput() StatefulServicePropertiesPtrOutput {
	return o
}

func (o StatefulServicePropertiesPtrOutput) ToStatefulServicePropertiesPtrOutputWithContext(ctx context.Context) StatefulServicePropertiesPtrOutput {
	return o
}

func (o StatefulServicePropertiesPtrOutput) Elem() StatefulServicePropertiesOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) StatefulServiceProperties {
		if v != nil {
			return *v
		}
		var ret StatefulServiceProperties
		return ret
	}).(StatefulServicePropertiesOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatefulServicePropertiesPtrOutput) CorrelationScheme() ServiceCorrelationArrayOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) []ServiceCorrelation {
		if v == nil {
			return nil
		}
		return v.CorrelationScheme
	}).(ServiceCorrelationArrayOutput)
}

// Specifies the move cost for the service.
func (o StatefulServicePropertiesPtrOutput) DefaultMoveCost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.DefaultMoveCost
	}).(pulumi.StringPtrOutput)
}

// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
func (o StatefulServicePropertiesPtrOutput) HasPersistedState() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *bool {
		if v == nil {
			return nil
		}
		return v.HasPersistedState
	}).(pulumi.BoolPtrOutput)
}

// The minimum replica set size as a number.
func (o StatefulServicePropertiesPtrOutput) MinReplicaSetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *int {
		if v == nil {
			return nil
		}
		return v.MinReplicaSetSize
	}).(pulumi.IntPtrOutput)
}

// Describes how the service is partitioned.
func (o StatefulServicePropertiesPtrOutput) PartitionDescription() pulumi.AnyOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) interface{} {
		if v == nil {
			return nil
		}
		return v.PartitionDescription
	}).(pulumi.AnyOutput)
}

// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
func (o StatefulServicePropertiesPtrOutput) PlacementConstraints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.PlacementConstraints
	}).(pulumi.StringPtrOutput)
}

// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesPtrOutput) QuorumLossWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.QuorumLossWaitDuration
	}).(pulumi.StringPtrOutput)
}

// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesPtrOutput) ReplicaRestartWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.ReplicaRestartWaitDuration
	}).(pulumi.StringPtrOutput)
}

// Scaling policies for this service.
func (o StatefulServicePropertiesPtrOutput) ScalingPolicies() ScalingPolicyArrayOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) []ScalingPolicy {
		if v == nil {
			return nil
		}
		return v.ScalingPolicies
	}).(ScalingPolicyArrayOutput)
}

// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
func (o StatefulServicePropertiesPtrOutput) ServiceDnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.ServiceDnsName
	}).(pulumi.StringPtrOutput)
}

// The kind of service (Stateless or Stateful).
// Expected value is 'Stateful'.
func (o StatefulServicePropertiesPtrOutput) ServiceKind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceKind
	}).(pulumi.StringPtrOutput)
}

// The service load metrics is given as an array of ServiceLoadMetric objects.
func (o StatefulServicePropertiesPtrOutput) ServiceLoadMetrics() ServiceLoadMetricArrayOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) []ServiceLoadMetric {
		if v == nil {
			return nil
		}
		return v.ServiceLoadMetrics
	}).(ServiceLoadMetricArrayOutput)
}

// The activation Mode of the service package
func (o StatefulServicePropertiesPtrOutput) ServicePackageActivationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.ServicePackageActivationMode
	}).(pulumi.StringPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatefulServicePropertiesPtrOutput) ServicePlacementPolicies() pulumi.ArrayOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) []interface{} {
		if v == nil {
			return nil
		}
		return v.ServicePlacementPolicies
	}).(pulumi.ArrayOutput)
}

// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesPtrOutput) ServicePlacementTimeLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.ServicePlacementTimeLimit
	}).(pulumi.StringPtrOutput)
}

// The name of the service type
func (o StatefulServicePropertiesPtrOutput) ServiceTypeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceTypeName
	}).(pulumi.StringPtrOutput)
}

// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesPtrOutput) StandByReplicaKeepDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.StandByReplicaKeepDuration
	}).(pulumi.StringPtrOutput)
}

// The target replica set size as a number.
func (o StatefulServicePropertiesPtrOutput) TargetReplicaSetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatefulServiceProperties) *int {
		if v == nil {
			return nil
		}
		return v.TargetReplicaSetSize
	}).(pulumi.IntPtrOutput)
}

// The properties of a stateful service resource.
type StatefulServicePropertiesResponse struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelationResponse `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
	HasPersistedState *bool `pulumi:"hasPersistedState"`
	// The minimum replica set size as a number.
	MinReplicaSetSize *int `pulumi:"minReplicaSetSize"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// The current deployment or provisioning state, which only appears in the response
	ProvisioningState string `pulumi:"provisioningState"`
	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
	QuorumLossWaitDuration *string `pulumi:"quorumLossWaitDuration"`
	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
	ReplicaRestartWaitDuration *string `pulumi:"replicaRestartWaitDuration"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicyResponse `pulumi:"scalingPolicies"`
	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
	// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
	// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDnsName *string `pulumi:"serviceDnsName"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateful'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetricResponse `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
	ServicePlacementTimeLimit *string `pulumi:"servicePlacementTimeLimit"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
	StandByReplicaKeepDuration *string `pulumi:"standByReplicaKeepDuration"`
	// The target replica set size as a number.
	TargetReplicaSetSize *int `pulumi:"targetReplicaSetSize"`
}

// The properties of a stateful service resource.
type StatefulServicePropertiesResponseOutput struct{ *pulumi.OutputState }

func (StatefulServicePropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulServicePropertiesResponse)(nil)).Elem()
}

func (o StatefulServicePropertiesResponseOutput) ToStatefulServicePropertiesResponseOutput() StatefulServicePropertiesResponseOutput {
	return o
}

func (o StatefulServicePropertiesResponseOutput) ToStatefulServicePropertiesResponseOutputWithContext(ctx context.Context) StatefulServicePropertiesResponseOutput {
	return o
}

// A list that describes the correlation of the service with other services.
func (o StatefulServicePropertiesResponseOutput) CorrelationScheme() ServiceCorrelationResponseArrayOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) []ServiceCorrelationResponse { return v.CorrelationScheme }).(ServiceCorrelationResponseArrayOutput)
}

// Specifies the move cost for the service.
func (o StatefulServicePropertiesResponseOutput) DefaultMoveCost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.DefaultMoveCost }).(pulumi.StringPtrOutput)
}

// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
func (o StatefulServicePropertiesResponseOutput) HasPersistedState() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *bool { return v.HasPersistedState }).(pulumi.BoolPtrOutput)
}

// The minimum replica set size as a number.
func (o StatefulServicePropertiesResponseOutput) MinReplicaSetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *int { return v.MinReplicaSetSize }).(pulumi.IntPtrOutput)
}

// Describes how the service is partitioned.
func (o StatefulServicePropertiesResponseOutput) PartitionDescription() pulumi.AnyOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) interface{} { return v.PartitionDescription }).(pulumi.AnyOutput)
}

// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
func (o StatefulServicePropertiesResponseOutput) PlacementConstraints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.PlacementConstraints }).(pulumi.StringPtrOutput)
}

// The current deployment or provisioning state, which only appears in the response
func (o StatefulServicePropertiesResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesResponseOutput) QuorumLossWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.QuorumLossWaitDuration }).(pulumi.StringPtrOutput)
}

// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesResponseOutput) ReplicaRestartWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.ReplicaRestartWaitDuration }).(pulumi.StringPtrOutput)
}

// Scaling policies for this service.
func (o StatefulServicePropertiesResponseOutput) ScalingPolicies() ScalingPolicyResponseArrayOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) []ScalingPolicyResponse { return v.ScalingPolicies }).(ScalingPolicyResponseArrayOutput)
}

// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
func (o StatefulServicePropertiesResponseOutput) ServiceDnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.ServiceDnsName }).(pulumi.StringPtrOutput)
}

// The kind of service (Stateless or Stateful).
// Expected value is 'Stateful'.
func (o StatefulServicePropertiesResponseOutput) ServiceKind() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) string { return v.ServiceKind }).(pulumi.StringOutput)
}

// The service load metrics is given as an array of ServiceLoadMetric objects.
func (o StatefulServicePropertiesResponseOutput) ServiceLoadMetrics() ServiceLoadMetricResponseArrayOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) []ServiceLoadMetricResponse { return v.ServiceLoadMetrics }).(ServiceLoadMetricResponseArrayOutput)
}

// The activation Mode of the service package
func (o StatefulServicePropertiesResponseOutput) ServicePackageActivationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.ServicePackageActivationMode }).(pulumi.StringPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatefulServicePropertiesResponseOutput) ServicePlacementPolicies() pulumi.ArrayOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) []interface{} { return v.ServicePlacementPolicies }).(pulumi.ArrayOutput)
}

// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesResponseOutput) ServicePlacementTimeLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.ServicePlacementTimeLimit }).(pulumi.StringPtrOutput)
}

// The name of the service type
func (o StatefulServicePropertiesResponseOutput) ServiceTypeName() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) string { return v.ServiceTypeName }).(pulumi.StringOutput)
}

// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesResponseOutput) StandByReplicaKeepDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.StandByReplicaKeepDuration }).(pulumi.StringPtrOutput)
}

// The target replica set size as a number.
func (o StatefulServicePropertiesResponseOutput) TargetReplicaSetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *int { return v.TargetReplicaSetSize }).(pulumi.IntPtrOutput)
}

// The properties of a stateless service resource.
type StatelessServiceProperties struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelation `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// The instance count.
	InstanceCount int `pulumi:"instanceCount"`
	// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstanceCount *int `pulumi:"minInstanceCount"`
	// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstancePercentage *int `pulumi:"minInstancePercentage"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicy `pulumi:"scalingPolicies"`
	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
	// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
	// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDnsName *string `pulumi:"serviceDnsName"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateless'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetric `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
}

// StatelessServicePropertiesInput is an input type that accepts StatelessServicePropertiesArgs and StatelessServicePropertiesOutput values.
// You can construct a concrete instance of `StatelessServicePropertiesInput` via:
//
//	StatelessServicePropertiesArgs{...}
type StatelessServicePropertiesInput interface {
	pulumi.Input

	ToStatelessServicePropertiesOutput() StatelessServicePropertiesOutput
	ToStatelessServicePropertiesOutputWithContext(context.Context) StatelessServicePropertiesOutput
}

// The properties of a stateless service resource.
type StatelessServicePropertiesArgs struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme ServiceCorrelationArrayInput `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost pulumi.StringPtrInput `pulumi:"defaultMoveCost"`
	// The instance count.
	InstanceCount pulumi.IntInput `pulumi:"instanceCount"`
	// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstanceCount pulumi.IntPtrInput `pulumi:"minInstanceCount"`
	// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstancePercentage pulumi.IntPtrInput `pulumi:"minInstancePercentage"`
	// Describes how the service is partitioned.
	PartitionDescription pulumi.Input `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints pulumi.StringPtrInput `pulumi:"placementConstraints"`
	// Scaling policies for this service.
	ScalingPolicies ScalingPolicyArrayInput `pulumi:"scalingPolicies"`
	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
	// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
	// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDnsName pulumi.StringPtrInput `pulumi:"serviceDnsName"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateless'.
	ServiceKind pulumi.StringInput `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics ServiceLoadMetricArrayInput `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode pulumi.StringPtrInput `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies pulumi.ArrayInput `pulumi:"servicePlacementPolicies"`
	// The name of the service type
	ServiceTypeName pulumi.StringInput `pulumi:"serviceTypeName"`
}

func (StatelessServicePropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatelessServiceProperties)(nil)).Elem()
}

func (i StatelessServicePropertiesArgs) ToStatelessServicePropertiesOutput() StatelessServicePropertiesOutput {
	return i.ToStatelessServicePropertiesOutputWithContext(context.Background())
}

func (i StatelessServicePropertiesArgs) ToStatelessServicePropertiesOutputWithContext(ctx context.Context) StatelessServicePropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatelessServicePropertiesOutput)
}

func (i StatelessServicePropertiesArgs) ToStatelessServicePropertiesPtrOutput() StatelessServicePropertiesPtrOutput {
	return i.ToStatelessServicePropertiesPtrOutputWithContext(context.Background())
}

func (i StatelessServicePropertiesArgs) ToStatelessServicePropertiesPtrOutputWithContext(ctx context.Context) StatelessServicePropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatelessServicePropertiesOutput).ToStatelessServicePropertiesPtrOutputWithContext(ctx)
}

// StatelessServicePropertiesPtrInput is an input type that accepts StatelessServicePropertiesArgs, StatelessServicePropertiesPtr and StatelessServicePropertiesPtrOutput values.
// You can construct a concrete instance of `StatelessServicePropertiesPtrInput` via:
//
//	        StatelessServicePropertiesArgs{...}
//
//	or:
//
//	        nil
type StatelessServicePropertiesPtrInput interface {
	pulumi.Input

	ToStatelessServicePropertiesPtrOutput() StatelessServicePropertiesPtrOutput
	ToStatelessServicePropertiesPtrOutputWithContext(context.Context) StatelessServicePropertiesPtrOutput
}

type statelessServicePropertiesPtrType StatelessServicePropertiesArgs

func StatelessServicePropertiesPtr(v *StatelessServicePropertiesArgs) StatelessServicePropertiesPtrInput {
	return (*statelessServicePropertiesPtrType)(v)
}

func (*statelessServicePropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StatelessServiceProperties)(nil)).Elem()
}

func (i *statelessServicePropertiesPtrType) ToStatelessServicePropertiesPtrOutput() StatelessServicePropertiesPtrOutput {
	return i.ToStatelessServicePropertiesPtrOutputWithContext(context.Background())
}

func (i *statelessServicePropertiesPtrType) ToStatelessServicePropertiesPtrOutputWithContext(ctx context.Context) StatelessServicePropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatelessServicePropertiesPtrOutput)
}

// The properties of a stateless service resource.
type StatelessServicePropertiesOutput struct{ *pulumi.OutputState }

func (StatelessServicePropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatelessServiceProperties)(nil)).Elem()
}

func (o StatelessServicePropertiesOutput) ToStatelessServicePropertiesOutput() StatelessServicePropertiesOutput {
	return o
}

func (o StatelessServicePropertiesOutput) ToStatelessServicePropertiesOutputWithContext(ctx context.Context) StatelessServicePropertiesOutput {
	return o
}

func (o StatelessServicePropertiesOutput) ToStatelessServicePropertiesPtrOutput() StatelessServicePropertiesPtrOutput {
	return o.ToStatelessServicePropertiesPtrOutputWithContext(context.Background())
}

func (o StatelessServicePropertiesOutput) ToStatelessServicePropertiesPtrOutputWithContext(ctx context.Context) StatelessServicePropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StatelessServiceProperties) *StatelessServiceProperties {
		return &v
	}).(StatelessServicePropertiesPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatelessServicePropertiesOutput) CorrelationScheme() ServiceCorrelationArrayOutput {
	return o.ApplyT(func(v StatelessServiceProperties) []ServiceCorrelation { return v.CorrelationScheme }).(ServiceCorrelationArrayOutput)
}

// Specifies the move cost for the service.
func (o StatelessServicePropertiesOutput) DefaultMoveCost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServiceProperties) *string { return v.DefaultMoveCost }).(pulumi.StringPtrOutput)
}

// The instance count.
func (o StatelessServicePropertiesOutput) InstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v StatelessServiceProperties) int { return v.InstanceCount }).(pulumi.IntOutput)
}

// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
func (o StatelessServicePropertiesOutput) MinInstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatelessServiceProperties) *int { return v.MinInstanceCount }).(pulumi.IntPtrOutput)
}

// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
func (o StatelessServicePropertiesOutput) MinInstancePercentage() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatelessServiceProperties) *int { return v.MinInstancePercentage }).(pulumi.IntPtrOutput)
}

// Describes how the service is partitioned.
func (o StatelessServicePropertiesOutput) PartitionDescription() pulumi.AnyOutput {
	return o.ApplyT(func(v StatelessServiceProperties) interface{} { return v.PartitionDescription }).(pulumi.AnyOutput)
}

// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
func (o StatelessServicePropertiesOutput) PlacementConstraints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServiceProperties) *string { return v.PlacementConstraints }).(pulumi.StringPtrOutput)
}

// Scaling policies for this service.
func (o StatelessServicePropertiesOutput) ScalingPolicies() ScalingPolicyArrayOutput {
	return o.ApplyT(func(v StatelessServiceProperties) []ScalingPolicy { return v.ScalingPolicies }).(ScalingPolicyArrayOutput)
}

// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
func (o StatelessServicePropertiesOutput) ServiceDnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServiceProperties) *string { return v.ServiceDnsName }).(pulumi.StringPtrOutput)
}

// The kind of service (Stateless or Stateful).
// Expected value is 'Stateless'.
func (o StatelessServicePropertiesOutput) ServiceKind() pulumi.StringOutput {
	return o.ApplyT(func(v StatelessServiceProperties) string { return v.ServiceKind }).(pulumi.StringOutput)
}

// The service load metrics is given as an array of ServiceLoadMetric objects.
func (o StatelessServicePropertiesOutput) ServiceLoadMetrics() ServiceLoadMetricArrayOutput {
	return o.ApplyT(func(v StatelessServiceProperties) []ServiceLoadMetric { return v.ServiceLoadMetrics }).(ServiceLoadMetricArrayOutput)
}

// The activation Mode of the service package
func (o StatelessServicePropertiesOutput) ServicePackageActivationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServiceProperties) *string { return v.ServicePackageActivationMode }).(pulumi.StringPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatelessServicePropertiesOutput) ServicePlacementPolicies() pulumi.ArrayOutput {
	return o.ApplyT(func(v StatelessServiceProperties) []interface{} { return v.ServicePlacementPolicies }).(pulumi.ArrayOutput)
}

// The name of the service type
func (o StatelessServicePropertiesOutput) ServiceTypeName() pulumi.StringOutput {
	return o.ApplyT(func(v StatelessServiceProperties) string { return v.ServiceTypeName }).(pulumi.StringOutput)
}

type StatelessServicePropertiesPtrOutput struct{ *pulumi.OutputState }

func (StatelessServicePropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StatelessServiceProperties)(nil)).Elem()
}

func (o StatelessServicePropertiesPtrOutput) ToStatelessServicePropertiesPtrOutput() StatelessServicePropertiesPtrOutput {
	return o
}

func (o StatelessServicePropertiesPtrOutput) ToStatelessServicePropertiesPtrOutputWithContext(ctx context.Context) StatelessServicePropertiesPtrOutput {
	return o
}

func (o StatelessServicePropertiesPtrOutput) Elem() StatelessServicePropertiesOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) StatelessServiceProperties {
		if v != nil {
			return *v
		}
		var ret StatelessServiceProperties
		return ret
	}).(StatelessServicePropertiesOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatelessServicePropertiesPtrOutput) CorrelationScheme() ServiceCorrelationArrayOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) []ServiceCorrelation {
		if v == nil {
			return nil
		}
		return v.CorrelationScheme
	}).(ServiceCorrelationArrayOutput)
}

// Specifies the move cost for the service.
func (o StatelessServicePropertiesPtrOutput) DefaultMoveCost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.DefaultMoveCost
	}).(pulumi.StringPtrOutput)
}

// The instance count.
func (o StatelessServicePropertiesPtrOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) *int {
		if v == nil {
			return nil
		}
		return &v.InstanceCount
	}).(pulumi.IntPtrOutput)
}

// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
func (o StatelessServicePropertiesPtrOutput) MinInstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) *int {
		if v == nil {
			return nil
		}
		return v.MinInstanceCount
	}).(pulumi.IntPtrOutput)
}

// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
func (o StatelessServicePropertiesPtrOutput) MinInstancePercentage() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) *int {
		if v == nil {
			return nil
		}
		return v.MinInstancePercentage
	}).(pulumi.IntPtrOutput)
}

// Describes how the service is partitioned.
func (o StatelessServicePropertiesPtrOutput) PartitionDescription() pulumi.AnyOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) interface{} {
		if v == nil {
			return nil
		}
		return v.PartitionDescription
	}).(pulumi.AnyOutput)
}

// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
func (o StatelessServicePropertiesPtrOutput) PlacementConstraints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.PlacementConstraints
	}).(pulumi.StringPtrOutput)
}

// Scaling policies for this service.
func (o StatelessServicePropertiesPtrOutput) ScalingPolicies() ScalingPolicyArrayOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) []ScalingPolicy {
		if v == nil {
			return nil
		}
		return v.ScalingPolicies
	}).(ScalingPolicyArrayOutput)
}

// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
func (o StatelessServicePropertiesPtrOutput) ServiceDnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.ServiceDnsName
	}).(pulumi.StringPtrOutput)
}

// The kind of service (Stateless or Stateful).
// Expected value is 'Stateless'.
func (o StatelessServicePropertiesPtrOutput) ServiceKind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceKind
	}).(pulumi.StringPtrOutput)
}

// The service load metrics is given as an array of ServiceLoadMetric objects.
func (o StatelessServicePropertiesPtrOutput) ServiceLoadMetrics() ServiceLoadMetricArrayOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) []ServiceLoadMetric {
		if v == nil {
			return nil
		}
		return v.ServiceLoadMetrics
	}).(ServiceLoadMetricArrayOutput)
}

// The activation Mode of the service package
func (o StatelessServicePropertiesPtrOutput) ServicePackageActivationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) *string {
		if v == nil {
			return nil
		}
		return v.ServicePackageActivationMode
	}).(pulumi.StringPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatelessServicePropertiesPtrOutput) ServicePlacementPolicies() pulumi.ArrayOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) []interface{} {
		if v == nil {
			return nil
		}
		return v.ServicePlacementPolicies
	}).(pulumi.ArrayOutput)
}

// The name of the service type
func (o StatelessServicePropertiesPtrOutput) ServiceTypeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatelessServiceProperties) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceTypeName
	}).(pulumi.StringPtrOutput)
}

// The properties of a stateless service resource.
type StatelessServicePropertiesResponse struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelationResponse `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// The instance count.
	InstanceCount int `pulumi:"instanceCount"`
	// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstanceCount *int `pulumi:"minInstanceCount"`
	// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstancePercentage *int `pulumi:"minInstancePercentage"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// The current deployment or provisioning state, which only appears in the response
	ProvisioningState string `pulumi:"provisioningState"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicyResponse `pulumi:"scalingPolicies"`
	// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
	// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
	// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
	ServiceDnsName *string `pulumi:"serviceDnsName"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateless'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetricResponse `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
}

// The properties of a stateless service resource.
type StatelessServicePropertiesResponseOutput struct{ *pulumi.OutputState }

func (StatelessServicePropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatelessServicePropertiesResponse)(nil)).Elem()
}

func (o StatelessServicePropertiesResponseOutput) ToStatelessServicePropertiesResponseOutput() StatelessServicePropertiesResponseOutput {
	return o
}

func (o StatelessServicePropertiesResponseOutput) ToStatelessServicePropertiesResponseOutputWithContext(ctx context.Context) StatelessServicePropertiesResponseOutput {
	return o
}

// A list that describes the correlation of the service with other services.
func (o StatelessServicePropertiesResponseOutput) CorrelationScheme() ServiceCorrelationResponseArrayOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) []ServiceCorrelationResponse { return v.CorrelationScheme }).(ServiceCorrelationResponseArrayOutput)
}

// Specifies the move cost for the service.
func (o StatelessServicePropertiesResponseOutput) DefaultMoveCost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) *string { return v.DefaultMoveCost }).(pulumi.StringPtrOutput)
}

// The instance count.
func (o StatelessServicePropertiesResponseOutput) InstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) int { return v.InstanceCount }).(pulumi.IntOutput)
}

// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
func (o StatelessServicePropertiesResponseOutput) MinInstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) *int { return v.MinInstanceCount }).(pulumi.IntPtrOutput)
}

// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
func (o StatelessServicePropertiesResponseOutput) MinInstancePercentage() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) *int { return v.MinInstancePercentage }).(pulumi.IntPtrOutput)
}

// Describes how the service is partitioned.
func (o StatelessServicePropertiesResponseOutput) PartitionDescription() pulumi.AnyOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) interface{} { return v.PartitionDescription }).(pulumi.AnyOutput)
}

// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
func (o StatelessServicePropertiesResponseOutput) PlacementConstraints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) *string { return v.PlacementConstraints }).(pulumi.StringPtrOutput)
}

// The current deployment or provisioning state, which only appears in the response
func (o StatelessServicePropertiesResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Scaling policies for this service.
func (o StatelessServicePropertiesResponseOutput) ScalingPolicies() ScalingPolicyResponseArrayOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) []ScalingPolicyResponse { return v.ScalingPolicies }).(ScalingPolicyResponseArrayOutput)
}

// Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
// When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
// When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
func (o StatelessServicePropertiesResponseOutput) ServiceDnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) *string { return v.ServiceDnsName }).(pulumi.StringPtrOutput)
}

// The kind of service (Stateless or Stateful).
// Expected value is 'Stateless'.
func (o StatelessServicePropertiesResponseOutput) ServiceKind() pulumi.StringOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) string { return v.ServiceKind }).(pulumi.StringOutput)
}

// The service load metrics is given as an array of ServiceLoadMetric objects.
func (o StatelessServicePropertiesResponseOutput) ServiceLoadMetrics() ServiceLoadMetricResponseArrayOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) []ServiceLoadMetricResponse { return v.ServiceLoadMetrics }).(ServiceLoadMetricResponseArrayOutput)
}

// The activation Mode of the service package
func (o StatelessServicePropertiesResponseOutput) ServicePackageActivationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) *string { return v.ServicePackageActivationMode }).(pulumi.StringPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatelessServicePropertiesResponseOutput) ServicePlacementPolicies() pulumi.ArrayOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) []interface{} { return v.ServicePlacementPolicies }).(pulumi.ArrayOutput)
}

// The name of the service type
func (o StatelessServicePropertiesResponseOutput) ServiceTypeName() pulumi.StringOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) string { return v.ServiceTypeName }).(pulumi.StringOutput)
}

// Azure resource identifier.
type SubResource struct {
	// Sub-resource ID. Both absolute resource ID and a relative resource ID are accepted.
	// An absolute ID starts with /subscriptions/ and contains the entire ID of the parent resource and the ID of the sub-resource in the end.
	// A relative ID replaces the ID of the parent resource with a token '$self', followed by the sub-resource ID itself.
	// Example of a relative ID: $self/frontEndConfigurations/my-frontend.
	Id *string `pulumi:"id"`
}

// SubResourceInput is an input type that accepts SubResourceArgs and SubResourceOutput values.
// You can construct a concrete instance of `SubResourceInput` via:
//
//	SubResourceArgs{...}
type SubResourceInput interface {
	pulumi.Input

	ToSubResourceOutput() SubResourceOutput
	ToSubResourceOutputWithContext(context.Context) SubResourceOutput
}

// Azure resource identifier.
type SubResourceArgs struct {
	// Sub-resource ID. Both absolute resource ID and a relative resource ID are accepted.
	// An absolute ID starts with /subscriptions/ and contains the entire ID of the parent resource and the ID of the sub-resource in the end.
	// A relative ID replaces the ID of the parent resource with a token '$self', followed by the sub-resource ID itself.
	// Example of a relative ID: $self/frontEndConfigurations/my-frontend.
	Id pulumi.StringPtrInput `pulumi:"id"`
}

func (SubResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubResource)(nil)).Elem()
}

func (i SubResourceArgs) ToSubResourceOutput() SubResourceOutput {
	return i.ToSubResourceOutputWithContext(context.Background())
}

func (i SubResourceArgs) ToSubResourceOutputWithContext(ctx context.Context) SubResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubResourceOutput)
}

func (i SubResourceArgs) ToSubResourcePtrOutput() SubResourcePtrOutput {
	return i.ToSubResourcePtrOutputWithContext(context.Background())
}

func (i SubResourceArgs) ToSubResourcePtrOutputWithContext(ctx context.Context) SubResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubResourceOutput).ToSubResourcePtrOutputWithContext(ctx)
}

// SubResourcePtrInput is an input type that accepts SubResourceArgs, SubResourcePtr and SubResourcePtrOutput values.
// You can construct a concrete instance of `SubResourcePtrInput` via:
//
//	        SubResourceArgs{...}
//
//	or:
//
//	        nil
type SubResourcePtrInput interface {
	pulumi.Input

	ToSubResourcePtrOutput() SubResourcePtrOutput
	ToSubResourcePtrOutputWithContext(context.Context) SubResourcePtrOutput
}

type subResourcePtrType SubResourceArgs

func SubResourcePtr(v *SubResourceArgs) SubResourcePtrInput {
	return (*subResourcePtrType)(v)
}

func (*subResourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubResource)(nil)).Elem()
}

func (i *subResourcePtrType) ToSubResourcePtrOutput() SubResourcePtrOutput {
	return i.ToSubResourcePtrOutputWithContext(context.Background())
}

func (i *subResourcePtrType) ToSubResourcePtrOutputWithContext(ctx context.Context) SubResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubResourcePtrOutput)
}

// SubResourceArrayInput is an input type that accepts SubResourceArray and SubResourceArrayOutput values.
// You can construct a concrete instance of `SubResourceArrayInput` via:
//
//	SubResourceArray{ SubResourceArgs{...} }
type SubResourceArrayInput interface {
	pulumi.Input

	ToSubResourceArrayOutput() SubResourceArrayOutput
	ToSubResourceArrayOutputWithContext(context.Context) SubResourceArrayOutput
}

type SubResourceArray []SubResourceInput

func (SubResourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubResource)(nil)).Elem()
}

func (i SubResourceArray) ToSubResourceArrayOutput() SubResourceArrayOutput {
	return i.ToSubResourceArrayOutputWithContext(context.Background())
}

func (i SubResourceArray) ToSubResourceArrayOutputWithContext(ctx context.Context) SubResourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubResourceArrayOutput)
}

// Azure resource identifier.
type SubResourceOutput struct{ *pulumi.OutputState }

func (SubResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubResource)(nil)).Elem()
}

func (o SubResourceOutput) ToSubResourceOutput() SubResourceOutput {
	return o
}

func (o SubResourceOutput) ToSubResourceOutputWithContext(ctx context.Context) SubResourceOutput {
	return o
}

func (o SubResourceOutput) ToSubResourcePtrOutput() SubResourcePtrOutput {
	return o.ToSubResourcePtrOutputWithContext(context.Background())
}

func (o SubResourceOutput) ToSubResourcePtrOutputWithContext(ctx context.Context) SubResourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SubResource) *SubResource {
		return &v
	}).(SubResourcePtrOutput)
}

// Sub-resource ID. Both absolute resource ID and a relative resource ID are accepted.
// An absolute ID starts with /subscriptions/ and contains the entire ID of the parent resource and the ID of the sub-resource in the end.
// A relative ID replaces the ID of the parent resource with a token '$self', followed by the sub-resource ID itself.
// Example of a relative ID: $self/frontEndConfigurations/my-frontend.
func (o SubResourceOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubResource) *string { return v.Id }).(pulumi.StringPtrOutput)
}

type SubResourcePtrOutput struct{ *pulumi.OutputState }

func (SubResourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubResource)(nil)).Elem()
}

func (o SubResourcePtrOutput) ToSubResourcePtrOutput() SubResourcePtrOutput {
	return o
}

func (o SubResourcePtrOutput) ToSubResourcePtrOutputWithContext(ctx context.Context) SubResourcePtrOutput {
	return o
}

func (o SubResourcePtrOutput) Elem() SubResourceOutput {
	return o.ApplyT(func(v *SubResource) SubResource {
		if v != nil {
			return *v
		}
		var ret SubResource
		return ret
	}).(SubResourceOutput)
}

// Sub-resource ID. Both absolute resource ID and a relative resource ID are accepted.
// An absolute ID starts with /subscriptions/ and contains the entire ID of the parent resource and the ID of the sub-resource in the end.
// A relative ID replaces the ID of the parent resource with a token '$self', followed by the sub-resource ID itself.
// Example of a relative ID: $self/frontEndConfigurations/my-frontend.
func (o SubResourcePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubResource) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

type SubResourceArrayOutput struct{ *pulumi.OutputState }

func (SubResourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubResource)(nil)).Elem()
}

func (o SubResourceArrayOutput) ToSubResourceArrayOutput() SubResourceArrayOutput {
	return o
}

func (o SubResourceArrayOutput) ToSubResourceArrayOutputWithContext(ctx context.Context) SubResourceArrayOutput {
	return o
}

func (o SubResourceArrayOutput) Index(i pulumi.IntInput) SubResourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubResource {
		return vs[0].([]SubResource)[vs[1].(int)]
	}).(SubResourceOutput)
}

// Azure resource identifier.
type SubResourceResponse struct {
	// Azure resource identifier.
	Id *string `pulumi:"id"`
}

// Azure resource identifier.
type SubResourceResponseOutput struct{ *pulumi.OutputState }

func (SubResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubResourceResponse)(nil)).Elem()
}

func (o SubResourceResponseOutput) ToSubResourceResponseOutput() SubResourceResponseOutput {
	return o
}

func (o SubResourceResponseOutput) ToSubResourceResponseOutputWithContext(ctx context.Context) SubResourceResponseOutput {
	return o
}

// Azure resource identifier.
func (o SubResourceResponseOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubResourceResponse) *string { return v.Id }).(pulumi.StringPtrOutput)
}

type SubResourceResponsePtrOutput struct{ *pulumi.OutputState }

func (SubResourceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubResourceResponse)(nil)).Elem()
}

func (o SubResourceResponsePtrOutput) ToSubResourceResponsePtrOutput() SubResourceResponsePtrOutput {
	return o
}

func (o SubResourceResponsePtrOutput) ToSubResourceResponsePtrOutputWithContext(ctx context.Context) SubResourceResponsePtrOutput {
	return o
}

func (o SubResourceResponsePtrOutput) Elem() SubResourceResponseOutput {
	return o.ApplyT(func(v *SubResourceResponse) SubResourceResponse {
		if v != nil {
			return *v
		}
		var ret SubResourceResponse
		return ret
	}).(SubResourceResponseOutput)
}

// Azure resource identifier.
func (o SubResourceResponsePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubResourceResponse) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

type SubResourceResponseArrayOutput struct{ *pulumi.OutputState }

func (SubResourceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubResourceResponse)(nil)).Elem()
}

func (o SubResourceResponseArrayOutput) ToSubResourceResponseArrayOutput() SubResourceResponseArrayOutput {
	return o
}

func (o SubResourceResponseArrayOutput) ToSubResourceResponseArrayOutputWithContext(ctx context.Context) SubResourceResponseArrayOutput {
	return o
}

func (o SubResourceResponseArrayOutput) Index(i pulumi.IntInput) SubResourceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubResourceResponse {
		return vs[0].([]SubResourceResponse)[vs[1].(int)]
	}).(SubResourceResponseOutput)
}

// Describes a Subnet.
type Subnet struct {
	// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
	EnableIpv6 *bool `pulumi:"enableIpv6"`
	// Subnet name.
	Name string `pulumi:"name"`
	// Full resource id for the network security group.
	NetworkSecurityGroupId *string `pulumi:"networkSecurityGroupId"`
	// Enable or Disable apply network policies on private end point in the subnet.
	PrivateEndpointNetworkPolicies *string `pulumi:"privateEndpointNetworkPolicies"`
	// Enable or Disable apply network policies on private link service in the subnet.
	PrivateLinkServiceNetworkPolicies *string `pulumi:"privateLinkServiceNetworkPolicies"`
}

// SubnetInput is an input type that accepts SubnetArgs and SubnetOutput values.
// You can construct a concrete instance of `SubnetInput` via:
//
//	SubnetArgs{...}
type SubnetInput interface {
	pulumi.Input

	ToSubnetOutput() SubnetOutput
	ToSubnetOutputWithContext(context.Context) SubnetOutput
}

// Describes a Subnet.
type SubnetArgs struct {
	// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
	EnableIpv6 pulumi.BoolPtrInput `pulumi:"enableIpv6"`
	// Subnet name.
	Name pulumi.StringInput `pulumi:"name"`
	// Full resource id for the network security group.
	NetworkSecurityGroupId pulumi.StringPtrInput `pulumi:"networkSecurityGroupId"`
	// Enable or Disable apply network policies on private end point in the subnet.
	PrivateEndpointNetworkPolicies pulumi.StringPtrInput `pulumi:"privateEndpointNetworkPolicies"`
	// Enable or Disable apply network policies on private link service in the subnet.
	PrivateLinkServiceNetworkPolicies pulumi.StringPtrInput `pulumi:"privateLinkServiceNetworkPolicies"`
}

func (SubnetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Subnet)(nil)).Elem()
}

func (i SubnetArgs) ToSubnetOutput() SubnetOutput {
	return i.ToSubnetOutputWithContext(context.Background())
}

func (i SubnetArgs) ToSubnetOutputWithContext(ctx context.Context) SubnetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubnetOutput)
}

// SubnetArrayInput is an input type that accepts SubnetArray and SubnetArrayOutput values.
// You can construct a concrete instance of `SubnetArrayInput` via:
//
//	SubnetArray{ SubnetArgs{...} }
type SubnetArrayInput interface {
	pulumi.Input

	ToSubnetArrayOutput() SubnetArrayOutput
	ToSubnetArrayOutputWithContext(context.Context) SubnetArrayOutput
}

type SubnetArray []SubnetInput

func (SubnetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Subnet)(nil)).Elem()
}

func (i SubnetArray) ToSubnetArrayOutput() SubnetArrayOutput {
	return i.ToSubnetArrayOutputWithContext(context.Background())
}

func (i SubnetArray) ToSubnetArrayOutputWithContext(ctx context.Context) SubnetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubnetArrayOutput)
}

// Describes a Subnet.
type SubnetOutput struct{ *pulumi.OutputState }

func (SubnetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Subnet)(nil)).Elem()
}

func (o SubnetOutput) ToSubnetOutput() SubnetOutput {
	return o
}

func (o SubnetOutput) ToSubnetOutputWithContext(ctx context.Context) SubnetOutput {
	return o
}

// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
func (o SubnetOutput) EnableIpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Subnet) *bool { return v.EnableIpv6 }).(pulumi.BoolPtrOutput)
}

// Subnet name.
func (o SubnetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Subnet) string { return v.Name }).(pulumi.StringOutput)
}

// Full resource id for the network security group.
func (o SubnetOutput) NetworkSecurityGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Subnet) *string { return v.NetworkSecurityGroupId }).(pulumi.StringPtrOutput)
}

// Enable or Disable apply network policies on private end point in the subnet.
func (o SubnetOutput) PrivateEndpointNetworkPolicies() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Subnet) *string { return v.PrivateEndpointNetworkPolicies }).(pulumi.StringPtrOutput)
}

// Enable or Disable apply network policies on private link service in the subnet.
func (o SubnetOutput) PrivateLinkServiceNetworkPolicies() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Subnet) *string { return v.PrivateLinkServiceNetworkPolicies }).(pulumi.StringPtrOutput)
}

type SubnetArrayOutput struct{ *pulumi.OutputState }

func (SubnetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Subnet)(nil)).Elem()
}

func (o SubnetArrayOutput) ToSubnetArrayOutput() SubnetArrayOutput {
	return o
}

func (o SubnetArrayOutput) ToSubnetArrayOutputWithContext(ctx context.Context) SubnetArrayOutput {
	return o
}

func (o SubnetArrayOutput) Index(i pulumi.IntInput) SubnetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Subnet {
		return vs[0].([]Subnet)[vs[1].(int)]
	}).(SubnetOutput)
}

// Describes a Subnet.
type SubnetResponse struct {
	// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
	EnableIpv6 *bool `pulumi:"enableIpv6"`
	// Subnet name.
	Name string `pulumi:"name"`
	// Full resource id for the network security group.
	NetworkSecurityGroupId *string `pulumi:"networkSecurityGroupId"`
	// Enable or Disable apply network policies on private end point in the subnet.
	PrivateEndpointNetworkPolicies *string `pulumi:"privateEndpointNetworkPolicies"`
	// Enable or Disable apply network policies on private link service in the subnet.
	PrivateLinkServiceNetworkPolicies *string `pulumi:"privateLinkServiceNetworkPolicies"`
}

// Describes a Subnet.
type SubnetResponseOutput struct{ *pulumi.OutputState }

func (SubnetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubnetResponse)(nil)).Elem()
}

func (o SubnetResponseOutput) ToSubnetResponseOutput() SubnetResponseOutput {
	return o
}

func (o SubnetResponseOutput) ToSubnetResponseOutputWithContext(ctx context.Context) SubnetResponseOutput {
	return o
}

// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
func (o SubnetResponseOutput) EnableIpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SubnetResponse) *bool { return v.EnableIpv6 }).(pulumi.BoolPtrOutput)
}

// Subnet name.
func (o SubnetResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SubnetResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Full resource id for the network security group.
func (o SubnetResponseOutput) NetworkSecurityGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubnetResponse) *string { return v.NetworkSecurityGroupId }).(pulumi.StringPtrOutput)
}

// Enable or Disable apply network policies on private end point in the subnet.
func (o SubnetResponseOutput) PrivateEndpointNetworkPolicies() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubnetResponse) *string { return v.PrivateEndpointNetworkPolicies }).(pulumi.StringPtrOutput)
}

// Enable or Disable apply network policies on private link service in the subnet.
func (o SubnetResponseOutput) PrivateLinkServiceNetworkPolicies() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubnetResponse) *string { return v.PrivateLinkServiceNetworkPolicies }).(pulumi.StringPtrOutput)
}

type SubnetResponseArrayOutput struct{ *pulumi.OutputState }

func (SubnetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubnetResponse)(nil)).Elem()
}

func (o SubnetResponseArrayOutput) ToSubnetResponseArrayOutput() SubnetResponseArrayOutput {
	return o
}

func (o SubnetResponseArrayOutput) ToSubnetResponseArrayOutputWithContext(ctx context.Context) SubnetResponseArrayOutput {
	return o
}

func (o SubnetResponseArrayOutput) Index(i pulumi.IntInput) SubnetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubnetResponse {
		return vs[0].([]SubnetResponse)[vs[1].(int)]
	}).(SubnetResponseOutput)
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponse struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *string `pulumi:"createdAt"`
	// The identity that created the resource.
	CreatedBy *string `pulumi:"createdBy"`
	// The type of identity that created the resource.
	CreatedByType *string `pulumi:"createdByType"`
	// The timestamp of resource last modification (UTC).
	LastModifiedAt *string `pulumi:"lastModifiedAt"`
	// The identity that last modified the resource.
	LastModifiedBy *string `pulumi:"lastModifiedBy"`
	// The type of identity that last modified the resource.
	LastModifiedByType *string `pulumi:"lastModifiedByType"`
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponseOutput struct{ *pulumi.OutputState }

func (SystemDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SystemDataResponse)(nil)).Elem()
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutput() SystemDataResponseOutput {
	return o
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutputWithContext(ctx context.Context) SystemDataResponseOutput {
	return o
}

// The timestamp of resource creation (UTC).
func (o SystemDataResponseOutput) CreatedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedAt }).(pulumi.StringPtrOutput)
}

// The identity that created the resource.
func (o SystemDataResponseOutput) CreatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that created the resource.
func (o SystemDataResponseOutput) CreatedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedByType }).(pulumi.StringPtrOutput)
}

// The timestamp of resource last modification (UTC).
func (o SystemDataResponseOutput) LastModifiedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedAt }).(pulumi.StringPtrOutput)
}

// The identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedByType }).(pulumi.StringPtrOutput)
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionScheme struct {
	// The number of partitions.
	Count int `pulumi:"count"`
	// The upper bound of the partition key range that
	// should be split between the partition Count
	HighKey float64 `pulumi:"highKey"`
	// The lower bound of the partition key range that
	// should be split between the partition Count
	LowKey float64 `pulumi:"lowKey"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'UniformInt64Range'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// UniformInt64RangePartitionSchemeInput is an input type that accepts UniformInt64RangePartitionSchemeArgs and UniformInt64RangePartitionSchemeOutput values.
// You can construct a concrete instance of `UniformInt64RangePartitionSchemeInput` via:
//
//	UniformInt64RangePartitionSchemeArgs{...}
type UniformInt64RangePartitionSchemeInput interface {
	pulumi.Input

	ToUniformInt64RangePartitionSchemeOutput() UniformInt64RangePartitionSchemeOutput
	ToUniformInt64RangePartitionSchemeOutputWithContext(context.Context) UniformInt64RangePartitionSchemeOutput
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionSchemeArgs struct {
	// The number of partitions.
	Count pulumi.IntInput `pulumi:"count"`
	// The upper bound of the partition key range that
	// should be split between the partition Count
	HighKey pulumi.Float64Input `pulumi:"highKey"`
	// The lower bound of the partition key range that
	// should be split between the partition Count
	LowKey pulumi.Float64Input `pulumi:"lowKey"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'UniformInt64Range'.
	PartitionScheme pulumi.StringInput `pulumi:"partitionScheme"`
}

func (UniformInt64RangePartitionSchemeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UniformInt64RangePartitionScheme)(nil)).Elem()
}

func (i UniformInt64RangePartitionSchemeArgs) ToUniformInt64RangePartitionSchemeOutput() UniformInt64RangePartitionSchemeOutput {
	return i.ToUniformInt64RangePartitionSchemeOutputWithContext(context.Background())
}

func (i UniformInt64RangePartitionSchemeArgs) ToUniformInt64RangePartitionSchemeOutputWithContext(ctx context.Context) UniformInt64RangePartitionSchemeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UniformInt64RangePartitionSchemeOutput)
}

func (i UniformInt64RangePartitionSchemeArgs) ToUniformInt64RangePartitionSchemePtrOutput() UniformInt64RangePartitionSchemePtrOutput {
	return i.ToUniformInt64RangePartitionSchemePtrOutputWithContext(context.Background())
}

func (i UniformInt64RangePartitionSchemeArgs) ToUniformInt64RangePartitionSchemePtrOutputWithContext(ctx context.Context) UniformInt64RangePartitionSchemePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UniformInt64RangePartitionSchemeOutput).ToUniformInt64RangePartitionSchemePtrOutputWithContext(ctx)
}

// UniformInt64RangePartitionSchemePtrInput is an input type that accepts UniformInt64RangePartitionSchemeArgs, UniformInt64RangePartitionSchemePtr and UniformInt64RangePartitionSchemePtrOutput values.
// You can construct a concrete instance of `UniformInt64RangePartitionSchemePtrInput` via:
//
//	        UniformInt64RangePartitionSchemeArgs{...}
//
//	or:
//
//	        nil
type UniformInt64RangePartitionSchemePtrInput interface {
	pulumi.Input

	ToUniformInt64RangePartitionSchemePtrOutput() UniformInt64RangePartitionSchemePtrOutput
	ToUniformInt64RangePartitionSchemePtrOutputWithContext(context.Context) UniformInt64RangePartitionSchemePtrOutput
}

type uniformInt64RangePartitionSchemePtrType UniformInt64RangePartitionSchemeArgs

func UniformInt64RangePartitionSchemePtr(v *UniformInt64RangePartitionSchemeArgs) UniformInt64RangePartitionSchemePtrInput {
	return (*uniformInt64RangePartitionSchemePtrType)(v)
}

func (*uniformInt64RangePartitionSchemePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UniformInt64RangePartitionScheme)(nil)).Elem()
}

func (i *uniformInt64RangePartitionSchemePtrType) ToUniformInt64RangePartitionSchemePtrOutput() UniformInt64RangePartitionSchemePtrOutput {
	return i.ToUniformInt64RangePartitionSchemePtrOutputWithContext(context.Background())
}

func (i *uniformInt64RangePartitionSchemePtrType) ToUniformInt64RangePartitionSchemePtrOutputWithContext(ctx context.Context) UniformInt64RangePartitionSchemePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UniformInt64RangePartitionSchemePtrOutput)
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionSchemeOutput struct{ *pulumi.OutputState }

func (UniformInt64RangePartitionSchemeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UniformInt64RangePartitionScheme)(nil)).Elem()
}

func (o UniformInt64RangePartitionSchemeOutput) ToUniformInt64RangePartitionSchemeOutput() UniformInt64RangePartitionSchemeOutput {
	return o
}

func (o UniformInt64RangePartitionSchemeOutput) ToUniformInt64RangePartitionSchemeOutputWithContext(ctx context.Context) UniformInt64RangePartitionSchemeOutput {
	return o
}

func (o UniformInt64RangePartitionSchemeOutput) ToUniformInt64RangePartitionSchemePtrOutput() UniformInt64RangePartitionSchemePtrOutput {
	return o.ToUniformInt64RangePartitionSchemePtrOutputWithContext(context.Background())
}

func (o UniformInt64RangePartitionSchemeOutput) ToUniformInt64RangePartitionSchemePtrOutputWithContext(ctx context.Context) UniformInt64RangePartitionSchemePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UniformInt64RangePartitionScheme) *UniformInt64RangePartitionScheme {
		return &v
	}).(UniformInt64RangePartitionSchemePtrOutput)
}

// The number of partitions.
func (o UniformInt64RangePartitionSchemeOutput) Count() pulumi.IntOutput {
	return o.ApplyT(func(v UniformInt64RangePartitionScheme) int { return v.Count }).(pulumi.IntOutput)
}

// The upper bound of the partition key range that
// should be split between the partition Count
func (o UniformInt64RangePartitionSchemeOutput) HighKey() pulumi.Float64Output {
	return o.ApplyT(func(v UniformInt64RangePartitionScheme) float64 { return v.HighKey }).(pulumi.Float64Output)
}

// The lower bound of the partition key range that
// should be split between the partition Count
func (o UniformInt64RangePartitionSchemeOutput) LowKey() pulumi.Float64Output {
	return o.ApplyT(func(v UniformInt64RangePartitionScheme) float64 { return v.LowKey }).(pulumi.Float64Output)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'UniformInt64Range'.
func (o UniformInt64RangePartitionSchemeOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v UniformInt64RangePartitionScheme) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

type UniformInt64RangePartitionSchemePtrOutput struct{ *pulumi.OutputState }

func (UniformInt64RangePartitionSchemePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UniformInt64RangePartitionScheme)(nil)).Elem()
}

func (o UniformInt64RangePartitionSchemePtrOutput) ToUniformInt64RangePartitionSchemePtrOutput() UniformInt64RangePartitionSchemePtrOutput {
	return o
}

func (o UniformInt64RangePartitionSchemePtrOutput) ToUniformInt64RangePartitionSchemePtrOutputWithContext(ctx context.Context) UniformInt64RangePartitionSchemePtrOutput {
	return o
}

func (o UniformInt64RangePartitionSchemePtrOutput) Elem() UniformInt64RangePartitionSchemeOutput {
	return o.ApplyT(func(v *UniformInt64RangePartitionScheme) UniformInt64RangePartitionScheme {
		if v != nil {
			return *v
		}
		var ret UniformInt64RangePartitionScheme
		return ret
	}).(UniformInt64RangePartitionSchemeOutput)
}

// The number of partitions.
func (o UniformInt64RangePartitionSchemePtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *UniformInt64RangePartitionScheme) *int {
		if v == nil {
			return nil
		}
		return &v.Count
	}).(pulumi.IntPtrOutput)
}

// The upper bound of the partition key range that
// should be split between the partition Count
func (o UniformInt64RangePartitionSchemePtrOutput) HighKey() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *UniformInt64RangePartitionScheme) *float64 {
		if v == nil {
			return nil
		}
		return &v.HighKey
	}).(pulumi.Float64PtrOutput)
}

// The lower bound of the partition key range that
// should be split between the partition Count
func (o UniformInt64RangePartitionSchemePtrOutput) LowKey() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *UniformInt64RangePartitionScheme) *float64 {
		if v == nil {
			return nil
		}
		return &v.LowKey
	}).(pulumi.Float64PtrOutput)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'UniformInt64Range'.
func (o UniformInt64RangePartitionSchemePtrOutput) PartitionScheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UniformInt64RangePartitionScheme) *string {
		if v == nil {
			return nil
		}
		return &v.PartitionScheme
	}).(pulumi.StringPtrOutput)
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionSchemeResponse struct {
	// The number of partitions.
	Count int `pulumi:"count"`
	// The upper bound of the partition key range that
	// should be split between the partition Count
	HighKey float64 `pulumi:"highKey"`
	// The lower bound of the partition key range that
	// should be split between the partition Count
	LowKey float64 `pulumi:"lowKey"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'UniformInt64Range'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionSchemeResponseOutput struct{ *pulumi.OutputState }

func (UniformInt64RangePartitionSchemeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UniformInt64RangePartitionSchemeResponse)(nil)).Elem()
}

func (o UniformInt64RangePartitionSchemeResponseOutput) ToUniformInt64RangePartitionSchemeResponseOutput() UniformInt64RangePartitionSchemeResponseOutput {
	return o
}

func (o UniformInt64RangePartitionSchemeResponseOutput) ToUniformInt64RangePartitionSchemeResponseOutputWithContext(ctx context.Context) UniformInt64RangePartitionSchemeResponseOutput {
	return o
}

// The number of partitions.
func (o UniformInt64RangePartitionSchemeResponseOutput) Count() pulumi.IntOutput {
	return o.ApplyT(func(v UniformInt64RangePartitionSchemeResponse) int { return v.Count }).(pulumi.IntOutput)
}

// The upper bound of the partition key range that
// should be split between the partition Count
func (o UniformInt64RangePartitionSchemeResponseOutput) HighKey() pulumi.Float64Output {
	return o.ApplyT(func(v UniformInt64RangePartitionSchemeResponse) float64 { return v.HighKey }).(pulumi.Float64Output)
}

// The lower bound of the partition key range that
// should be split between the partition Count
func (o UniformInt64RangePartitionSchemeResponseOutput) LowKey() pulumi.Float64Output {
	return o.ApplyT(func(v UniformInt64RangePartitionSchemeResponse) float64 { return v.LowKey }).(pulumi.Float64Output)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'UniformInt64Range'.
func (o UniformInt64RangePartitionSchemeResponseOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v UniformInt64RangePartitionSchemeResponse) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

type UserAssignedIdentityResponse struct {
	// The client id of user assigned identity.
	ClientId string `pulumi:"clientId"`
	// The principal id of user assigned identity.
	PrincipalId string `pulumi:"principalId"`
}

type UserAssignedIdentityResponseOutput struct{ *pulumi.OutputState }

func (UserAssignedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserAssignedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedIdentityResponseOutput) ToUserAssignedIdentityResponseOutput() UserAssignedIdentityResponseOutput {
	return o
}

func (o UserAssignedIdentityResponseOutput) ToUserAssignedIdentityResponseOutputWithContext(ctx context.Context) UserAssignedIdentityResponseOutput {
	return o
}

// The client id of user assigned identity.
func (o UserAssignedIdentityResponseOutput) ClientId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedIdentityResponse) string { return v.ClientId }).(pulumi.StringOutput)
}

// The principal id of user assigned identity.
func (o UserAssignedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type UserAssignedIdentityResponseMapOutput struct{ *pulumi.OutputState }

func (UserAssignedIdentityResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]UserAssignedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedIdentityResponseMapOutput) ToUserAssignedIdentityResponseMapOutput() UserAssignedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedIdentityResponseMapOutput) ToUserAssignedIdentityResponseMapOutputWithContext(ctx context.Context) UserAssignedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedIdentityResponseMapOutput) MapIndex(k pulumi.StringInput) UserAssignedIdentityResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) UserAssignedIdentityResponse {
		return vs[0].(map[string]UserAssignedIdentityResponse)[vs[1].(string)]
	}).(UserAssignedIdentityResponseOutput)
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtension struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion *bool `pulumi:"autoUpgradeMinorVersion"`
	// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
	EnableAutomaticUpgrade *bool `pulumi:"enableAutomaticUpgrade"`
	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
	ForceUpdateTag *string `pulumi:"forceUpdateTag"`
	// The name of the extension.
	Name string `pulumi:"name"`
	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings interface{} `pulumi:"protectedSettings"`
	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []string `pulumi:"provisionAfterExtensions"`
	// The name of the extension handler publisher.
	Publisher string `pulumi:"publisher"`
	// Json formatted public settings for the extension.
	Settings interface{} `pulumi:"settings"`
	// Indicates the setup order for the extension.
	SetupOrder []string `pulumi:"setupOrder"`
	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type string `pulumi:"type"`
	// Specifies the version of the script handler.
	TypeHandlerVersion string `pulumi:"typeHandlerVersion"`
}

// VMSSExtensionInput is an input type that accepts VMSSExtensionArgs and VMSSExtensionOutput values.
// You can construct a concrete instance of `VMSSExtensionInput` via:
//
//	VMSSExtensionArgs{...}
type VMSSExtensionInput interface {
	pulumi.Input

	ToVMSSExtensionOutput() VMSSExtensionOutput
	ToVMSSExtensionOutputWithContext(context.Context) VMSSExtensionOutput
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionArgs struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion pulumi.BoolPtrInput `pulumi:"autoUpgradeMinorVersion"`
	// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
	EnableAutomaticUpgrade pulumi.BoolPtrInput `pulumi:"enableAutomaticUpgrade"`
	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
	ForceUpdateTag pulumi.StringPtrInput `pulumi:"forceUpdateTag"`
	// The name of the extension.
	Name pulumi.StringInput `pulumi:"name"`
	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings pulumi.Input `pulumi:"protectedSettings"`
	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions pulumi.StringArrayInput `pulumi:"provisionAfterExtensions"`
	// The name of the extension handler publisher.
	Publisher pulumi.StringInput `pulumi:"publisher"`
	// Json formatted public settings for the extension.
	Settings pulumi.Input `pulumi:"settings"`
	// Indicates the setup order for the extension.
	SetupOrder pulumi.StringArrayInput `pulumi:"setupOrder"`
	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type pulumi.StringInput `pulumi:"type"`
	// Specifies the version of the script handler.
	TypeHandlerVersion pulumi.StringInput `pulumi:"typeHandlerVersion"`
}

func (VMSSExtensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VMSSExtension)(nil)).Elem()
}

func (i VMSSExtensionArgs) ToVMSSExtensionOutput() VMSSExtensionOutput {
	return i.ToVMSSExtensionOutputWithContext(context.Background())
}

func (i VMSSExtensionArgs) ToVMSSExtensionOutputWithContext(ctx context.Context) VMSSExtensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMSSExtensionOutput)
}

// VMSSExtensionArrayInput is an input type that accepts VMSSExtensionArray and VMSSExtensionArrayOutput values.
// You can construct a concrete instance of `VMSSExtensionArrayInput` via:
//
//	VMSSExtensionArray{ VMSSExtensionArgs{...} }
type VMSSExtensionArrayInput interface {
	pulumi.Input

	ToVMSSExtensionArrayOutput() VMSSExtensionArrayOutput
	ToVMSSExtensionArrayOutputWithContext(context.Context) VMSSExtensionArrayOutput
}

type VMSSExtensionArray []VMSSExtensionInput

func (VMSSExtensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMSSExtension)(nil)).Elem()
}

func (i VMSSExtensionArray) ToVMSSExtensionArrayOutput() VMSSExtensionArrayOutput {
	return i.ToVMSSExtensionArrayOutputWithContext(context.Background())
}

func (i VMSSExtensionArray) ToVMSSExtensionArrayOutputWithContext(ctx context.Context) VMSSExtensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMSSExtensionArrayOutput)
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionOutput struct{ *pulumi.OutputState }

func (VMSSExtensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VMSSExtension)(nil)).Elem()
}

func (o VMSSExtensionOutput) ToVMSSExtensionOutput() VMSSExtensionOutput {
	return o
}

func (o VMSSExtensionOutput) ToVMSSExtensionOutputWithContext(ctx context.Context) VMSSExtensionOutput {
	return o
}

// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
func (o VMSSExtensionOutput) AutoUpgradeMinorVersion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMSSExtension) *bool { return v.AutoUpgradeMinorVersion }).(pulumi.BoolPtrOutput)
}

// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
func (o VMSSExtensionOutput) EnableAutomaticUpgrade() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMSSExtension) *bool { return v.EnableAutomaticUpgrade }).(pulumi.BoolPtrOutput)
}

// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
func (o VMSSExtensionOutput) ForceUpdateTag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMSSExtension) *string { return v.ForceUpdateTag }).(pulumi.StringPtrOutput)
}

// The name of the extension.
func (o VMSSExtensionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.Name }).(pulumi.StringOutput)
}

// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
func (o VMSSExtensionOutput) ProtectedSettings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtension) interface{} { return v.ProtectedSettings }).(pulumi.AnyOutput)
}

// Collection of extension names after which this extension needs to be provisioned.
func (o VMSSExtensionOutput) ProvisionAfterExtensions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VMSSExtension) []string { return v.ProvisionAfterExtensions }).(pulumi.StringArrayOutput)
}

// The name of the extension handler publisher.
func (o VMSSExtensionOutput) Publisher() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.Publisher }).(pulumi.StringOutput)
}

// Json formatted public settings for the extension.
func (o VMSSExtensionOutput) Settings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtension) interface{} { return v.Settings }).(pulumi.AnyOutput)
}

// Indicates the setup order for the extension.
func (o VMSSExtensionOutput) SetupOrder() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VMSSExtension) []string { return v.SetupOrder }).(pulumi.StringArrayOutput)
}

// Specifies the type of the extension; an example is "CustomScriptExtension".
func (o VMSSExtensionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.Type }).(pulumi.StringOutput)
}

// Specifies the version of the script handler.
func (o VMSSExtensionOutput) TypeHandlerVersion() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.TypeHandlerVersion }).(pulumi.StringOutput)
}

type VMSSExtensionArrayOutput struct{ *pulumi.OutputState }

func (VMSSExtensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMSSExtension)(nil)).Elem()
}

func (o VMSSExtensionArrayOutput) ToVMSSExtensionArrayOutput() VMSSExtensionArrayOutput {
	return o
}

func (o VMSSExtensionArrayOutput) ToVMSSExtensionArrayOutputWithContext(ctx context.Context) VMSSExtensionArrayOutput {
	return o
}

func (o VMSSExtensionArrayOutput) Index(i pulumi.IntInput) VMSSExtensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VMSSExtension {
		return vs[0].([]VMSSExtension)[vs[1].(int)]
	}).(VMSSExtensionOutput)
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionResponse struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion *bool `pulumi:"autoUpgradeMinorVersion"`
	// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
	EnableAutomaticUpgrade *bool `pulumi:"enableAutomaticUpgrade"`
	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
	ForceUpdateTag *string `pulumi:"forceUpdateTag"`
	// The name of the extension.
	Name string `pulumi:"name"`
	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings interface{} `pulumi:"protectedSettings"`
	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []string `pulumi:"provisionAfterExtensions"`
	// The provisioning state, which only appears in the response.
	ProvisioningState string `pulumi:"provisioningState"`
	// The name of the extension handler publisher.
	Publisher string `pulumi:"publisher"`
	// Json formatted public settings for the extension.
	Settings interface{} `pulumi:"settings"`
	// Indicates the setup order for the extension.
	SetupOrder []string `pulumi:"setupOrder"`
	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type string `pulumi:"type"`
	// Specifies the version of the script handler.
	TypeHandlerVersion string `pulumi:"typeHandlerVersion"`
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionResponseOutput struct{ *pulumi.OutputState }

func (VMSSExtensionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VMSSExtensionResponse)(nil)).Elem()
}

func (o VMSSExtensionResponseOutput) ToVMSSExtensionResponseOutput() VMSSExtensionResponseOutput {
	return o
}

func (o VMSSExtensionResponseOutput) ToVMSSExtensionResponseOutputWithContext(ctx context.Context) VMSSExtensionResponseOutput {
	return o
}

// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
func (o VMSSExtensionResponseOutput) AutoUpgradeMinorVersion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) *bool { return v.AutoUpgradeMinorVersion }).(pulumi.BoolPtrOutput)
}

// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
func (o VMSSExtensionResponseOutput) EnableAutomaticUpgrade() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) *bool { return v.EnableAutomaticUpgrade }).(pulumi.BoolPtrOutput)
}

// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
func (o VMSSExtensionResponseOutput) ForceUpdateTag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) *string { return v.ForceUpdateTag }).(pulumi.StringPtrOutput)
}

// The name of the extension.
func (o VMSSExtensionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
func (o VMSSExtensionResponseOutput) ProtectedSettings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) interface{} { return v.ProtectedSettings }).(pulumi.AnyOutput)
}

// Collection of extension names after which this extension needs to be provisioned.
func (o VMSSExtensionResponseOutput) ProvisionAfterExtensions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) []string { return v.ProvisionAfterExtensions }).(pulumi.StringArrayOutput)
}

// The provisioning state, which only appears in the response.
func (o VMSSExtensionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// The name of the extension handler publisher.
func (o VMSSExtensionResponseOutput) Publisher() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.Publisher }).(pulumi.StringOutput)
}

// Json formatted public settings for the extension.
func (o VMSSExtensionResponseOutput) Settings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) interface{} { return v.Settings }).(pulumi.AnyOutput)
}

// Indicates the setup order for the extension.
func (o VMSSExtensionResponseOutput) SetupOrder() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) []string { return v.SetupOrder }).(pulumi.StringArrayOutput)
}

// Specifies the type of the extension; an example is "CustomScriptExtension".
func (o VMSSExtensionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Specifies the version of the script handler.
func (o VMSSExtensionResponseOutput) TypeHandlerVersion() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.TypeHandlerVersion }).(pulumi.StringOutput)
}

type VMSSExtensionResponseArrayOutput struct{ *pulumi.OutputState }

func (VMSSExtensionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMSSExtensionResponse)(nil)).Elem()
}

func (o VMSSExtensionResponseArrayOutput) ToVMSSExtensionResponseArrayOutput() VMSSExtensionResponseArrayOutput {
	return o
}

func (o VMSSExtensionResponseArrayOutput) ToVMSSExtensionResponseArrayOutputWithContext(ctx context.Context) VMSSExtensionResponseArrayOutput {
	return o
}

func (o VMSSExtensionResponseArrayOutput) Index(i pulumi.IntInput) VMSSExtensionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VMSSExtensionResponse {
		return vs[0].([]VMSSExtensionResponse)[vs[1].(int)]
	}).(VMSSExtensionResponseOutput)
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificate struct {
	// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
	CertificateStore string `pulumi:"certificateStore"`
	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	CertificateUrl string `pulumi:"certificateUrl"`
}

// VaultCertificateInput is an input type that accepts VaultCertificateArgs and VaultCertificateOutput values.
// You can construct a concrete instance of `VaultCertificateInput` via:
//
//	VaultCertificateArgs{...}
type VaultCertificateInput interface {
	pulumi.Input

	ToVaultCertificateOutput() VaultCertificateOutput
	ToVaultCertificateOutputWithContext(context.Context) VaultCertificateOutput
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateArgs struct {
	// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
	CertificateStore pulumi.StringInput `pulumi:"certificateStore"`
	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	CertificateUrl pulumi.StringInput `pulumi:"certificateUrl"`
}

func (VaultCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultCertificate)(nil)).Elem()
}

func (i VaultCertificateArgs) ToVaultCertificateOutput() VaultCertificateOutput {
	return i.ToVaultCertificateOutputWithContext(context.Background())
}

func (i VaultCertificateArgs) ToVaultCertificateOutputWithContext(ctx context.Context) VaultCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultCertificateOutput)
}

// VaultCertificateArrayInput is an input type that accepts VaultCertificateArray and VaultCertificateArrayOutput values.
// You can construct a concrete instance of `VaultCertificateArrayInput` via:
//
//	VaultCertificateArray{ VaultCertificateArgs{...} }
type VaultCertificateArrayInput interface {
	pulumi.Input

	ToVaultCertificateArrayOutput() VaultCertificateArrayOutput
	ToVaultCertificateArrayOutputWithContext(context.Context) VaultCertificateArrayOutput
}

type VaultCertificateArray []VaultCertificateInput

func (VaultCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultCertificate)(nil)).Elem()
}

func (i VaultCertificateArray) ToVaultCertificateArrayOutput() VaultCertificateArrayOutput {
	return i.ToVaultCertificateArrayOutputWithContext(context.Background())
}

func (i VaultCertificateArray) ToVaultCertificateArrayOutputWithContext(ctx context.Context) VaultCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultCertificateArrayOutput)
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateOutput struct{ *pulumi.OutputState }

func (VaultCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultCertificate)(nil)).Elem()
}

func (o VaultCertificateOutput) ToVaultCertificateOutput() VaultCertificateOutput {
	return o
}

func (o VaultCertificateOutput) ToVaultCertificateOutputWithContext(ctx context.Context) VaultCertificateOutput {
	return o
}

// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
func (o VaultCertificateOutput) CertificateStore() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificate) string { return v.CertificateStore }).(pulumi.StringOutput)
}

// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
func (o VaultCertificateOutput) CertificateUrl() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificate) string { return v.CertificateUrl }).(pulumi.StringOutput)
}

type VaultCertificateArrayOutput struct{ *pulumi.OutputState }

func (VaultCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultCertificate)(nil)).Elem()
}

func (o VaultCertificateArrayOutput) ToVaultCertificateArrayOutput() VaultCertificateArrayOutput {
	return o
}

func (o VaultCertificateArrayOutput) ToVaultCertificateArrayOutputWithContext(ctx context.Context) VaultCertificateArrayOutput {
	return o
}

func (o VaultCertificateArrayOutput) Index(i pulumi.IntInput) VaultCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultCertificate {
		return vs[0].([]VaultCertificate)[vs[1].(int)]
	}).(VaultCertificateOutput)
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateResponse struct {
	// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
	CertificateStore string `pulumi:"certificateStore"`
	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	CertificateUrl string `pulumi:"certificateUrl"`
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateResponseOutput struct{ *pulumi.OutputState }

func (VaultCertificateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultCertificateResponse)(nil)).Elem()
}

func (o VaultCertificateResponseOutput) ToVaultCertificateResponseOutput() VaultCertificateResponseOutput {
	return o
}

func (o VaultCertificateResponseOutput) ToVaultCertificateResponseOutputWithContext(ctx context.Context) VaultCertificateResponseOutput {
	return o
}

// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
func (o VaultCertificateResponseOutput) CertificateStore() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificateResponse) string { return v.CertificateStore }).(pulumi.StringOutput)
}

// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
func (o VaultCertificateResponseOutput) CertificateUrl() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificateResponse) string { return v.CertificateUrl }).(pulumi.StringOutput)
}

type VaultCertificateResponseArrayOutput struct{ *pulumi.OutputState }

func (VaultCertificateResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultCertificateResponse)(nil)).Elem()
}

func (o VaultCertificateResponseArrayOutput) ToVaultCertificateResponseArrayOutput() VaultCertificateResponseArrayOutput {
	return o
}

func (o VaultCertificateResponseArrayOutput) ToVaultCertificateResponseArrayOutputWithContext(ctx context.Context) VaultCertificateResponseArrayOutput {
	return o
}

func (o VaultCertificateResponseArrayOutput) Index(i pulumi.IntInput) VaultCertificateResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultCertificateResponse {
		return vs[0].([]VaultCertificateResponse)[vs[1].(int)]
	}).(VaultCertificateResponseOutput)
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroup struct {
	// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault SubResource `pulumi:"sourceVault"`
	// The list of key vault references in SourceVault which contain certificates.
	VaultCertificates []VaultCertificate `pulumi:"vaultCertificates"`
}

// VaultSecretGroupInput is an input type that accepts VaultSecretGroupArgs and VaultSecretGroupOutput values.
// You can construct a concrete instance of `VaultSecretGroupInput` via:
//
//	VaultSecretGroupArgs{...}
type VaultSecretGroupInput interface {
	pulumi.Input

	ToVaultSecretGroupOutput() VaultSecretGroupOutput
	ToVaultSecretGroupOutputWithContext(context.Context) VaultSecretGroupOutput
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupArgs struct {
	// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault SubResourceInput `pulumi:"sourceVault"`
	// The list of key vault references in SourceVault which contain certificates.
	VaultCertificates VaultCertificateArrayInput `pulumi:"vaultCertificates"`
}

func (VaultSecretGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultSecretGroup)(nil)).Elem()
}

func (i VaultSecretGroupArgs) ToVaultSecretGroupOutput() VaultSecretGroupOutput {
	return i.ToVaultSecretGroupOutputWithContext(context.Background())
}

func (i VaultSecretGroupArgs) ToVaultSecretGroupOutputWithContext(ctx context.Context) VaultSecretGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultSecretGroupOutput)
}

// VaultSecretGroupArrayInput is an input type that accepts VaultSecretGroupArray and VaultSecretGroupArrayOutput values.
// You can construct a concrete instance of `VaultSecretGroupArrayInput` via:
//
//	VaultSecretGroupArray{ VaultSecretGroupArgs{...} }
type VaultSecretGroupArrayInput interface {
	pulumi.Input

	ToVaultSecretGroupArrayOutput() VaultSecretGroupArrayOutput
	ToVaultSecretGroupArrayOutputWithContext(context.Context) VaultSecretGroupArrayOutput
}

type VaultSecretGroupArray []VaultSecretGroupInput

func (VaultSecretGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultSecretGroup)(nil)).Elem()
}

func (i VaultSecretGroupArray) ToVaultSecretGroupArrayOutput() VaultSecretGroupArrayOutput {
	return i.ToVaultSecretGroupArrayOutputWithContext(context.Background())
}

func (i VaultSecretGroupArray) ToVaultSecretGroupArrayOutputWithContext(ctx context.Context) VaultSecretGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultSecretGroupArrayOutput)
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultSecretGroup)(nil)).Elem()
}

func (o VaultSecretGroupOutput) ToVaultSecretGroupOutput() VaultSecretGroupOutput {
	return o
}

func (o VaultSecretGroupOutput) ToVaultSecretGroupOutputWithContext(ctx context.Context) VaultSecretGroupOutput {
	return o
}

// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
func (o VaultSecretGroupOutput) SourceVault() SubResourceOutput {
	return o.ApplyT(func(v VaultSecretGroup) SubResource { return v.SourceVault }).(SubResourceOutput)
}

// The list of key vault references in SourceVault which contain certificates.
func (o VaultSecretGroupOutput) VaultCertificates() VaultCertificateArrayOutput {
	return o.ApplyT(func(v VaultSecretGroup) []VaultCertificate { return v.VaultCertificates }).(VaultCertificateArrayOutput)
}

type VaultSecretGroupArrayOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultSecretGroup)(nil)).Elem()
}

func (o VaultSecretGroupArrayOutput) ToVaultSecretGroupArrayOutput() VaultSecretGroupArrayOutput {
	return o
}

func (o VaultSecretGroupArrayOutput) ToVaultSecretGroupArrayOutputWithContext(ctx context.Context) VaultSecretGroupArrayOutput {
	return o
}

func (o VaultSecretGroupArrayOutput) Index(i pulumi.IntInput) VaultSecretGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultSecretGroup {
		return vs[0].([]VaultSecretGroup)[vs[1].(int)]
	}).(VaultSecretGroupOutput)
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupResponse struct {
	// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault SubResourceResponse `pulumi:"sourceVault"`
	// The list of key vault references in SourceVault which contain certificates.
	VaultCertificates []VaultCertificateResponse `pulumi:"vaultCertificates"`
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupResponseOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultSecretGroupResponse)(nil)).Elem()
}

func (o VaultSecretGroupResponseOutput) ToVaultSecretGroupResponseOutput() VaultSecretGroupResponseOutput {
	return o
}

func (o VaultSecretGroupResponseOutput) ToVaultSecretGroupResponseOutputWithContext(ctx context.Context) VaultSecretGroupResponseOutput {
	return o
}

// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
func (o VaultSecretGroupResponseOutput) SourceVault() SubResourceResponseOutput {
	return o.ApplyT(func(v VaultSecretGroupResponse) SubResourceResponse { return v.SourceVault }).(SubResourceResponseOutput)
}

// The list of key vault references in SourceVault which contain certificates.
func (o VaultSecretGroupResponseOutput) VaultCertificates() VaultCertificateResponseArrayOutput {
	return o.ApplyT(func(v VaultSecretGroupResponse) []VaultCertificateResponse { return v.VaultCertificates }).(VaultCertificateResponseArrayOutput)
}

type VaultSecretGroupResponseArrayOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultSecretGroupResponse)(nil)).Elem()
}

func (o VaultSecretGroupResponseArrayOutput) ToVaultSecretGroupResponseArrayOutput() VaultSecretGroupResponseArrayOutput {
	return o
}

func (o VaultSecretGroupResponseArrayOutput) ToVaultSecretGroupResponseArrayOutputWithContext(ctx context.Context) VaultSecretGroupResponseArrayOutput {
	return o
}

func (o VaultSecretGroupResponseArrayOutput) Index(i pulumi.IntInput) VaultSecretGroupResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultSecretGroupResponse {
		return vs[0].([]VaultSecretGroupResponse)[vs[1].(int)]
	}).(VaultSecretGroupResponseOutput)
}

// Specifies the gallery application that should be made available to the underlying VMSS.
type VmApplication struct {
	// Optional, Specifies the uri to an azure blob that will replace the default configuration for the package if provided.
	ConfigurationReference *string `pulumi:"configurationReference"`
	// If set to true, when a new Gallery Application version is available in PIR/SIG, it will be automatically updated for the underlying VMSS.
	EnableAutomaticUpgrade *bool `pulumi:"enableAutomaticUpgrade"`
	// Optional, Specifies the order in which the packages have to be installed.
	Order *int `pulumi:"order"`
	// Specifies the GalleryApplicationVersion resource id on the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{application}/versions/{version}.
	PackageReferenceId string `pulumi:"packageReferenceId"`
	// Optional, If true, any failure for any operation in the VmApplication will fail the deployment.
	TreatFailureAsDeploymentFailure *bool `pulumi:"treatFailureAsDeploymentFailure"`
	// Optional, Specifies a passthrough value for more generic context. Accepts a JSON-formatted string e.g. '{"Tag1":"Value1","Tag2":"Value2"}'.
	VmGalleryTags *string `pulumi:"vmGalleryTags"`
}

// VmApplicationInput is an input type that accepts VmApplicationArgs and VmApplicationOutput values.
// You can construct a concrete instance of `VmApplicationInput` via:
//
//	VmApplicationArgs{...}
type VmApplicationInput interface {
	pulumi.Input

	ToVmApplicationOutput() VmApplicationOutput
	ToVmApplicationOutputWithContext(context.Context) VmApplicationOutput
}

// Specifies the gallery application that should be made available to the underlying VMSS.
type VmApplicationArgs struct {
	// Optional, Specifies the uri to an azure blob that will replace the default configuration for the package if provided.
	ConfigurationReference pulumi.StringPtrInput `pulumi:"configurationReference"`
	// If set to true, when a new Gallery Application version is available in PIR/SIG, it will be automatically updated for the underlying VMSS.
	EnableAutomaticUpgrade pulumi.BoolPtrInput `pulumi:"enableAutomaticUpgrade"`
	// Optional, Specifies the order in which the packages have to be installed.
	Order pulumi.IntPtrInput `pulumi:"order"`
	// Specifies the GalleryApplicationVersion resource id on the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{application}/versions/{version}.
	PackageReferenceId pulumi.StringInput `pulumi:"packageReferenceId"`
	// Optional, If true, any failure for any operation in the VmApplication will fail the deployment.
	TreatFailureAsDeploymentFailure pulumi.BoolPtrInput `pulumi:"treatFailureAsDeploymentFailure"`
	// Optional, Specifies a passthrough value for more generic context. Accepts a JSON-formatted string e.g. '{"Tag1":"Value1","Tag2":"Value2"}'.
	VmGalleryTags pulumi.StringPtrInput `pulumi:"vmGalleryTags"`
}

func (VmApplicationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmApplication)(nil)).Elem()
}

func (i VmApplicationArgs) ToVmApplicationOutput() VmApplicationOutput {
	return i.ToVmApplicationOutputWithContext(context.Background())
}

func (i VmApplicationArgs) ToVmApplicationOutputWithContext(ctx context.Context) VmApplicationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmApplicationOutput)
}

// VmApplicationArrayInput is an input type that accepts VmApplicationArray and VmApplicationArrayOutput values.
// You can construct a concrete instance of `VmApplicationArrayInput` via:
//
//	VmApplicationArray{ VmApplicationArgs{...} }
type VmApplicationArrayInput interface {
	pulumi.Input

	ToVmApplicationArrayOutput() VmApplicationArrayOutput
	ToVmApplicationArrayOutputWithContext(context.Context) VmApplicationArrayOutput
}

type VmApplicationArray []VmApplicationInput

func (VmApplicationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmApplication)(nil)).Elem()
}

func (i VmApplicationArray) ToVmApplicationArrayOutput() VmApplicationArrayOutput {
	return i.ToVmApplicationArrayOutputWithContext(context.Background())
}

func (i VmApplicationArray) ToVmApplicationArrayOutputWithContext(ctx context.Context) VmApplicationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmApplicationArrayOutput)
}

// Specifies the gallery application that should be made available to the underlying VMSS.
type VmApplicationOutput struct{ *pulumi.OutputState }

func (VmApplicationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmApplication)(nil)).Elem()
}

func (o VmApplicationOutput) ToVmApplicationOutput() VmApplicationOutput {
	return o
}

func (o VmApplicationOutput) ToVmApplicationOutputWithContext(ctx context.Context) VmApplicationOutput {
	return o
}

// Optional, Specifies the uri to an azure blob that will replace the default configuration for the package if provided.
func (o VmApplicationOutput) ConfigurationReference() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmApplication) *string { return v.ConfigurationReference }).(pulumi.StringPtrOutput)
}

// If set to true, when a new Gallery Application version is available in PIR/SIG, it will be automatically updated for the underlying VMSS.
func (o VmApplicationOutput) EnableAutomaticUpgrade() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VmApplication) *bool { return v.EnableAutomaticUpgrade }).(pulumi.BoolPtrOutput)
}

// Optional, Specifies the order in which the packages have to be installed.
func (o VmApplicationOutput) Order() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VmApplication) *int { return v.Order }).(pulumi.IntPtrOutput)
}

// Specifies the GalleryApplicationVersion resource id on the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{application}/versions/{version}.
func (o VmApplicationOutput) PackageReferenceId() pulumi.StringOutput {
	return o.ApplyT(func(v VmApplication) string { return v.PackageReferenceId }).(pulumi.StringOutput)
}

// Optional, If true, any failure for any operation in the VmApplication will fail the deployment.
func (o VmApplicationOutput) TreatFailureAsDeploymentFailure() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VmApplication) *bool { return v.TreatFailureAsDeploymentFailure }).(pulumi.BoolPtrOutput)
}

// Optional, Specifies a passthrough value for more generic context. Accepts a JSON-formatted string e.g. '{"Tag1":"Value1","Tag2":"Value2"}'.
func (o VmApplicationOutput) VmGalleryTags() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmApplication) *string { return v.VmGalleryTags }).(pulumi.StringPtrOutput)
}

type VmApplicationArrayOutput struct{ *pulumi.OutputState }

func (VmApplicationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmApplication)(nil)).Elem()
}

func (o VmApplicationArrayOutput) ToVmApplicationArrayOutput() VmApplicationArrayOutput {
	return o
}

func (o VmApplicationArrayOutput) ToVmApplicationArrayOutputWithContext(ctx context.Context) VmApplicationArrayOutput {
	return o
}

func (o VmApplicationArrayOutput) Index(i pulumi.IntInput) VmApplicationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VmApplication {
		return vs[0].([]VmApplication)[vs[1].(int)]
	}).(VmApplicationOutput)
}

// Specifies the gallery application that should be made available to the underlying VMSS.
type VmApplicationResponse struct {
	// Optional, Specifies the uri to an azure blob that will replace the default configuration for the package if provided.
	ConfigurationReference *string `pulumi:"configurationReference"`
	// If set to true, when a new Gallery Application version is available in PIR/SIG, it will be automatically updated for the underlying VMSS.
	EnableAutomaticUpgrade *bool `pulumi:"enableAutomaticUpgrade"`
	// Optional, Specifies the order in which the packages have to be installed.
	Order *int `pulumi:"order"`
	// Specifies the GalleryApplicationVersion resource id on the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{application}/versions/{version}.
	PackageReferenceId string `pulumi:"packageReferenceId"`
	// Optional, If true, any failure for any operation in the VmApplication will fail the deployment.
	TreatFailureAsDeploymentFailure *bool `pulumi:"treatFailureAsDeploymentFailure"`
	// Optional, Specifies a passthrough value for more generic context. Accepts a JSON-formatted string e.g. '{"Tag1":"Value1","Tag2":"Value2"}'.
	VmGalleryTags *string `pulumi:"vmGalleryTags"`
}

// Specifies the gallery application that should be made available to the underlying VMSS.
type VmApplicationResponseOutput struct{ *pulumi.OutputState }

func (VmApplicationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmApplicationResponse)(nil)).Elem()
}

func (o VmApplicationResponseOutput) ToVmApplicationResponseOutput() VmApplicationResponseOutput {
	return o
}

func (o VmApplicationResponseOutput) ToVmApplicationResponseOutputWithContext(ctx context.Context) VmApplicationResponseOutput {
	return o
}

// Optional, Specifies the uri to an azure blob that will replace the default configuration for the package if provided.
func (o VmApplicationResponseOutput) ConfigurationReference() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmApplicationResponse) *string { return v.ConfigurationReference }).(pulumi.StringPtrOutput)
}

// If set to true, when a new Gallery Application version is available in PIR/SIG, it will be automatically updated for the underlying VMSS.
func (o VmApplicationResponseOutput) EnableAutomaticUpgrade() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VmApplicationResponse) *bool { return v.EnableAutomaticUpgrade }).(pulumi.BoolPtrOutput)
}

// Optional, Specifies the order in which the packages have to be installed.
func (o VmApplicationResponseOutput) Order() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VmApplicationResponse) *int { return v.Order }).(pulumi.IntPtrOutput)
}

// Specifies the GalleryApplicationVersion resource id on the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{application}/versions/{version}.
func (o VmApplicationResponseOutput) PackageReferenceId() pulumi.StringOutput {
	return o.ApplyT(func(v VmApplicationResponse) string { return v.PackageReferenceId }).(pulumi.StringOutput)
}

// Optional, If true, any failure for any operation in the VmApplication will fail the deployment.
func (o VmApplicationResponseOutput) TreatFailureAsDeploymentFailure() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VmApplicationResponse) *bool { return v.TreatFailureAsDeploymentFailure }).(pulumi.BoolPtrOutput)
}

// Optional, Specifies a passthrough value for more generic context. Accepts a JSON-formatted string e.g. '{"Tag1":"Value1","Tag2":"Value2"}'.
func (o VmApplicationResponseOutput) VmGalleryTags() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmApplicationResponse) *string { return v.VmGalleryTags }).(pulumi.StringPtrOutput)
}

type VmApplicationResponseArrayOutput struct{ *pulumi.OutputState }

func (VmApplicationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmApplicationResponse)(nil)).Elem()
}

func (o VmApplicationResponseArrayOutput) ToVmApplicationResponseArrayOutput() VmApplicationResponseArrayOutput {
	return o
}

func (o VmApplicationResponseArrayOutput) ToVmApplicationResponseArrayOutputWithContext(ctx context.Context) VmApplicationResponseArrayOutput {
	return o
}

func (o VmApplicationResponseArrayOutput) Index(i pulumi.IntInput) VmApplicationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VmApplicationResponse {
		return vs[0].([]VmApplicationResponse)[vs[1].(int)]
	}).(VmApplicationResponseOutput)
}

// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically, Get Started ->. Enter any required information and then click Save.
type VmImagePlan struct {
	// The plan ID.
	Name *string `pulumi:"name"`
	// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
	Product *string `pulumi:"product"`
	// The promotion code.
	PromotionCode *string `pulumi:"promotionCode"`
	// The publisher ID.
	Publisher *string `pulumi:"publisher"`
}

// VmImagePlanInput is an input type that accepts VmImagePlanArgs and VmImagePlanOutput values.
// You can construct a concrete instance of `VmImagePlanInput` via:
//
//	VmImagePlanArgs{...}
type VmImagePlanInput interface {
	pulumi.Input

	ToVmImagePlanOutput() VmImagePlanOutput
	ToVmImagePlanOutputWithContext(context.Context) VmImagePlanOutput
}

// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically, Get Started ->. Enter any required information and then click Save.
type VmImagePlanArgs struct {
	// The plan ID.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
	Product pulumi.StringPtrInput `pulumi:"product"`
	// The promotion code.
	PromotionCode pulumi.StringPtrInput `pulumi:"promotionCode"`
	// The publisher ID.
	Publisher pulumi.StringPtrInput `pulumi:"publisher"`
}

func (VmImagePlanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmImagePlan)(nil)).Elem()
}

func (i VmImagePlanArgs) ToVmImagePlanOutput() VmImagePlanOutput {
	return i.ToVmImagePlanOutputWithContext(context.Background())
}

func (i VmImagePlanArgs) ToVmImagePlanOutputWithContext(ctx context.Context) VmImagePlanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmImagePlanOutput)
}

func (i VmImagePlanArgs) ToVmImagePlanPtrOutput() VmImagePlanPtrOutput {
	return i.ToVmImagePlanPtrOutputWithContext(context.Background())
}

func (i VmImagePlanArgs) ToVmImagePlanPtrOutputWithContext(ctx context.Context) VmImagePlanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmImagePlanOutput).ToVmImagePlanPtrOutputWithContext(ctx)
}

// VmImagePlanPtrInput is an input type that accepts VmImagePlanArgs, VmImagePlanPtr and VmImagePlanPtrOutput values.
// You can construct a concrete instance of `VmImagePlanPtrInput` via:
//
//	        VmImagePlanArgs{...}
//
//	or:
//
//	        nil
type VmImagePlanPtrInput interface {
	pulumi.Input

	ToVmImagePlanPtrOutput() VmImagePlanPtrOutput
	ToVmImagePlanPtrOutputWithContext(context.Context) VmImagePlanPtrOutput
}

type vmImagePlanPtrType VmImagePlanArgs

func VmImagePlanPtr(v *VmImagePlanArgs) VmImagePlanPtrInput {
	return (*vmImagePlanPtrType)(v)
}

func (*vmImagePlanPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VmImagePlan)(nil)).Elem()
}

func (i *vmImagePlanPtrType) ToVmImagePlanPtrOutput() VmImagePlanPtrOutput {
	return i.ToVmImagePlanPtrOutputWithContext(context.Background())
}

func (i *vmImagePlanPtrType) ToVmImagePlanPtrOutputWithContext(ctx context.Context) VmImagePlanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmImagePlanPtrOutput)
}

// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically, Get Started ->. Enter any required information and then click Save.
type VmImagePlanOutput struct{ *pulumi.OutputState }

func (VmImagePlanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmImagePlan)(nil)).Elem()
}

func (o VmImagePlanOutput) ToVmImagePlanOutput() VmImagePlanOutput {
	return o
}

func (o VmImagePlanOutput) ToVmImagePlanOutputWithContext(ctx context.Context) VmImagePlanOutput {
	return o
}

func (o VmImagePlanOutput) ToVmImagePlanPtrOutput() VmImagePlanPtrOutput {
	return o.ToVmImagePlanPtrOutputWithContext(context.Background())
}

func (o VmImagePlanOutput) ToVmImagePlanPtrOutputWithContext(ctx context.Context) VmImagePlanPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VmImagePlan) *VmImagePlan {
		return &v
	}).(VmImagePlanPtrOutput)
}

// The plan ID.
func (o VmImagePlanOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmImagePlan) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
func (o VmImagePlanOutput) Product() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmImagePlan) *string { return v.Product }).(pulumi.StringPtrOutput)
}

// The promotion code.
func (o VmImagePlanOutput) PromotionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmImagePlan) *string { return v.PromotionCode }).(pulumi.StringPtrOutput)
}

// The publisher ID.
func (o VmImagePlanOutput) Publisher() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmImagePlan) *string { return v.Publisher }).(pulumi.StringPtrOutput)
}

type VmImagePlanPtrOutput struct{ *pulumi.OutputState }

func (VmImagePlanPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmImagePlan)(nil)).Elem()
}

func (o VmImagePlanPtrOutput) ToVmImagePlanPtrOutput() VmImagePlanPtrOutput {
	return o
}

func (o VmImagePlanPtrOutput) ToVmImagePlanPtrOutputWithContext(ctx context.Context) VmImagePlanPtrOutput {
	return o
}

func (o VmImagePlanPtrOutput) Elem() VmImagePlanOutput {
	return o.ApplyT(func(v *VmImagePlan) VmImagePlan {
		if v != nil {
			return *v
		}
		var ret VmImagePlan
		return ret
	}).(VmImagePlanOutput)
}

// The plan ID.
func (o VmImagePlanPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmImagePlan) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
func (o VmImagePlanPtrOutput) Product() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmImagePlan) *string {
		if v == nil {
			return nil
		}
		return v.Product
	}).(pulumi.StringPtrOutput)
}

// The promotion code.
func (o VmImagePlanPtrOutput) PromotionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmImagePlan) *string {
		if v == nil {
			return nil
		}
		return v.PromotionCode
	}).(pulumi.StringPtrOutput)
}

// The publisher ID.
func (o VmImagePlanPtrOutput) Publisher() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmImagePlan) *string {
		if v == nil {
			return nil
		}
		return v.Publisher
	}).(pulumi.StringPtrOutput)
}

// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically, Get Started ->. Enter any required information and then click Save.
type VmImagePlanResponse struct {
	// The plan ID.
	Name *string `pulumi:"name"`
	// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
	Product *string `pulumi:"product"`
	// The promotion code.
	PromotionCode *string `pulumi:"promotionCode"`
	// The publisher ID.
	Publisher *string `pulumi:"publisher"`
}

// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically, Get Started ->. Enter any required information and then click Save.
type VmImagePlanResponseOutput struct{ *pulumi.OutputState }

func (VmImagePlanResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmImagePlanResponse)(nil)).Elem()
}

func (o VmImagePlanResponseOutput) ToVmImagePlanResponseOutput() VmImagePlanResponseOutput {
	return o
}

func (o VmImagePlanResponseOutput) ToVmImagePlanResponseOutputWithContext(ctx context.Context) VmImagePlanResponseOutput {
	return o
}

// The plan ID.
func (o VmImagePlanResponseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmImagePlanResponse) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
func (o VmImagePlanResponseOutput) Product() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmImagePlanResponse) *string { return v.Product }).(pulumi.StringPtrOutput)
}

// The promotion code.
func (o VmImagePlanResponseOutput) PromotionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmImagePlanResponse) *string { return v.PromotionCode }).(pulumi.StringPtrOutput)
}

// The publisher ID.
func (o VmImagePlanResponseOutput) Publisher() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmImagePlanResponse) *string { return v.Publisher }).(pulumi.StringPtrOutput)
}

type VmImagePlanResponsePtrOutput struct{ *pulumi.OutputState }

func (VmImagePlanResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmImagePlanResponse)(nil)).Elem()
}

func (o VmImagePlanResponsePtrOutput) ToVmImagePlanResponsePtrOutput() VmImagePlanResponsePtrOutput {
	return o
}

func (o VmImagePlanResponsePtrOutput) ToVmImagePlanResponsePtrOutputWithContext(ctx context.Context) VmImagePlanResponsePtrOutput {
	return o
}

func (o VmImagePlanResponsePtrOutput) Elem() VmImagePlanResponseOutput {
	return o.ApplyT(func(v *VmImagePlanResponse) VmImagePlanResponse {
		if v != nil {
			return *v
		}
		var ret VmImagePlanResponse
		return ret
	}).(VmImagePlanResponseOutput)
}

// The plan ID.
func (o VmImagePlanResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmImagePlanResponse) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
func (o VmImagePlanResponsePtrOutput) Product() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmImagePlanResponse) *string {
		if v == nil {
			return nil
		}
		return v.Product
	}).(pulumi.StringPtrOutput)
}

// The promotion code.
func (o VmImagePlanResponsePtrOutput) PromotionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmImagePlanResponse) *string {
		if v == nil {
			return nil
		}
		return v.PromotionCode
	}).(pulumi.StringPtrOutput)
}

// The publisher ID.
func (o VmImagePlanResponsePtrOutput) Publisher() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmImagePlanResponse) *string {
		if v == nil {
			return nil
		}
		return v.Publisher
	}).(pulumi.StringPtrOutput)
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentity struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []string `pulumi:"userAssignedIdentities"`
}

// VmManagedIdentityInput is an input type that accepts VmManagedIdentityArgs and VmManagedIdentityOutput values.
// You can construct a concrete instance of `VmManagedIdentityInput` via:
//
//	VmManagedIdentityArgs{...}
type VmManagedIdentityInput interface {
	pulumi.Input

	ToVmManagedIdentityOutput() VmManagedIdentityOutput
	ToVmManagedIdentityOutputWithContext(context.Context) VmManagedIdentityOutput
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityArgs struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities pulumi.StringArrayInput `pulumi:"userAssignedIdentities"`
}

func (VmManagedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmManagedIdentity)(nil)).Elem()
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityOutput() VmManagedIdentityOutput {
	return i.ToVmManagedIdentityOutputWithContext(context.Background())
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityOutputWithContext(ctx context.Context) VmManagedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityOutput)
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return i.ToVmManagedIdentityPtrOutputWithContext(context.Background())
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityOutput).ToVmManagedIdentityPtrOutputWithContext(ctx)
}

// VmManagedIdentityPtrInput is an input type that accepts VmManagedIdentityArgs, VmManagedIdentityPtr and VmManagedIdentityPtrOutput values.
// You can construct a concrete instance of `VmManagedIdentityPtrInput` via:
//
//	        VmManagedIdentityArgs{...}
//
//	or:
//
//	        nil
type VmManagedIdentityPtrInput interface {
	pulumi.Input

	ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput
	ToVmManagedIdentityPtrOutputWithContext(context.Context) VmManagedIdentityPtrOutput
}

type vmManagedIdentityPtrType VmManagedIdentityArgs

func VmManagedIdentityPtr(v *VmManagedIdentityArgs) VmManagedIdentityPtrInput {
	return (*vmManagedIdentityPtrType)(v)
}

func (*vmManagedIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VmManagedIdentity)(nil)).Elem()
}

func (i *vmManagedIdentityPtrType) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return i.ToVmManagedIdentityPtrOutputWithContext(context.Background())
}

func (i *vmManagedIdentityPtrType) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityPtrOutput)
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmManagedIdentity)(nil)).Elem()
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityOutput() VmManagedIdentityOutput {
	return o
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityOutputWithContext(ctx context.Context) VmManagedIdentityOutput {
	return o
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return o.ToVmManagedIdentityPtrOutputWithContext(context.Background())
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VmManagedIdentity) *VmManagedIdentity {
		return &v
	}).(VmManagedIdentityPtrOutput)
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VmManagedIdentity) []string { return v.UserAssignedIdentities }).(pulumi.StringArrayOutput)
}

type VmManagedIdentityPtrOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmManagedIdentity)(nil)).Elem()
}

func (o VmManagedIdentityPtrOutput) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return o
}

func (o VmManagedIdentityPtrOutput) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return o
}

func (o VmManagedIdentityPtrOutput) Elem() VmManagedIdentityOutput {
	return o.ApplyT(func(v *VmManagedIdentity) VmManagedIdentity {
		if v != nil {
			return *v
		}
		var ret VmManagedIdentity
		return ret
	}).(VmManagedIdentityOutput)
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityPtrOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VmManagedIdentity) []string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.StringArrayOutput)
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityResponse struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []string `pulumi:"userAssignedIdentities"`
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityResponseOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmManagedIdentityResponse)(nil)).Elem()
}

func (o VmManagedIdentityResponseOutput) ToVmManagedIdentityResponseOutput() VmManagedIdentityResponseOutput {
	return o
}

func (o VmManagedIdentityResponseOutput) ToVmManagedIdentityResponseOutputWithContext(ctx context.Context) VmManagedIdentityResponseOutput {
	return o
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityResponseOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VmManagedIdentityResponse) []string { return v.UserAssignedIdentities }).(pulumi.StringArrayOutput)
}

type VmManagedIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmManagedIdentityResponse)(nil)).Elem()
}

func (o VmManagedIdentityResponsePtrOutput) ToVmManagedIdentityResponsePtrOutput() VmManagedIdentityResponsePtrOutput {
	return o
}

func (o VmManagedIdentityResponsePtrOutput) ToVmManagedIdentityResponsePtrOutputWithContext(ctx context.Context) VmManagedIdentityResponsePtrOutput {
	return o
}

func (o VmManagedIdentityResponsePtrOutput) Elem() VmManagedIdentityResponseOutput {
	return o.ApplyT(func(v *VmManagedIdentityResponse) VmManagedIdentityResponse {
		if v != nil {
			return *v
		}
		var ret VmManagedIdentityResponse
		return ret
	}).(VmManagedIdentityResponseOutput)
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityResponsePtrOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VmManagedIdentityResponse) []string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.StringArrayOutput)
}

// Managed data disk description.
type VmssDataDisk struct {
	// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
	DiskLetter string `pulumi:"diskLetter"`
	// Disk size for each vm in the node type in GBs.
	DiskSizeGB int `pulumi:"diskSizeGB"`
	// Managed data disk type. Specifies the storage account type for the managed disk
	DiskType string `pulumi:"diskType"`
	// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
	Lun int `pulumi:"lun"`
}

// VmssDataDiskInput is an input type that accepts VmssDataDiskArgs and VmssDataDiskOutput values.
// You can construct a concrete instance of `VmssDataDiskInput` via:
//
//	VmssDataDiskArgs{...}
type VmssDataDiskInput interface {
	pulumi.Input

	ToVmssDataDiskOutput() VmssDataDiskOutput
	ToVmssDataDiskOutputWithContext(context.Context) VmssDataDiskOutput
}

// Managed data disk description.
type VmssDataDiskArgs struct {
	// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
	DiskLetter pulumi.StringInput `pulumi:"diskLetter"`
	// Disk size for each vm in the node type in GBs.
	DiskSizeGB pulumi.IntInput `pulumi:"diskSizeGB"`
	// Managed data disk type. Specifies the storage account type for the managed disk
	DiskType pulumi.StringInput `pulumi:"diskType"`
	// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
	Lun pulumi.IntInput `pulumi:"lun"`
}

func (VmssDataDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmssDataDisk)(nil)).Elem()
}

func (i VmssDataDiskArgs) ToVmssDataDiskOutput() VmssDataDiskOutput {
	return i.ToVmssDataDiskOutputWithContext(context.Background())
}

func (i VmssDataDiskArgs) ToVmssDataDiskOutputWithContext(ctx context.Context) VmssDataDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmssDataDiskOutput)
}

// VmssDataDiskArrayInput is an input type that accepts VmssDataDiskArray and VmssDataDiskArrayOutput values.
// You can construct a concrete instance of `VmssDataDiskArrayInput` via:
//
//	VmssDataDiskArray{ VmssDataDiskArgs{...} }
type VmssDataDiskArrayInput interface {
	pulumi.Input

	ToVmssDataDiskArrayOutput() VmssDataDiskArrayOutput
	ToVmssDataDiskArrayOutputWithContext(context.Context) VmssDataDiskArrayOutput
}

type VmssDataDiskArray []VmssDataDiskInput

func (VmssDataDiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmssDataDisk)(nil)).Elem()
}

func (i VmssDataDiskArray) ToVmssDataDiskArrayOutput() VmssDataDiskArrayOutput {
	return i.ToVmssDataDiskArrayOutputWithContext(context.Background())
}

func (i VmssDataDiskArray) ToVmssDataDiskArrayOutputWithContext(ctx context.Context) VmssDataDiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmssDataDiskArrayOutput)
}

// Managed data disk description.
type VmssDataDiskOutput struct{ *pulumi.OutputState }

func (VmssDataDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmssDataDisk)(nil)).Elem()
}

func (o VmssDataDiskOutput) ToVmssDataDiskOutput() VmssDataDiskOutput {
	return o
}

func (o VmssDataDiskOutput) ToVmssDataDiskOutputWithContext(ctx context.Context) VmssDataDiskOutput {
	return o
}

// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
func (o VmssDataDiskOutput) DiskLetter() pulumi.StringOutput {
	return o.ApplyT(func(v VmssDataDisk) string { return v.DiskLetter }).(pulumi.StringOutput)
}

// Disk size for each vm in the node type in GBs.
func (o VmssDataDiskOutput) DiskSizeGB() pulumi.IntOutput {
	return o.ApplyT(func(v VmssDataDisk) int { return v.DiskSizeGB }).(pulumi.IntOutput)
}

// Managed data disk type. Specifies the storage account type for the managed disk
func (o VmssDataDiskOutput) DiskType() pulumi.StringOutput {
	return o.ApplyT(func(v VmssDataDisk) string { return v.DiskType }).(pulumi.StringOutput)
}

// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
func (o VmssDataDiskOutput) Lun() pulumi.IntOutput {
	return o.ApplyT(func(v VmssDataDisk) int { return v.Lun }).(pulumi.IntOutput)
}

type VmssDataDiskArrayOutput struct{ *pulumi.OutputState }

func (VmssDataDiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmssDataDisk)(nil)).Elem()
}

func (o VmssDataDiskArrayOutput) ToVmssDataDiskArrayOutput() VmssDataDiskArrayOutput {
	return o
}

func (o VmssDataDiskArrayOutput) ToVmssDataDiskArrayOutputWithContext(ctx context.Context) VmssDataDiskArrayOutput {
	return o
}

func (o VmssDataDiskArrayOutput) Index(i pulumi.IntInput) VmssDataDiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VmssDataDisk {
		return vs[0].([]VmssDataDisk)[vs[1].(int)]
	}).(VmssDataDiskOutput)
}

// Managed data disk description.
type VmssDataDiskResponse struct {
	// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
	DiskLetter string `pulumi:"diskLetter"`
	// Disk size for each vm in the node type in GBs.
	DiskSizeGB int `pulumi:"diskSizeGB"`
	// Managed data disk type. Specifies the storage account type for the managed disk
	DiskType string `pulumi:"diskType"`
	// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
	Lun int `pulumi:"lun"`
}

// Managed data disk description.
type VmssDataDiskResponseOutput struct{ *pulumi.OutputState }

func (VmssDataDiskResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmssDataDiskResponse)(nil)).Elem()
}

func (o VmssDataDiskResponseOutput) ToVmssDataDiskResponseOutput() VmssDataDiskResponseOutput {
	return o
}

func (o VmssDataDiskResponseOutput) ToVmssDataDiskResponseOutputWithContext(ctx context.Context) VmssDataDiskResponseOutput {
	return o
}

// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
func (o VmssDataDiskResponseOutput) DiskLetter() pulumi.StringOutput {
	return o.ApplyT(func(v VmssDataDiskResponse) string { return v.DiskLetter }).(pulumi.StringOutput)
}

// Disk size for each vm in the node type in GBs.
func (o VmssDataDiskResponseOutput) DiskSizeGB() pulumi.IntOutput {
	return o.ApplyT(func(v VmssDataDiskResponse) int { return v.DiskSizeGB }).(pulumi.IntOutput)
}

// Managed data disk type. Specifies the storage account type for the managed disk
func (o VmssDataDiskResponseOutput) DiskType() pulumi.StringOutput {
	return o.ApplyT(func(v VmssDataDiskResponse) string { return v.DiskType }).(pulumi.StringOutput)
}

// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
func (o VmssDataDiskResponseOutput) Lun() pulumi.IntOutput {
	return o.ApplyT(func(v VmssDataDiskResponse) int { return v.Lun }).(pulumi.IntOutput)
}

type VmssDataDiskResponseArrayOutput struct{ *pulumi.OutputState }

func (VmssDataDiskResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmssDataDiskResponse)(nil)).Elem()
}

func (o VmssDataDiskResponseArrayOutput) ToVmssDataDiskResponseArrayOutput() VmssDataDiskResponseArrayOutput {
	return o
}

func (o VmssDataDiskResponseArrayOutput) ToVmssDataDiskResponseArrayOutputWithContext(ctx context.Context) VmssDataDiskResponseArrayOutput {
	return o
}

func (o VmssDataDiskResponseArrayOutput) Index(i pulumi.IntInput) VmssDataDiskResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VmssDataDiskResponse {
		return vs[0].([]VmssDataDiskResponse)[vs[1].(int)]
	}).(VmssDataDiskResponseOutput)
}

func init() {
	pulumi.RegisterOutputType(AddRemoveIncrementalNamedPartitionScalingMechanismOutput{})
	pulumi.RegisterOutputType(AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput{})
	pulumi.RegisterOutputType(AdditionalNetworkInterfaceConfigurationOutput{})
	pulumi.RegisterOutputType(AdditionalNetworkInterfaceConfigurationArrayOutput{})
	pulumi.RegisterOutputType(AdditionalNetworkInterfaceConfigurationResponseOutput{})
	pulumi.RegisterOutputType(AdditionalNetworkInterfaceConfigurationResponseArrayOutput{})
	pulumi.RegisterOutputType(ApplicationHealthPolicyOutput{})
	pulumi.RegisterOutputType(ApplicationHealthPolicyPtrOutput{})
	pulumi.RegisterOutputType(ApplicationHealthPolicyResponseOutput{})
	pulumi.RegisterOutputType(ApplicationHealthPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyPtrOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyResponseOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyPtrOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyResponseOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityArrayOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityResponseOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityResponseArrayOutput{})
	pulumi.RegisterOutputType(AveragePartitionLoadScalingTriggerOutput{})
	pulumi.RegisterOutputType(AveragePartitionLoadScalingTriggerResponseOutput{})
	pulumi.RegisterOutputType(AverageServiceLoadScalingTriggerOutput{})
	pulumi.RegisterOutputType(AverageServiceLoadScalingTriggerResponseOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryPtrOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryResponseOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryResponsePtrOutput{})
	pulumi.RegisterOutputType(ClientCertificateOutput{})
	pulumi.RegisterOutputType(ClientCertificateArrayOutput{})
	pulumi.RegisterOutputType(ClientCertificateResponseOutput{})
	pulumi.RegisterOutputType(ClientCertificateResponseArrayOutput{})
	pulumi.RegisterOutputType(ClusterHealthPolicyOutput{})
	pulumi.RegisterOutputType(ClusterHealthPolicyPtrOutput{})
	pulumi.RegisterOutputType(ClusterHealthPolicyResponseOutput{})
	pulumi.RegisterOutputType(ClusterHealthPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ClusterMonitoringPolicyOutput{})
	pulumi.RegisterOutputType(ClusterMonitoringPolicyPtrOutput{})
	pulumi.RegisterOutputType(ClusterMonitoringPolicyResponseOutput{})
	pulumi.RegisterOutputType(ClusterMonitoringPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ClusterUpgradeDeltaHealthPolicyOutput{})
	pulumi.RegisterOutputType(ClusterUpgradeDeltaHealthPolicyPtrOutput{})
	pulumi.RegisterOutputType(ClusterUpgradeDeltaHealthPolicyResponseOutput{})
	pulumi.RegisterOutputType(ClusterUpgradeDeltaHealthPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ClusterUpgradePolicyOutput{})
	pulumi.RegisterOutputType(ClusterUpgradePolicyPtrOutput{})
	pulumi.RegisterOutputType(ClusterUpgradePolicyResponseOutput{})
	pulumi.RegisterOutputType(ClusterUpgradePolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionPtrOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionResponseOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionResponsePtrOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationArrayOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationResponseOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationResponseArrayOutput{})
	pulumi.RegisterOutputType(IpConfigurationOutput{})
	pulumi.RegisterOutputType(IpConfigurationArrayOutput{})
	pulumi.RegisterOutputType(IpConfigurationPublicIPAddressConfigurationOutput{})
	pulumi.RegisterOutputType(IpConfigurationPublicIPAddressConfigurationPtrOutput{})
	pulumi.RegisterOutputType(IpConfigurationResponseOutput{})
	pulumi.RegisterOutputType(IpConfigurationResponseArrayOutput{})
	pulumi.RegisterOutputType(IpConfigurationResponsePublicIPAddressConfigurationOutput{})
	pulumi.RegisterOutputType(IpConfigurationResponsePublicIPAddressConfigurationPtrOutput{})
	pulumi.RegisterOutputType(IpTagOutput{})
	pulumi.RegisterOutputType(IpTagArrayOutput{})
	pulumi.RegisterOutputType(IpTagResponseOutput{})
	pulumi.RegisterOutputType(IpTagResponseArrayOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleArrayOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleResponseOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleResponseArrayOutput{})
	pulumi.RegisterOutputType(ManagedIdentityOutput{})
	pulumi.RegisterOutputType(ManagedIdentityPtrOutput{})
	pulumi.RegisterOutputType(ManagedIdentityResponseOutput{})
	pulumi.RegisterOutputType(ManagedIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(NamedPartitionSchemeOutput{})
	pulumi.RegisterOutputType(NamedPartitionSchemePtrOutput{})
	pulumi.RegisterOutputType(NamedPartitionSchemeResponseOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleArrayOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleResponseOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleResponseArrayOutput{})
	pulumi.RegisterOutputType(NodeTypeNatConfigOutput{})
	pulumi.RegisterOutputType(NodeTypeNatConfigArrayOutput{})
	pulumi.RegisterOutputType(NodeTypeNatConfigResponseOutput{})
	pulumi.RegisterOutputType(NodeTypeNatConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuPtrOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuResponseOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuResponsePtrOutput{})
	pulumi.RegisterOutputType(PartitionInstanceCountScaleMechanismOutput{})
	pulumi.RegisterOutputType(PartitionInstanceCountScaleMechanismResponseOutput{})
	pulumi.RegisterOutputType(ResourceAzStatusResponseOutput{})
	pulumi.RegisterOutputType(ResourceAzStatusResponseArrayOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyPtrOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyResponseOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ScalingPolicyOutput{})
	pulumi.RegisterOutputType(ScalingPolicyArrayOutput{})
	pulumi.RegisterOutputType(ScalingPolicyResponseOutput{})
	pulumi.RegisterOutputType(ScalingPolicyResponseArrayOutput{})
	pulumi.RegisterOutputType(ServiceCorrelationOutput{})
	pulumi.RegisterOutputType(ServiceCorrelationArrayOutput{})
	pulumi.RegisterOutputType(ServiceCorrelationResponseOutput{})
	pulumi.RegisterOutputType(ServiceCorrelationResponseArrayOutput{})
	pulumi.RegisterOutputType(ServiceEndpointOutput{})
	pulumi.RegisterOutputType(ServiceEndpointArrayOutput{})
	pulumi.RegisterOutputType(ServiceEndpointResponseOutput{})
	pulumi.RegisterOutputType(ServiceEndpointResponseArrayOutput{})
	pulumi.RegisterOutputType(ServiceLoadMetricOutput{})
	pulumi.RegisterOutputType(ServiceLoadMetricArrayOutput{})
	pulumi.RegisterOutputType(ServiceLoadMetricResponseOutput{})
	pulumi.RegisterOutputType(ServiceLoadMetricResponseArrayOutput{})
	pulumi.RegisterOutputType(ServicePlacementInvalidDomainPolicyOutput{})
	pulumi.RegisterOutputType(ServicePlacementInvalidDomainPolicyResponseOutput{})
	pulumi.RegisterOutputType(ServicePlacementNonPartiallyPlaceServicePolicyOutput{})
	pulumi.RegisterOutputType(ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput{})
	pulumi.RegisterOutputType(ServicePlacementPreferPrimaryDomainPolicyOutput{})
	pulumi.RegisterOutputType(ServicePlacementPreferPrimaryDomainPolicyResponseOutput{})
	pulumi.RegisterOutputType(ServicePlacementRequireDomainDistributionPolicyOutput{})
	pulumi.RegisterOutputType(ServicePlacementRequireDomainDistributionPolicyResponseOutput{})
	pulumi.RegisterOutputType(ServicePlacementRequiredDomainPolicyOutput{})
	pulumi.RegisterOutputType(ServicePlacementRequiredDomainPolicyResponseOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyPtrOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyMapOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyResponseOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyResponseMapOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionArrayOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionResponseOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionResponseArrayOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionArrayOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionResponseOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionResponseArrayOutput{})
	pulumi.RegisterOutputType(SingletonPartitionSchemeOutput{})
	pulumi.RegisterOutputType(SingletonPartitionSchemePtrOutput{})
	pulumi.RegisterOutputType(SingletonPartitionSchemeResponseOutput{})
	pulumi.RegisterOutputType(SkuOutput{})
	pulumi.RegisterOutputType(SkuResponseOutput{})
	pulumi.RegisterOutputType(StatefulServicePropertiesOutput{})
	pulumi.RegisterOutputType(StatefulServicePropertiesPtrOutput{})
	pulumi.RegisterOutputType(StatefulServicePropertiesResponseOutput{})
	pulumi.RegisterOutputType(StatelessServicePropertiesOutput{})
	pulumi.RegisterOutputType(StatelessServicePropertiesPtrOutput{})
	pulumi.RegisterOutputType(StatelessServicePropertiesResponseOutput{})
	pulumi.RegisterOutputType(SubResourceOutput{})
	pulumi.RegisterOutputType(SubResourcePtrOutput{})
	pulumi.RegisterOutputType(SubResourceArrayOutput{})
	pulumi.RegisterOutputType(SubResourceResponseOutput{})
	pulumi.RegisterOutputType(SubResourceResponsePtrOutput{})
	pulumi.RegisterOutputType(SubResourceResponseArrayOutput{})
	pulumi.RegisterOutputType(SubnetOutput{})
	pulumi.RegisterOutputType(SubnetArrayOutput{})
	pulumi.RegisterOutputType(SubnetResponseOutput{})
	pulumi.RegisterOutputType(SubnetResponseArrayOutput{})
	pulumi.RegisterOutputType(SystemDataResponseOutput{})
	pulumi.RegisterOutputType(UniformInt64RangePartitionSchemeOutput{})
	pulumi.RegisterOutputType(UniformInt64RangePartitionSchemePtrOutput{})
	pulumi.RegisterOutputType(UniformInt64RangePartitionSchemeResponseOutput{})
	pulumi.RegisterOutputType(UserAssignedIdentityResponseOutput{})
	pulumi.RegisterOutputType(UserAssignedIdentityResponseMapOutput{})
	pulumi.RegisterOutputType(VMSSExtensionOutput{})
	pulumi.RegisterOutputType(VMSSExtensionArrayOutput{})
	pulumi.RegisterOutputType(VMSSExtensionResponseOutput{})
	pulumi.RegisterOutputType(VMSSExtensionResponseArrayOutput{})
	pulumi.RegisterOutputType(VaultCertificateOutput{})
	pulumi.RegisterOutputType(VaultCertificateArrayOutput{})
	pulumi.RegisterOutputType(VaultCertificateResponseOutput{})
	pulumi.RegisterOutputType(VaultCertificateResponseArrayOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupArrayOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupResponseOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupResponseArrayOutput{})
	pulumi.RegisterOutputType(VmApplicationOutput{})
	pulumi.RegisterOutputType(VmApplicationArrayOutput{})
	pulumi.RegisterOutputType(VmApplicationResponseOutput{})
	pulumi.RegisterOutputType(VmApplicationResponseArrayOutput{})
	pulumi.RegisterOutputType(VmImagePlanOutput{})
	pulumi.RegisterOutputType(VmImagePlanPtrOutput{})
	pulumi.RegisterOutputType(VmImagePlanResponseOutput{})
	pulumi.RegisterOutputType(VmImagePlanResponsePtrOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityPtrOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityResponseOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(VmssDataDiskOutput{})
	pulumi.RegisterOutputType(VmssDataDiskArrayOutput{})
	pulumi.RegisterOutputType(VmssDataDiskResponseOutput{})
	pulumi.RegisterOutputType(VmssDataDiskResponseArrayOutput{})
}
