// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package videoanalyzer

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Pipeline topology describes the processing steps to be applied when processing content for a particular outcome. The topology should be defined according to the scenario to be achieved and can be reused across many pipeline instances which share the same processing characteristics. For instance, a pipeline topology which captures content from a RTSP camera and archives the content can be reused across many different cameras, as long as the same processing is to be applied across all the cameras. Individual instance properties can be defined through the use of user-defined parameters, which allow for a topology to be parameterized. This allows  individual pipelines refer to different values, such as individual cameras' RTSP endpoints and credentials. Overall a topology is composed of the following:
//
//   - Parameters: list of user defined parameters that can be references across the topology nodes.
//   - Sources: list of one or more data sources nodes such as an RTSP source which allows for content to be ingested from cameras.
//   - Processors: list of nodes which perform data analysis or transformations.
//   - Sinks: list of one or more data sinks which allow for data to be stored or exported to other destinations.
//     API Version: 2021-11-01-preview.
func LookupPipelineTopology(ctx *pulumi.Context, args *LookupPipelineTopologyArgs, opts ...pulumi.InvokeOption) (*LookupPipelineTopologyResult, error) {
	var rv LookupPipelineTopologyResult
	err := ctx.Invoke("azure-native:videoanalyzer:getPipelineTopology", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

type LookupPipelineTopologyArgs struct {
	AccountName          string `pulumi:"accountName"`
	PipelineTopologyName string `pulumi:"pipelineTopologyName"`
	ResourceGroupName    string `pulumi:"resourceGroupName"`
}

// Pipeline topology describes the processing steps to be applied when processing content for a particular outcome. The topology should be defined according to the scenario to be achieved and can be reused across many pipeline instances which share the same processing characteristics. For instance, a pipeline topology which captures content from a RTSP camera and archives the content can be reused across many different cameras, as long as the same processing is to be applied across all the cameras. Individual instance properties can be defined through the use of user-defined parameters, which allow for a topology to be parameterized. This allows  individual pipelines refer to different values, such as individual cameras' RTSP endpoints and credentials. Overall a topology is composed of the following:
//
//   - Parameters: list of user defined parameters that can be references across the topology nodes.
//   - Sources: list of one or more data sources nodes such as an RTSP source which allows for content to be ingested from cameras.
//   - Processors: list of nodes which perform data analysis or transformations.
//   - Sinks: list of one or more data sinks which allow for data to be stored or exported to other destinations.
type LookupPipelineTopologyResult struct {
	Description *string                        `pulumi:"description"`
	Id          string                         `pulumi:"id"`
	Kind        string                         `pulumi:"kind"`
	Name        string                         `pulumi:"name"`
	Parameters  []ParameterDeclarationResponse `pulumi:"parameters"`
	Processors  []EncoderProcessorResponse     `pulumi:"processors"`
	Sinks       []VideoSinkResponse            `pulumi:"sinks"`
	Sku         SkuResponse                    `pulumi:"sku"`
	Sources     []interface{}                  `pulumi:"sources"`
	SystemData  SystemDataResponse             `pulumi:"systemData"`
	Type        string                         `pulumi:"type"`
}

func LookupPipelineTopologyOutput(ctx *pulumi.Context, args LookupPipelineTopologyOutputArgs, opts ...pulumi.InvokeOption) LookupPipelineTopologyResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (LookupPipelineTopologyResult, error) {
			args := v.(LookupPipelineTopologyArgs)
			r, err := LookupPipelineTopology(ctx, &args, opts...)
			var s LookupPipelineTopologyResult
			if r != nil {
				s = *r
			}
			return s, err
		}).(LookupPipelineTopologyResultOutput)
}

type LookupPipelineTopologyOutputArgs struct {
	AccountName          pulumi.StringInput `pulumi:"accountName"`
	PipelineTopologyName pulumi.StringInput `pulumi:"pipelineTopologyName"`
	ResourceGroupName    pulumi.StringInput `pulumi:"resourceGroupName"`
}

func (LookupPipelineTopologyOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupPipelineTopologyArgs)(nil)).Elem()
}

// Pipeline topology describes the processing steps to be applied when processing content for a particular outcome. The topology should be defined according to the scenario to be achieved and can be reused across many pipeline instances which share the same processing characteristics. For instance, a pipeline topology which captures content from a RTSP camera and archives the content can be reused across many different cameras, as long as the same processing is to be applied across all the cameras. Individual instance properties can be defined through the use of user-defined parameters, which allow for a topology to be parameterized. This allows  individual pipelines refer to different values, such as individual cameras' RTSP endpoints and credentials. Overall a topology is composed of the following:
//
//   - Parameters: list of user defined parameters that can be references across the topology nodes.
//   - Sources: list of one or more data sources nodes such as an RTSP source which allows for content to be ingested from cameras.
//   - Processors: list of nodes which perform data analysis or transformations.
//   - Sinks: list of one or more data sinks which allow for data to be stored or exported to other destinations.
type LookupPipelineTopologyResultOutput struct{ *pulumi.OutputState }

func (LookupPipelineTopologyResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupPipelineTopologyResult)(nil)).Elem()
}

func (o LookupPipelineTopologyResultOutput) ToLookupPipelineTopologyResultOutput() LookupPipelineTopologyResultOutput {
	return o
}

func (o LookupPipelineTopologyResultOutput) ToLookupPipelineTopologyResultOutputWithContext(ctx context.Context) LookupPipelineTopologyResultOutput {
	return o
}

func (o LookupPipelineTopologyResultOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupPipelineTopologyResult) *string { return v.Description }).(pulumi.StringPtrOutput)
}

func (o LookupPipelineTopologyResultOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v LookupPipelineTopologyResult) string { return v.Id }).(pulumi.StringOutput)
}

func (o LookupPipelineTopologyResultOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v LookupPipelineTopologyResult) string { return v.Kind }).(pulumi.StringOutput)
}

func (o LookupPipelineTopologyResultOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v LookupPipelineTopologyResult) string { return v.Name }).(pulumi.StringOutput)
}

func (o LookupPipelineTopologyResultOutput) Parameters() ParameterDeclarationResponseArrayOutput {
	return o.ApplyT(func(v LookupPipelineTopologyResult) []ParameterDeclarationResponse { return v.Parameters }).(ParameterDeclarationResponseArrayOutput)
}

func (o LookupPipelineTopologyResultOutput) Processors() EncoderProcessorResponseArrayOutput {
	return o.ApplyT(func(v LookupPipelineTopologyResult) []EncoderProcessorResponse { return v.Processors }).(EncoderProcessorResponseArrayOutput)
}

func (o LookupPipelineTopologyResultOutput) Sinks() VideoSinkResponseArrayOutput {
	return o.ApplyT(func(v LookupPipelineTopologyResult) []VideoSinkResponse { return v.Sinks }).(VideoSinkResponseArrayOutput)
}

func (o LookupPipelineTopologyResultOutput) Sku() SkuResponseOutput {
	return o.ApplyT(func(v LookupPipelineTopologyResult) SkuResponse { return v.Sku }).(SkuResponseOutput)
}

func (o LookupPipelineTopologyResultOutput) Sources() pulumi.ArrayOutput {
	return o.ApplyT(func(v LookupPipelineTopologyResult) []interface{} { return v.Sources }).(pulumi.ArrayOutput)
}

func (o LookupPipelineTopologyResultOutput) SystemData() SystemDataResponseOutput {
	return o.ApplyT(func(v LookupPipelineTopologyResult) SystemDataResponse { return v.SystemData }).(SystemDataResponseOutput)
}

func (o LookupPipelineTopologyResultOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v LookupPipelineTopologyResult) string { return v.Type }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterOutputType(LookupPipelineTopologyResultOutput{})
}
